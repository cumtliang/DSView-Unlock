/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2023 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef _UI_FN_H
#define _UI_FN_H

#include <QFont>

class QToolBar;
class QWidget;

namespace ui
{
    void set_toolbar_font(QToolBar *bar, QFont font);

    void set_form_font(QWidget *wid, QFont font);

} // namespace ui

#endif/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "msgbox.h"
#include <assert.h>
#include <QMessageBox>
#include "../dialogs/dsmessagebox.h"
#include "../basedef.h"
#include "../appcore/appcontrol.h"
#include "langresource.h"

//QMessageBox::information(NULL, "Title", "Content",QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
//QMessageBox::information(NULL, "Title", "Content",QMessageBox::Yes|QMessageBox::No);
//QMessageBox::information(NULL, "Title", "Content");
//QMessageBox::information(NULL, "Title", "Content",QMessageBox::Yes|QMessageBox::No|QMessageBox::Abort);

void MsgBox::Show(const QString text)
{
    MsgBox::Show("", text, "", NULL, NULL);
}

void MsgBox::Show(const QString title, const QString text, QWidget *parent)
{
    MsgBox::Show(title, text, "", parent,NULL);
}

void Show(const QString title, const QString text, const QString infoText)
{
    MsgBox::Show(title, text, infoText, NULL, NULL);
}

void MsgBox::Show(const QString title, const QString text, 
        QWidget *parent, dsv::dialogs::DSMessageBox **box)
{
    MsgBox::Show(title, text, "", parent, box);
}

void MsgBox::Show(const QString title, const QString text, const QString infoText, 
        QWidget *parent, dsv::dialogs::DSMessageBox **box)
{
    assert(!text.isEmpty());

    QString str;
    str.append("\n");
    str.append(text);

    if (parent == NULL){
        parent = dsv::appcore::AppControl::Instance()->GetTopWindow();
    }

    dsv::dialogs::DSMessageBox msg(parent, title);

    if (box != NULL){
        *box = &msg;
    }

    msg.mBox()->setText(str);
    msg.mBox()->setStandardButtons(QMessageBox::Ok);
    msg.mBox()->setIcon(QMessageBox::Warning);

    if (infoText != ""){
        msg.mBox()->setInformativeText(infoText);
    }

    msg.exec();     
}

bool MsgBox::Confirm(const QString text, QWidget *parent)
{
    return MsgBox::Confirm(text, "", NULL, parent);
}

bool MsgBox::Confirm(const QString text, const QString infoText, 
        dsv::dialogs::DSMessageBox **box, QWidget *parent)
{
    assert(!text.isEmpty());

    QString str;
    str.append("\n");
    str.append(text);

    if (parent == NULL){
        parent = dsv::appcore::AppControl::Instance()->GetTopWindow();
    }

    const char *title = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_BOX_CONFIRM), "Confirm");
    dsv::dialogs::DSMessageBox msg(parent, title);
    msg.mBox()->setText(str);
    msg.mBox()->setStandardButtons(QMessageBox::Yes | QMessageBox::No);
    msg.mBox()->setIcon(QMessageBox::Question);

    if (infoText != ""){
        msg.mBox()->setInformativeText(infoText);
    }

    if (box != NULL){
        *box = &msg;
    }

    msg.exec();
    return msg.IsYes();
}
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2022 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "langresource.h"
#include <stddef.h>
#include <QFile>
#include <QByteArray>
#include <QJsonParseError>
#include <QJsonValue>
#include <QJsonArray>
#include <QJsonObject>
#include <assert.h>
#include "../log.h"
#include "../config/appconfig.h"

using namespace dsv::config;

//---------------Lang_resource_page
Lang_resource_page::Lang_resource_page()
{
    _id = -1;
    _source = NULL;
    _loaded = false;
    _released = false;
    _is_dynamic = false;
}

void Lang_resource_page::Clear()
{
    _res.clear();
    _res_history.clear();
}

//---------------LangResource

LangResource::LangResource()
{
    _current_page = NULL;
    _cur_lang = -1;
}

LangResource *LangResource::Instance()
{
    static LangResource *ins = NULL;

    if (ins == NULL)
    {
        ins = new LangResource();
    }

    return ins;
}

const char *LangResource::get_lang_key(int lang)
{
    int num = sizeof(lang_id_keys) / sizeof(lang_key_item);
    const char *lan_name = NULL;

    for (int i = 0; i < num; i++)
    {
        if (lang_id_keys[i].id == lang)
        {
            lan_name = lang_id_keys[i].name;
            break;
        }
    }

    return lan_name;
}

bool LangResource::Load(int lang)
{
    std::lock_guard<std::mutex> lock(_mutex);

    int num = sizeof(lang_id_keys) / sizeof(lang_key_item);
    const char *lan_name = get_lang_key(lang);

    if (lan_name == NULL)
    {
        dsv_err("Can't find language key,lang:%d", lang);
        return false;
    }

    _cur_lang = lang;

    _query_decoders.clear();

    release_self();

    num = sizeof(lange_page_keys) / sizeof(lang_page_item);

    for (int i = 0; i < num; i++)
    { 
        Lang_resource_page *p = new Lang_resource_page();
        p->_id = lange_page_keys[i].id;
        p->_source = lange_page_keys[i].source;
        p->_is_dynamic = lange_page_keys[i].is_dynamic;
        _pages.push_back(p);
    }

    return true;
}

void LangResource::Release()
{
    std::lock_guard<std::mutex> lock(_mutex);
    release_self();
}

void LangResource::release_self()
{ 
    for (Lang_resource_page *p : _pages)
    {
        p->Clear();
        delete p;
    }
    _pages.clear();
}

void LangResource::load_page(Lang_resource_page &p)
{
    if (p._loaded)
        return;
    p._loaded = true;

    const char *lan_name = get_lang_key(_cur_lang);
    if (lan_name == NULL){
        dsv_err("Can't find language key,lang:%d", _cur_lang);
        return;
    }

    QString fileNmae(p._source);
    QStringList files = fileNmae.split(",");
        
    for (int x=0; x<files.count(); x++){
        QString file = AppConfig::GetAppDataDir() + "/lang/" + QString(lan_name) + "/" + files[x].trimmed();
        load_page(p, file);
    }
}

void LangResource::load_page(Lang_resource_page &p, QString file)
{ 
    QFile f(file);
    if (f.exists() == false){
        if (_cur_lang != LAN_EN && p._is_dynamic == false)
            dsv_warn("Warning:Language source file is not exists: %s", file.toLocal8Bit().data());
        return;
    }
    f.open(QFile::ReadOnly | QFile::Text);
    QByteArray raw_bytes = f.readAll();
    f.close();

    if (raw_bytes.length() == 0)
        return;

    //dsv_info("Load lang resouce file: %s", file.toLocal8Bit().data());

    QJsonParseError error;
    QString jsonStr(raw_bytes.data());
    QByteArray qbs = jsonStr.toUtf8();
    QJsonDocument doc = QJsonDocument::fromJson(qbs, &error);

    if (error.error != QJsonParseError::NoError)
    {
        QString estr = error.errorString();
        dsv_err("LangResource::load_page(), parse json error:\"%s\"!", estr.toUtf8().data());
        return;
    }

    QJsonArray jarray = doc.array();

    for (const QJsonValue &dec_value : jarray)
    {
        QJsonObject obj = dec_value.toObject();

        if (obj.contains("id") && obj.contains("text")){
            QString id = obj["id"].toString().trimmed();
            QString text = obj["text"].toString();
            p._res[id.toStdString()] = text.toStdString();
        }
    }
}

const char* LangResource::get_lang_text(int page_id, const char *str_id, const char *default_str)
{
    assert(str_id);
    assert(default_str); 

    std::lock_guard<std::mutex> lock(_mutex);

    if (*str_id == '\0' || *default_str == '\0'){
        dsv_err("LangResource::get_lang_text(), param is empty.");
        assert(false);
    }

    if (_current_page == NULL || _current_page->_id != page_id){
        _current_page = NULL; 
        for (Lang_resource_page *p : _pages){
            if (p->_id == page_id){
                _current_page = p;
                break;
            }
        }
    }

    if (_current_page == NULL){
        if (_cur_lang != LAN_EN)
            dsv_warn("Warning:Can't find language source page:%d", page_id);
        return default_str;
    }

    if (_current_page->_loaded == false)
        load_page(*_current_page);

    std::string key(str_id);

    if (_current_page->_released){
        auto it = _current_page->_res_history.find(key);
        if (it != _current_page->_res_history.end()){
            return (*it).second.c_str();
        }
    }
    else{
        auto it = _current_page->_res.find(key);
        if (it != _current_page->_res.end()){
            if (_current_page->_is_dynamic){
                _current_page->_res_history[key] = (*it).second; //Save to history list.
            }
            return (*it).second.c_str();
        }
    }   
   
    if(_cur_lang != LAN_EN){
        dsv_warn("Warning:Can't get language text:%s", str_id);
    }

    return default_str;
}

bool LangResource::is_new_decoder(const char *decoder_id)
{
    std::lock_guard<std::mutex> lock(_mutex);

    std::string key(decoder_id);
    if (_query_decoders.find(key) == _query_decoders.end()){
        _query_decoders[key] = 1;
        return true;
    }

    return false;
}

void LangResource::reload_dynamic()
{
    std::lock_guard<std::mutex> lock(_mutex);

    for (Lang_resource_page *p : _pages)
    {
        if (p->_is_dynamic){
            p->_released = false;
            p->_loaded = false;
            load_page(*p);
        }
    }
}

void LangResource::release_dynamic()
{
    std::lock_guard<std::mutex> lock(_mutex);

    for (Lang_resource_page *p : _pages)
    {
        if (p->_is_dynamic){
            p->_res.clear();
            p->_released = true;
        }
    }
}
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#pragma once

#include <QString>

class QWidget;

namespace dsv{
    namespace dialogs{
        class DSMessageBox;
    }
}

class MsgBox
{
public:
    static void Show(const QString text);
    static void Show(const QString title, const QString text, QWidget *parent=0);
    static void Show(const QString title, const QString text, const QString infoText); 
    static void Show(const QString title, const QString text, QWidget *parent, dsv::dialogs::DSMessageBox **box);
    static void Show(const QString title, const QString text, const QString infoText, QWidget *parent, dsv::dialogs::DSMessageBox **box);

    static bool Confirm(const QString text, QWidget *parent=0);
    static bool Confirm(const QString text, const QString infoText, dsv::dialogs::DSMessageBox **box=0, QWidget *parent=0);
};/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#include "dscombobox.h"
#include <QFontMetrics>
#include <QString>
#include <QGuiApplication>
#include <QScreen>
#include "../config/appconfig.h"
 
using namespace dsv::config;

DsComboBox::DsComboBox(QWidget *parent) : QComboBox(parent)
{
    _contentWidth = 0;
    _bPopup = false;
    QComboBox::setSizeAdjustPolicy(QComboBox::AdjustToContents);   
}
  
 void DsComboBox::addItem(const QString &atext, const QVariant &auserData)
 {
      QComboBox::addItem(atext, auserData);

#ifdef Q_OS_DARWIN
      if (!atext.isEmpty()){
          QFontMetrics fm = this->fontMetrics();
          int w = fm.boundingRect(atext).width();
          if (w > _contentWidth){
              _contentWidth = w;                                
              this->setStyleSheet("QAbstractItemView{min-width:" + QString::number(w + 30) + "px;}");
          }
      }
#endif
 }

 void DsComboBox::showPopup()
 {
	QComboBox::showPopup();
    _bPopup = true;

    QWidget *popup = this->findChild<QFrame*>();
    auto rc = popup->geometry();
    int x = rc.left();
    int y = rc.top();
    int w = rc.right() - rc.left() + 2;
    int h = rc.bottom() - rc.top() + 20;

#ifdef Q_OS_DARWIN
    x += 6;
#endif

#ifndef _WIN32
    w += 3;
#endif

    popup->setGeometry(x, y, w, h);

    int sy = QGuiApplication::primaryScreen()->size().height(); 
    if (sy <= 1080){
        popup->setMaximumHeight(750); 
    }
    
    if (AppConfig::Instance().frameOptions.style == THEME_STYLE_DARK){       
        popup->setStyleSheet("background-color:#262626;");
    }
    else{
        popup->setStyleSheet("background-color:#white;");
    }
 }

 void DsComboBox::hidePopup()
 {
     QComboBox::hidePopup();
     _bPopup = false;
 }
 
/****************************************************************************
** Meta object code from reading C++ file 'dscombobox.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "dscombobox.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'dscombobox.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSDsComboBoxENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSDsComboBoxENDCLASS = QtMocHelpers::stringData(
    "DsComboBox"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSDsComboBoxENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[11];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSDsComboBoxENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSDsComboBoxENDCLASS_t qt_meta_stringdata_CLASSDsComboBoxENDCLASS = {
    {
        QT_MOC_LITERAL(0, 10)   // "DsComboBox"
    },
    "DsComboBox"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSDsComboBoxENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject DsComboBox::staticMetaObject = { {
    QMetaObject::SuperData::link<QComboBox::staticMetaObject>(),
    qt_meta_stringdata_CLASSDsComboBoxENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSDsComboBoxENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSDsComboBoxENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<DsComboBox, std::true_type>
    >,
    nullptr
} };

void DsComboBox::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *DsComboBox::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *DsComboBox::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSDsComboBoxENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QComboBox::qt_metacast(_clname);
}

int DsComboBox::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QComboBox::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2023 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "fn.h"
#include <assert.h>
#include <QPushButton>
#include <QToolButton>
#include <QComboBox>
#include <QLabel>
#include <QAction>
#include <QToolBar>
#include <QWidget>
#include <QLineEdit>
#include <QTabWidget>
#include <QGroupBox>
#include <QTextEdit>
#include <QRadioButton>
#include <QCheckBox>
#include "../config/appconfig.h"

namespace ui
{
    void set_toolbar_font(QToolBar *bar, QFont font)
    {
        assert(bar);

        auto buttons = bar->findChildren<QToolButton*>();
        for(auto o : buttons)
        { 
            o->setFont(font);
        }

        auto buttons2 = bar->findChildren<QPushButton*>();
        for(auto o : buttons2)
        { 
            o->setFont(font);
        }

        auto comboxs = bar->findChildren<QComboBox*>();
        for(auto o : comboxs)
        { 
            o->setFont(font);
        }

        auto labels = bar->findChildren<QLabel*>();
        for(auto o : labels)
        { 
            o->setFont(font);
        }

        auto actions = bar->findChildren<QAction*>();
        for(auto o : actions)
        { 
            o->setFont(font);
        }
    }
    
    void set_form_font(QWidget *wid, QFont font)
    {
        assert(wid);

        auto buttons2 = wid->findChildren<QPushButton*>();
        for(auto o : buttons2)
        { 
            o->setFont(font);
        }

        auto comboxs = wid->findChildren<QComboBox*>();
        for(auto o : comboxs)
        { 
            o->setFont(font);
        }

        auto labels = wid->findChildren<QLabel*>();
        for(auto o : labels)
        { 
            o->setFont(font);
        }

        auto edits = wid->findChildren<QLineEdit*>();
        for(auto o : edits)
        { 
            o->setFont(font);
        }

        auto textEdits = wid->findChildren<QTextEdit*>();
        for(auto o : textEdits)
        { 
            o->setFont(font);
        }

        auto radios = wid->findChildren<QRadioButton*>();
        for(auto o : radios)
        { 
            o->setFont(font);
        }

        auto checks = wid->findChildren<QCheckBox*>();
        for(auto o : checks)
        { 
            o->setFont(font);
        }

        // Magnify the size.
        font.setPointSizeF(font.pointSizeF() + 1);

        auto tabs = wid->findChildren<QTabWidget*>();
        for(auto o : tabs)
        { 
            o->setFont(font); 
        }

        auto groups = wid->findChildren<QGroupBox*>();
        for(auto o : groups)
        { 
            o->setFont(font);
        }
    }

} // namespace ui/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSCOMBOBOX_H
#define DSCOMBOBOX_H

#include <QComboBox>
#include <QKeyEvent>

class DsComboBox : public QComboBox
{
    Q_OBJECT

public:
    explicit DsComboBox(QWidget *parent = nullptr);

    void addItem(const QString &atext, const QVariant &userData = QVariant());

public:
    void showPopup() override;

    void hidePopup() override;

    inline bool  IsPopup(){
        return _bPopup;
    } 

private:
    int     _contentWidth;
    bool    _bPopup;
};



#endif // DSCOMBOBOX_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2022 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef LANG_RESOURCE_H
#define LANG_RESOURCE_H

#include <map>
#include <vector>
#include <QString>
#include <string>
#include <mutex>
#include "string_ids.h"

struct lang_key_item
{
    int id;
    const char *name;
};

class Lang_resource_page
{
public:
    Lang_resource_page();
    void Clear();

public:
    int     _id;
    const char   *_source;
    bool    _loaded;
    bool    _released;
    bool    _is_dynamic;
    std::map<std::string, std::string> _res;
    std::map<std::string, std::string> _res_history;
};

struct lang_page_item
{
    int id;
    const char *source;
    bool is_dynamic;
};

static const struct lang_key_item lang_id_keys[] = 
{
    {25, "cn"},
    {31, "en"}
};

static const struct lang_page_item lange_page_keys[] = 
{
    {STR_PAGE_TOOLBAR, "toolbar.json", false},
    {STR_PAGE_MSG, "msg.json", false},
    {STR_PAGE_DLG, "dlg.json", false},
    {STR_PAGE_DSL, "dsl_list.json, dsl_label.json, dsl_channel.json", false},
    {STR_PAGE_DECODER, "dec/0.json,dec/a.json,dec/f.json,dec/k.json,dec/p.json,dec/u.json", true},
};

class LangResource
{
private:
    LangResource();

public:
    static LangResource* Instance();
    bool Load(int lang);
    void Release();
  
    const char* get_lang_text(int page_id, const char *str_id, const char *default_str);
    bool is_new_decoder(const char *decoder_id);
    void reload_dynamic();
    void release_dynamic();

    inline bool is_lang_en(){
        return _cur_lang == 31;
    }
   
private:
    void release_self();
    const char *get_lang_key(int lang);

    void load_page(Lang_resource_page &p);

    void load_page(Lang_resource_page &p, QString file);
 
private:
    std::vector<Lang_resource_page*> _pages;
    Lang_resource_page    *_current_page;
    int     _cur_lang;
    std::map<std::string, int> _query_decoders;
    mutable std::mutex  _mutex;  
};

#define S_ID(id) #id
#define L_S(pid,sid,dv) (LangResource::Instance()->get_lang_text((pid), (sid), (dv)))

#endif/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2022 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef STRING_IDS_H
#define STRING_IDS_H

#define     STR_PAGE_MSG        1
#define     STR_PAGE_TOOLBAR    2
#define     STR_PAGE_DLG        3
#define     STR_PAGE_DSL        100
#define     STR_PAGE_DECODER    101

#define IDS_MSG_LOG_LEVEL
#endif
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef _I_CALLBACKS_
#define _I_CALLBACKS_


class ISessionCallback
{
public: 
    virtual void session_error()=0;
    virtual void session_save()=0;
    virtual void data_updated()=0;
    virtual void update_capture()=0;
    virtual void cur_snap_samplerate_changed()=0;
    virtual void signals_changed()=0;
    virtual void receive_trigger(quint64 trigger_pos)=0;
    virtual void frame_ended()=0;
    virtual void frame_began()=0;
    virtual void show_region(uint64_t start, uint64_t end, bool keep)=0;
    virtual void show_wait_trigger()=0;
    virtual void repeat_hold(int percent)=0;
    virtual void decode_done()=0;
    virtual void receive_data_len(quint64 len)=0;    
    virtual void receive_header()=0;
    virtual void trigger_message(int msg)=0;  
    virtual void delay_prop_msg(QString strMsg)=0;
};

class ISessionDataGetter
{
public:
    virtual bool genSessionData(std::string &str) = 0;
};


class IDlgCallback
{
public:
    virtual void OnDlgResult(bool bYes)=0;
};

class IMainForm{
public:
    virtual void switchLanguage(int language)=0;
};


#define DSV_MSG_START_COLLECT_WORK_PREV 5001
#define DSV_MSG_START_COLLECT_WORK      5002
#define DSV_MSG_COLLECT_START           5003
#define DSV_MSG_COLLECT_END             5004
#define DSV_MSG_END_COLLECT_WORK_PREV   5005
#define DSV_MSG_END_COLLECT_WORK        5006
#define DSV_MSG_REV_END_PACKET          5007

#define DSV_MSG_DEVICE_LIST_UPDATED     6000
#define DSV_MSG_BEGIN_DEVICE_OPTIONS    6001 //Begin show device options dialog.
#define DSV_MSG_END_DEVICE_OPTIONS      6002
#define DSV_MSG_DEVICE_OPTIONS_UPDATED  6003
#define DSV_MSG_DEVICE_DURATION_UPDATED 6004
#define DSV_MSG_DEVICE_MODE_CHANGED     6005
#define DSV_MSG_CURRENT_DEVICE_CHANGE_PREV  6006
#define DSV_MSG_CURRENT_DEVICE_CHANGED  6007
#define DSV_MSG_NEW_USB_DEVICE          6008
#define DSV_MSG_CURRENT_DEVICE_DETACHED 6009
#define DSV_MSG_DEVICE_CONFIG_UPDATED   6010
#define DSV_MSG_DEMO_OPERATION_MODE_CHNAGED   6011
#define DSV_MSG_COLLECT_MODE_CHANGED    6012

#define DSV_MSG_TRIG_NEXT_COLLECT       7001
#define DSV_MSG_SAVE_COMPLETE           7002
#define DSV_MSG_STORE_CONF_PREV         7003

#define DSV_MSG_CLEAR_DECODE_DATA       8001

#define DSV_MSG_APP_OPTIONS_CHANGED     9001
#define DSV_MSG_FONT_OPTIONS_CHANGED    9002

class IMessageListener
{
public:
    virtual void OnMessage(int msg)=0;
};

class IDecoderPannel
{
public:
    virtual void update_deocder_item_name(void *trace_handel, const char *name)=0;
};

class IFontForm
{
public:
    virtual void update_font()=0;
};

#endif
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2022 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "log.h"
#include <QString>
#include <QDir>
#include  "config/appconfig.h"
#include "utility/path.h"
#include <string>

using namespace dsv::config;

xlog_writer *dsv_log = nullptr;

namespace dsv{
static xlog_context *log_ctx = nullptr;
static bool b_logfile = false;
static int log_file_index = -1; 

void dsv_log_init()
{
    if (log_ctx == nullptr){
        log_ctx = xlog_new();  
        dsv_log = xlog_create_writer(log_ctx, "DSView"); 
    }
} 

void dsv_log_uninit()
{ 
    xlog_free(log_ctx);
    xlog_free_writer(dsv_log);
    log_ctx = nullptr;
    dsv_log = nullptr;
}

xlog_context* dsv_log_context()
{
    return log_ctx;
}

void dsv_log_level(int l)
{
    xlog_set_level(log_ctx, l);
    dsv_info("%s%d", "Set log level: ", l);
}

void dsv_log_enalbe_logfile(bool append)
{
    if (!b_logfile && log_ctx){
        b_logfile = true; 
        
        QString lf = get_dsv_log_path();
        
        dsv_info("%s\"%s\"", "Store log to file: ", lf.toUtf8().data());

        std::string log_file = dsv::path::ToUnicodePath(lf);

        int ret = xlog_add_receiver_from_file(log_ctx, log_file.c_str(), &log_file_index, append);
        if (ret != 0){
            dsv_err("Create log file error!");
        }
    }
}

void dsv_clear_log_file()
{   
    if (b_logfile && log_ctx)
    {
        QString lf = get_dsv_log_path();
        std::string log_file = dsv::path::ToUnicodePath(lf);
        int ret = xlog_reset_log_file(log_ctx, log_file_index, log_file.c_str());

        if (ret != 0){
            dsv_err("Clear log file error!");
        }
    }
    else{
        QDir dir;
        QString filePath = get_dsv_log_path();
        if (dir.exists(filePath))
        {
            dir.remove(filePath);
        }
    }
}

void dsv_set_log_file_enable(bool flag)
{
    if (b_logfile && log_ctx)
    {
        xlog_set_receiver_enable(log_ctx, log_file_index, flag);
    }
}

void dsv_remove_log_file()
{
    if (b_logfile && log_ctx)
    {
        b_logfile = false;
        xlog_remove_receiver_by_index(log_ctx, log_file_index);
        log_file_index = -1;
    }
}

QString get_dsv_log_path()
{
    QString lf;

    #ifdef Q_OS_LINUX
        lf = QDir::homePath() + "/DSView.log";
    #endif

    #ifdef _WIN32
        lf = AppConfig::GetUserDataDir() + "/DSView.log";
    #endif

    #ifdef Q_OS_DARWIN
        lf = AppConfig::GetUserDataDir() + "/DSView.log";
    #endif

    return lf;
}

} //namespace dsv/****************************************************************************
** Meta object code from reading C++ file 'property.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "property.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'property.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEPropertyENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEPropertyENDCLASS = QtMocHelpers::stringData(
    "dsv::prop::Property"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEPropertyENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[20];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEPropertyENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEPropertyENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEPropertyENDCLASS = {
    {
        QT_MOC_LITERAL(0, 19)   // "dsv::prop::Property"
    },
    "dsv::prop::Property"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEpropSCOPEPropertyENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::prop::Property::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEPropertyENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEpropSCOPEPropertyENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEPropertyENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<Property, std::true_type>
    >,
    nullptr
} };

void dsv::prop::Property::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *dsv::prop::Property::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::prop::Property::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEPropertyENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int dsv::prop::Property::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
/****************************************************************************
** Meta object code from reading C++ file 'enum.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "enum.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'enum.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEEnumENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEEnumENDCLASS = QtMocHelpers::stringData(
    "dsv::prop::Enum",
    "on_current_item_changed",
    ""
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEEnumENDCLASS_t {
    uint offsetsAndSizes[6];
    char stringdata0[16];
    char stringdata1[24];
    char stringdata2[1];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEEnumENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEEnumENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEEnumENDCLASS = {
    {
        QT_MOC_LITERAL(0, 15),  // "dsv::prop::Enum"
        QT_MOC_LITERAL(16, 23),  // "on_current_item_changed"
        QT_MOC_LITERAL(40, 0)   // ""
    },
    "dsv::prop::Enum",
    "on_current_item_changed",
    ""
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEpropSCOPEEnumENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   20,    2, 0x08,    1 /* Private */,

 // slots: parameters
    QMetaType::Void, QMetaType::Int,    2,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::prop::Enum::staticMetaObject = { {
    QMetaObject::SuperData::link<Property::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEEnumENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEpropSCOPEEnumENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEEnumENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<Enum, std::true_type>,
        // method 'on_current_item_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>
    >,
    nullptr
} };

void dsv::prop::Enum::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<Enum *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->on_current_item_changed((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        default: ;
        }
    }
}

const QMetaObject *dsv::prop::Enum::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::prop::Enum::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEEnumENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return Property::qt_metacast(_clname);
}

int dsv::prop::Enum::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = Property::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 1;
    }
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_PROP_ENUM_H
#define DSVIEW_PV_PROP_ENUM_H

#include <utility>
#include <vector>
#include "property.h"

class DsComboBox;

namespace dsv {
namespace prop {

class Enum : public Property
{
    Q_OBJECT;

public:
    Enum(QString name, QString label, std::vector<std::pair<GVariant*, QString> > values,
		Getter getter, Setter setter);

	virtual ~Enum();

    QWidget* get_widget(QWidget *parent, bool auto_commit);

	void commit();

private slots:
    void on_current_item_changed(int);

private:
	const std::vector< std::pair<GVariant*, QString> > _values;

	DsComboBox *_selector;
};

} // prop
} // pv

#endif // DSVIEW_PV_PROP_ENUM_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_PROP_BOOL_H
#define DSVIEW_PV_PROP_BOOL_H

#include "property.h"

class QCheckBox;

namespace dsv {
namespace prop {

class Bool : public Property
{
    Q_OBJECT;

public:
    Bool(QString name, QString label, Getter getter, Setter setter);

	virtual ~Bool();

    QWidget* get_widget(QWidget *parent, bool auto_commit);
	bool labeled_widget();

    GVariant* get_value();

	void commit();

private slots:
    void on_state_changed(int);

private:
	QCheckBox *_check_box;
};

} // prop
} // pv

#endif // DSVIEW_PV_PROP_BOOL_H
/****************************************************************************
** Meta object code from reading C++ file 'bool.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "bool.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'bool.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEBoolENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEBoolENDCLASS = QtMocHelpers::stringData(
    "dsv::prop::Bool",
    "on_state_changed",
    ""
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEBoolENDCLASS_t {
    uint offsetsAndSizes[6];
    char stringdata0[16];
    char stringdata1[17];
    char stringdata2[1];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEBoolENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEBoolENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEBoolENDCLASS = {
    {
        QT_MOC_LITERAL(0, 15),  // "dsv::prop::Bool"
        QT_MOC_LITERAL(16, 16),  // "on_state_changed"
        QT_MOC_LITERAL(33, 0)   // ""
    },
    "dsv::prop::Bool",
    "on_state_changed",
    ""
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEpropSCOPEBoolENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   20,    2, 0x08,    1 /* Private */,

 // slots: parameters
    QMetaType::Void, QMetaType::Int,    2,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::prop::Bool::staticMetaObject = { {
    QMetaObject::SuperData::link<Property::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEBoolENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEpropSCOPEBoolENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEBoolENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<Bool, std::true_type>,
        // method 'on_state_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>
    >,
    nullptr
} };

void dsv::prop::Bool::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<Bool *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->on_state_changed((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        default: ;
        }
    }
}

const QMetaObject *dsv::prop::Bool::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::prop::Bool::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEBoolENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return Property::qt_metacast(_clname);
}

int dsv::prop::Bool::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = Property::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 1;
    }
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#include "property.h"

namespace dsv {
namespace prop {

Property::Property(QString name, QString label, Getter getter, Setter setter) :
	_getter(getter),
	_setter(setter),
    _name(name),
    _label(label)
{
}

Property::~Property(){

}

const QString& Property::name()
{
	return _name;
}

const QString& Property::label()
{
    return _label;
}

bool Property::labeled_widget()
{
	return false;
}

GVariant* Property::get_value()
{
    return NULL;
}

} // prop
} // pv
/****************************************************************************
** Meta object code from reading C++ file 'string.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "string.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'string.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEStringENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEStringENDCLASS = QtMocHelpers::stringData(
    "dsv::prop::String",
    "on_text_edited",
    ""
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEStringENDCLASS_t {
    uint offsetsAndSizes[6];
    char stringdata0[18];
    char stringdata1[15];
    char stringdata2[1];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEStringENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEStringENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEStringENDCLASS = {
    {
        QT_MOC_LITERAL(0, 17),  // "dsv::prop::String"
        QT_MOC_LITERAL(18, 14),  // "on_text_edited"
        QT_MOC_LITERAL(33, 0)   // ""
    },
    "dsv::prop::String",
    "on_text_edited",
    ""
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEpropSCOPEStringENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   20,    2, 0x08,    1 /* Private */,

 // slots: parameters
    QMetaType::Void, QMetaType::QString,    2,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::prop::String::staticMetaObject = { {
    QMetaObject::SuperData::link<Property::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEStringENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEpropSCOPEStringENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEStringENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<String, std::true_type>,
        // method 'on_text_edited'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<const QString &, std::false_type>
    >,
    nullptr
} };

void dsv::prop::String::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<String *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->on_text_edited((*reinterpret_cast< std::add_pointer_t<QString>>(_a[1]))); break;
        default: ;
        }
    }
}

const QMetaObject *dsv::prop::String::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::prop::String::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEStringENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return Property::qt_metacast(_clname);
}

int dsv::prop::String::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = Property::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 1;
    }
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2013 Joel Holdsworth <joel@airwebreathe.org.uk>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include <assert.h>

#include <QLineEdit>
#include <QSpinBox>

#include "string.h"

namespace dsv {
namespace prop {

String::String(QString name, QString label,
	Getter getter,
	Setter setter) :
    Property(name, label, getter, setter),
	_line_edit(NULL)
{
}

QWidget* String::get_widget(QWidget *parent, bool auto_commit)
{
	if (_line_edit)
		return _line_edit;

	GVariant *const value = _getter ? _getter() : NULL;
	if (!value)
		return NULL;

	_line_edit = new QLineEdit(parent);
	_line_edit->setText(QString::fromUtf8(
        g_variant_get_string(value, NULL)));
	g_variant_unref(value);

	if (auto_commit)
		connect(_line_edit, SIGNAL(textEdited(const QString&)),
			this, SLOT(on_text_edited(const QString&)));

	return _line_edit;
}

void String::commit()
{
	assert(_setter);

	if (!_line_edit)
		return;

    QByteArray ba = _line_edit->text().toUtf8();
    _setter(g_variant_new_string(ba.data()));
}

void String::on_text_edited(const QString&)
{
	commit();
}

} // prop
} // pv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_PROP_INT_H
#define DSVIEW_PV_PROP_INT_H

#include <utility>
#include <boost/optional.hpp>
#include "property.h"

class QSpinBox;

namespace dsv {
namespace prop {

class Int : public Property
{
    Q_OBJECT;

public:
    Int(QString name, QString label, QString suffix,
		boost::optional< std::pair<int64_t, int64_t> > range,
		Getter getter, Setter setter);

	virtual ~Int();

    QWidget* get_widget(QWidget *parent, bool auto_commit);

	void commit();

private slots:
    void on_value_changed(int);

private:
	const QString _suffix;
	const boost::optional< std::pair<int64_t, int64_t> > _range;

    GVariant *_value;
	QSpinBox *_spin_box;
};

} // prop
} // pv

#endif // DSVIEW_PV_PROP_INT_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "int.h"
#include <stdint.h>
#include <assert.h>
#include <math.h>
#include <QSpinBox>


using boost::optional;
using namespace std;

//#define INT8_MIN    (-0x7f - 1)
//#define INT16_MIN   (-0x7fff - 1)
//#define INT32_MIN   (-0x7fffffff - 1)
//#define INT64_MIN   (-0x7fffffffffffffff - 1)
//
//#define INT8_MAX    0x7f
//#define INT16_MAX   0x7fff
//#define INT32_MAX   0x7fffffff
//#define INT64_MAX   0x7fffffffffffffff
//
//#define UINT8_MAX   0xff
//#define UINT16_MAX  0xffff
//#define UINT32_MAX  0xffffffff
//#define UINT64_MAX  0xffffffffffffffff

namespace dsv {
namespace prop {

Int::Int(QString name, QString label,
    QString suffix,
    boost::optional< pair<int64_t, int64_t> > range,
    Getter getter,
    Setter setter) :
    Property(name, label, getter, setter),
	_suffix(suffix),
	_range(range),
    _value(NULL),
	_spin_box(NULL)
{
}

Int::~Int()
{
    if (_value)
        g_variant_unref(_value);
}

QWidget* Int::get_widget(QWidget *parent, bool auto_commit)
{
    int64_t int_val = 0, range_min = 0, range_max = 0;

    if (_spin_box)
        return _spin_box;

    if (_value)
        g_variant_unref(_value);

    _value = _getter ? _getter() : NULL;
    if (!_value)
        return NULL;

    _spin_box = new QSpinBox(parent);
    _spin_box->setSuffix(_suffix);

    const GVariantType *const type = g_variant_get_type(_value);
    assert(type);

    if (g_variant_type_equal(type, G_VARIANT_TYPE_BYTE))
    {
        int_val = g_variant_get_byte(_value);
        range_min = 0, range_max = UINT8_MAX;
    }
    else if (g_variant_type_equal(type, G_VARIANT_TYPE_INT16))
    {
        int_val = g_variant_get_int16(_value);
        range_min = INT16_MIN, range_max = INT16_MAX;
    }
    else if (g_variant_type_equal(type, G_VARIANT_TYPE_UINT16))
    {
        int_val = g_variant_get_uint16(_value);
        range_min = 0, range_max = UINT16_MAX;
    }
    else if (g_variant_type_equal(type, G_VARIANT_TYPE_INT32))
    {
        int_val = g_variant_get_int32(_value);
        range_min = INT32_MIN, range_max = INT32_MAX;
    }
    else if (g_variant_type_equal(type, G_VARIANT_TYPE_UINT32))
    {
        int_val = g_variant_get_uint32(_value);
        range_min = 0, range_max = UINT32_MAX;
    }
    else if (g_variant_type_equal(type, G_VARIANT_TYPE_INT64))
    {
        int_val = g_variant_get_int64(_value);
        range_min = INT64_MIN, range_max = INT64_MAX;
    }
    else if (g_variant_type_equal(type, G_VARIANT_TYPE_UINT64))
    {
        int_val = g_variant_get_uint64(_value);
        range_min = 0, range_max = UINT64_MAX;
    }
    else
    {
        // Unexpected value type.
        assert(0);
    }

    // @todo Sigrok supports 64-bit quantities, but Qt does not have a
    // standard widget to allow the values to be modified over the full
    // 64-bit range on 32-bit machines. To solve the issue we need a
    // custom widget.

    range_min = max(range_min, (int64_t)INT_MIN);
    range_max = min(range_max, (int64_t)INT_MAX);

    if (_range)
        _spin_box->setRange((int)_range->first, (int)_range->second);
    else
        _spin_box->setRange((int)range_min, (int)range_max);

    _spin_box->setValue((int)int_val);

    if (auto_commit)
        connect(_spin_box, SIGNAL(valueChanged(int)),
            this, SLOT(on_value_changed(int)));

    return _spin_box;
}

void Int::commit()
{
    assert(_setter);

    if (!_spin_box)
        return;

    assert(_value);

    GVariant *new_value = NULL;
    const GVariantType *const type = g_variant_get_type(_value);
    assert(type);

    if (g_variant_type_equal(type, G_VARIANT_TYPE_BYTE))
        new_value = g_variant_new_byte(_spin_box->value());
    else if (g_variant_type_equal(type, G_VARIANT_TYPE_INT16))
        new_value = g_variant_new_int16(_spin_box->value());
    else if (g_variant_type_equal(type, G_VARIANT_TYPE_UINT16))
        new_value = g_variant_new_uint16(_spin_box->value());
    else if (g_variant_type_equal(type, G_VARIANT_TYPE_INT32))
        new_value = g_variant_new_int32(_spin_box->value());
    else if (g_variant_type_equal(type, G_VARIANT_TYPE_UINT32))
        new_value = g_variant_new_int32(_spin_box->value());
    else if (g_variant_type_equal(type, G_VARIANT_TYPE_INT64))
        new_value = g_variant_new_int64(_spin_box->value());
    else if (g_variant_type_equal(type, G_VARIANT_TYPE_UINT64))
        new_value = g_variant_new_uint64(_spin_box->value());
    else
    {
        // Unexpected value type.
        assert(0);
    }

    assert(new_value);

    g_variant_unref(_value);
    g_variant_ref(new_value);
    _value = new_value;

    _setter(new_value);
}

void Int::on_value_changed(int)
{
    commit();
}

} // prop
} // pv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "deviceoptions.h"
#include <boost/bind.hpp>
#include <QObject>
#include <stdint.h>
#include "../bool.h"
#include "../double.h"
#include "../enum.h"
#include "../int.h"
#include "../../config/appconfig.h"
#include "../../log.h"
#include "../../appcore/appcontrol.h"
#include "../../appcore/sigsession.h"
#include "../../appcore/deviceagent.h"
#include "../../ui/langresource.h"
 
using namespace std;
using namespace dsv::appcore;

namespace dsv {
namespace prop {
namespace binding {

DeviceOptions::DeviceOptions()
{
	GVariant *gvar_opts, *gvar_list;
	gsize num_opts;

	auto session = AppControl::Instance()->GetSession();
	auto device_agent = session->get_device();

	gvar_opts = device_agent->get_config_list(NULL, SR_CONF_DEVICE_OPTIONS);
	 
    if (gvar_opts == NULL)
		/* Driver supports no device instance options. */
		return;

	const int *const options = (const int32_t *)g_variant_get_fixed_array(
		gvar_opts, &num_opts, sizeof(int32_t));
	
	for (unsigned int i = 0; i < num_opts; i++) {
		const struct sr_config_info *const info =
			device_agent->get_config_info(options[i]);

		if (!info)
			continue;

		const int key = info->key;

		gvar_list = device_agent->get_config_list(NULL, key);

        const QString name(info->name);
        const char *label_char = info->name;
        QString label(label_char);

		switch(key)
		{
		case SR_CONF_SAMPLERATE:
            bind_samplerate(name, label, gvar_list);
			break;

		case SR_CONF_CAPTURE_RATIO:
            bind_int(name, label, key, "%", pair<int64_t, int64_t>(0, 100));
			break;

		case SR_CONF_PATTERN_MODE:
		case SR_CONF_BUFFERSIZE:
		case SR_CONF_TRIGGER_SOURCE:		
        case SR_CONF_MAX_HEIGHT:
        case SR_CONF_MAX_HEIGHT_VALUE:
        case SR_CONF_PROBE_COUPLING:
        case SR_CONF_PROBE_EN:
        case SR_CONF_ZERO:
        case SR_CONF_STREAM:
        case SR_CONF_TEST:
        case SR_CONF_STATUS:
        case SR_CONF_PROBE_FACTOR:
            bind_enum(name, label, key, gvar_list);
			break;

		case SR_CONF_OPERATION_MODE:
        case SR_CONF_BUFFER_OPTIONS:
        case SR_CONF_THRESHOLD:
		case SR_CONF_FILTER: 
			bind_list(name, label, key, gvar_list);
			break;

        case SR_CONF_VTH:
            bind_double(name, label, key, "V", pair<double, double>(0.0, 5.0), 1, 0.1);
            break;

		case SR_CONF_RLE:
        case SR_CONF_RLE_SUPPORT:
        case SR_CONF_CLOCK_TYPE:
        case SR_CONF_CLOCK_EDGE:
        case SR_CONF_INSTANT:
            bind_bool(name, label, key);
            break;

		case SR_CONF_TIMEBASE:
            bind_enum(name, label, key, gvar_list, print_timebase);
			break;

        case SR_CONF_PROBE_VDIV:
            bind_enum(name, label, key, gvar_list, print_vdiv);
            break;

        case SR_CONF_BANDWIDTH_LIMIT:
            bind_bandwidths(name, label, key, gvar_list);
            break;

        default:
            gvar_list = NULL;
		}

		if (gvar_list)
			g_variant_unref(gvar_list);
	}
    if (gvar_opts)
        g_variant_unref(gvar_opts);
}

GVariant* DeviceOptions::config_getter(int key)
{ 
	auto session = AppControl::Instance()->GetSession();
	auto device_agent = session->get_device();	
	return device_agent->get_config(key);
}

void DeviceOptions::config_setter(int key, GVariant* value)
{
	auto session = AppControl::Instance()->GetSession();
	auto device_agent = session->get_device();
    device_agent->set_config(key, value);
}

void DeviceOptions::bind_bool(const QString &name, const QString label, int key)
{
	QString text = LangResource::Instance()->get_lang_text(STR_PAGE_DSL, label.toLocal8Bit().data(), label.toLocal8Bit().data());
	_properties.push_back(
        new Bool(name, text, bind(config_getter, key),
			bind(config_setter, key, _1)));
}

void DeviceOptions::bind_enum(const QString &name, const QString label, int key,
    GVariant *const gvar_list, boost::function<QString (GVariant*)> printer)
{
	GVariant *gvar;
	GVariantIter iter;
	std::vector< pair<GVariant*, QString> > values;

	assert(gvar_list);

	g_variant_iter_init (&iter, gvar_list);

	while ((gvar = g_variant_iter_next_value (&iter)))
	{
		QString v = printer(gvar);
		values.push_back(make_pair(gvar, v));
	}

	_properties.push_back(
        new Enum(name, label, values,
			bind(config_getter, key),
			bind(config_setter, key, _1)));
}

void DeviceOptions::bind_int(const QString &name, const QString label, int key, QString suffix,
    boost::optional< std::pair<int64_t, int64_t> > range)
{
	_properties.push_back(
        new Int(name, label, suffix, range,
			bind(config_getter, key),
			bind(config_setter, key, _1)));
}

void DeviceOptions::bind_double(const QString &name, const QString label, int key, QString suffix,
    boost::optional< std::pair<double, double> > range,
    int decimals, boost::optional<double> step)
{
    _properties.push_back(
        new Double(name, label, decimals, suffix, range, step,
            bind(config_getter, key),
            bind(config_setter, key, _1)));
}

QString DeviceOptions::print_gvariant(GVariant *const gvar)
{
	QString s;

	if (g_variant_is_of_type(gvar, G_VARIANT_TYPE("s"))){
        s = QString::fromUtf8(g_variant_get_string(gvar, NULL));
	}
	else
	{
		gchar *const text = g_variant_print(gvar, FALSE);
        s = QString::fromUtf8(text);
		g_free(text);
	}

	return s;
}

void DeviceOptions::bind_samplerate(const QString &name, const QString label,
    GVariant *const gvar_list)
{
	GVariant *gvar_list_samplerates;

	assert(gvar_list);

	if ((gvar_list_samplerates = g_variant_lookup_value(gvar_list,
			"samplerate-steps", G_VARIANT_TYPE("at"))))
	{
		gsize num_elements;
		const uint64_t *const elements =
			(const uint64_t *)g_variant_get_fixed_array(
				gvar_list_samplerates, &num_elements, sizeof(uint64_t));

		assert(num_elements == 3);

		_properties.push_back(
			//tr
            new Double(name, label, 0, L_S(STR_PAGE_DLG, S_ID(IDS_DLG_HZ), "Hz"),
				make_pair((double)elements[0], (double)elements[1]),
						(double)elements[2],
				bind(samplerate_double_getter),
				bind(samplerate_double_setter, _1)));

		g_variant_unref(gvar_list_samplerates);
	}
	else if ((gvar_list_samplerates = g_variant_lookup_value(gvar_list,
			"samplerates", G_VARIANT_TYPE("at"))))
	{
        bind_enum(name, label, SR_CONF_SAMPLERATE,
			gvar_list_samplerates, print_samplerate);
		g_variant_unref(gvar_list_samplerates);
	}
}

QString DeviceOptions::print_samplerate(GVariant *const gvar)
{
	char *const s = sr_samplerate_string(
		g_variant_get_uint64(gvar));
	const QString qstring(s);
	g_free(s);
	return qstring;
}

GVariant* DeviceOptions::samplerate_double_getter()
{
    GVariant *const gvar = config_getter(SR_CONF_SAMPLERATE);

	if(!gvar)
		return NULL;

	GVariant *const gvar_double = g_variant_new_double(
		g_variant_get_uint64(gvar));

	g_variant_unref(gvar);

	return gvar_double;
}

void DeviceOptions::samplerate_double_setter(GVariant *value)
{
	GVariant *const gvar = g_variant_new_uint64(
		g_variant_get_double(value));
	config_setter(SR_CONF_SAMPLERATE, gvar);
}

QString DeviceOptions::print_timebase(GVariant *const gvar)
{
	uint64_t p, q;
	g_variant_get(gvar, "(tt)", &p, &q);
	return QString(sr_period_string(p * q));
}

QString DeviceOptions::print_vdiv(GVariant *const gvar)
{
	uint64_t p, q;
	g_variant_get(gvar, "(tt)", &p, &q);
	return QString(sr_voltage_string(p, q));
}

void DeviceOptions::bind_bandwidths(const QString &name, const QString label, int key,
    GVariant *const gvar_list, boost::function<QString (GVariant*)> printer)
{
	(void)printer;

	bool bw_limit = false;
	GVariant *gvar;
	std::vector< pair<GVariant*, QString> > values;
	struct sr_list_item *plist;

	assert(gvar_list);
	plist = (struct sr_list_item*)g_variant_get_uint64(gvar_list);
	assert(plist);

	auto session = AppControl::Instance()->GetSession();
	auto device_agent = session->get_device();	
	device_agent->get_config_bool(SR_CONF_BANDWIDTH, bw_limit);

    if (bw_limit == false){
        return;
	}

	while (plist && plist->id >= 0)
	{ 
		QString v = LangResource::Instance()->get_lang_text(STR_PAGE_DSL, plist->name, plist->name);
		gvar = g_variant_new_int16(plist->id);
		values.push_back(make_pair(gvar, v));
        plist++;
	}

	_properties.push_back(
        new Enum(name, label, values,
			bind(config_getter, key),
			bind(config_setter, key, _1)));
}

void DeviceOptions::bind_list(const QString &name, const QString label, int key, GVariant *const gvar_list)
{
	GVariant *gvar;
	std::vector< pair<GVariant*, QString> > values;
	struct sr_list_item *plist;

	assert(gvar_list);
	plist = (struct sr_list_item*)g_variant_get_uint64(gvar_list);
	assert(plist);

	while (plist && plist->id >= 0)
	{ 
		QString v = LangResource::Instance()->get_lang_text(STR_PAGE_DSL, plist->name, plist->name);
		gvar = g_variant_new_int16(plist->id);
		values.push_back(make_pair(gvar, v));
        plist++;
	}

	_properties.push_back(
        new Enum(name, label, values,
			bind(config_getter, key),
			bind(config_setter, key, _1)));
}

} // binding
} // prop
} // pv

/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */
 
#include "binding.h"
#include <QFormLayout>
#include <QLabel>
#include "../property.h"


namespace dsv {
namespace prop {
namespace binding {

const std::vector<Property*>& Binding::properties()
{
	return _properties;
}

Binding::Binding(){
    _row_num = 0;    
}

void Binding::commit()
{
    for(auto p : _properties) {
        p->commit();
    }
}

void Binding::add_properties_to_form(QFormLayout *layout, bool auto_commit, QFont font)
{
    assert(layout);

    for(auto p : _properties)
    {
        QWidget *const widget = p->get_widget(layout->parentWidget(), auto_commit);

        if (p->labeled_widget()){
            layout->addRow(widget);
            widget->setFont(font);
            _row_num++;
        }
        else{
            const QString &lbstr = p->label();
            //remove data format options
            if (lbstr == "Data format"){
                continue;                
            }   
            QLabel *lb = new QLabel(p->label());
            lb->setFont(font);
            widget->setFont(font);
            layout->addRow(lb, widget);
            _row_num++;
        } 
    }
}

std::map<Property*,GVariant*> Binding::get_property_value()
{
    std::map <Property*,GVariant*> pvalue;
            
    for(auto p : _properties)
    {
        pvalue[p] = p->get_value();
    }

    return pvalue;
}

QString Binding::print_gvariant(GVariant *const gvar)
{
    QString s;

    if (g_variant_is_of_type(gvar, G_VARIANT_TYPE("s")))
        s = QString::fromUtf8(g_variant_get_string(gvar, NULL));
    else
    {
        gchar *const text = g_variant_print(gvar, FALSE);
        s = QString::fromUtf8(text);
        g_free(text);
    }

    return s;
}

} // binding
} // prop
} // pv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_PROP_BINDING_DEVICEOPTIONS_H
#define DSVIEW_PV_PROP_BINDING_DEVICEOPTIONS_H

#include <boost/function.hpp>
#include <boost/optional.hpp>
#include <QString>
#include <libsigrok.h> 
#include "binding.h" 

namespace dsv {
namespace prop {
namespace binding {

class DeviceOptions : public Binding
{
public:
	DeviceOptions();

private:

	static GVariant* config_getter(int key);

	static void config_setter(int key, GVariant* value);

    void bind_bool(const QString &name, const QString label, int key);

    void bind_enum(const QString &name, const QString label, int key, GVariant *const gvar_list,
		boost::function<QString (GVariant*)> printer = print_gvariant);

	void bind_list(const QString &name, const QString label, int key, GVariant *const gvar_list);

    void bind_int(const QString &name, const QString label, int key, QString suffix,
		boost::optional< std::pair<int64_t, int64_t> > range);

    void bind_double(const QString &name, const QString label, int key, QString suffix,
        boost::optional<std::pair<double, double> > range,
        int decimals, boost::optional<double> step);

	static QString print_gvariant(GVariant *const gvar);

    void bind_samplerate(const QString &name, const QString label,GVariant *const gvar_list);

	static QString print_samplerate(GVariant *const gvar);

	static GVariant* samplerate_double_getter();

	static void samplerate_double_setter(GVariant *value);

	static QString print_timebase(GVariant *const gvar);

	static QString print_vdiv(GVariant *const gvar);

    void bind_bandwidths(const QString &name, const QString label, int key,GVariant *const gvar_list,
        boost::function<QString (GVariant*)> printer = print_gvariant);
 
};

} // binding
} // prop
} // pv

#endif // DSVIEW_PV_PROP_BINDING_DEVICEOPTIONS_H
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2013 Joel Holdsworth <joel@airwebreathe.org.uk>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_PROP_BINDING_DECODEROPTIONS_H
#define DSVIEW_PV_PROP_BINDING_DECODEROPTIONS_H

#include "binding.h"
#include <QFont>
#include "../property.h"

struct srd_decoder_option;

namespace dsv{
	namespace decode{
    	class Decoder;
	}

	namespace data{
		class DecoderStack;
	}
}

using namespace dsv::data;
using namespace dsv::decode;

namespace dsv {
namespace prop {
namespace binding {

class DecoderOptions : public Binding
{
public:
	DecoderOptions(DecoderStack *decoder_stack, Decoder* decoder);

    GVariant* getter(const char *id);

    void setter(const char *id, GVariant *value);

private:
	static Property* bind_enum(const QString &name,
		const srd_decoder_option *option,
		Property::Getter getter, Property::Setter setter);



private:
	Decoder 	*_decoder;
};

} // binding
} // prop
} // pv

#endif // DSVIEW_PV_PROP_BINDING_DECODEROPTIONS_H
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2013 Joel Holdsworth <joel@airwebreathe.org.uk>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "decoderoptions.h"
#include <libsigrokdecode.h>
#include <boost/bind.hpp> 
#include <boost/none_t.hpp>
#include "../double.h"
#include "../enum.h"
#include "../int.h"
#include "../string.h"
#include "../../data/decoderstack.h"
#include "../../decode/decoder.h"
#include "../../ui/langresource.h"
#include "../../config/appconfig.h"

using namespace boost;
using namespace std;
using namespace dsv::config;
using namespace dsv::appcore;
 
namespace dsv {
namespace prop {
namespace binding {

DecoderOptions::DecoderOptions(DecoderStack* decoder_stack, Decoder *decoder):
	Binding(),
	_decoder(decoder)
{
	assert(_decoder);
	(void)decoder_stack;

	const srd_decoder *const dec = _decoder->decoder();
	assert(dec);

	bool bLang = AppConfig::Instance().appOptions.transDecoderDlg;

	if (LangResource::Instance()->is_lang_en()){
        bLang = false;
    }

	for (GSList *l = dec->options; l; l = l->next)
	{ 
		const srd_decoder_option *const opt =
			(srd_decoder_option*)l->data;

		const char *desc_str = NULL;
		const char *lang_str = NULL;

        if (opt->idn != NULL && LangResource::Instance()->is_lang_en() == false){
            lang_str = LangResource::Instance()->get_lang_text(STR_PAGE_DECODER, opt->idn, opt->desc);
        }

		if (lang_str != NULL && bLang){
            desc_str = lang_str;
        }
        else{
            desc_str = opt->desc;
        }

		const QString name = QString::fromUtf8(desc_str);

		const Property::Getter getter = bind(
			&DecoderOptions::getter, this, opt->id);
		const Property::Setter setter = bind(
			&DecoderOptions::setter, this, opt->id, _1);

		Property *prop = NULL;

		if (opt->values)
            prop = bind_enum(name, opt, getter, setter);
		else if (g_variant_is_of_type(opt->def, G_VARIANT_TYPE("d")))
            prop = new Double(name, name, 2, "",none, none, getter, setter);
		else if (g_variant_is_of_type(opt->def, G_VARIANT_TYPE("x")))
			prop = new Int(name, name, "", none, getter, setter);
		else if (g_variant_is_of_type(opt->def, G_VARIANT_TYPE("s")))
			prop = new String(name, name, getter, setter);
		else
			continue;

		_properties.push_back(prop);
	}
}

Property* DecoderOptions::bind_enum(
	const QString &name, const srd_decoder_option *option,
	Property::Getter getter, Property::Setter setter)
{
    std::vector<std::pair<GVariant*, QString> > values;
	for (GSList *l = option->values; l; l = l->next) {
		GVariant *const var = (GVariant*)l->data;
		assert(var);
		values.push_back(make_pair(var, print_gvariant(var)));
	}

    return new Enum(name, name, values, getter, setter);
}

GVariant* DecoderOptions::getter(const char *id)
{
	GVariant *val = NULL;

	assert(_decoder);

	// Get the value from the hash table if it is already present
	const map<string, GVariant*>& options = _decoder->options();
	auto iter = options.find(id);

	if (iter != options.end())
		val = (*iter).second;
	else
	{
		assert(_decoder->decoder());

		// Get the default value if not
		for (GSList *l = _decoder->decoder()->options; l; l = l->next)
		{
			const srd_decoder_option *const opt =
				(srd_decoder_option*)l->data;
			if (strcmp(opt->id, id) == 0) {
				val = opt->def;
				break;
			}
		}
	}

	if (val)
		g_variant_ref(val);

	return val;
}

void DecoderOptions::setter(const char *id, GVariant *value)
{
	assert(_decoder);
	_decoder->set_option(id, value);
}

} // binding
} // prop
} // pv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2018 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "probeoptions.h"
#include <boost/bind.hpp>
#include <QObject>
#include <stdint.h>
#include "../bool.h"
#include "../double.h"
#include "../enum.h"
#include "../int.h"
#include "../../config/appconfig.h"
#include "../../log.h"
#include "../../appcore/appcontrol.h"
#include "../../appcore/sigsession.h"
#include "../../ui/langresource.h"

using namespace std;
using namespace dsv::appcore;

namespace dsv {
namespace prop {
namespace binding {

ProbeOptions::ProbeOptions(struct sr_channel *probe) :
    Binding(), 
	_probe(probe)
{ 
	GVariant *gvar_opts;
	gsize num_opts;

    auto session = AppControl::Instance()->GetSession();
    auto device_agent = session->get_device();

    gvar_opts = device_agent->get_config_list(NULL, SR_CONF_PROBE_CONFIGS);
    if (gvar_opts == NULL){
		/* Driver supports no device instance options. */
		return;
    }

	const int *const options = (const int32_t *)g_variant_get_fixed_array(
		gvar_opts, &num_opts, sizeof(int32_t));

	for (unsigned int i = 0; i < num_opts; i++) 
    {
		const struct sr_config_info *const info =
			device_agent->get_config_info(options[i]);

		if (!info)
			continue;

		const int key = info->key;

        GVariant *gvar_list = device_agent->get_config_list(NULL, key);

        const QString name(info->name);
        const char *label_char =  LangResource::Instance()->get_lang_text(STR_PAGE_DSL, info->name, info->name);       
        const QString label(label_char);

		switch(key)
		{
        case SR_CONF_PROBE_VDIV:
            bind_vdiv(name, label, gvar_list);
			break;

        case SR_CONF_PROBE_MAP_MIN:
        case SR_CONF_PROBE_MAP_MAX:
            bind_double(name, label, key, "",
                        pair<double, double>(-999999.99, 999999.99), 2, 0.01);
            break;

        case SR_CONF_PROBE_COUPLING:
            bind_coupling(name, label, gvar_list);
            break;

        case SR_CONF_PROBE_MAP_UNIT:
            bind_enum(name, label, key, gvar_list);
			break;

        case SR_CONF_PROBE_MAP_DEFAULT:
            bind_bool(name, label, key);
            break;
		}

		if (gvar_list)
			g_variant_unref(gvar_list);
	}
    g_variant_unref(gvar_opts);
}

GVariant* ProbeOptions::config_getter(const struct sr_channel *probe, int key)
{ 
    auto session = AppControl::Instance()->GetSession();
    auto device_agent = session->get_device();
    return device_agent->get_config(key, probe, NULL);
}

void ProbeOptions::config_setter(struct sr_channel *probe, int key, GVariant* value)
{
    auto session = AppControl::Instance()->GetSession();
    auto device_agent = session->get_device();
    device_agent->set_config(key, value, probe, NULL);
}

void ProbeOptions::bind_bool(const QString &name, const QString label, int key)
{
	_properties.push_back(
        new Bool(name, label, bind(config_getter, _probe, key),
            bind(config_setter, _probe, key, _1)));
}

void ProbeOptions::bind_enum(const QString &name, const QString label, int key,
    GVariant *const gvar_list, boost::function<QString (GVariant*)> printer)
{
	GVariant *gvar;
	GVariantIter iter;
	std::vector< pair<GVariant*, QString> > values;

	assert(gvar_list);

	g_variant_iter_init (&iter, gvar_list);
	while ((gvar = g_variant_iter_next_value (&iter)))
		values.push_back(make_pair(gvar, printer(gvar)));

	_properties.push_back(
        new Enum(name, label, values,
            bind(config_getter, _probe, key),
            bind(config_setter,  _probe, key, _1)));
}

void ProbeOptions::bind_int(const QString &name, const QString label, int key, QString suffix,
    boost::optional< std::pair<int64_t, int64_t> > range)
{
	_properties.push_back(
        new Int(name, label, suffix, range,
            bind(config_getter,  _probe, key),
            bind(config_setter,  _probe, key, _1)));
}

void ProbeOptions::bind_double(const QString &name, const QString label, int key, QString suffix,
    boost::optional< std::pair<double, double> > range,
    int decimals, boost::optional<double> step)
{
    _properties.push_back(
        new Double(name, label, decimals, suffix, range, step,
            bind(config_getter,  _probe, key),
            bind(config_setter,  _probe, key, _1)));
}

void ProbeOptions::bind_vdiv(const QString &name, const QString label,
    GVariant *const gvar_list)
{
    GVariant *gvar_list_vdivs;

	assert(gvar_list);

    if ((gvar_list_vdivs = g_variant_lookup_value(gvar_list,
            "vdivs", G_VARIANT_TYPE("at"))))
	{
        bind_enum(name, label, SR_CONF_PROBE_VDIV,
            gvar_list_vdivs, print_vdiv);
        g_variant_unref(gvar_list_vdivs);
	}
}

void ProbeOptions::bind_coupling(const QString &name, const QString label,
    GVariant *const gvar_list)
{
    GVariant *gvar_list_coupling;

    assert(gvar_list);

    if ((gvar_list_coupling = g_variant_lookup_value(gvar_list,
            "coupling", G_VARIANT_TYPE("ay"))))
    {
        bind_enum(name, label, SR_CONF_PROBE_COUPLING,
            gvar_list_coupling, print_coupling);
        g_variant_unref(gvar_list_coupling);
    }
}

QString ProbeOptions::print_gvariant(GVariant *const gvar)
{
    QString s;

    if (g_variant_is_of_type(gvar, G_VARIANT_TYPE("s")))
        s = QString::fromUtf8(g_variant_get_string(gvar, NULL));
    else
    {
        gchar *const text = g_variant_print(gvar, FALSE);
        s = QString::fromUtf8(text);
        g_free(text);
    }

    return s;
}

QString ProbeOptions::print_vdiv(GVariant *const gvar)
{
    uint64_t p, q;
    g_variant_get(gvar, "t", &p);
    if (p < 1000ULL) {
        q = 1000;
    } else {
        q = 1;
        p /= 1000;
    }
	return QString(sr_voltage_string(p, q));
}

QString ProbeOptions::print_coupling(GVariant *const gvar)
{
    uint8_t coupling;
    g_variant_get(gvar, "y", &coupling);
    if (coupling == SR_DC_COUPLING) {
        return QString("DC");
    } else if (coupling == SR_AC_COUPLING) {
        return QString("AC");
    } else if (coupling == SR_GND_COUPLING) {
        return QString("GND");
    } else {
        return QString("Undefined");
    }
}

} // binding
} // prop
} // pv

/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2018 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_PROP_BINDING_PROBEOPTIONS_H
#define DSVIEW_PV_PROP_BINDING_PROBEOPTIONS_H

#include <boost/function.hpp>
#include <boost/optional.hpp>
#include <QString>
#include <libsigrok.h> 
#include "binding.h"


namespace dsv {
namespace prop {
namespace binding {

class ProbeOptions : public Binding
{
public:
	ProbeOptions(struct sr_channel *probe);

private:

	static GVariant* config_getter(
		const struct sr_channel *probe, int key);
		
	static void config_setter(
        	struct sr_channel *probe, int key, GVariant* value);

    void bind_bool(const QString &name, const QString label, int key);
    void bind_enum(const QString &name, const QString label, int key,
		GVariant *const gvar_list,
		boost::function<QString (GVariant*)> printer = print_gvariant);
    void bind_int(const QString &name, const QString label, int key, QString suffix,
		boost::optional< std::pair<int64_t, int64_t> > range);

    void bind_double(const QString &name, const QString label, int key, QString suffix,
        boost::optional<std::pair<double, double> > range,
        int decimals, boost::optional<double> step);

	static QString print_gvariant(GVariant *const gvar);

    void bind_vdiv(const QString &name, const QString label,
		GVariant *const gvar_list);
    void bind_coupling(const QString &name, const QString label,
        GVariant *const gvar_list);

	static QString print_vdiv(GVariant *const gvar);
    static QString print_coupling(GVariant *const gvar);

protected:
	struct sr_channel *const _probe;
};

} // binding
} // prop
} // pv

#endif // DSVIEW_PV_PROP_BINDING_DEVICEOPTIONS_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_PROP_BINDING_BINDING_H
#define DSVIEW_PV_PROP_BINDING_BINDING_H

#include <glib.h>
#include <vector>
#include <map> 
#include <QFont>
#include <QString>

class QFormLayout;
class QWidget;

namespace dsv {
namespace prop {

class Property;

namespace binding {

class Binding
{
public:
    Binding();

    const std::vector<Property*>& properties();

    void commit();

    void add_properties_to_form(QFormLayout *layout,
        bool auto_commit, QFont font);

    std::map<Property*,GVariant*> get_property_value();

    static QString print_gvariant(GVariant *const gvar);

    inline int get_row_count(){
        return _row_num;
    }

protected:
	std::vector<Property*> _properties;

	QWidget *_form;

    int    _row_num;
};

} // binding
} // prop
} // pv

#endif // DSVIEW_PV_PROP_BINDING_BINDING_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "enum.h"
#include <assert.h>
#include <QAbstractItemView>
#include "../ui/dscombobox.h"

using namespace boost;
using namespace std;

namespace dsv {
namespace prop {

Enum::Enum(QString name, QString label,
    std::vector<pair<GVariant*, QString> > values,
    Getter getter, Setter setter) :
    Property(name, label, getter, setter),
	_values(values),
	_selector(NULL)
{
    for (std::vector< pair<GVariant*, QString> >::const_iterator i =
        _values.begin(); i != _values.end(); i++)
        g_variant_ref((*i).first);
}

Enum::~Enum()
{
	for (unsigned int i = 0; i < _values.size(); i++){
        if (_values[i].first)
            g_variant_unref(_values[i].first);
	}

	if (_selector != NULL){
		delete _selector;
		_selector = NULL;
	}
}

QWidget* Enum::get_widget(QWidget *parent, bool auto_commit)
{
	if (_selector)
		return _selector;

	GVariant *const value = _getter ? _getter() : NULL;
    if (!value) {
        return NULL;
    }

	_selector = new DsComboBox(parent);

	for (unsigned int i = 0; i < _values.size(); i++) {
		const pair<GVariant*, QString> &v = _values[i];
        _selector->addItem(v.second, QVariant::fromValue((void*)v.first));
		
		if (value && g_variant_compare(v.first, value) == 0)
			_selector->setCurrentIndex(i);
	}

	g_variant_unref(value);

    if (auto_commit) {
        connect(_selector, SIGNAL(currentIndexChanged(int)),
            this, SLOT(on_current_item_changed(int)));
    }

	return _selector;
}

void Enum::commit()
{
	assert(_setter);

	if (!_selector)
		return;

	const int index = _selector->currentIndex();
	if (index < 0)
		return;

	_setter((GVariant*)_selector->itemData(index).value<void*>());
}

void Enum::on_current_item_changed(int)
{
    commit();
}

} // prop
} // pv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_PROP_DOUBLE_H
#define DSVIEW_PV_PROP_DOUBLE_H

#include <utility>
#include <boost/optional.hpp>
#include "property.h"

class QDoubleSpinBox;

namespace dsv {
namespace prop {

class Double : public Property
{
    Q_OBJECT;

public:
    Double(QString name, QString label, int decimals, QString suffix,
		boost::optional< std::pair<double, double> > range,
		boost::optional<double> step,
		Getter getter,
		Setter setter);

	virtual ~Double();

    QWidget* get_widget(QWidget *parent, bool auto_commit);

	void commit();

private slots:
    void on_value_changed(double);

private:
	const int _decimals;
	const QString _suffix;
	const boost::optional< std::pair<double, double> > _range;
	const boost::optional<double> _step;

	QDoubleSpinBox *_spin_box;
};

} // prop
} // pv

#endif // DSVIEW_PV_PROP_DOUBLE_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_PROP_PROPERTY_H
#define DSVIEW_PV_PROP_PROPERTY_H

#include <glib.h>
#include <boost/function.hpp>
#include <QString>
#include <QWidget>

class QWidget;

namespace dsv {
namespace prop {

class Property : public QObject
{
    Q_OBJECT;

public:
	typedef boost::function<GVariant* ()> Getter;
	typedef boost::function<void (GVariant*)> Setter;

protected:
    Property(QString name, QString label, Getter getter, Setter setter);

public:
    const QString& name();
    const QString& label();

    virtual ~Property();

    virtual QWidget* get_widget(QWidget *parent,
        bool auto_commit = false) = 0;
	virtual bool labeled_widget();

    virtual GVariant* get_value();

	virtual void commit() = 0;

protected:
	const Getter _getter;
	const Setter _setter;

private:
    QString _name;
    QString _label;
};

} // prop
} // pv

#endif // DSVIEW_PV_PROP_PROPERTY_H
/****************************************************************************
** Meta object code from reading C++ file 'double.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "double.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'double.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEDoubleENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEDoubleENDCLASS = QtMocHelpers::stringData(
    "dsv::prop::Double",
    "on_value_changed",
    ""
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEDoubleENDCLASS_t {
    uint offsetsAndSizes[6];
    char stringdata0[18];
    char stringdata1[17];
    char stringdata2[1];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEDoubleENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEDoubleENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEDoubleENDCLASS = {
    {
        QT_MOC_LITERAL(0, 17),  // "dsv::prop::Double"
        QT_MOC_LITERAL(18, 16),  // "on_value_changed"
        QT_MOC_LITERAL(35, 0)   // ""
    },
    "dsv::prop::Double",
    "on_value_changed",
    ""
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEpropSCOPEDoubleENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   20,    2, 0x08,    1 /* Private */,

 // slots: parameters
    QMetaType::Void, QMetaType::Double,    2,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::prop::Double::staticMetaObject = { {
    QMetaObject::SuperData::link<Property::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEDoubleENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEpropSCOPEDoubleENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEDoubleENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<Double, std::true_type>,
        // method 'on_value_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<double, std::false_type>
    >,
    nullptr
} };

void dsv::prop::Double::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<Double *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->on_value_changed((*reinterpret_cast< std::add_pointer_t<double>>(_a[1]))); break;
        default: ;
        }
    }
}

const QMetaObject *dsv::prop::Double::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::prop::Double::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEDoubleENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return Property::qt_metacast(_clname);
}

int dsv::prop::Double::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = Property::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 1;
    }
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "double.h"
#include <assert.h>
#include <QDoubleSpinBox>

using namespace std;
using namespace boost;

namespace dsv {
namespace prop {

Double::Double(QString name, QString label,
    int decimals,
    QString suffix,
    boost::optional< pair<double, double> > range,
    boost::optional<double> step,
    Getter getter,
    Setter setter) :
    Property(name, label, getter, setter),
	_decimals(decimals),
	_suffix(suffix),
	_range(range),
	_step(step),
	_spin_box(NULL)
{
}

Double::~Double()
{
}

QWidget* Double::get_widget(QWidget *parent, bool auto_commit)
{
	if (_spin_box)
		return _spin_box;

	_spin_box = new QDoubleSpinBox(parent);
	_spin_box->setDecimals(_decimals);
	_spin_box->setSuffix(_suffix);
	if (_range)
		_spin_box->setRange(_range->first, _range->second);
	if (_step)
		_spin_box->setSingleStep(*_step);

	GVariant *const value = _getter ? _getter() : NULL;

	if (value) {
		_spin_box->setValue(g_variant_get_double(value));
		g_variant_unref(value);
	}

    if (auto_commit) {
        connect(_spin_box, SIGNAL(valueChanged(double)),
            this, SLOT(on_value_changed(double)));
    }

	return _spin_box;
}

void Double::commit()
{
	assert(_setter);

	if (!_spin_box)
		return;

	_setter(g_variant_new_double(_spin_box->value()));
}

void Double::on_value_changed(double)
{
    commit();
}

} // prop
} // pv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "bool.h"
#include <assert.h>
#include <QCheckBox>

using namespace std;
using namespace boost;

namespace dsv {
namespace prop {

Bool::Bool(QString name, QString label, Getter getter, Setter setter) :
    Property(name, label, getter, setter),
	_check_box(NULL)
{
}

Bool::~Bool()
{
}

QWidget* Bool::get_widget(QWidget *parent, bool auto_commit)
{
	if (_check_box)
		return _check_box;

    _check_box = new QCheckBox(label(), parent);

	GVariant *const value = _getter ? _getter() : NULL;

	if (value) {
		_check_box->setCheckState(g_variant_get_boolean(value) ?
			Qt::Checked : Qt::Unchecked);
		g_variant_unref(value);
	}

    if (auto_commit) {
        connect(_check_box, SIGNAL(stateChanged(int)),
            this, SLOT(on_state_changed(int)));
    }

	return _check_box;
}

bool Bool::labeled_widget()
{
	return true;
}

GVariant* Bool::get_value()
{
    GVariant *const value = _getter ? _getter() : NULL;

    return value;
}

void Bool::commit()
{
	assert(_setter);

	if (!_check_box)
		return;

	_setter(g_variant_new_boolean(
		_check_box->checkState() == Qt::Checked));
}


void Bool::on_state_changed(int)
{
    commit();
}

} // prop
} // pv
/****************************************************************************
** Meta object code from reading C++ file 'int.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "int.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'int.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEIntENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEIntENDCLASS = QtMocHelpers::stringData(
    "dsv::prop::Int",
    "on_value_changed",
    ""
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEIntENDCLASS_t {
    uint offsetsAndSizes[6];
    char stringdata0[15];
    char stringdata1[17];
    char stringdata2[1];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEIntENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEIntENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEIntENDCLASS = {
    {
        QT_MOC_LITERAL(0, 14),  // "dsv::prop::Int"
        QT_MOC_LITERAL(15, 16),  // "on_value_changed"
        QT_MOC_LITERAL(32, 0)   // ""
    },
    "dsv::prop::Int",
    "on_value_changed",
    ""
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEpropSCOPEIntENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   20,    2, 0x08,    1 /* Private */,

 // slots: parameters
    QMetaType::Void, QMetaType::Int,    2,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::prop::Int::staticMetaObject = { {
    QMetaObject::SuperData::link<Property::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEIntENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEpropSCOPEIntENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEIntENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<Int, std::true_type>,
        // method 'on_value_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>
    >,
    nullptr
} };

void dsv::prop::Int::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<Int *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->on_value_changed((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        default: ;
        }
    }
}

const QMetaObject *dsv::prop::Int::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::prop::Int::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEpropSCOPEIntENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return Property::qt_metacast(_clname);
}

int dsv::prop::Int::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = Property::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 1;
    }
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2013 Joel Holdsworth <joel@airwebreathe.org.uk>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_PROP_STRING_H
#define DSVIEW_PV_PROP_STRING_H

#include "property.h"

class QLineEdit;

namespace dsv {
namespace prop {

class String : public Property
{
	Q_OBJECT;

public:
    String(QString name, QString label, Getter getter, Setter setter);

	QWidget* get_widget(QWidget *parent, bool auto_commit);

	void commit();

private slots:
	void on_text_edited(const QString&);

private:
	QLineEdit *_line_edit;
};

} // prop
} // pv

#endif // DSVIEW_PV_PROP_STRING_H
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2012 Alexandru Gagniuc <mr.nuke.me@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _DSVIEW_CONFIG_H
#define _DSVIEW_CONFIG_H

/* Application details */
#define DS_TITLE "DSView"
#define DS_DESCRIPTION "A GUI for instruments of DreamSourceLab"
#define DS_BIN_NAME "DSView"

/* DSView version information */
#define DS_VERSION_MAJOR 1
#define DS_VERSION_MINOR 3
#define DS_VERSION_MICRO 0
#define DS_VERSION_STRING "1.3.0"

#endif
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "appconfig.h" 
#include <QApplication>
#include <QSettings>
#include <QLocale>
#include <QDir> 
#include <assert.h>
#include <QStandardPaths>
#include "../log.h"

#define MAX_PROTOCOL_FORMAT_LIST 15

namespace dsv {
namespace config {

StringPair::StringPair(const std::string &key, const std::string &value)
{
    m_key = key;
    m_value = value;
}

//------------function
static QString FormatArrayToString(std::vector<StringPair> &protocolFormats)
{
    QString str;

    for (StringPair &o : protocolFormats){
         if (!str.isEmpty()){
             str += ";";
         } 
         str += o.m_key.c_str();
         str += "=";
         str += o.m_value.c_str(); 
    }

    return str;
}

static void StringToFormatArray(const QString &str, std::vector<StringPair> &protocolFormats)
{
    QStringList arr = str.split(";");
    for (int i=0; i<arr.size(); i++){
        QString line = arr[i];
        if (!line.isEmpty()){
            QStringList vs = line.split("=");
            if (vs.size() == 2){
                protocolFormats.push_back(StringPair(vs[0].toStdString(), vs[1].toStdString()));
            }
        }
    }
}

//----------------read write field
static void getFiled(const char *key, QSettings &st, QString &f, const char *dv)
{
    f = st.value(key, dv).toString();
}

static void setFiled(const char *key, QSettings &st, QString f)
{
    st.setValue(key, f);
}

static void getFiled(const char *key, QSettings &st, int &f, int dv)
{
    f = st.value(key, dv).toInt();
}

static void setFiled(const char *key, QSettings &st, int f)
{
    st.setValue(key, f);
}

static void getFiled(const char *key, QSettings &st, bool &f, bool dv)
{
    f = st.value(key, dv).toBool();
}

static void setFiled(const char *key, QSettings &st, bool f){
    st.setValue(key, f);
}

static void getFiled(const char *key, QSettings &st, float &f, float dv)
{
    f = st.value(key, dv).toInt();
}

static void setFiled(const char *key, QSettings &st, float f)
{
    st.setValue(key, f);
}

///------ app
static void _loadApp(AppOptions &o, QSettings &st)
{
    st.beginGroup("Application"); 
    getFiled("quickScroll", st, o.quickScroll, true);
    getFiled("warnofMultiTrig", st, o.warnofMultiTrig, true);
    getFiled("originalData", st, o.originalData, false);
    getFiled("ableSaveLog", st, o.ableSaveLog, false);
    getFiled("appendLogMode", st, o.appendLogMode, false);
    getFiled("logLevel", st, o.logLevel, 3);
    getFiled("transDecoderDlg", st, o.transDecoderDlg, true);
    getFiled("trigPosDisplayInMid", st, o.trigPosDisplayInMid, true);
    getFiled("displayProfileInBar", st, o.displayProfileInBar, false);
    getFiled("swapBackBufferAlways", st, o.swapBackBufferAlways, false);
    getFiled("fontSize", st, o.fontSize, 9.0);

    o.warnofMultiTrig = true;

    QString fmt;
    getFiled("protocalFormats", st, fmt, "");
    if (fmt != ""){
         StringToFormatArray(fmt, o.m_protocolFormats);
    }
   
    st.endGroup();
}

static void _saveApp(AppOptions &o, QSettings &st)
{
    st.beginGroup("Application");
    setFiled("quickScroll", st, o.quickScroll);
    setFiled("warnofMultiTrig", st, o.warnofMultiTrig);
    setFiled("originalData", st, o.originalData);
    setFiled("ableSaveLog", st, o.ableSaveLog);
    setFiled("appendLogMode", st, o.appendLogMode);
    setFiled("logLevel", st, o.logLevel);
    setFiled("transDecoderDlg", st, o.transDecoderDlg);
    setFiled("trigPosDisplayInMid", st, o.trigPosDisplayInMid);
    setFiled("displayProfileInBar", st, o.displayProfileInBar);
    setFiled("swapBackBufferAlways", st, o.swapBackBufferAlways);
    setFiled("fontSize", st, o.fontSize);

    QString fmt =  FormatArrayToString(o.m_protocolFormats);
    setFiled("protocalFormats", st, fmt);
    st.endGroup();  
}

//-----frame

static void _loadDockOptions(DockOptions &o, QSettings &st, const char *group)
{
    st.beginGroup(group);
    getFiled("decodeDoc", st, o.decodeDock, false);
    getFiled("triggerDoc", st, o.triggerDock, false);
    getFiled("measureDoc", st, o.measureDock, false);
    getFiled("searchDoc", st, o.searchDock, false);
    st.endGroup();
}

static void _saveDockOptions(DockOptions &o, QSettings &st, const char *group)
{
    st.beginGroup(group);
    setFiled("decodeDoc", st, o.decodeDock);
    setFiled("triggerDoc", st, o.triggerDock);
    setFiled("measureDoc", st, o.measureDock);
    setFiled("searchDoc", st, o.searchDock);
    st.endGroup();
}

static void _loadFrame(FrameOptions &o, QSettings &st)
{
    st.beginGroup("MainFrame"); 
    getFiled("style", st, o.style, THEME_STYLE_DARK);
    getFiled("language", st, o.language, -1);
    getFiled("isMax", st, o.isMax, false);  
    getFiled("left", st, o.left, 0);
    getFiled("top", st, o.top, 0);
    getFiled("right", st, o.right, 0);
    getFiled("bottom", st, o.bottom, 0);

    _loadDockOptions(o._logicDock, st, "LOGIC_DOCK");
    _loadDockOptions(o._analogDock, st, "ANALOG_DOCK");
    _loadDockOptions(o._dsoDock, st, "DSO_DOCK");

    o.windowState = st.value("windowState", QByteArray()).toByteArray();
    st.endGroup();

    if (o.language == -1 || (o.language != LAN_CN && o.language != LAN_EN)){
        //get local language
        QLocale locale;

        if (QLocale::languageToString(locale.language()) == "Chinese")
            o.language = LAN_CN;            
        else
            o.language = LAN_EN; 
    }
}

static void _saveFrame(FrameOptions &o, QSettings &st)
{
    st.beginGroup("MainFrame");
    setFiled("style", st, o.style);
    setFiled("language", st, o.language);
    setFiled("isMax", st, o.isMax);  
    setFiled("left", st, o.left);
    setFiled("top", st, o.top);
    setFiled("right", st, o.right);
    setFiled("bottom", st, o.bottom);
    st.setValue("windowState", o.windowState); 

    _saveDockOptions(o._logicDock, st, "LOGIC_DOCK");
    _saveDockOptions(o._analogDock, st, "ANALOG_DOCK");
    _saveDockOptions(o._dsoDock, st, "DSO_DOCK");
    
    st.endGroup();
}

//------history
static void _loadHistory(UserHistory &o, QSettings &st)
{
    st.beginGroup("UserHistory");
    getFiled("exportDir", st, o.exportDir, ""); 
    getFiled("saveDir", st, o.saveDir, ""); 
    getFiled("showDocuments", st, o.showDocuments, true);
    getFiled("screenShotPath", st, o.screenShotPath, ""); 
    getFiled("sessionDir", st, o.sessionDir, ""); 
    getFiled("openDir", st, o.openDir, ""); 
    getFiled("protocolExportPath", st, o.protocolExportPath, ""); 
    getFiled("exportFormat", st, o.exportFormat, ""); 
    st.endGroup();
}
 
static void _saveHistory(UserHistory &o, QSettings &st)
{
    st.beginGroup("UserHistory");
    setFiled("exportDir", st, o.exportDir); 
    setFiled("saveDir", st, o.saveDir); 
    setFiled("showDocuments", st, o.showDocuments); 
    setFiled("screenShotPath", st, o.screenShotPath); 
    setFiled("sessionDir", st, o.sessionDir); 
    setFiled("openDir", st, o.openDir); 
    setFiled("protocolExportPath", st, o.protocolExportPath);
    setFiled("exportFormat", st, o.exportFormat); 
    st.endGroup();
}

/*
//------font
static void _loadFont(FontOptions &o, QSettings &st)
{
    st.beginGroup("FontSetting");
    getFiled("toolbarName", st, o.toolbar.name, "");
    getFiled("toolbarSize", st, o.toolbar.size, 9);
    getFiled("channelLabelName", st, o.channelLabel.name, "");
    getFiled("channelLabelSize", st, o.channelLabel.size, 9);
    getFiled("channelBodyName", st, o.channelBody.name, "");
    getFiled("channelBodySize", st, o.channelBody.size, 9);
    getFiled("rulerName", st, o.ruler.name, "");
    getFiled("ruleSize", st, o.ruler.size, 9);
    getFiled("titleName", st, o.title.name, "");
    getFiled("titleSize", st, o.title.size, 9);
    getFiled("otherName", st, o.other.name, "");
    getFiled("otherSize", st, o.other.size, 9);

    st.endGroup();
}

static void _saveFont(FontOptions &o, QSettings &st)
{
    st.beginGroup("FontSetting");
    setFiled("toolbarName", st, o.toolbar.name);
    setFiled("toolbarSize", st, o.toolbar.size);
    setFiled("channelLabelName", st, o.channelLabel.name);
    setFiled("channelLabelSize", st, o.channelLabel.size);
    setFiled("channelBodyName", st, o.channelBody.name);
    setFiled("channelBodySize", st, o.channelBody.size);
    setFiled("rulerName", st, o.ruler.name);
    setFiled("ruleSize", st, o.ruler.size);
    setFiled("titleName", st, o.title.name);
    setFiled("titleSize", st, o.title.size);
    setFiled("otherName", st, o.other.name);
    setFiled("otherSize", st, o.other.size);

    st.endGroup();
}
*/

//------------AppConfig

AppConfig::AppConfig()
{ 
}

AppConfig::AppConfig(AppConfig &o) 
{
    (void)o;
}

AppConfig::~AppConfig()
{
}

 AppConfig& AppConfig::Instance()
 {
     static AppConfig *ins = NULL;
     if (ins == NULL){
         ins = new AppConfig();
     }
     return *ins;
 }

void AppConfig::LoadAll()
{   
    QSettings st(QApplication::organizationName(), QApplication::applicationName());
    _loadApp(appOptions, st);
    _loadHistory(userHistory, st);
    _loadFrame(frameOptions, st);

    //dsv_dbg("Config file path:\"%s\"", st.fileName().toUtf8().data());
}

void AppConfig::SaveApp()
{
    QSettings st(QApplication::organizationName(), QApplication::applicationName());
    _saveApp(appOptions, st);
}

void AppConfig::SaveHistory()
{
    QSettings st(QApplication::organizationName(), QApplication::applicationName());
    _saveHistory(userHistory, st);
}

void AppConfig::SaveFrame()
{
    QSettings st(QApplication::organizationName(), QApplication::applicationName());
    _saveFrame(frameOptions, st);
}

void AppConfig::SetProtocolFormat(const std::string &protocolName, const std::string &value)
{
    bool bChange = false;
    for (StringPair &o : appOptions.m_protocolFormats){
        if (o.m_key == protocolName){
            o.m_value = value;
            bChange = true;
            break;
        }    
    }

    if (!bChange)
    {
        if (appOptions.m_protocolFormats.size() > MAX_PROTOCOL_FORMAT_LIST)
        {
            while (appOptions.m_protocolFormats.size() < MAX_PROTOCOL_FORMAT_LIST)
            {
                appOptions.m_protocolFormats.erase(appOptions.m_protocolFormats.begin());
            }
        }
        appOptions.m_protocolFormats.push_back(StringPair(protocolName, value));
        bChange = true;
    }

    if (bChange){
        SaveApp();
    }
}

std::string AppConfig::GetProtocolFormat(const std::string &protocolName)
{
     for (StringPair &o : appOptions.m_protocolFormats){
        if (o.m_key == protocolName){ 
            return o.m_value;
        }
    }
    return "";
}

//-------------api
QString AppConfig::GetIconPath()
{   
    QString style = AppConfig::Instance().frameOptions.style;
    if (style == ""){
        style = THEME_STYLE_DARK;
    }
    return ":/icons/" + style;
}

QString AppConfig::GetAppDataDir()
{
//applicationDirPath not end with '/'
#ifdef Q_OS_LINUX
    QDir dir(QCoreApplication::applicationDirPath());
    if (dir.cd("..") && dir.cd("share") && dir.cd("DSView"))
    {
         return dir.absolutePath();        
    }
    QDir dir1("/usr/local/share/DSView");
    if (dir1.exists()){
        return dir1.absolutePath();
    }

    dsv_err("Data directory is not exists: ../share/DSView");
    assert(false);   
#else

#ifdef Q_OS_DARWIN
    QDir dir1(QCoreApplication::applicationDirPath());
    //"./res" is not exists
    if (dir1.cd("res") == false){
        QDir dir(QCoreApplication::applicationDirPath());
        // ../share/DSView
        if (dir.cd("..") && dir.cd("share") && dir.cd("DSView"))
        {
            return dir.absolutePath();
        }
    }
#endif

    // The bin location
    return QCoreApplication::applicationDirPath();
#endif
}

QString AppConfig::GetFirmwareDir()
{
    QDir dir1 =  GetAppDataDir() + "/res";
    // ./res
    if (dir1.exists()){
        return dir1.absolutePath();
    }

    QDir dir(QCoreApplication::applicationDirPath());
    // ../share/DSView/res
    if (dir.cd("..") && dir.cd("share") && dir.cd("DSView") && dir.cd("res"))
    {
         return dir.absolutePath();
    }
 
    dsv_err("%s%s", "Resource directory is not exists:", dir1.absolutePath().toUtf8().data());
    return dir1.absolutePath();
}

QString AppConfig::GetUserDataDir()
{
#if QT_VERSION >= 0x050400
    return QStandardPaths::writableLocation(QStandardPaths::AppDataLocation);
#else
    return QStandardPaths::writableLocation(QStandardPaths::DataLocation);
#endif
}

QString AppConfig::GetDecodeScriptDir()
{
    QString path = GetAppDataDir() + "/decoders";

    QDir dir1;
    // ./decoders
    if (dir1.exists(path))
    {
         return path;     
    }

    QDir dir(QCoreApplication::applicationDirPath());
    // ../share/libsigrokdecode4DSL/decoders
    if (dir.cd("..") && dir.cd("share") && dir.cd("libsigrokdecode4DSL") && dir.cd("decoders"))
    {
        return dir.absolutePath();        
    }
    return "";
}

QString AppConfig::GetProfileDir()
{
#if QT_VERSION >= 0x050400
    return QStandardPaths::writableLocation(QStandardPaths::AppDataLocation);
#else
    return QStandardPaths::writableLocation(QStandardPaths::DataLocation);
#endif
}

} //config
} //dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef CONFIG_APPCONIFG_H
#define CONFIG_APPCONIFG_H

#include <string>
#include <vector>
#include <QString>
#include <QByteArray>

#define LAN_CN  25
#define LAN_EN  31

#define THEME_STYLE_DARK   "dark"
#define THEME_STYLE_LIGHT  "light"
#define APP_NAME  "DSView"

namespace dsv {
namespace config {
  
class StringPair
{
public:
   StringPair(const std::string &key, const std::string &value);
   std::string m_key;
   std::string m_value;
};

struct AppOptions
{   
    bool  quickScroll;
    bool  warnofMultiTrig;
    bool  originalData;
    bool  ableSaveLog;
    bool  appendLogMode;
    int   logLevel;
    bool  transDecoderDlg;
    bool  trigPosDisplayInMid;
    bool  displayProfileInBar;
    bool  swapBackBufferAlways;
    float fontSize;

    std::vector<StringPair> m_protocolFormats;
};
 
 // The dock pannel open status.
 struct DockOptions
 {
  bool        decodeDock;
  bool        triggerDock;
  bool        measureDock;
  bool        searchDock;
};

struct FrameOptions
{ 
  QString     style;
  int         language; 
  int         left; //frame region
  int         top;
  int         right;
  int         bottom;
  bool        isMax;
  QByteArray  windowState;

  DockOptions   _logicDock;
  DockOptions   _analogDock;
  DockOptions   _dsoDock;
};

struct UserHistory
{ 
  QString   exportDir;
  QString   saveDir;
  bool      showDocuments;
  QString   screenShotPath;
  QString   sessionDir;
  QString   openDir;
  QString   protocolExportPath;
  QString   exportFormat;
};

struct FontParam
{
  QString   name;
  float     size;
};

struct FontOptions
{
  FontParam toolbar;
  FontParam channelLabel;
  FontParam channelBody;
  FontParam ruler;
  FontParam title;
  FontParam other;
};

class AppConfig
{
private:
  AppConfig();
  ~AppConfig();
  AppConfig(AppConfig &o);

public:
  static AppConfig &Instance();

  void LoadAll();
  void SaveApp();  
  void SaveHistory();
  void SaveFrame();
  
  void SetProtocolFormat(const std::string &protocolName, const std::string &value);
  std::string GetProtocolFormat(const std::string &protocolName); 

  inline bool IsLangCn()
  {
    return frameOptions.language == LAN_CN;
  }

  static QString GetIconPath();
  static QString GetAppDataDir();
  static QString GetFirmwareDir();
  static QString GetUserDataDir();
  static QString GetDecodeScriptDir();
  static QString GetProfileDir();

public:
  AppOptions    appOptions;
  UserHistory   userHistory;
  FrameOptions  frameOptions;
};

} //config
} //dsv

#endif
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_MAINWINDOW_H
#define DSVIEW_PV_MAINWINDOW_H

#include <list>
#include <QMainWindow>
#include <QTranslator>
#include <QJsonDocument>
#include <chrono>
#include "../dialogs/dsmessagebox.h"
#include "../interface/icallbacks.h"
#include "eventobject.h"
#include "../com/dstimer.h"

class QAction;
class QMenuBar;
class QMenu;
class QVBoxLayout;
class QStatusBar;
class QToolBar;
class QWidget;
class QDockWidget;

using std::chrono::high_resolution_clock;
using std::chrono::milliseconds;

namespace dsv{
	namespace appcore{
    	class SigSession;
        class AppControl;
        class DeviceAgent;
	}
}

namespace dsv{
	namespace toolbars {
        class SamplingBar;
        class TrigBar;
        class FileBar;
        class LogoBar;
        class TitleBar;
    }
    namespace dock{
        class ProtocolDock;
        class TriggerDock;
        class DsoTriggerDock;
        class MeasureDock;
        class SearchDock;
    }
    namespace view {
        class View;
    }
}
using namespace dsv::toolbars;
using namespace dsv::dock;
using namespace dsv::com;
using namespace dsv::view;

namespace dsv {
namespace appcore {
class SigSession;
 
//The mainwindow,referenced by MainFrame
//TODO: create graph view,toolbar,and show device list
class MainWindow : 
    public QMainWindow,
    public ISessionCallback,
    public IMainForm,
    public ISessionDataGetter,
    public IMessageListener
{
	Q_OBJECT

public:
    static const int Min_Width  = 800;
    static const int Min_Height = 520;
    static const int Base_Height = 150;
    static const int Per_Chan_Height = 35;
     
public:
    explicit MainWindow(toolbars::TitleBar *title_bar, QWidget *parent = 0);

    void openDoc();

public slots: 
    void switchTheme(QString style);
    void restore_dock();

private slots:
	void on_load_file(QString file_name);
    void on_open_doc();  
    void on_protocol(bool visible);
    void on_trigger(bool visible);
    void on_measure(bool visible);
    void on_search(bool visible);
    void on_screenShot();
    void on_save();

    void on_export();
    bool on_load_session(QString name);  
    bool on_store_session(QString name); 
    void on_data_updated();
 
    void on_session_error();
    void on_signals_changed();
    void on_receive_trigger(quint64 trigger_pos);
    void on_frame_ended();
    void on_frame_began();
    void on_decode_done();
    void on_receive_data_len(quint64 len);
    void on_cur_snap_samplerate_changed();
    void on_trigger_message(int msg);
    void on_delay_prop_msg();
  
signals:
    void prgRate(int progress);

public:
    //IMainForm
    void switchLanguage(int language) override;
    bool able_to_close(); 
   
private: 
	void setup_ui();
    void retranslateUi(); 
    bool eventFilter(QObject *object, QEvent *event);
    void check_usb_device_speed();
    void reset_all_view();
    bool confirm_to_store_data();
    void update_toolbar_view_status();
    void calc_min_height();    
    void update_title_bar_text();

    //json operation
private:
    QString gen_config_file_path(bool isNewFormat);
    bool load_config_from_file(QString file);
    bool load_config_from_json(QJsonDocument &doc, bool &haveDecoder);
    void load_device_config();
    bool gen_config_json(QJsonObject &sessionVar);
    void save_config();
    bool save_config_to_file(QString file);
    void load_channel_view_indexs(QJsonDocument &doc); 
    QJsonDocument get_config_json_from_data_file(QString file, bool &bSucesss);
    QJsonArray get_decoder_json_from_data_file(QString file, bool &bSucesss);
    void check_config_file_version(); 
    void load_demo_decoder_config(QString optname);
   
private:
    //ISessionCallback 
    void session_error() override;
    void session_save() override;
    void data_updated() override;
    void update_capture() override;
    void cur_snap_samplerate_changed() override;      
    void signals_changed() override;
    void receive_trigger(quint64 trigger_pos) override;
    void frame_ended() override;
    void frame_began() override;
    void show_region(uint64_t start, uint64_t end, bool keep) override;
    void show_wait_trigger() override;
    void repeat_hold(int percent) override;
    void decode_done() override;
    void receive_data_len(quint64 len) override;
    void receive_header() override;    
    void trigger_message(int msg) override;   
    void delay_prop_msg(QString strMsg) override; 

    //ISessionDataGetter
    bool genSessionData(std::string &str) override;

    //IMessageListener
    void OnMessage(int msg) override;

private: 
	dsv::view::View          *_view;
    dialogs::DSMessageBox   *_msg;

	QMenuBar                *_menu_bar;
	QMenu                   *_menu_file;
	QAction                 *_action_open;
	QAction                 *_action_connect;
	QAction                 *_action_quit;

	QMenu                   *_menu_view;
	QAction                 *_action_view_zoom_in;
	QAction                 *_action_view_zoom_out;
	QAction                 *_action_view_show_cursors;

	QMenu                   *_menu_help;
	QAction                 *_action_about;

	QWidget                 *_central_widget;
	QVBoxLayout             *_vertical_layout;

	toolbars::SamplingBar   *_sampling_bar;
    toolbars::TrigBar       *_trig_bar;
    toolbars::FileBar       *_file_bar;
    toolbars::LogoBar       *_logo_bar; //help button, on top right
    toolbars::TitleBar      *_title_bar;


    QDockWidget             *_protocol_dock;
    dock::ProtocolDock      *_protocol_widget;
    QDockWidget             *_trigger_dock;
    QDockWidget             *_dso_trigger_dock;
    dock::TriggerDock       *_trigger_widget;
    dock::DsoTriggerDock    *_dso_trigger_widget;
    QDockWidget             *_measure_dock;
    dock::MeasureDock       *_measure_widget;
    QDockWidget             *_search_dock;
    dock::SearchDock        *_search_widget;

    QTranslator     _qtTrans;
    QTranslator     _myTrans;
    EventObject     _event; 
    SigSession      *_session;
    DeviceAgent     *_device_agent;
    bool            _is_auto_switch_device;
    high_resolution_clock::time_point _last_key_press_time;
    bool            _is_save_confirm_msg;
    QString         _pattern_mode;
    QWidget         *_frame;
    DsTimer         _delay_prop_msg_timer;
    QString         _strMsg;
    QString         _lst_title_string;
    QString         _title_ext_string;

    int _key_value;
    bool _key_vaild;
};

} //namespace com
} //namespace appcore

#endif // DSVIEW_PV_MAINWINDOW_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "eventobject.h"

namespace dsv {
namespace appcore {

EventObject::EventObject(){
    
}

DeviceEventObject::DeviceEventObject()
{
}

} //namespace com
} //namespace appcore/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#pragma once

#include <string>
#include <vector>

struct sr_context;
class QWidget;
class IFontForm;

namespace dsv {
namespace appcore {

class SigSession;

class AppControl
{
private:
    explicit AppControl();
    ~AppControl();
    AppControl(AppControl &o);

public:
    static AppControl* Instance();

    void Destroy();

    bool Init();

    bool Start();

    void Stop();

    void UnInit(); 

    inline SigSession*  GetSession(){
        return _session;
    } 

    inline void SetTopWindow(QWidget *w){
        _topWindow = w;
    }

    inline QWidget* GetTopWindow(){
        return _topWindow;
    }

    bool TopWindowIsMaximized();

    void add_font_form(IFontForm *form);
    void remove_font_form(IFontForm *form);
    void update_font_forms();

public:
    std::string        _open_file_name; 

private: 
    SigSession      *_session;
    QWidget             *_topWindow;
    std::vector<IFontForm*> _font_forms;
};

} //namespace com
} //namespace appcore
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "mainframe.h"
#include <QVBoxLayout>
#include <QEvent>
#include <QMouseEvent>
#include <QHoverEvent>
#include <QPixmap>
#include <QPainter>
#include <QLabel>
#include <QDialogButtonBox>
#include <QBitmap>
#include <QResizeEvent>
#include <QDesktopServices>
#include <QPushButton>
#include <QMessageBox> 
#include <QScreen>
#include <QApplication>
#include <QFile> 
#include <QGuiApplication>
#include <QFont>
#include <algorithm>
#include "mainwindow.h"
#include "../toolbars/titlebar.h"
#include "../dialogs/dsmessagebox.h"
#include "../dialogs/dsdialog.h"
#include "../basedef.h"
#include "../config/appconfig.h"
#include "../ui/msgbox.h"
#include "appcontrol.h"
#include "../ui/langresource.h"
#include "../log.h"

using namespace dsv::config;

namespace dsv {
namespace appcore {

MainFrame::MainFrame()
{
    _layout = NULL;
    _bDraging = false;
    _hit_border = None;
    _freezing = false; 
    _titleBar = NULL;
    _mainWindow = NULL;

    AppControl::Instance()->SetTopWindow(this);

    setAttribute(Qt::WA_TranslucentBackground);
    // Make this a borderless window which can't
    // be resized or moved via the window system
    #ifdef _WIN32
    setWindowFlags(Qt::Window | Qt::FramelessWindowHint | Qt::WindowSystemMenuHint | Qt::WindowMinMaxButtonsHint);
    #else
    setWindowFlags(Qt::Window | Qt::FramelessWindowHint | Qt::WindowSystemMenuHint);
    #endif

    setMinimumWidth(MainWindow::Min_Width);
    setMinimumHeight(MainWindow::Min_Height);  
  
    // Set the window icon
    QIcon icon;
    icon.addFile(QString::fromUtf8(":/icons/logo.svg"), QSize(), QIcon::Normal, QIcon::Off);    
    setWindowIcon(icon);
    
    // Title
    _titleBar = new toolbars::TitleBar(true, this);

    // MainWindow
    _mainWindow = new MainWindow(_titleBar, this);
    _mainWindow->setWindowFlags(Qt::Widget);

    QVBoxLayout *vbox = new QVBoxLayout();
    vbox->setContentsMargins(0,0,0,0);
    vbox->setSpacing(0);
    vbox->addWidget(_titleBar);
    vbox->addWidget(_mainWindow);

    _top_left = new widgets::Border (TopLeft, this);
    _top_left->setFixedSize(Margin, Margin);
    _top_left->installEventFilter(this);
    _top = new widgets::Border (Top, this);
    _top->setFixedHeight(Margin);
    _top->installEventFilter(this);
    _top_right = new widgets::Border (TopRight, this);
    _top_right->setFixedSize(Margin, Margin);
    _top_right->installEventFilter(this);

    _left = new widgets::Border (Left, this);
    _left->setFixedWidth(Margin);
    _left->installEventFilter(this);
    _right = new widgets::Border (Right, this);
    _right->setFixedWidth(Margin);
    _right->installEventFilter(this);

    _bottom_left = new widgets::Border (BottomLeft, this);
    _bottom_left->setFixedSize(Margin, Margin);
    _bottom_left->installEventFilter(this);
    _bottom = new widgets::Border (Bottom, this);
    _bottom->setFixedHeight(Margin);
    _bottom->installEventFilter(this);
    _bottom_right = new widgets::Border (BottomRight, this);
    _bottom_right->setFixedSize(Margin, Margin);
    _bottom_right->installEventFilter(this);

    _layout = new QGridLayout(this);
    _layout->setSpacing(0);
    _layout->setContentsMargins(0,0,0,0);
    _layout->addWidget(_top_left, 0, 0);
    _layout->addWidget(_top, 0, 1);
    _layout->addWidget(_top_right, 0, 2);
    _layout->addWidget(_left, 1, 0);
    _layout->addLayout(vbox, 1, 1);
    _layout->addWidget(_right, 1, 2);
    _layout->addWidget(_bottom_left, 2, 0);
    _layout->addWidget(_bottom, 2, 1);
    _layout->addWidget(_bottom_right, 2, 2);

#ifdef _WIN32
    _taskBtn = new QWinTaskbarButton(this);
	connect(_mainWindow, SIGNAL(prgRate(int)), this, SLOT(setTaskbarProgress(int)));
#endif

    connect(&_timer, SIGNAL(timeout()), this, SLOT(unfreezing()));
}
 
void MainFrame::resizeEvent(QResizeEvent *event)
{
    QFrame::resizeEvent(event);

    if (_layout == NULL){
        return;
    }

    if (isMaximized()) {
        hide_border();
    } else {
        show_border();
    }
    _titleBar->setRestoreButton(isMaximized());
    _layout->update();
}

void MainFrame::closeEvent(QCloseEvent *event)
{ 
    writeSettings();

    if (_mainWindow->able_to_close()){
          event->accept();
    }
    else{
          event->ignore();
    }  
}

void MainFrame::unfreezing()
{
    _freezing = false;
}

void MainFrame::hide_border()
{
    _top_left->setVisible(false);
    _top_right->setVisible(false);
    _top->setVisible(false);
    _left->setVisible(false);
    _right->setVisible(false);
    _bottom_left->setVisible(false);
    _bottom->setVisible(false);
    _bottom_right->setVisible(false);
}

void MainFrame::show_border()
{ 
    _top_left->setVisible(true);
    _top_right->setVisible(true);
    _top->setVisible(true);
    _left->setVisible(true);
    _right->setVisible(true);
    _bottom_left->setVisible(true);
    _bottom->setVisible(true);
    _bottom_right->setVisible(true);
}

void MainFrame::showNormal()
{
    show_border();  
    QFrame::showNormal();
}

void MainFrame::showMaximized()
{ 
    hide_border();

#ifdef _WIN32
    float sk = QGuiApplication::primaryScreen()->logicalDotsPerInch() / 96;
    if (sk >= 1.5)
    {
        auto rect = QGuiApplication::primaryScreen()->availableGeometry();  
        this->move(rect.left(), rect.top());
        this->resize(rect.width(), rect.height());
    }
#endif

    QFrame::showMaximized(); 
}

void MainFrame::showMinimized()
{ 
    writeSettings();
    QFrame::showMinimized();
}

bool MainFrame::eventFilter(QObject *object, QEvent *event)
{
    const QEvent::Type type = event->type();
    const QMouseEvent *const mouse_event = (QMouseEvent*)event;
    int newWidth;
    int newHeight;
    int newLeft;
    int newTop;

    if (type != QEvent::MouseMove 
        && type != QEvent::MouseButtonPress 
        && type != QEvent::MouseButtonRelease
        && type != QEvent::Leave){
        return QFrame::eventFilter(object, event);
    }

    //when window is maximized, or is moving, call return 
    if (isMaximized() || _titleBar->IsMoving()){
       return QFrame::eventFilter(object, event);
    }
 
    if (!_bDraging && type == QEvent::MouseMove && (!(mouse_event->buttons() | Qt::NoButton))){
           if (object == _top_left) {
                _hit_border = TopLeft;
                setCursor(Qt::SizeFDiagCursor);
            } else if (object == _bottom_right) {
                _hit_border = BottomRight;
                setCursor(Qt::SizeFDiagCursor);
            } else if (object == _top_right) {
                _hit_border = TopRight;
                setCursor(Qt::SizeBDiagCursor);
            } else if (object == _bottom_left) {
                _hit_border = BottomLeft;
                setCursor(Qt::SizeBDiagCursor);
            } else if (object == _left) {
                _hit_border = Left;
                setCursor(Qt::SizeHorCursor);
            } else if (object == _right) {
                _hit_border = Right;
                setCursor(Qt::SizeHorCursor);
            } else if (object == _bottom) {
                _hit_border = Bottom;
                setCursor(Qt::SizeVerCursor);
            } else if (object == _top) {
                _hit_border = Top;
                setCursor(Qt::SizeVerCursor);
            } else {
                _hit_border = None;
                setCursor(Qt::ArrowCursor);
            }

            return QFrame::eventFilter(object, event);
    }

  if (type == QEvent::MouseMove) {

#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
    int x0 = (int)mouse_event->globalPosition().x();
    int y0 = (int)mouse_event->globalPosition().y();
#else
    int x0 = mouse_event->globalX();
    int y0 = mouse_event->globalY();
#endif

         if(mouse_event->buttons().testFlag(Qt::LeftButton)) {
            if (!_freezing) {
                switch (_hit_border) {
                case TopLeft:
                    newWidth = std::max(_dragStartGeometry.right() - x0, minimumWidth());
                    newHeight = std::max(_dragStartGeometry.bottom() - y0, minimumHeight());
                    newLeft = geometry().left();
                    newTop = geometry().top();
                    if (newWidth > minimumWidth())
                        newLeft = x0;
                    if (newHeight > minimumHeight())
                        newTop = y0;
                    setGeometry(newLeft, newTop, newWidth, newHeight);
                    saveWindowRegion();                    
                   break;

                case BottomLeft:
                    newWidth = std::max(_dragStartGeometry.right() - x0, minimumWidth());
                    newHeight = std::max(y0 - _dragStartGeometry.top(), minimumHeight());
                    newLeft = geometry().left();
                    if (newWidth > minimumWidth())
                        newLeft = x0;
                    setGeometry(newLeft, _dragStartGeometry.top(), newWidth, newHeight);
                    saveWindowRegion();
                   break;

                case TopRight:
                    newWidth = std::max(x0 - _dragStartGeometry.left(), minimumWidth());
                    newHeight = std::max(_dragStartGeometry.bottom() - y0, minimumHeight());
                    newTop = geometry().top();
                    if (newHeight > minimumHeight())
                        newTop = y0;
                    setGeometry(_dragStartGeometry.left(), newTop, newWidth, newHeight);
                    saveWindowRegion();
                   break;

                case BottomRight:
                    newWidth = std::max(x0 - _dragStartGeometry.left(), minimumWidth());
                    newHeight = std::max(y0 - _dragStartGeometry.top(), minimumHeight());
                    setGeometry(_dragStartGeometry.left(), _dragStartGeometry.top(), newWidth, newHeight);
                    saveWindowRegion();
                   break;

                case Left:
                    newWidth = _dragStartGeometry.right() - x0;
                    if (newWidth > minimumWidth()){
                         setGeometry(x0, _dragStartGeometry.top(), newWidth, height());
                         saveWindowRegion();
                    }                       
                   break;

                case Right:
                    newWidth = x0 - _dragStartGeometry.left();
                    if (newWidth > minimumWidth()){
                         setGeometry(_dragStartGeometry.left(), _dragStartGeometry.top(), newWidth, height());
                         saveWindowRegion();
                    }                       
                   break;

                case Top:
                    newHeight = _dragStartGeometry.bottom() - y0;
                    if (newHeight > minimumHeight()){
                        setGeometry(_dragStartGeometry.left(), y0,width(), newHeight);
                        saveWindowRegion();
                    }                        
                   break;

                case Bottom:
                    newHeight = y0 - _dragStartGeometry.top();
                    if (newHeight > minimumHeight()){
                        setGeometry(_dragStartGeometry.left(), _dragStartGeometry.top(), width(), newHeight);
                        saveWindowRegion();
                    }                       
                   break;

                default:
                   break;
                }
                _freezing = true;
            } 
            return true;
        }
    }
     else if (type == QEvent::MouseButtonPress) {
        if (mouse_event->button() == Qt::LeftButton) 
        if (_hit_border != None)
            _bDraging = true;
        _timer.start(50);
        _dragStartGeometry = geometry();
    } 
    else if (type == QEvent::MouseButtonRelease) {
        if (mouse_event->button() == Qt::LeftButton) {         
            _bDraging = false;
            _timer.stop();
        }
    } else if (!_bDraging && type == QEvent::Leave) {
        _hit_border = None;
        setCursor(Qt::ArrowCursor);
    } 
    
 
    return QFrame::eventFilter(object, event);
}

 void MainFrame::saveWindowRegion()
 {
     AppConfig &app = AppConfig::Instance();    
     QRect rc = geometry();
     app.frameOptions.left = rc.left();
     app.frameOptions.top = rc.top();
     app.frameOptions.right = rc.right();
     app.frameOptions.bottom = rc.bottom();
 }

void MainFrame::writeSettings()
{  
    AppConfig &app = AppConfig::Instance();
    app.frameOptions.isMax = isMaximized(); 

    if (!isMaximized()){
          saveWindowRegion();
    }
  
    app.SaveFrame(); 
}

void MainFrame::readSettings()
{
    if (_layout == NULL)
        return;

    AppConfig &app = AppConfig::Instance(); 
   
    if (app.frameOptions.language > 0){
         _mainWindow->switchLanguage(app.frameOptions.language);
    }

      int left = app.frameOptions.left;
      int top = app.frameOptions.top;
      int right = app.frameOptions.right;
      int bottom = app.frameOptions.bottom;

      int screen_width = QGuiApplication::primaryScreen()->availableGeometry().width();
      int screen_height = QGuiApplication::primaryScreen()->availableGeometry().height();

      bool bReset = false;

      //size from config is error
      if (right == 0)
      {
          bReset = true;
      }
      if (right - left >= screen_width)
      {
          bReset = true;
      }
      int sp = 70;
      if (right < sp || bottom < sp || left + sp >= screen_width || top + sp >= screen_height){
          bReset = true;
      }

      if (app.frameOptions.isMax)
      {
          showMaximized(); // show max by system api
      }
      else if (bReset)
      { 
          resize(screen_width / 2, screen_height / 1.5);
          const int origX = std::max(0, (screen_width - width()) / 2);
          const int origY = std::max(0, (screen_height - height()) / 2);
          move(origX, origY);
      }
      else
      {
          resize(right - left, bottom - top);
          move(left, top);
      }

    // restore dockwidgets
    _mainWindow->restore_dock();
    _titleBar->setRestoreButton(app.frameOptions.isMax);
}

#ifdef _WIN32
void MainFrame::showEvent(QShowEvent *event)
{
    // Taskbar Progress Effert for Win7 and Above
    if (_taskBtn->window() == NULL) {
        _taskBtn->setWindow(windowHandle());
        _taskPrg = _taskBtn->progress();
    }
    event->accept();
}
#endif

void MainFrame::setTaskbarProgress(int progress)
{
#ifdef _WIN32
    if (progress > 0) {
        _taskPrg->setVisible(true);
        _taskPrg->setValue(progress);
    } else {
        _taskPrg->setVisible(false);
    }
#else
	(void)progress;
#endif
}

void MainFrame::show_doc()
{
     AppConfig &app = AppConfig::Instance(); 
     int lan = app.frameOptions.language;
      
    if (app.userHistory.showDocuments) {
        dialogs::DSDialog dlg(this, true);
        dlg.setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_DOCUMENT), "Document"));

        QString path = AppConfig::GetAppDataDir() + "/showDoc" + QString::number(lan)+ ".png";
        if (!QFile::exists(path)){
            path = ":/icons/showDoc"+QString::number(lan)+".png";
        }

        QLabel tipsLabel;
        tipsLabel.setPixmap(path);

        QMessageBox msg;
        msg.setWindowFlags(Qt::Dialog | Qt::FramelessWindowHint | Qt::WindowSystemMenuHint);
        msg.setContentsMargins(0, 0, 0, 0);
       
        QPushButton *noMoreButton = msg.addButton(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_NOT_SHOW_AGAIN), "Not Show Again"), QMessageBox::ActionRole);
        msg.addButton(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_IGNORE), "Ignore"), QMessageBox::ActionRole);
        QPushButton *openButton = msg.addButton(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_OPEN), "Open"), QMessageBox::ActionRole);

        QVBoxLayout layout;
        layout.addWidget(&tipsLabel);
        layout.addWidget(&msg, 0, Qt::AlignRight);
        layout.setContentsMargins(0, 0, 0, 0);

        dlg.layout()->addLayout(&layout);
        connect(&msg, SIGNAL(buttonClicked(QAbstractButton*)), &dlg, SLOT(accept()));

        dlg.exec();

        if (msg.clickedButton() == openButton) {
            _mainWindow->openDoc();
        }
        if (msg.clickedButton() == noMoreButton){
            app.userHistory.showDocuments = false;
            app.SaveHistory();
        }   
    }
}

} //namespace com
} //namespace appcore
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "sigsession.h"
#include <libsigrokdecode.h>
#include <assert.h>
#include <stdexcept>
#include <sys/stat.h>
#include <map>
#include <QString>
#include "mainwindow.h"
#include "../data/analogsnapshot.h"
#include "../data/dsosnapshot.h"
#include "../data/logicsnapshot.h"
#include "../data/decoderstack.h"
#include "../decode/decoder.h"
#include "../data/decodermodel.h"
#include "../data/spectrumstack.h"
#include "../data/mathstack.h"
#include "../view/analogsignal.h"
#include "../view/dsosignal.h"
#include "../view/logicsignal.h"
#include "../view/groupsignal.h"
#include "../view/decodetrace.h"
#include "../view/spectrumtrace.h"
#include "../view/lissajoustrace.h"
#include "../view/mathtrace.h"
#include "../decode/decoderstatus.h"
#include "../basedef.h"
#include "../log.h"
#include "../config/appconfig.h"
#include "../utility/path.h"
#include "../ui/msgbox.h"
#include "../ui/langresource.h"

using namespace dsv::config;

namespace dsv {
namespace appcore {

    SessionData::SessionData()
    {
        _cur_snap_samplerate = 0;
        _cur_samplelimits = 0;
    }

    void SessionData::clear()
    {
        logic.clear();
        analog.clear();
        dso.clear();
    }

    // TODO: This should not be necessary
    SigSession *SigSession::_session = NULL;

    SigSession::SigSession()
    {
        // TODO: This should not be necessary
        _session = this; 

        _map_zoom = 0;
        _repeat_hold_prg = 0;
        _repeat_intvl = 1;
        _error = No_err;
        _is_instant = false;
        _is_working = false;
        _is_saving = false;
        _device_status = ST_INIT;
        _noData_cnt = 0;
        _data_lock = false;
        _data_updated = false;
        _clt_mode = COLLECT_SINGLE;
        _rt_refresh_time_id = 0;
        _rt_ck_refresh_time_id = 0;
        _view_data = NULL;
        _capture_data = NULL;
        _is_stream_mode = false;
        _is_action = false;
        _decoder_pannel = NULL;
        _is_triged = false;

        _data_list.push_back(new SessionData());
        _data_list.push_back(new SessionData());
        _view_data = _data_list[0];
        _capture_data = _data_list[0];

        this->add_msg_listener(this);

        _decoder_model = new dsv::data::DecoderModel(NULL);

        _lissajous_trace = NULL;
        _math_trace = NULL;
        _is_decoding = false;
        _bClose = false;
        _callback = NULL;
        _work_time_id = 0;
        _capture_times = 0;
        _confirm_store_time_id = 0;
        _repeat_wait_prog_step = 10;

        _device_agent.set_callback(this);

        _feed_timer.SetCallback(std::bind(&SigSession::feed_timeout, this));
        _repeat_timer.SetCallback(std::bind(&SigSession::repeat_capture_wait_timeout, this));
        _repeat_wait_prog_timer.SetCallback(std::bind(&SigSession::repeat_wait_prog_timeout, this));
        _refresh_rt_timer.SetCallback(std::bind(&SigSession::realtime_refresh_timeout, this));       
        _trig_check_timer.SetCallback(std::bind(&SigSession::trig_check_timeout, this));
    }

    SigSession::SigSession(SigSession &o)
    {
        (void)o;
    }

    SigSession::~SigSession()
    {
        for(auto p : _data_list){
            p->clear();
            delete p;
        }
        _data_list.clear();
    }

    bool SigSession::init()
    {
        ds_log_set_context(dsv_log_context());

        ds_set_event_callback(device_lib_event_callback);

        ds_set_datafeed_callback(data_feed_callback);

        // firmware resource directory
        QString resdir = AppConfig::GetFirmwareDir();
        std::string res_path = dsv::path::ToUnicodePath(resdir);
        ds_set_firmware_resource_dir(res_path.c_str());

        if (ds_lib_init() != SR_OK)
        {
            dsv_err("DSView run ERROR: collect lib init failed.");
            return false;
        }

        return true;
    }

    void SigSession::uninit()
    {
        this->Close();

        ds_lib_exit();
    }

    bool SigSession::set_default_device()
    {
        assert(!_is_saving);
        
        if (_is_working){
            dsv_info("SigSession::set_default_device()The current device is working, now to stop it.");
            dsv_info("SigSession::set_default_device(), stop capture");
            stop_capture();
        }

        struct ds_device_base_info *array = NULL;
        int count = 0;

        dsv_info("Set default device.");

        if (ds_get_device_list(&array, &count) != SR_OK)
        {
            dsv_err("Get device list error!");
            return false;
        }
        if (count < 1 || array == NULL)
        {
            dsv_err("Error! Device list is empty, can't set default device.");
            return false;
        }

        struct ds_device_base_info *dev = (array + count - 1);
        ds_device_handle dev_handle = dev->handle;

        free(array);

        if (set_device(dev_handle))
        {
            return true;
        }
        return false;
    }

    bool SigSession::set_device(ds_device_handle dev_handle)
    {
        assert(!_is_saving);
        assert(!_is_working);
        assert(_callback);

        ds_device_handle old_dev = _device_agent.handle();
 
        _callback->trigger_message(DSV_MSG_CURRENT_DEVICE_CHANGE_PREV);
        // Release the old device.
        _device_agent.release();
        _device_status = ST_INIT;

        if (ds_active_device(dev_handle) != SR_OK)
        {
            dsv_err("Switch device error!");
            return false;
        }

        _device_agent.update();
        set_collect_mode(COLLECT_SINGLE);

        if (_device_agent.is_file()){
            std::string dev_name = dsv::path::ToUnicodePath(_device_agent.name());
            dsv_info("Switch to file \"%s\" done.", dev_name.c_str());
        }
        else
            dsv_info("Switch to device \"%s\" done.", _device_agent.name().toUtf8().data());

        clear_all_decoder();

        _view_data->clear();
        _capture_data->clear();
        _capture_data = _view_data;
 
        init_signals();

        set_cur_snap_samplerate(_device_agent.get_sample_rate());
        set_cur_samplelimits(_device_agent.get_sample_limit());

        // The current device changed.
        _callback->trigger_message(DSV_MSG_CURRENT_DEVICE_CHANGED);

        if (ds_get_last_error() == SR_ERR_DEVICE_FIRMWARE_VERSION_LOW)
        {
            QString strMsg = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_TO_RECONNECT_FOR_FIRMWARE), 
                    "Please reconnect the device!");
            _callback->delay_prop_msg(strMsg);
            return false;
        }

        if (ds_get_last_error() == SR_ERR_FIRMWARE_NOT_EXIST)
        {
            QString strMsg = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_FIRMWARE_NOT_EXIST), 
                    "Firmware not exist!");
            _callback->delay_prop_msg(strMsg);
            return false;
        }

        if (ds_get_last_error() == SR_ERR_DEVICE_USB_IO_ERROR)
        {
            QString strMsg = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_DEVICE_USB_IO_ERROR), 
                    "USB io error!");
            _callback->delay_prop_msg(strMsg);
            return false;
        }

        if (ds_get_last_error() == SR_ERR_DEVICE_IS_EXCLUSIVE)
        {
            QString strMsg = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_DEVICE_BUSY_SWITCH_FAILED), 
                        "Device is busy!");
            if (old_dev != NULL_HANDLE)
                MsgBox::Show(strMsg);
            else
                _callback->delay_prop_msg(strMsg);
            return false;
        }

        return true;
    }

    bool SigSession::set_file(QString name)
    {
        assert(!_is_saving);
        assert(!_is_working);

        std::string file_name = dsv::path::ToUnicodePath(name);
        dsv_info("Load file: \"%s\"", file_name.c_str());

        std::string file_str = name.toUtf8().toStdString();

        if (ds_device_from_file(file_str.c_str()) != SR_OK)
        {
            dsv_err("Load file error!");
            return false;
        }

        return set_default_device();
    }

    void SigSession::close_file(ds_device_handle dev_handle)
    {
        assert(dev_handle);

        if (dev_handle == _device_agent.handle() && _is_working)
        {
            dsv_err("The virtual device is running, can't remove it.");
            return;
        }
        bool isCurrent = dev_handle == _device_agent.handle();

        if (ds_remove_device(dev_handle) != SR_OK)
        {
            dsv_err("Remove virtual deivice error!");
        }

        if (isCurrent)
            set_default_device();
    }

    bool SigSession::have_hardware_data()
    {
        if (_device_agent.have_instance() && _device_agent.is_hardware())
        {
            Snapshot *data = get_signal_snapshot();
            return data->have_data();
        }
        return false;
    }

    struct ds_device_base_info *SigSession::get_device_list(int &out_count, int &actived_index)
    {
        out_count = 0;
        actived_index = -1;
        struct ds_device_base_info *array = NULL;

        if (ds_get_device_list(&array, &out_count) == SR_OK)
        {
            actived_index = ds_get_actived_device_index();
            return array;
        }
        return NULL;
    }

    uint64_t SigSession::cur_samplerate()
    {
        // samplerate for current viewport
        if (_device_agent.get_work_mode() == DSO)
            return _device_agent.get_sample_rate();
        else
            return cur_snap_samplerate();
    }

    uint64_t SigSession::cur_snap_samplerate()
    {
        // samplerate for current snapshot
        return _capture_data->_cur_snap_samplerate;
    }

    uint64_t SigSession::cur_samplelimits(){
        return _capture_data->_cur_samplelimits;
    }

    double SigSession::cur_sampletime()
    {
        return cur_samplelimits() * 1.0 / cur_samplerate();
    }

    double SigSession::cur_snap_sampletime()
    {
        return cur_samplelimits() * 1.0 / cur_snap_samplerate();
    }

    double SigSession::cur_view_time()
    {
        return _device_agent.get_time_base() * DS_CONF_DSO_HDIVS * 1.0 / SR_SEC(1);
    }

    void SigSession::set_cur_snap_samplerate(uint64_t samplerate)
    {
        assert(samplerate != 0);
        
        _capture_data->_cur_snap_samplerate = samplerate;
        _capture_data->get_logic()->set_samplerate(samplerate);
        _capture_data->get_analog()->set_samplerate(samplerate);
        _capture_data->get_dso()->set_samplerate(samplerate);

        if (_device_agent.get_work_mode() == DSO)
        { 
            for(auto s : _signals){
                if (s->get_type() == SR_CHANNEL_DSO){
                    view::DsoSignal *ch = (view::DsoSignal*)s;
                    uint64_t k = ch->get_vDial()->get_value();
                    _capture_data->get_dso()->set_measure_voltage_factor(k, ch->get_index()); 
                    _capture_data->get_dso()->set_data_scale(ch->get_scale(), ch->get_index());                                                 
                }
            }
        }
  
        // DecoderStack
        for (auto d : _decode_traces)
        {
            d->decoder()->set_samplerate(samplerate);
        }

        // Math
        if (_math_trace && _math_trace->enabled())
            _math_trace->get_math_stack()->set_samplerate(_device_agent.get_sample_rate());
        // SpectrumStack
        for (auto m : _spectrum_traces){
            m->get_spectrum_stack()->set_samplerate(samplerate);
        }

        _callback->cur_snap_samplerate_changed();
    }

    void SigSession::set_cur_samplelimits(uint64_t samplelimits)
    {
        assert(samplelimits != 0);
        _capture_data->_cur_samplelimits = samplelimits;
    }

    void SigSession::capture_init()
    {
        // update instant setting
        _device_agent.set_config_bool(SR_CONF_INSTANT, _is_instant);
        _callback->update_capture();

        set_cur_snap_samplerate(_device_agent.get_sample_rate());
        set_cur_samplelimits(_device_agent.get_sample_limit());

        _data_updated = false;
        _trigger_flag = false;
        _trigger_ch = 0;
        _hw_replied = false;
        _rt_refresh_time_id = 0;
        _rt_ck_refresh_time_id = 0; 
        _noData_cnt = 0;
        
        data_unlock();

        // Init data container
        _capture_data->clear();

        int mode = _device_agent.get_work_mode();
        if (mode == DSO)
        { 
            for (auto m : _spectrum_traces){ 
                m->get_spectrum_stack()->init();
            }

            if (_math_trace){
                _math_trace->get_math_stack()->init();
            }
        }   

        // update current hw offset
        for (auto s : _signals)
        {  
            if (s->signal_type() == SR_CHANNEL_DSO){   
                auto sig = (view::DsoSignal*)s;
                sig->set_zero_ratio(sig->get_zero_ratio());
                sig->set_stop_scale(1);
            }            
            else if (s->signal_type() == SR_CHANNEL_ANALOG){  
                auto sig = (view::AnalogSignal*)s;
                sig->set_zero_ratio(sig->get_zero_ratio());
            }
        }

        // Start timer 
        if (mode == DSO || mode == ANALOG)
            _feed_timer.Start(FeedInterval);
        else
            _feed_timer.Stop();
    }

    bool SigSession::start_capture(bool instant)
    {
        _is_action = true;
        int ret = action_start_capture(instant);
        _is_action = false;
        return ret;
    }

    bool SigSession::action_start_capture(bool instant)
    {
        assert(_callback);

        dsv_info("Start collect.");

        if (_is_working)
        {
            dsv_err("Error! Is working now.");
            return false;
        }

        // Check that a device instance has been selected.
        if (_device_agent.have_instance() == false)
        {
            dsv_err("Error!No device selected");
            assert(false);
        }
        if (_device_status == ST_RUNNING || _device_agent.is_collecting())
        {
            dsv_err("Error!Device is running.");
            return false;
        }

        clear_all_decode_task2();
        clear_decode_result(); 
        
        _capture_data->clear();
        _view_data->clear();       
        _is_stream_mode = false;
        _capture_times = 0;
        _dso_packet_count = 0;

        _capture_data = _view_data;
        set_cur_snap_samplerate(_device_agent.get_sample_rate());
        set_cur_samplelimits(_device_agent.get_sample_limit());

        set_session_time(QDateTime::currentDateTime());

        int mode = _device_agent.get_work_mode();
        if (mode == LOGIC)
        {
            if (is_repeat_mode()
                    && _device_agent.is_hardware() 
                    && _device_agent.is_stream_mode()){
                set_repeat_intvl(0.1);
            }

            if (_device_agent.is_hardware()){
                _is_stream_mode = _device_agent.is_stream_mode();
            }
            else if (_device_agent.is_demo() || _device_agent.is_file()){
                _is_stream_mode = true;
            }

            if (is_loop_mode() && !_is_stream_mode){
                set_collect_mode(COLLECT_SINGLE); // Reset the capture mode.
            }

            if (is_loop_mode() && _device_agent.is_demo())
            {
                QString opt_mode = _device_agent.get_demo_operation_mode();
                if (opt_mode != "random"){
                    set_collect_mode(COLLECT_SINGLE);
                }
            }

            if (_device_agent.is_hardware() || _device_agent.is_demo()){
                bool bv = is_loop_mode() && _is_stream_mode;
                _device_agent.set_config_bool(SR_CONF_LOOP_MODE, bv);
            }
        }
       
        update_view();

        // update setting
        if (_device_agent.is_file())
            _is_instant = true;
        else
            _is_instant = instant;

        _callback->trigger_message(DSV_MSG_START_COLLECT_WORK_PREV);

        if (exec_capture())
        {   
            _work_time_id++;
            _is_working = true;
            _callback->trigger_message(DSV_MSG_START_COLLECT_WORK);           

            // Start a timer, for able to refresh the view per (1000 / 30)ms.
            if (is_realtime_refresh()){
                _refresh_rt_timer.Start(1000 / 30);
            }

            return true;
        }

        return false;
    }

    bool SigSession::exec_capture()
    {
        if (_device_agent.is_collecting())
        {
            dsv_err("Error!Device is running.");
            return false;
        }

        if (_device_agent.have_enabled_channel() == false)
        {
            QString err_str(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_NO_ENABLED_CHANNEL), "No channels enabled!"));
            MsgBox::Show(err_str);
            return false;
        }
        
        _capture_times++;
        _is_triged = false;

        int mode = _device_agent.get_work_mode();
        bool bAddDecoder = false;
        bool bSwapBuffer = false;
   
        if (mode == DSO || mode == ANALOG)
        {
            // reset measure of dso signal
            for (auto s : _signals){ 
                if (s->signal_type() == SR_CHANNEL_DSO){
                    view::DsoSignal *dsoSig = (view::DsoSignal*)s;
                    dsoSig->set_mValid(false);
                }
            }   
        }
        else
        {    
            if (is_single_mode())
            {
                if (_is_stream_mode)
                    bAddDecoder = true;
            }
            else if (is_repeat_mode())
            { 
                if (_is_stream_mode)
                {
                    if (_capture_times == 1)
                        bAddDecoder = true;
                    else
                        bSwapBuffer = true;
                }
                else{
                    bSwapBuffer = true;
                }             
            }
            else if (is_loop_mode())
            {
                 
            }
        }

        if (mode == LOGIC && _device_agent.is_hardware() 
            && _device_agent.get_hardware_operation_mode() == LO_OP_BUFFER)
        {
            _trig_check_timer.Start(200);
        }

        if (bAddDecoder){
            clear_all_decode_task2();
            clear_decode_result(); 
        }

        // Set the buffer to store the captured data
        if (bSwapBuffer){
            int buf_index = 0;
            for(int i=0; i<(int)_data_list.size(); i++){
                if (_data_list[i] == _view_data){
                    buf_index = i;
                    break;
                }
            }

            buf_index = (buf_index + 1) % 2;
            _capture_data = _data_list[buf_index];
            _capture_data->clear();

            set_cur_snap_samplerate(_device_agent.get_sample_rate());
            set_cur_samplelimits(_device_agent.get_sample_limit());
        }

        capture_init();

        if (_device_agent.start() == false){
            dsv_err("Start collect error!");
            return false;
        }

        if (mode == LOGIC)
        {
            for (auto de : _decode_traces){
                if (bAddDecoder){
                    de->decoder()->set_capture_end_flag(false);                 
                    de->frame_ended();
                    add_decode_task(de);
                }
            } 
        }

        return true;
    }

    bool SigSession::stop_capture()
    {
        _is_action = true;
        int ret = action_stop_capture();
        _is_action = false;
        return ret;
    }

    bool SigSession::action_stop_capture()
    { 
        if (!_is_working)
            return false;

        dsv_info("Stop collect.");

        if (_bClose)
        {
            _is_working = false;
            _repeat_timer.Stop();
            _repeat_wait_prog_timer.Stop();
            _refresh_rt_timer.Stop();
            exit_capture();
            return true;
        }

        bool wait_upload = false;
        if (is_single_mode() && _device_agent.get_work_mode() == LOGIC)
        { 
           _device_agent.get_config_bool(SR_CONF_WAIT_UPLOAD, wait_upload);
        }

        if (!wait_upload)
        {
            _is_working = false;
            _repeat_timer.Stop();
            _repeat_wait_prog_timer.Stop();
            _refresh_rt_timer.Stop();

            if (_repeat_hold_prg != 0 && is_repeat_mode()){
                _repeat_hold_prg = 0;
                _callback->repeat_hold(_repeat_hold_prg);
            }                

            _callback->trigger_message(DSV_MSG_END_COLLECT_WORK_PREV);

            exit_capture();

            data_unlock();

            if (is_repeat_mode() && _device_status != ST_RUNNING){
                _callback->trigger_message(DSV_MSG_END_COLLECT_WORK);
            }

            return true;
        }
        else
        {
            dsv_info("Data is uploading from device data buffer, waiting for stop.");
        }
        return false;
    }

    void SigSession::exit_capture()
    {
        _is_instant = false;

        _feed_timer.Stop();

        if (_device_agent.is_collecting())
            _device_agent.stop();
    }

    bool SigSession::get_capture_status(bool &triggered, int &progress)
    {
        uint64_t sample_limits = cur_samplelimits();
        sr_status status;

        if (_device_agent.get_device_status(status, true))
        { 
            triggered = status.trig_hit & 0x01;
            uint64_t captured_cnt = status.trig_hit >> 2;

            captured_cnt = ((uint64_t)status.captured_cnt0 +
                            ((uint64_t)status.captured_cnt1 << 8) +
                            ((uint64_t)status.captured_cnt2 << 16) +
                            ((uint64_t)status.captured_cnt3 << 24) +
                            (captured_cnt << 32));

            int mode = _device_agent.get_work_mode();

            if (mode == DSO)
                captured_cnt = captured_cnt * _signals.size() / get_ch_num(SR_CHANNEL_DSO);
                
            if (triggered)
                progress = (sample_limits - captured_cnt) * 100.0 / sample_limits;
            else
                progress = captured_cnt * 100.0 / sample_limits;

            if (progress == 100 && mode == LOGIC && _capture_data->get_logic()->have_data() == false){
                progress = 0;
            }

            return true;
        }
        return false;
    }

    std::vector<view::Signal *> &SigSession::get_signals()
    {
        return _signals;
    } 

    void SigSession::check_update()
    {
        ds_lock_guard lock(_data_mutex);

        if (_device_agent.is_collecting() == false)
            return;

        if (_data_updated)
        {
            if (_device_agent.get_work_mode() != LOGIC)
                data_updated();
                
            _data_updated = false;
            _noData_cnt = 0;
            data_auto_unlock();
        }
        else
        {
            if (++_noData_cnt >= (WaitShowTime / FeedInterval))
                nodata_timeout();
        }
    }

    void SigSession::init_signals()
    { 
        if (_device_agent.have_instance() == false)
        {
            assert(false);
        }

        std::vector<view::Signal *> sigs;
        unsigned int logic_probe_count = 0;
        unsigned int dso_probe_count = 0;
        unsigned int analog_probe_count = 0;

        _capture_data->clear();
        _view_data->clear();
        set_cur_snap_samplerate(_device_agent.get_sample_rate());
        set_cur_samplelimits(_device_agent.get_sample_limit());    

        // Detect what data types we will receive
        if (_device_agent.have_instance())
        {
            for (const GSList *l = _device_agent.get_channels(); l; l = l->next)
            {
                const sr_channel *const probe = (const sr_channel *)l->data;

                switch (probe->type)
                {
                case SR_CHANNEL_LOGIC:
                    if (probe->enabled)
                        logic_probe_count++;
                    break;

                case SR_CHANNEL_DSO:
                    dso_probe_count++;
                    break;

                case SR_CHANNEL_ANALOG:
                    if (probe->enabled)
                        analog_probe_count++;
                    break;
                }
            }
        }

        for (GSList *l = _device_agent.get_channels(); l; l = l->next)
        {
            sr_channel *probe = (sr_channel *)l->data;
            assert(probe); 

            switch (probe->type)
            {
            case SR_CHANNEL_LOGIC:
                if (probe->enabled){
                    view::Signal *signal = new view::LogicSignal(_view_data->get_logic(), probe);
                    sigs.push_back(signal);
                }
                break;

            case SR_CHANNEL_DSO:{
                    view::Signal *signal = new view::DsoSignal(_view_data->get_dso(), probe);
                    sigs.push_back(signal);
                }
                break;

            case SR_CHANNEL_ANALOG:
                if (probe->enabled){
                    view::Signal *signal = new view::AnalogSignal(_view_data->get_analog(), probe);
                    sigs.push_back(signal);
                }
                break;
            } 
        }
 
        clear_signals();
        std::vector<view::Signal *>().swap(_signals);
        _signals = sigs;
        make_channels_view_index();

        spectrum_rebuild();
        lissajous_disable();
        math_disable();
    }

    void SigSession::reload()
    {
        if (_device_agent.have_instance() == false)
        {
            assert(false);
        }

        if (_is_working)
            return;

        std::vector<view::Signal *> sigs;
        view::Signal *signal = NULL;
        int logic_chan_num = 0;
        int dso_chan_num = 0;
        int all_chann_num = 0;
        int start_view_dex = -1;

        set_cur_snap_samplerate(_device_agent.get_sample_rate());
        set_cur_samplelimits(_device_agent.get_sample_limit());

        // Make the logic probe list
        for (GSList *l = _device_agent.get_channels(); l; l = l->next)
        {
            sr_channel *probe = (sr_channel *)l->data;
  
            signal = NULL;
            all_chann_num++;
 
            switch (probe->type)
            {
            case SR_CHANNEL_LOGIC:
                if (probe->enabled)
                {    
                    logic_chan_num++;

                    auto i = _signals.begin();

                    while (i != _signals.end())
                    {
                        if ((*i)->get_index() == probe->index)
                        {                            
                            if ((*i)->signal_type() == SR_CHANNEL_LOGIC){
                                view::LogicSignal *logicSig = (view::LogicSignal*)(*i);
                                signal = new view::LogicSignal(logicSig, _view_data->get_logic(), probe);
                                if (logicSig->get_view_index() < start_view_dex || start_view_dex == -1)
                                    start_view_dex = logicSig->get_view_index();
                            }
                               
                            break;
                        }
                        i++;
                    }

                    if (signal == NULL)
                    {
                        signal = new view::LogicSignal(_view_data->get_logic(), probe);
                    }
                }
                break;

            case SR_CHANNEL_ANALOG:
                if (probe->enabled)
                { 
                    dso_chan_num++;

                    auto i = _signals.begin();
                    while (i != _signals.end())
                    {
                        if ((*i)->get_index() == probe->index)
                        {
                            if ((*i)->signal_type() == SR_CHANNEL_ANALOG){
                                view::AnalogSignal *analogSig = (view::AnalogSignal*)(*i);
                                signal = new view::AnalogSignal(analogSig, _view_data->get_analog(), probe);
                            }                               
                            break;
                        }
                        i++;
                    }
                    if (signal == NULL)
                    {
                        signal = new view::AnalogSignal(_view_data->get_analog(), probe);
                    }
                }
                break;
            }
            if (signal != NULL)
                sigs.push_back(signal);
        }

        if (!sigs.empty())
        { 
            std::vector<int> view_indexs;
            for(auto s : _signals){
                view_indexs.push_back(s->get_view_index());
            }

            dsv_info("SigSession::reload(), clear signals");
            clear_signals();
            std::vector<view::Signal *>().swap(_signals);
            _signals = sigs;
            make_channels_view_index(start_view_dex);

            if (_device_agent.get_work_mode() == LOGIC){
                for (unsigned int i=0; i<view_indexs.size() && i<_signals.size(); i++){
                    _signals[i]->set_view_index(view_indexs[i]);
                }
            }
        }

        spectrum_rebuild();

        //dsv_info("Rebuild channnel list, logic channel count:%d, dso channel count:%d, all:%d", 
        //            logic_chan_num, dso_chan_num, all_chann_num);
    }

    void SigSession::refresh(int holdtime)
    {
        ds_lock_guard lock(_data_mutex);

        data_lock();
        _view_data->get_logic()->init();

        clear_all_decode_task2();
        clear_decode_result();

        _view_data->get_dso()->init();
       
        for (auto m : _spectrum_traces)
        { 
            m->get_spectrum_stack()->init();
        }

        if (_math_trace)
            _math_trace->get_math_stack()->init();

        _view_data->get_analog()->init();

        _out_timer.TimeOut(holdtime, std::bind(&SigSession::feed_timeout, this));
        _data_updated = true;
    }

    void SigSession::data_auto_lock(int lock)
    {
        _data_auto_lock = lock;
    }

    void SigSession::data_auto_unlock()
    {
        if (_data_auto_lock > 0)
            _data_auto_lock--;
        else if (_data_auto_lock < 0)
            _data_auto_lock = 0;
    }

    bool SigSession::get_data_auto_lock()
    {
        return _data_auto_lock != 0;
    }

    void SigSession::feed_in_header(const sr_dev_inst *sdi)
    {
        (void)sdi;
        _trigger_pos = 0;
        _callback->receive_header();
    }

    void SigSession::feed_in_meta(const sr_dev_inst *sdi,
                                  const sr_datafeed_meta &meta)
    {
        (void)sdi;

        for (const GSList *l = meta.config; l; l = l->next)
        {
            const sr_config *const src = (const sr_config *)l->data;
            switch (src->key)
            {
            case SR_CONF_SAMPLERATE:
                /// @todo handle samplerate changes
                /// samplerate = (uint64_t *)src->value;
                break;
            }
        }
    }

    void SigSession::feed_in_trigger(const ds_trigger_pos &trigger_pos)
    {
        _hw_replied = true;
        if (_device_agent.get_work_mode() != DSO)
        {
            _trigger_flag = (trigger_pos.status & 0x01);
            if (_trigger_flag)
            {
                _trigger_pos = trigger_pos.real_pos;
                _callback->receive_trigger(_trigger_pos);
            }
        }
        else
        {
            int probe_count = 0;
            int probe_en_count = 0;
            for (const GSList *l = _device_agent.get_channels(); l; l = l->next)
            {
                const sr_channel *const probe = (const sr_channel *)l->data;
                if (probe->type == SR_CHANNEL_DSO)
                {
                    probe_count++;
                    if (probe->enabled)
                        probe_en_count++;
                }
            }
            _trigger_pos = trigger_pos.real_pos * probe_count / probe_en_count;
            _callback->receive_trigger(_trigger_pos);
        }
    }

    void SigSession::feed_in_logic(const sr_datafeed_logic &o)
    {  
        if (_capture_data->get_logic()->memory_failed())
        {
            dsv_err("Unexpected logic packet");
            return;
        }

        if (!_is_triged && o.length > 0)
        {
            _is_triged = true;
            _trig_time = QDateTime::currentDateTime();
        }  

        if (_capture_data->get_logic()->last_ended())
        {
            _capture_data->get_logic()->set_loop(is_loop_mode());

            bool bNotFree = _is_decoding && _view_data == _capture_data;

            _capture_data->get_logic()->first_payload(o, 
                            _device_agent.get_sample_limit(),
                            _device_agent.get_channels(),
                            !bNotFree);

            // @todo Putting this here means that only listeners querying
            // for logic will be notified. Currently the only user of
            // frame_began is DecoderStack, but in future we need to signal
            // this after both analog and logic sweeps have begun.
            _callback->frame_began();
        }
        else
        {
            // Append to the existing data snapshot
            _capture_data->get_logic()->append_payload(o);
        }

        if (_capture_data->get_logic()->memory_failed())
        {
            _error = Malloc_err;
            _callback->session_error();
            return;
        }

        set_receive_data_len(o.length * 8 / get_ch_num(SR_CHANNEL_LOGIC));

        _data_updated = true;
    }

    void SigSession::feed_in_dso(const sr_datafeed_dso &o)
    {
        if (_capture_data->get_dso()->memory_failed())
        {
            dsv_err("Unexpected dso packet");
            return; // This dso packet was not expected.
        }

        _dso_packet_count++;

        if (!_is_triged && o.num_samples > 0)
        {
            _is_triged = true;
            _trig_time = QDateTime::currentDateTime();
            set_session_time(_trig_time);
        }

        if (_capture_data->get_dso()->last_ended())
        { 
            // reset scale of dso signal
            for (auto s : _signals)
            { 
                if (s->signal_type() == SR_CHANNEL_DSO){   
                    view::DsoSignal *dsoSig = (view::DsoSignal*)s;
                    dsoSig->set_scale(dsoSig->get_view_rect().height()); 
                }
            }

            // first payload
            _capture_data->get_dso()->first_payload(o, 
                    _device_agent.get_sample_limit(), 
                    _device_agent.get_channels(),
                    _is_instant,
                    _device_agent.is_file());
        }
        else
        {
            // Append to the existing data snapshot
            _capture_data->get_dso()->append_payload(o);
        }

        for (auto s : _signals)
        { 
            if (s->signal_type() == SR_CHANNEL_DSO && (s->enabled())){
                view::DsoSignal *dsoSig = (view::DsoSignal*)s;
                dsoSig->paint_prepare();
            }                
        }

        if (o.num_samples != 0 && (!_is_instant || _dso_packet_count == 1))
        {
            // update current sample rate
            set_cur_snap_samplerate(_device_agent.get_sample_rate());
        }

        if (_capture_data->get_dso()->memory_failed())
        {
            _error = Malloc_err;
            _callback->session_error();
            return;
        }

        // calculate related spectrum results
        for (auto m : _spectrum_traces)
        {
            if (m->enabled())
                m->get_spectrum_stack()->calc_fft();
        }

        // calculate related math results
        if (_math_trace && _math_trace->enabled())
        {
            _math_trace->get_math_stack()->realloc(_device_agent.get_sample_limit());
            _math_trace->get_math_stack()->calc_math();
        }

        _trigger_flag = o.trig_flag;
        _trigger_ch = o.trig_ch;

        //Trigger update()
        set_receive_data_len(o.num_samples);

        if (!_is_instant)
            data_lock();

        _data_updated = true;
    }

    void SigSession::feed_in_analog(const sr_datafeed_analog &o)
    {
        if (_capture_data->get_analog()->memory_failed())
        {
            dsv_err("Unexpected analog packet");
            return; // This analog packet was not expected.
        }

        if (_capture_data->get_analog()->last_ended())
        {
            // reset scale of analog signal
            for (auto s : _signals)
            { 
                if (s->signal_type() == SR_CHANNEL_ANALOG){   
                    view::AnalogSignal *analogSig = (view::AnalogSignal*)s;
                    analogSig->set_scale(analogSig->get_totalHeight());
                }
            }

            // first payload
            _capture_data->get_analog()->first_payload(o, _device_agent.get_sample_limit(), _device_agent.get_channels());
        }
        else
        {
            // Append to the existing data snapshot
            _capture_data->get_analog()->append_payload(o);
        }

        if (_capture_data->get_analog()->memory_failed())
        {
            _error = Malloc_err;
            _callback->session_error();
            return;
        }

        set_receive_data_len(o.num_samples);
        _data_updated = true;
    }

    void SigSession::data_feed_in(const struct sr_dev_inst *sdi,
                                  const struct sr_datafeed_packet *packet)
    {
        assert(sdi);
        assert(packet); 

        ds_lock_guard lock(_data_mutex);

        if (_data_lock && packet->type != SR_DF_END)
            return;

        if (packet->type != SR_DF_END &&
            packet->status != SR_PKT_OK)
        {
            _error = Pkt_data_err;
            _callback->session_error();
            return;
        }

        switch (packet->type)
        {
        case SR_DF_HEADER:
            feed_in_header(sdi);
            break;

        case SR_DF_META:
            assert(packet->payload);
            feed_in_meta(sdi,
                         *(const sr_datafeed_meta *)packet->payload);
            break;

        case SR_DF_TRIGGER:
            assert(packet->payload);
            feed_in_trigger(*(const ds_trigger_pos *)packet->payload);
            break;

        case SR_DF_LOGIC:
            assert(packet->payload);
            feed_in_logic(*(const sr_datafeed_logic *)packet->payload);
            break;

        case SR_DF_DSO:
            assert(packet->payload);
            feed_in_dso(*(const sr_datafeed_dso *)packet->payload);
            break;

        case SR_DF_ANALOG:
            assert(packet->payload);
            feed_in_analog(*(const sr_datafeed_analog *)packet->payload);
            break;

        case SR_DF_OVERFLOW:
        {
            if (_error == No_err)
            {
                _error = Data_overflow;
                _callback->session_error();
            }
            break;
        }
        case SR_DF_END:
        {
            dsv_info("------------SR_DF_END packet.");

            _capture_data->get_logic()->capture_ended();
            _capture_data->get_dso()->capture_ended();
            _capture_data->get_analog()->capture_ended();

            if (packet->status != SR_PKT_OK)
            {
                _error = Pkt_data_err;
                _callback->session_error();
            }
            else
            {
                int mode = _device_agent.get_work_mode();

                // Post a message to start all decode tasks.
                if (mode == LOGIC){
                    _callback->trigger_message(DSV_MSG_REV_END_PACKET);
                }
                else{
                    _callback->frame_ended();
                }                     
            }           

            break;
        }
        }
    }

    void SigSession::data_feed_callback(const struct sr_dev_inst *sdi,
                                        const struct sr_datafeed_packet *packet)
    {
        assert(_session);
        _session->data_feed_in(sdi, packet);
    }

    uint16_t SigSession::get_ch_num(int type)
    {
        uint16_t num_channels = 0;
        uint16_t logic_ch_num = 0;
        uint16_t dso_ch_num = 0;
        uint16_t analog_ch_num = 0;

        if (_device_agent.have_instance())
        {
            for (auto s : _signals)
            { 
                if (!s->enabled())
                    continue;
                
                if (s->signal_type() == SR_CHANNEL_LOGIC)
                    logic_ch_num++;
                else if (s->signal_type() == SR_CHANNEL_DSO)
                    dso_ch_num++;
                else if (s->signal_type() == SR_CHANNEL_ANALOG)
                    analog_ch_num++;
            }
        }

        switch (type)
        {
        case SR_CHANNEL_LOGIC:
            num_channels = logic_ch_num;
            break;
        case SR_CHANNEL_DSO:
            num_channels = dso_ch_num;
            break;
        case SR_CHANNEL_ANALOG:
            num_channels = analog_ch_num;
            break;
        default:
            num_channels = logic_ch_num + dso_ch_num + analog_ch_num;
            break;
        }

        return num_channels;
    }

    bool SigSession::add_decoder(srd_decoder *const dec, bool silent, DecoderStatus *dstatus,
                                 std::list<dsv::decode::Decoder *> &sub_decoders, view::Trace* &out_trace)
    {
        if (dec == NULL)
        {
            dsv_err("Decoder instance is null!");
            assert(false);
        }

        out_trace = NULL;

        //dsv_info("Create new decoder,name:\"%s\",id:\"%s\"", dec->name, dec->id);

        try
        {
            bool ret = false;

            // Create the decoder
            std::map<const srd_channel *, int> probes;
            data::DecoderStack *decoder_stack = new data::DecoderStack(this, dec, dstatus);
            assert(decoder_stack);

            // Make a list of all the probes
            std::vector<const srd_channel *> all_probes;

            for (const GSList *i = dec->channels; i; i = i->next){
                all_probes.push_back((const srd_channel *)i->data);
            }

            for (const GSList *i = dec->opt_channels; i; i = i->next){
                all_probes.push_back((const srd_channel *)i->data);
            }

            decoder_stack->stack().front()->set_probes(probes);

            // Create the decode signal
            view::DecodeTrace *trace = new view::DecodeTrace(this, decoder_stack, _decode_traces.size());
            assert(trace);

            // add sub decoder
            for (auto sub : sub_decoders)
            {
                trace->decoder()->add_sub_decoder(sub);
            }

            if (sub_decoders.size() > 0){
                auto lst_sub = sub_decoders.end();
                lst_sub--;
                QString sub_dec_name((*lst_sub)->decoder()->name);
                if (sub_dec_name != "")
                    trace->set_name(sub_dec_name);
            }

            sub_decoders.clear();

            // set view early for decode start/end region setting
            for (auto s : _signals)
            {
                if (s->get_view())
                {
                    trace->set_view(s->get_view());
                    break;
                }
            }

            if (silent)
            {
                ret = true;
            }
            else if (trace->create_popup(true))
            {
                ret = true;
            }

            if (ret)
            {
                _decode_traces.push_back(trace);

                // add decode task from ui
                if (!silent && have_view_data())
                {
                    add_decode_task(trace);
                }

                signals_changed();
                data_updated();
                
                out_trace = trace;
            }
            else
            {
                delete trace;
            }

            return ret;
        }
        catch (...)
        {
            dsv_err("Error!add_decoder() throws an exception.");
        }

        return false;
    }

    int SigSession::get_trace_index_by_key_handel(void *handel)
    {
        int dex = 0;

        for (auto tr : _decode_traces)
        {
            if (tr->decoder()->get_key_handel() == handel)
            {
                return dex;
            }
            ++dex;
        }

        return -1;
    }

    void SigSession::remove_decoder(int index)
    {
        int size = (int)_decode_traces.size();
        assert(index < size);

        auto it = _decode_traces.begin() + index;
        auto trace = (*it);
        _decode_traces.erase(it);

        bool isRunning = trace->decoder()->IsRunning();

        remove_decode_task(trace);

        if (isRunning)
        {
            // destroy it in thread
            trace->_delete_flag = true;
        }
        else
        {
            delete trace;
            signals_changed();
        }
    }

    void SigSession::remove_decoder_by_key_handel(void *handel)
    {
        int dex = get_trace_index_by_key_handel(handel);
        remove_decoder(dex);
    }

    void SigSession::rst_decoder(int index)
    {
        auto trace = get_decoder_trace(index);

        if (trace && trace->create_popup(false))
        {
            remove_decode_task(trace); // remove old task
            trace->decoder()->clear();
            add_decode_task(trace);
            data_updated();
        }
    }

    void SigSession::rst_decoder_by_key_handel(void *handel)
    {
        int dex = get_trace_index_by_key_handel(handel);
        rst_decoder(dex);
    }

    void SigSession::spectrum_rebuild()
    {
        bool has_dso_signal = false;

        for (auto s : _signals)
        { 
            if (s->signal_type() == SR_CHANNEL_DSO){
                has_dso_signal = true;
                // check already have
                auto iter = _spectrum_traces.begin();

                for (unsigned int i = 0; i < _spectrum_traces.size(); i++, iter++){
                    if ((*iter)->get_index() == s->get_index())
                        break;
                }

                // if not, rebuild
                if (iter == _spectrum_traces.end())
                {
                    auto spectrum_stack = new data::SpectrumStack(this, s->get_index());
                    auto spectrum_trace = new view::SpectrumTrace(this, spectrum_stack, s->get_index());
                    _spectrum_traces.push_back(spectrum_trace);
                }
            }
        }

        if (!has_dso_signal)
        {
            RELEASE_ARRAY(_spectrum_traces);
        }

        signals_changed();
    }

    void SigSession::lissajous_rebuild(bool enable, int xindex, int yindex, double percent)
    {
        DESTROY_OBJECT(_lissajous_trace);
        _lissajous_trace = new view::LissajousTrace(enable, _view_data->get_dso(), xindex, yindex, percent);
        signals_changed();
    }

    void SigSession::lissajous_disable()
    {
        if (_lissajous_trace)
            _lissajous_trace->set_enable(false);
    }

    void SigSession::math_rebuild(bool enable, view::DsoSignal *dsoSig1,
                                  view::DsoSignal *dsoSig2,
                                  data::MathStack::MathType type)
    {
        ds_lock_guard lock(_data_mutex);

        assert(dsoSig1);
        assert(dsoSig2);

        DESTROY_OBJECT(_math_trace);

        auto math_stack = new data::MathStack(this, dsoSig1, dsoSig2, type);        
        _math_trace = new view::MathTrace(enable, math_stack, dsoSig1, dsoSig2);

        if (_math_trace && _math_trace->enabled())
        {
            int rt = _view_data->get_dso()->samplerate();
            if (rt > 0){
                _math_trace->get_math_stack()->set_samplerate(rt);
                _math_trace->get_math_stack()->realloc(_device_agent.get_sample_limit());
                _math_trace->get_math_stack()->calc_math();
            }           
        }
        signals_changed();
    }

    void SigSession::math_disable()
    {
        if (_math_trace)
            _math_trace->set_enable(false);
    }

    void SigSession::nodata_timeout()
    {
        int flag;
        _device_agent.get_config_byte(SR_CONF_TRIGGER_SOURCE, flag);
        if (flag != DSO_TRIGGER_AUTO)
        {
            _callback->show_wait_trigger();
        }
    }

    void SigSession::feed_timeout()
    {
        data_unlock();

        if (!_data_updated)
        {
            if (++_noData_cnt >= (WaitShowTime / FeedInterval))
                nodata_timeout();
        }
    }

    data::Snapshot *SigSession::get_snapshot(int type)
    {
        if (type == SR_CHANNEL_LOGIC)
            return _view_data->get_logic();
        else if (type == SR_CHANNEL_ANALOG)
            return _view_data->get_analog();
        else if (type == SR_CHANNEL_DSO)
            return _view_data->get_dso();
        else
            return NULL;
    }

    void SigSession::clear_error()
    {
        _error_pattern = 0;
        _error = No_err;
    }

    int SigSession::get_repeat_hold()
    {
        if (_is_working && is_repeat_mode())
            return _repeat_hold_prg;
        else
            return 0;
    }

    void SigSession::auto_end()
    {
        for (auto s : _signals)
        { 
            if (s->signal_type() == SR_CHANNEL_DSO)
            {
                view::DsoSignal *dsoSig = (view::DsoSignal*)s;
                dsoSig->auto_end();
            }
        }
    }

    void SigSession::Open()
    {
    }

    void SigSession::Close()
    {
        if (_bClose)
            return;

        _bClose = true;

        // Stop decode thread.
        clear_all_decoder(false);

        dsv_info("SigSession::Close(), stop capture");
        stop_capture();

        // TODO: This should not be necessary
        _session = NULL;
    }

    // append a decode task, and try create a thread
    void SigSession::add_decode_task(view::DecodeTrace *trace)
    {
        std::lock_guard<std::mutex> lock(_decode_task_mutex);
        _decode_tasks.push_back(trace);

        if (!_is_decoding)
        {
            if (_decode_thread.joinable())
                _decode_thread.join();

            _decode_thread = std::thread(&SigSession::decode_task_proc, this);
            _is_decoding = true;
        }
    }

    void SigSession::remove_decode_task(view::DecodeTrace *trace)
    {
        std::lock_guard<std::mutex> lock(_decode_task_mutex);

        for (auto it = _decode_tasks.begin(); it != _decode_tasks.end(); it++)
        {
            if ((*it) == trace)
            {
                (*it)->decoder()->stop_decode_work();
                _decode_tasks.erase(it);
                dsv_info("remove a waiting decode task");
                return;
            }
        }

        // the task maybe is running
        trace->decoder()->stop_decode_work();
    }

    void SigSession::clear_all_decoder(bool bUpdateView)
    {
        if (_decode_traces.empty())
            return;

        // create the wait task deque
        int dex = -1;
        clear_all_decode_task(dex);

        view::DecodeTrace *runningTrace = NULL;
        if (dex != -1)
        {
            runningTrace = _decode_traces[dex];
            runningTrace->_delete_flag = true; // destroy it in thread
        }

        for (auto trace : _decode_traces)
        {
            if (trace != runningTrace)
                delete trace;
        }
        _decode_traces.clear();

        if (!_bClose && bUpdateView)
            signals_changed();
    }

    void SigSession::clear_all_decode_task(int &runningDex)
    {
        if (true)
        {
            std::lock_guard<std::mutex> lock(_decode_task_mutex);

            // remove wait task
            for (auto trace : _decode_tasks)
            {
                trace->decoder()->stop_decode_work(); // set decode proc stop flag
            }
            _decode_tasks.clear();
        }

        // make sure the running task can stop
        runningDex = -1;
        int dex = 0;
        for (auto trace : _decode_traces)
        {
            if (trace->decoder()->IsRunning())
            {
                trace->decoder()->stop_decode_work();
                runningDex = dex;
            }
            dex++;
        }

        // Wait the thread end.
        if (_decode_thread.joinable())
            _decode_thread.join();
    }

    view::DecodeTrace *SigSession::get_decoder_trace(int index)
    {
        if (index >= 0 && index < (int)_decode_traces.size())
        {
            return _decode_traces[index];
        }
        assert(false);
    }

    view::DecodeTrace *SigSession::get_top_decode_task()
    {
        std::lock_guard<std::mutex> lock(_decode_task_mutex);

        auto it = _decode_tasks.begin();
        if (it != _decode_tasks.end())
        {
            auto p = (*it);
            _decode_tasks.erase(it);
            return p;
        }

        return NULL;
    }

    // the decode task thread proc
    void SigSession::decode_task_proc()
    {
        dsv_info("------->decode thread start");
        auto task = get_top_decode_task();

        while (task != NULL)
        {
            if (!task->_delete_flag)
            {
                task->decoder()->begin_decode_work();
            }

            if (task->_delete_flag)
            {
                dsv_info("destroy a decoder in task thread");

                DESTROY_QT_LATER(task);
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
                if (!_bClose)
                {
                    signals_changed();
                }
            }

            task = get_top_decode_task();
        }

        _view_data->get_logic()->decode_end();

        dsv_info("------->decode thread end");
        _is_decoding = false;        
    }

    Snapshot *SigSession::get_signal_snapshot()
    {
        int mode = _device_agent.get_work_mode();
        if (mode == ANALOG)
            return _view_data->get_analog();
        else if (mode == DSO)
            return _view_data->get_dso();
        else
            return _view_data->get_logic();
    }

    void SigSession::device_lib_event_callback(int event)
    {
        if (_session == NULL)
        {
            dsv_err("Error!Global variable \"_session\" is null.");
            return;
        }
        _session->on_device_lib_event(event);
    }

    void SigSession::on_device_lib_event(int event)
    {
        if (_callback == NULL)
        {
            dsv_detail("The callback is null, so the device event was ignored.");
            return;
        }

        switch (event)
        {
        case DS_EV_DEVICE_RUNNING:
            _device_status = ST_RUNNING;
            set_receive_data_len(0);
            break;

        case DS_EV_DEVICE_STOPPED:
            _device_status = ST_STOPPED;
            // Confirm that SR_DF_END was received
            if (   !_capture_data->get_logic()->last_ended() 
                || !_capture_data->get_dso()->last_ended()
                || !_capture_data->get_analog()->last_ended())
            {
                dsv_err("Error!The data is not completed.");
                assert(false);
            }
            break;

        case DS_EV_COLLECT_TASK_START:
            _callback->trigger_message(DSV_MSG_COLLECT_START);
            break;

        case DS_EV_COLLECT_TASK_END:
        case DS_EV_COLLECT_TASK_END_BY_ERROR:
        case DS_EV_COLLECT_TASK_END_BY_DETACHED:
        {
            _callback->trigger_message(DSV_MSG_COLLECT_END);

            if (_capture_data->get_logic()->last_ended() == false)
                dsv_err("The collected data is error!");

            if (_capture_data->get_dso()->last_ended() == false)
                dsv_err("The collected data is error!");

            if (_capture_data->get_analog()->last_ended() == false)
                dsv_err("The collected data is error!");

            // trig next collect
            if (is_repeat_mode() && _is_working && event == DS_EV_COLLECT_TASK_END)
            {
                _callback->trigger_message(DSV_MSG_TRIG_NEXT_COLLECT);
            }
            else
            {
                _is_working = false;
                _is_instant = false;
                _callback->trigger_message(DSV_MSG_END_COLLECT_WORK);
            }
        }
        break;

        case DS_EV_NEW_DEVICE_ATTACH:
            _callback->trigger_message(DSV_MSG_NEW_USB_DEVICE);
        break;

        case DS_EV_CURRENT_DEVICE_DETACH:
        {
            if (_is_working){
                dsv_info("SigSession::on_device_lib_event,DS_EV_CURRENT_DEVICE_DETACH, stop capture");
                stop_capture();
            }

            _callback->trigger_message(DSV_MSG_CURRENT_DEVICE_DETACHED);
        }            
        break;

        case DS_EV_INACTIVE_DEVICE_DETACH:
            _callback->trigger_message(DSV_MSG_DEVICE_LIST_UPDATED); // Update list only.
            break;
        
        case DS_EV_DEVICE_SPEED_NOT_MATCH:
            _callback->trigger_message(DS_EV_DEVICE_SPEED_NOT_MATCH);
            break;

        default:
            dsv_err("Error!Unknown device event.");
            break;
        }
    }

    void SigSession::add_msg_listener(IMessageListener *ln)
    {
        _msg_listeners.push_back(ln);
    }

    void SigSession::broadcast_msg(int msg)
    {
        for (IMessageListener *cb : _msg_listeners)
        {
            cb->OnMessage(msg);
        }
    }

    void SigSession::set_collect_mode(DEVICE_COLLECT_MODE m)
    {
        assert(!_is_working);

        if (_clt_mode != m)
        {
            _clt_mode = m;
            _repeat_hold_prg = 0;
        }

        _callback->trigger_message(DSV_MSG_COLLECT_MODE_CHANGED);
    }

    void SigSession::repeat_capture_wait_timeout()
    {
        _repeat_timer.Stop();
        _repeat_wait_prog_timer.Stop();

        _repeat_hold_prg = 0;

        if (_is_working)
        {
            _callback->repeat_hold(_repeat_hold_prg);
            exec_capture();
        }
    }

    void SigSession::repeat_wait_prog_timeout()
    {
        _repeat_hold_prg -= _repeat_wait_prog_step;

        if (_repeat_hold_prg < 0)
            _repeat_hold_prg = 0;

        if (_is_working)
            _callback->repeat_hold(_repeat_hold_prg);
    }

    void SigSession::OnMessage(int msg)
    {
        switch (msg)
        {
        case DSV_MSG_DEVICE_OPTIONS_UPDATED:
            reload();
            break;

        case DSV_MSG_TRIG_NEXT_COLLECT:
            {
                if (_is_working && is_repeat_mode())
                {
                    if (_repeat_intvl > 0)
                    {
                        _repeat_hold_prg = 100;
                        _repeat_timer.Start(_repeat_intvl * 1000);
                        int intvl = _repeat_intvl * 1000 / 20;

                        if (intvl >= 100){
                            _repeat_wait_prog_step = 5;
                        }
                        else if (_repeat_intvl >= 1){
                            intvl = _repeat_intvl * 1000 / 10;
                            _repeat_wait_prog_step = 10;
                        }
                        else{
                            intvl = _repeat_intvl * 1000 / 5;
                            _repeat_wait_prog_step = 20;
                        }

                        _repeat_wait_prog_timer.Start(intvl);
                    }
                    else
                    {
                        _repeat_hold_prg = 0;
                        exec_capture();
                    }
                }
            }
            break;

        case DSV_MSG_REV_END_PACKET:
            {
                if (_device_agent.get_work_mode() == LOGIC)
                {  
                    bool bAddDecoder = false;
                    bool bSwapBuffer = false;

                    if (is_single_mode())
                    {
                        if (!_is_stream_mode)
                            bAddDecoder = true;
                    }
                    else if(is_repeat_mode())
                    {
                        if (!_is_stream_mode){
                            bAddDecoder = true;
                            bSwapBuffer = true;
                        }
                        else if (_capture_times > 1){
                            bAddDecoder = true;
                            bSwapBuffer = true;
                        }
                    }
                    else if (is_loop_mode())
                    {
                        bAddDecoder = true;
                    }

                    if (is_repeat_mode())
                    {
                        AppConfig &app = AppConfig::Instance();
                        bool swapBackBufferAlways = app.appOptions.swapBackBufferAlways;
                        if (!swapBackBufferAlways && !_is_working && _capture_times > 1){
                            bAddDecoder = false;
                            bSwapBuffer = false;
                            _capture_data->clear();
                        }
                    }

                    if (bAddDecoder){
                        clear_all_decode_task2();
                        clear_decode_result();
                    }

                    _trig_check_timer.Stop();

                    //Switch the caputrued data buffer to view.
                    if (bSwapBuffer)
                    {
                        if (_view_data != _capture_data)
                            _view_data->clear();
                        
                        _view_data = _capture_data; 
                        attach_data_to_signal(_view_data); 
                        set_session_time(_trig_time);
                    }

                    for (auto de : _decode_traces)
                    {
                        de->decoder()->set_capture_end_flag(true);

                        if (bAddDecoder){ 
                            de->frame_ended();
                            add_decode_task(de);
                        }
                    }

                    _callback->frame_ended();
                }
            }
            break;

        case DSV_MSG_COLLECT_END:   
            break;

        case DS_EV_DEVICE_SPEED_NOT_MATCH:
            {
                QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_DEVICE_SPEED_TOO_LOW), "Speed too low!"));
                _callback->delay_prop_msg(strMsg);
            }
            break;
        }     
    }

    void SigSession::DeviceConfigChanged()
    {
        // Nonthing.
    }

    bool SigSession::switch_work_mode(int mode)
    {
        assert(!_is_working);
        int cur_mode = _device_agent.get_work_mode();

        if (cur_mode != mode)
        {
            set_collect_mode(COLLECT_SINGLE);

            _device_agent.set_config_int16(SR_CONF_DEVICE_MODE, mode);

            if (cur_mode == LOGIC){
                clear_all_decode_task2();
                clear_decode_result();
            }

            _is_stream_mode = false;
            if (mode == LOGIC){
                if (_device_agent.is_hardware()){
                    _is_stream_mode = _device_agent.is_stream_mode();
                }
                else if (_device_agent.is_demo()){
                    _is_stream_mode = true;
                }
            }

            _capture_data->clear();
            _view_data->clear();
            _capture_data = _view_data;              
            
            init_signals();

            set_cur_snap_samplerate(_device_agent.get_sample_rate());
            set_cur_samplelimits(_device_agent.get_sample_limit()); 

            dsv_info("Switch work mode to:%d", mode);

            broadcast_msg(DSV_MSG_DEVICE_MODE_CHANGED);

            return true;
        }
        return false;
    }

    bool SigSession::is_first_store_confirm()
    {
        if (_work_time_id != _confirm_store_time_id){
            _confirm_store_time_id = _work_time_id;
            return true;
        }
        return false;
    }

    void SigSession::realtime_refresh_timeout()
    {
        _rt_refresh_time_id++;
    }

    bool SigSession::have_new_realtime_refresh(bool keep)
    {
        if (_rt_ck_refresh_time_id != _rt_refresh_time_id){
            if (!keep){
                _rt_ck_refresh_time_id = _rt_refresh_time_id;
            }
            return true;
        }
        return false;    
    }

    void SigSession::clear_decode_result()
    {
        for (auto de : _decode_traces){
            de->decoder()->init();
            de->decoder()->set_capture_end_flag(false);
        }
        _callback->trigger_message(DSV_MSG_CLEAR_DECODE_DATA);
    }

    void SigSession::attach_data_to_signal(SessionData *data)
    {
        assert(data);

        view::LogicSignal *s1;
        view::AnalogSignal *s2;
        view::DsoSignal *s3;

        for (auto sig : _signals){
            int type = sig->signal_type();
            switch(type){
                case SR_CHANNEL_LOGIC:
                    s1 = (view::LogicSignal*)sig;
                    s1->set_data(data->get_logic());
                    break;
                case SR_CHANNEL_ANALOG:
                    s2 = (view::AnalogSignal*)sig;
                    s2->set_data(data->get_analog());
                    break;
                case SR_CHANNEL_DSO:
                    s3 = (view::DsoSignal*)sig;
                    s3->set_data(data->get_dso());
                    break;
            }
        }
    }

    void SigSession::clear_signals()
    {   
        DESTROY_OBJECT(_math_trace);
        
        for (int i=0; i< (int)_signals.size(); i++)
        {
            auto *p = _signals[i];
            p->sig_released(p);
            
            DESTROY_QT_LATER(p);
        }
        _signals.clear();
    }

    view::Signal* SigSession::get_signal_by_index(int index)
    {
        for (int i=0; i< (int)_signals.size(); i++)
        {
            auto *p = _signals[i];
            if (p->get_index() == index)
                return p;
        }
        return NULL;
    }

    bool SigSession::is_realtime_refresh()
    {
        if (is_loop_mode())
            return true;
        if (_is_stream_mode && is_single_mode())
            return true;
        if (_is_stream_mode && is_repeat_mode() && is_single_buffer())
            return true;
        return false;     
    }

    void SigSession::on_load_config_end()
    {
        set_cur_snap_samplerate(_device_agent.get_sample_rate());
        set_cur_samplelimits(_device_agent.get_sample_limit());
    }

    void SigSession::clear_view_data()
    {
        _view_data->clear();
        data_updated();
    }

    void SigSession::set_trace_name(view::Trace *trace, QString name)
    {
        assert(trace);

        trace->set_name(name);

        int traceType = trace->get_type();

        if (traceType == SR_CHANNEL_LOGIC || traceType == SR_CHANNEL_ANALOG)
        { 
            _device_agent.set_channel_name(trace->get_index(), name.toUtf8());
        }
        else if (traceType == SR_CHANNEL_DECODER && _decoder_pannel != NULL){
            _decoder_pannel->update_deocder_item_name(trace, name.toUtf8().data());
        }
    }

    void SigSession::set_decoder_row_label(int index, QString label)
    {
        auto trace = get_decoder_trace(index);
        if (trace != NULL){
            set_trace_name(trace, label);
        }
    }

    view::Trace* SigSession::get_channel_by_index(int orgIndex)
    {
        for(auto t : _signals){
            if (t->get_index() == orgIndex){
                return t;
            }
        }
        return NULL;
    }

    void SigSession::make_channels_view_index(int start_dex)
    {
        int index = 0;

        if (start_dex != -1)
            index  = start_dex;

        for(auto t : _signals){
            t->set_view_index(index++);
        }
    }

    void SigSession::trig_check_timeout()
    {   
        bool triged = false;
        int pro;

        if (_is_triged){
            _trig_check_timer.Stop();
            return;
        }
        
        if (get_capture_status(triged, pro) && triged)
        {
            _trig_time = QDateTime::currentDateTime();
            _is_triged = true;
            _trig_check_timer.Stop();
        }
    }

} //namespace com
} //namespace appcore
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef _EVENT_OBJECT_H
#define _EVENT_OBJECT_H

#include <QObject>

namespace dsv {
namespace appcore {

class EventObject : public QObject
{
    Q_OBJECT

public:
    EventObject(); 


signals:
    void show_error(QString error);
    void capture_state_changed(int state);
    void data_updated();

    void session_error();
    void signals_changed();
    void receive_trigger(quint64 trigger_pos);
    void frame_ended();
    void frame_began();

    void decode_done();
    void receive_data_len(quint64 len);
    void cur_snap_samplerate_changed();
    void trigger_message(int msg);
};


class DeviceEventObject : public QObject
{
    Q_OBJECT

public:
    DeviceEventObject(); 


signals: 
    void device_updated();
};

} //namespace com
} //namespace appcore

#endif/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2022 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DEVICE_AGENT_H
#define DEVICE_AGENT_H
 
#include <glib.h>
#include <stdint.h>
#include <libsigrok.h>
#include <QString>
#include <vector>

namespace dsv {
namespace appcore {

class IDeviceAgentCallback
{
    public:
        virtual void DeviceConfigChanged()=0;
};

class DeviceAgent
{
public:
    DeviceAgent();

    void update();

    inline bool have_instance(){
        return _dev_handle != NULL_HANDLE;
    }

    inline QString name(){
        return _dev_name;
    }

    inline QString path(){
        return _path;
    }

    inline QString driver_name(){
        return _driver_name;
    }

    inline ds_device_handle handle(){
        return _dev_handle;
    }

    struct sr_dev_inst* inst();

    inline bool is_file(){
        return _dev_type == DEV_TYPE_FILELOG;
    }

    inline bool is_demo(){
        return _dev_type == DEV_TYPE_DEMO;
    }

    inline bool is_hardware(){
        return _dev_type == DEV_TYPE_USB;
    }

    inline bool is_virtual(){
        return (is_file() || is_demo());
    }

    inline bool is_hardware_logic(){
        return is_hardware() && _driver_name == "DSLogic";
    }

    inline bool is_hardware_dso(){
        return is_hardware() && _driver_name == "DSCope";
    }

    inline void set_callback(IDeviceAgentCallback *callback){
        _callback = callback;
    }

	bool enable_probe(const sr_channel *probe, bool enable);

    bool enable_probe(int probe_index, bool enable);

    bool set_channel_name(int ch_index, const char *name);

    /**
	 * @brief Gets the sample limit from the driver.
	 *
	 * @return The returned sample limit from the driver, or 0 if the
	 * 	sample limit could not be read.
	 */
	uint64_t get_sample_limit();

     /**
     * @brief Gets the sample rate from the driver.
     *
     * @return The returned sample rate from the driver, or 0 if the
     * 	sample rate could not be read.
     */
    uint64_t get_sample_rate();

       /**
     * @brief Gets the time base from the driver.
     *
     * @return The returned time base from the driver, or 0 if the
     * 	time base could not be read.
     */
    uint64_t get_time_base();

     /**
     * @brief Gets the sample time from the driver.
     *
     * @return The returned sample time from the driver, or 0 if the
     * 	sample time could not be read.
     */
    double get_sample_time();

    /**
     * @brief Gets the device mode list from the driver.
     *
     * @return The returned device mode list from the driver, or NULL if the
     * 	mode list could not be read.
     */
    const GSList *get_device_mode_list();

    /**
     * Check whether the trigger exists
     */
    bool is_trigger_enabled();

    bool have_enabled_channel(); 

    GSList* get_channels();

    /**
     * Start collect data.
     */
    bool start();

    /**
     * Stop collect
     */
    bool stop();

    /**
     * Stop and close.
    */
    void release();

    bool is_collecting();

    inline bool is_new_device(){
        return _is_new_device;
    }

    bool channel_is_enable(int index);

    int get_hardware_operation_mode();

    bool is_stream_mode();

    bool check_firmware_version();

    QString get_demo_operation_mode(); 

public:
    GVariant* get_config_list(const sr_channel_group *group, int key);

    GVariant* get_config(int key, const sr_channel *ch = NULL, const sr_channel_group *cg = NULL);
    bool set_config(int key, GVariant *data, const sr_channel *ch = NULL, const sr_channel_group *cg = NULL);
    bool have_config(int key, const sr_channel *ch = NULL, const sr_channel_group *cg = NULL);

    bool get_config_string(int key, QString &value, const sr_channel *ch = NULL, const sr_channel_group *cg = NULL);
    bool set_config_string(int key, const char *value, const sr_channel *ch = NULL, const sr_channel_group *cg = NULL);

    bool get_config_bool(int key, bool &value, const sr_channel *ch = NULL, const sr_channel_group *cg = NULL);
    bool set_config_bool(int key, bool value, const sr_channel *ch = NULL, const sr_channel_group *cg = NULL);

    bool get_config_uint64(int key, uint64_t &value, const sr_channel *ch = NULL, const sr_channel_group *cg = NULL);
    bool set_config_uint64(int key, uint64_t value, const sr_channel *ch = NULL, const sr_channel_group *cg = NULL);

    bool get_config_uint16(int key, int &value, const sr_channel *ch = NULL, const sr_channel_group *cg = NULL);
    bool set_config_uint16(int key, int value, const sr_channel *ch = NULL, const sr_channel_group *cg = NULL);

    bool get_config_uint32(int key, uint32_t &value, const sr_channel *ch = NULL, const sr_channel_group *cg = NULL);
    bool set_config_uint32(int key, uint32_t value, const sr_channel *ch = NULL, const sr_channel_group *cg = NULL);

    bool get_config_int16(int key, int &value, const sr_channel *ch = NULL, const sr_channel_group *cg = NULL);
    bool set_config_int16(int key, int value, const sr_channel *ch = NULL, const sr_channel_group *cg = NULL);

    bool get_config_int32(int key, int &value, const sr_channel *ch = NULL, const sr_channel_group *cg = NULL);
    bool set_config_int32(int key, int value, const sr_channel *ch = NULL, const sr_channel_group *cg = NULL);

    bool get_config_byte(int key, int &value, const sr_channel *ch = NULL, const sr_channel_group *cg = NULL);
    bool set_config_byte(int key, int value, const sr_channel *ch = NULL, const sr_channel_group *cg = NULL);

    bool get_config_double(int key, double &value, const sr_channel *ch = NULL, const sr_channel_group *cg = NULL);
    bool set_config_double(int key, double value, const sr_channel *ch = NULL, const sr_channel_group *cg = NULL);

private:
    void config_changed(); 

    //---------------device config-----------/
public:
  int get_work_mode(); 

  const struct sr_config_info* get_config_info(int key);

  bool get_device_status(struct sr_status &status, gboolean prg);

  struct sr_config* new_config(int key, GVariant *data);

  void free_config(struct sr_config *src);

private:
    ds_device_handle _dev_handle;
    int         _dev_type;
    QString     _dev_name;
    QString     _driver_name;
    QString     _path;
    bool        _is_new_device;
    struct sr_dev_inst  *_di; 
    IDeviceAgentCallback *_callback;
};

} //namespace com
} //namespace appcore

#endif/****************************************************************************
** Meta object code from reading C++ file 'mainframe.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "mainframe.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'mainframe.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEMainFrameENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEMainFrameENDCLASS = QtMocHelpers::stringData(
    "dsv::appcore::MainFrame",
    "unfreezing",
    "",
    "showNormal",
    "showMaximized",
    "showMinimized",
    "show_doc",
    "setTaskbarProgress",
    "progress"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEMainFrameENDCLASS_t {
    uint offsetsAndSizes[18];
    char stringdata0[24];
    char stringdata1[11];
    char stringdata2[1];
    char stringdata3[11];
    char stringdata4[14];
    char stringdata5[14];
    char stringdata6[9];
    char stringdata7[19];
    char stringdata8[9];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEMainFrameENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEMainFrameENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEMainFrameENDCLASS = {
    {
        QT_MOC_LITERAL(0, 23),  // "dsv::appcore::MainFrame"
        QT_MOC_LITERAL(24, 10),  // "unfreezing"
        QT_MOC_LITERAL(35, 0),  // ""
        QT_MOC_LITERAL(36, 10),  // "showNormal"
        QT_MOC_LITERAL(47, 13),  // "showMaximized"
        QT_MOC_LITERAL(61, 13),  // "showMinimized"
        QT_MOC_LITERAL(75, 8),  // "show_doc"
        QT_MOC_LITERAL(84, 18),  // "setTaskbarProgress"
        QT_MOC_LITERAL(103, 8)   // "progress"
    },
    "dsv::appcore::MainFrame",
    "unfreezing",
    "",
    "showNormal",
    "showMaximized",
    "showMinimized",
    "show_doc",
    "setTaskbarProgress",
    "progress"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEappcoreSCOPEMainFrameENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       6,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   50,    2, 0x0a,    1 /* Public */,
       3,    0,   51,    2, 0x0a,    2 /* Public */,
       4,    0,   52,    2, 0x0a,    3 /* Public */,
       5,    0,   53,    2, 0x0a,    4 /* Public */,
       6,    0,   54,    2, 0x0a,    5 /* Public */,
       7,    1,   55,    2, 0x0a,    6 /* Public */,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::Int,    8,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::appcore::MainFrame::staticMetaObject = { {
    QMetaObject::SuperData::link<QFrame::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEMainFrameENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEappcoreSCOPEMainFrameENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEMainFrameENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<MainFrame, std::true_type>,
        // method 'unfreezing'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'showNormal'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'showMaximized'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'showMinimized'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'show_doc'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'setTaskbarProgress'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>
    >,
    nullptr
} };

void dsv::appcore::MainFrame::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<MainFrame *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->unfreezing(); break;
        case 1: _t->showNormal(); break;
        case 2: _t->showMaximized(); break;
        case 3: _t->showMinimized(); break;
        case 4: _t->show_doc(); break;
        case 5: _t->setTaskbarProgress((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        default: ;
        }
    }
}

const QMetaObject *dsv::appcore::MainFrame::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::appcore::MainFrame::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEMainFrameENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QFrame::qt_metacast(_clname);
}

int dsv::appcore::MainFrame::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QFrame::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 6)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 6;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 6)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 6;
    }
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "mainwindow.h"
#include <QAction>
#include <QButtonGroup>
#include <QFileDialog>
#include <QMessageBox>
#include <QMenu>
#include <QMenuBar>
#include <QStatusBar>
#include <QVBoxLayout>
#include <QWidget>
#include <QDesktopServices>
#include <QKeyEvent>
#include <QEvent>
#include <QtGlobal>
#include <QApplication>
#include <QStandardPaths>
#include <QScreen>
#include <QTimer>
#include <libusb-1.0/libusb.h>
#include <QGuiApplication>
#include <QTextStream>
#include <QJsonValue>
#include <QJsonArray>
#include <functional>
/* __STDC_FORMAT_MACROS is required for PRIu64 and friends (in C++). */
#include <inttypes.h>
#include <stdint.h>
#include <stdarg.h>
#include <glib.h>
#include <list>
#include <thread>
#include <stdlib.h>

//include with qt5
#if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
#include <QDesktopWidget>
#endif

#include "../data/logicsnapshot.h"
#include "../data/dsosnapshot.h"
#include "../data/analogsnapshot.h"
#include "../dialogs/about.h"
#include "../dialogs/deviceoptions.h"
#include "../dialogs/storeprogress.h"
#include "../dialogs/waitingdialog.h"
#include "../dialogs/regionoptions.h"
#include "../toolbars/samplingbar.h"
#include "../toolbars/trigbar.h"
#include "../toolbars/filebar.h"
#include "../toolbars/logobar.h"
#include "../toolbars/titlebar.h"
#include "../dock/triggerdock.h"
#include "../dock/dsotriggerdock.h"
#include "../dock/measuredock.h"
#include "../dock/searchdock.h"
#include "../dock/protocoldock.h"
#include "../view/view.h"
#include "../view/trace.h"
#include "../view/signal.h"
#include "../view/dsosignal.h"
#include "../view/logicsignal.h"
#include "../view/analogsignal.h"
#include "../ui/msgbox.h"
#include "../config/appconfig.h"
#include "../utility/encoding.h"
#include "../utility/path.h"
#include "../log.h"
#include "sigsession.h"
#include "deviceagent.h"
#include "../com/zipmaker.h"
#include "../ui/langresource.h"
#include "mainframe.h"
#include "../basedef.h"
#include "appcontrol.h"


using namespace dsv::config;

namespace dsv {
namespace appcore {

    MainWindow::MainWindow(toolbars::TitleBar *title_bar, QWidget *parent)
        : QMainWindow(parent)
    {
        _msg = NULL;
        _frame = parent;

        assert(title_bar);

        _title_bar = title_bar;
        AppControl::Instance()->add_font_form(title_bar);

        _session = AppControl::Instance()->GetSession();
        _session->set_callback(this);
        _device_agent = _session->get_device();
        _session->add_msg_listener(this);

        _is_auto_switch_device = false;
        _is_save_confirm_msg = false;

        _pattern_mode = "random";

        setup_ui();

        setContextMenuPolicy(Qt::NoContextMenu);

        _key_vaild = false;
        _last_key_press_time = high_resolution_clock::now();

        update_title_bar_text();
    }

    void MainWindow::setup_ui()
    {
        setObjectName(QString::fromUtf8("MainWindow"));
        setContentsMargins(0, 0, 0, 0);
        layout()->setSpacing(0);

        // Setup the central widget
        _central_widget = new QWidget(this);
        _vertical_layout = new QVBoxLayout(_central_widget);
        _vertical_layout->setSpacing(0);
        _vertical_layout->setContentsMargins(0, 0, 0, 0);
        setCentralWidget(_central_widget);

        // Setup the sampling bar
        _sampling_bar = new toolbars::SamplingBar(_session, this);        
        _sampling_bar->setObjectName("sampling_bar");
        _trig_bar = new toolbars::TrigBar(_session, this);
        _trig_bar->setObjectName("trig_bar");
        _file_bar = new toolbars::FileBar(_session, this);
        _file_bar->setObjectName("file_bar");
        _logo_bar = new toolbars::LogoBar(_session, this);
        _logo_bar->setObjectName("logo_bar");

        // trigger dock
        _trigger_dock = new QDockWidget(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_TRIGGER_DOCK_TITLE), "Trigger Setting..."), this);
        _trigger_dock->setObjectName("trigger_dock");
        _trigger_dock->setFeatures(QDockWidget::DockWidgetMovable);
        _trigger_dock->setAllowedAreas(Qt::RightDockWidgetArea);
        _trigger_dock->setVisible(false);
        _trigger_widget = new dock::TriggerDock(_trigger_dock, _session);        
        _trigger_dock->setWidget(_trigger_widget);

        _dso_trigger_dock = new QDockWidget(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_TRIGGER_DOCK_TITLE), "Trigger Setting..."), this);
        _dso_trigger_dock->setObjectName("dso_trigger_dock");
        _dso_trigger_dock->setFeatures(QDockWidget::DockWidgetMovable);
        _dso_trigger_dock->setAllowedAreas(Qt::RightDockWidgetArea);
        _dso_trigger_dock->setVisible(false);
        _dso_trigger_widget = new dock::DsoTriggerDock(_dso_trigger_dock, _session);
        _dso_trigger_dock->setWidget(_dso_trigger_widget);

        // Setup _view widget
        _view = new dsv::view::View(_session, _sampling_bar, this);
        _vertical_layout->addWidget(_view);

        setIconSize(QSize(40, 40));
        addToolBar(_sampling_bar);
        addToolBar(_trig_bar);
        addToolBar(_file_bar);
        addToolBar(_logo_bar);

        AppControl::Instance()->add_font_form(_sampling_bar);
        AppControl::Instance()->add_font_form(_trig_bar);
        AppControl::Instance()->add_font_form(_file_bar);
        AppControl::Instance()->add_font_form(_logo_bar);

        // Setup the dockWidget
        _protocol_dock = new QDockWidget(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_PROTOCOL_DOCK_TITLE), "Decode Protocol"), this);
        _protocol_dock->setObjectName("protocol_dock");
        _protocol_dock->setFeatures(QDockWidget::DockWidgetMovable);
        _protocol_dock->setAllowedAreas(Qt::RightDockWidgetArea);
        _protocol_dock->setVisible(false);
        _protocol_widget = new dock::ProtocolDock(_protocol_dock, *_view, _session);
        _protocol_dock->setWidget(_protocol_widget);

        _session->set_decoder_pannel(_protocol_widget);

        // measure dock
        _measure_dock = new QDockWidget(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_MEASURE_DOCK_TITLE), "Measurement"), this);
        _measure_dock->setObjectName("measure_dock");
        _measure_dock->setFeatures(QDockWidget::DockWidgetMovable);
        _measure_dock->setAllowedAreas(Qt::RightDockWidgetArea);
        _measure_dock->setVisible(false);
        _measure_widget = new dock::MeasureDock(_measure_dock, *_view, _session);
        _measure_dock->setWidget(_measure_widget);

        // search dock
        _search_dock = new QDockWidget(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SEARCH_DOCK_TITLE), "Search..."), this);
        _search_dock->setObjectName("search_dock");
        _search_dock->setFeatures(QDockWidget::NoDockWidgetFeatures);
        _search_dock->setTitleBarWidget(new QWidget(_search_dock));
        _search_dock->setAllowedAreas(Qt::BottomDockWidgetArea);
        _search_dock->setVisible(false);

        _search_widget = new dock::SearchDock(_search_dock, *_view, _session);
        _search_dock->setWidget(_search_widget);

        addDockWidget(Qt::RightDockWidgetArea, _protocol_dock);
        addDockWidget(Qt::RightDockWidgetArea, _trigger_dock);
        addDockWidget(Qt::RightDockWidgetArea, _dso_trigger_dock);
        addDockWidget(Qt::RightDockWidgetArea, _measure_dock);
        addDockWidget(Qt::BottomDockWidgetArea, _search_dock);

        // event filter
        _view->installEventFilter(this);
        _sampling_bar->installEventFilter(this);
        _trig_bar->installEventFilter(this);
        _file_bar->installEventFilter(this);
        _logo_bar->installEventFilter(this);
        _dso_trigger_dock->installEventFilter(this);
        _trigger_dock->installEventFilter(this);
        _protocol_dock->installEventFilter(this);
        _measure_dock->installEventFilter(this);
        _search_dock->installEventFilter(this);

        // defaut language
        AppConfig &app = AppConfig::Instance();
        switchLanguage(app.frameOptions.language);
        switchTheme(app.frameOptions.style);

        retranslateUi();

        _sampling_bar->set_view(_view);

        // Add the font form
        AppControl::Instance()->add_font_form(_protocol_widget);
        AppControl::Instance()->add_font_form(_dso_trigger_widget);
        AppControl::Instance()->add_font_form(_measure_widget);
        AppControl::Instance()->add_font_form(_search_widget);
        AppControl::Instance()->add_font_form(_trigger_widget);
        AppControl::Instance()->add_font_form(_view->get_time_view());
        AppControl::Instance()->add_font_form(_view);

        // event
        connect(&_event, SIGNAL(session_error()), this, SLOT(on_session_error()));
        connect(&_event, SIGNAL(signals_changed()), this, SLOT(on_signals_changed()));
        connect(&_event, SIGNAL(receive_trigger(quint64)), this, SLOT(on_receive_trigger(quint64)));
        connect(&_event, SIGNAL(frame_ended()), this, SLOT(on_frame_ended()), Qt::DirectConnection);
        connect(&_event, SIGNAL(frame_began()), this, SLOT(on_frame_began()), Qt::DirectConnection);
        connect(&_event, SIGNAL(decode_done()), this, SLOT(on_decode_done()));
        connect(&_event, SIGNAL(data_updated()), this, SLOT(on_data_updated()));
        connect(&_event, SIGNAL(cur_snap_samplerate_changed()), this, SLOT(on_cur_snap_samplerate_changed()));
        connect(&_event, SIGNAL(receive_data_len(quint64)), this, SLOT(on_receive_data_len(quint64)));
        connect(&_event, SIGNAL(trigger_message(int)), this, SLOT(on_trigger_message(int)));

        // view
        connect(_view, SIGNAL(cursor_update()), _measure_widget, SLOT(cursor_update()));
        connect(_view, SIGNAL(cursor_moving()), _measure_widget, SLOT(cursor_moving()));
        connect(_view, SIGNAL(cursor_moved()), _measure_widget, SLOT(reCalc()));
        connect(_view, SIGNAL(prgRate(int)), this, SIGNAL(prgRate(int)));
        connect(_view, SIGNAL(auto_trig(int)), _dso_trigger_widget, SLOT(auto_trig(int)));

        // trig_bar
        connect(_trig_bar, SIGNAL(sig_protocol(bool)), this, SLOT(on_protocol(bool)));
        connect(_trig_bar, SIGNAL(sig_trigger(bool)), this, SLOT(on_trigger(bool)));
        connect(_trig_bar, SIGNAL(sig_measure(bool)), this, SLOT(on_measure(bool)));
        connect(_trig_bar, SIGNAL(sig_search(bool)), this, SLOT(on_search(bool)));
        connect(_trig_bar, SIGNAL(sig_setTheme(QString)), this, SLOT(switchTheme(QString)));
        connect(_trig_bar, SIGNAL(sig_show_lissajous(bool)), _view, SLOT(show_lissajous(bool)));

        // file toolbar
        connect(_file_bar, SIGNAL(sig_load_file(QString)), this, SLOT(on_load_file(QString)));
        connect(_file_bar, SIGNAL(sig_save()), this, SLOT(on_save()));
        connect(_file_bar, SIGNAL(sig_export()), this, SLOT(on_export()));
        connect(_file_bar, SIGNAL(sig_screenShot()), this, SLOT(on_screenShot()), Qt::QueuedConnection);
        connect(_file_bar, SIGNAL(sig_load_session(QString)), this, SLOT(on_load_session(QString)));
        connect(_file_bar, SIGNAL(sig_store_session(QString)), this, SLOT(on_store_session(QString)));

        // logobar
        connect(_logo_bar, SIGNAL(sig_open_doc()), this, SLOT(on_open_doc()));

        connect(_protocol_widget, SIGNAL(protocol_updated()), this, SLOT(on_signals_changed()));

        // SamplingBar
        connect(_sampling_bar, SIGNAL(sig_store_session_data()), this, SLOT(on_save()));

        //
        connect(_dso_trigger_widget, SIGNAL(set_trig_pos(int)), _view, SLOT(set_trig_pos(int)));

        _delay_prop_msg_timer.SetCallback(std::bind(&MainWindow::on_delay_prop_msg, this));

        _logo_bar->set_mainform_callback(this);

        // Try load from file.
        QString ldFileName(AppControl::Instance()->_open_file_name.c_str());
        if (ldFileName != "")
        {   
            std::string file_name = dsv::path::ToUnicodePath(ldFileName);

            if (QFile::exists(ldFileName))
            {              
                dsv_info("Auto load file:%s", file_name.c_str());
                on_load_file(ldFileName);
            }
            else
            {
                dsv_err("file is not exists:%s", file_name.c_str());
                MsgBox::Show(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_OPEN_FILE_ERROR), "Open file error!"), ldFileName, NULL);
            }
        }
        else
        {
            _session->set_default_device();
        }
    }

    //*
    void MainWindow::retranslateUi()
    {
        _trigger_dock->setWindowTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_TRIGGER_DOCK_TITLE), "Trigger Setting..."));
        _dso_trigger_dock->setWindowTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_TRIGGER_DOCK_TITLE), "Trigger Setting..."));
        _protocol_dock->setWindowTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_PROTOCOL_DOCK_TITLE), "Decode Protocol"));
        _measure_dock->setWindowTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_MEASURE_DOCK_TITLE), "Measurement"));
        _search_dock->setWindowTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SEARCH_DOCK_TITLE), "Search..."));
        _view->get_time_view()->update_lang();
    }

    void MainWindow::on_load_file(QString file_name)
    {
        try
        {
            if (_device_agent->is_hardware()){
                save_config();
            }

            _session->set_file(file_name);
        }
        catch (QString e)
        {   
            QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_FAIL_TO_LOAD), "Failed to load "));
            strMsg += file_name;
            MsgBox::Show(strMsg);
            _session->set_default_device();
        }
    }

    void MainWindow::session_error()
    {
        _event.session_error();
    }

    void MainWindow::session_save()
    {
        save_config();
    }

    void MainWindow::on_session_error()
    {
        QString title;
        QString details;
        QString ch_status = "";

        switch (_session->get_error())
        {
        case SigSession::Hw_err:
            dsv_info("MainWindow::on_session_error(),Hw_err, stop capture");
            _session->stop_capture();
            title = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_HARDWARE_ERROR), "Hardware Operation Failed");
            details = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_HARDWARE_ERROR_DET), 
                      "Please replug device to refresh hardware configuration!");
            break;
        case SigSession::Malloc_err:
            dsv_info("MainWindow::on_session_error(),Malloc_err, stop capture");
            _session->stop_capture();
            title = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_MALLOC_ERROR), "Malloc Error");
            details = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_MALLOC_ERROR_DET), 
                      "Memory is not enough for this sample!\nPlease reduce the sample depth!");
            break;
        case SigSession::Pkt_data_err:
            title = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_PACKET_ERROR), "Packet Error");
            details = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_PACKET_ERROR_DET), 
            "the content of received packet are not expected!");
            _session->refresh(0);
            break;
        case SigSession::Data_overflow:
            dsv_info("MainWindow::on_session_error(),Data_overflow, stop capture");
            _session->stop_capture();
            title = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_DATA_OVERFLOW), "Data Overflow");
            details = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_DATA_OVERFLOW_DET), 
                      "USB bandwidth can not support current sample rate! \nPlease reduce the sample rate!");
            break;
        default:
            title = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_UNDEFINED_ERROR), "Undefined Error");
            details = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_UNDEFINED_ERROR_DET), "Not expected error!");
            break;
        }

        dsv::dialogs::DSMessageBox msg(this, title);
        msg.mBox()->setText(details);
        msg.mBox()->setStandardButtons(QMessageBox::Ok);
        msg.mBox()->setIcon(QMessageBox::Warning);
        connect(_session->device_event_object(), SIGNAL(device_updated()), &msg, SLOT(accept()));
        _msg = &msg;
        msg.exec();
        _msg = NULL;

        _session->clear_error();
    }

    void MainWindow::save_config()
    { 
        if (_device_agent->have_instance() == false)
        {
            dsv_info("There is no need to save the configuration");
            return;
        }

        AppConfig &app = AppConfig::Instance();        

        if (_device_agent->is_hardware()){
            QString sessionFile = gen_config_file_path(true);
            save_config_to_file(sessionFile);
        }

        app.frameOptions.windowState = saveState();
        app.SaveFrame();
    }

    QString MainWindow::gen_config_file_path(bool isNewFormat)
    { 
        AppConfig &app = AppConfig::Instance();

        QString file = AppConfig::GetProfileDir();
        QDir dir(file);
        if (dir.exists() == false){
            dir.mkpath(file);
        } 

        QString driver_name = _device_agent->driver_name();
        QString mode_name = QString::number(_device_agent->get_work_mode()); 
        QString lang_name;
        QString base_path = dir.absolutePath() + "/" + driver_name + mode_name;

        if (!isNewFormat){
            lang_name = QString::number(app.frameOptions.language);           
        }

        return base_path + ".ses" + lang_name + ".dsc";
    }

    bool MainWindow::able_to_close()
    {
        if (_device_agent->is_hardware() && _session->have_hardware_data() == false){
            _sampling_bar->commit_settings();
        }
        // not used, refer to closeEvent of mainFrame
        save_config();
        
        if (confirm_to_store_data()){
            on_save();
            return false; 
        } 
        return true;
    }

    void MainWindow::on_protocol(bool visible)
    {
        _protocol_dock->setVisible(visible);

        if (!visible)
            _view->setFocus();
    }

    void MainWindow::on_trigger(bool visible)
    {
        if (_device_agent->get_work_mode() != DSO)
        {
            _trigger_widget->update_view();
            _trigger_dock->setVisible(visible);
            _dso_trigger_dock->setVisible(false);
        }
        else
        {
            _dso_trigger_widget->update_view();
            _trigger_dock->setVisible(false);
            _dso_trigger_dock->setVisible(visible);
        }

        if (!visible)
            _view->setFocus();
    }

    void MainWindow::on_measure(bool visible)
    {
        _measure_dock->setVisible(visible);

        if (!visible)
            _view->setFocus();
    }

    void MainWindow::on_search(bool visible)
    {
        _search_dock->setVisible(visible);
        _view->show_search_cursor(visible);

        if (!visible)
            _view->setFocus();
    }

    void MainWindow::on_screenShot()
    {
        AppConfig &app = AppConfig::Instance();
        QString default_name = app.userHistory.screenShotPath + "/" + APP_NAME + QDateTime::currentDateTime().toString("-yyMMdd-hhmmss");

        int x = parentWidget()->pos().x();
        int y = parentWidget()->pos().y();
        int w = parentWidget()->frameGeometry().width();
        int h = parentWidget()->frameGeometry().height();

        (void)h;
        (void)w;
        (void)x;
        (void)y;

#ifdef _WIN32 
    #if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
        QPixmap pixmap = QGuiApplication::primaryScreen()->grabWindow(QApplication::desktop->winId(), x, y, w, h);
    #else
        QPixmap pixmap = QPixmap::grabWidget(parentWidget());
    #endif
#elif __APPLE__ 
        x += MainFrame::Margin;
        y += MainFrame::Margin;
        w -= MainFrame::Margin * 2;
        h -= MainFrame::Margin * 2;

    #if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
        QPixmap pixmap = QGuiApplication::primaryScreen()->grabWindow(winId(), x, y, w, h);
    #else
        QDesktopWidget *desktop = QApplication::desktop();
        int curMonitor = desktop->screenNumber(this);
        QPixmap pixmap = QGuiApplication::screens().at(curMonitor)->grabWindow(winId(), x, y, w, h);
    #endif       
#else       
        QPixmap pixmap = QGuiApplication::primaryScreen()->grabWindow(winId());
#endif

        QString format = "png";
        QString fileName = QFileDialog::getSaveFileName(
            this,
            L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SAVE_AS), "Save As"),
            default_name,
            "png file(*.png);;jpeg file(*.jpeg)",
            &format);

        if (!fileName.isEmpty())
        {
            QStringList list = format.split('.').last().split(')');
            QString suffix = list.first();

            QFileInfo f(fileName);
            if (f.suffix().compare(suffix))
            {
                //tr
                fileName += "." + suffix;
            }

            pixmap.save(fileName, suffix.toLatin1());

            fileName = path::GetDirectoryName(fileName);

            if (app.userHistory.screenShotPath != fileName)
            {
                app.userHistory.screenShotPath = fileName;
                app.SaveHistory();
            }
        }
    }

    // save file
    void MainWindow::on_save()
    {
        using dsv::dialogs::StoreProgress;

        if (_device_agent->have_instance() == false)
        {
            dsv_info("Have no device, can't to save data.");
            return;
        }

        if (_session->is_working()){
            dsv_info("Save data: stop the current device."); 
            _session->stop_capture();
        }

        _session->set_saving(true);

        StoreProgress *dlg = new StoreProgress(_session, this);
        dlg->save_run(this);
    }

    void MainWindow::on_export()
    {
        using dsv::dialogs::StoreProgress;

        if (_session->is_working()){
            dsv_info("Export data: stop the current device."); 
            _session->stop_capture();
        }

        StoreProgress *dlg = new StoreProgress(_session, this);
        dlg->export_run();
    }

    bool MainWindow::on_load_session(QString name)
    {
        return load_config_from_file(name);
    }

    bool MainWindow::load_config_from_file(QString file)
    {
        if (file == ""){
            dsv_err("File name is empty.");
            assert(false);
        }

        _protocol_widget->del_all_protocol();

        std::string file_name = dsv::path::ToUnicodePath(file);
        dsv_info("Load device profile: \"%s\"", file_name.c_str());
        
        QFile sf(file);

        if (!sf.exists()){ 
            dsv_warn("Warning: device profile is not exists: \"%s\"", file_name.c_str());
            return false;
        }

        if (!sf.open(QIODevice::ReadOnly))
        {
            dsv_warn("Warning: Couldn't open device profile to load!");
            return false;
        }

        QString data = QString::fromUtf8(sf.readAll());
        QJsonDocument doc = QJsonDocument::fromJson(data.toUtf8());
        sf.close();

        bool bDecoder = false;
        int ret = load_config_from_json(doc, bDecoder);

        if (ret && _device_agent->get_work_mode() == DSO)
        {
            _dso_trigger_widget->update_view();
        }

        if (_device_agent->is_hardware()){
            _title_ext_string = file;
            update_title_bar_text();
        }

        return ret;
    }

    bool MainWindow::gen_config_json(QJsonObject &sessionVar)
    {
        AppConfig &app = AppConfig::Instance();

        GVariant *gvar_opts;
        GVariant *gvar;
        gsize num_opts;

        QString title = QApplication::applicationName() + " v" + QApplication::applicationVersion();

        QJsonArray channelVar;
        sessionVar["Version"] = QJsonValue::fromVariant(SESSION_FORMAT_VERSION);
        sessionVar["Device"] = QJsonValue::fromVariant(_device_agent->driver_name());
        sessionVar["DeviceMode"] = QJsonValue::fromVariant(_device_agent->get_work_mode());
        sessionVar["Language"] = QJsonValue::fromVariant(app.frameOptions.language);
        sessionVar["Title"] = QJsonValue::fromVariant(title);

        if (_device_agent->is_hardware() && _device_agent->get_work_mode() == LOGIC)
        {
            sessionVar["CollectMode"] = _session->get_collect_mode();
        }

        gvar_opts = _device_agent->get_config_list(NULL, SR_CONF_DEVICE_SESSIONS);
        if (gvar_opts == NULL)
        {
            dsv_warn("Device config list is empty. id:SR_CONF_DEVICE_SESSIONS");
            /* Driver supports no device instance sessions. */
            return false;
        }

        const int *const options = (const int32_t *)g_variant_get_fixed_array(
                                        gvar_opts, &num_opts, sizeof(int32_t));

        for (unsigned int i = 0; i < num_opts; i++)
        {
            const struct sr_config_info *const info = _device_agent->get_config_info(options[i]);
            gvar = _device_agent->get_config(info->key);
            if (gvar != NULL)
            {
                if (info->datatype == SR_T_BOOL)
                    sessionVar[info->name] = QJsonValue::fromVariant(g_variant_get_boolean(gvar));
                else if (info->datatype == SR_T_UINT64)
                    sessionVar[info->name] = QJsonValue::fromVariant(QString::number(g_variant_get_uint64(gvar)));
                else if (info->datatype == SR_T_UINT8)
                    sessionVar[info->name] = QJsonValue::fromVariant(g_variant_get_byte(gvar));
                 else if (info->datatype == SR_T_INT16)
                    sessionVar[info->name] = QJsonValue::fromVariant(g_variant_get_int16(gvar));
                else if (info->datatype == SR_T_FLOAT) //save as string format
                    sessionVar[info->name] = QJsonValue::fromVariant(QString::number(g_variant_get_double(gvar)));
                else if (info->datatype == SR_T_CHAR)
                    sessionVar[info->name] = QJsonValue::fromVariant(g_variant_get_string(gvar, NULL));
                else if (info->datatype == SR_T_LIST)
                    sessionVar[info->name] =  QJsonValue::fromVariant(g_variant_get_int16(gvar));
                else{
                    dsv_err("Unkown config info type:%d", info->datatype);
                    assert(false);
                }
                g_variant_unref(gvar);                
            }
        }

        for (auto s : _session->get_signals())
        {
            QJsonObject s_obj;
            s_obj["index"] = s->get_index();
            s_obj["view_index"] = s->get_view_index();
            s_obj["type"] = s->get_type();
            s_obj["enabled"] = s->enabled();
            s_obj["name"] = s->get_name();

            if (s->get_colour().isValid())
                s_obj["colour"] = QJsonValue::fromVariant(s->get_colour());
            else
                s_obj["colour"] = QJsonValue::fromVariant("default");

            view::LogicSignal *logicSig = NULL;
            if ((logicSig = dynamic_cast<view::LogicSignal *>(s)))
            {
                s_obj["strigger"] = logicSig->get_trig();
            }
            
            if (s->signal_type() == SR_CHANNEL_DSO)
            {
                view::DsoSignal *dsoSig = (view::DsoSignal*)s;
                s_obj["vdiv"] = QJsonValue::fromVariant(static_cast<qulonglong>(dsoSig->get_vDialValue()));
                s_obj["vfactor"] = QJsonValue::fromVariant(static_cast<qulonglong>(dsoSig->get_factor()));
                s_obj["coupling"] = dsoSig->get_acCoupling();
                s_obj["trigValue"] = dsoSig->get_trig_vrate();
                s_obj["zeroPos"] = dsoSig->get_zero_ratio();
            }
 
            if (s->signal_type() == SR_CHANNEL_ANALOG)
            {
                view::AnalogSignal *analogSig = (view::AnalogSignal*)s;
                s_obj["vdiv"] = QJsonValue::fromVariant(static_cast<qulonglong>(analogSig->get_vdiv()));
                s_obj["vfactor"] = QJsonValue::fromVariant(static_cast<qulonglong>(analogSig->get_factor()));
                s_obj["coupling"] = analogSig->get_acCoupling();
                s_obj["zeroPos"] = analogSig->get_zero_ratio();
                s_obj["mapUnit"] = analogSig->get_mapUnit();
                s_obj["mapMin"] = analogSig->get_mapMin();
                s_obj["mapMax"] = analogSig->get_mapMax();
                s_obj["mapDefault"] = analogSig->get_mapDefault();
            }
            channelVar.append(s_obj);
        }
        sessionVar["channel"] = channelVar;

        if (_device_agent->get_work_mode() == LOGIC)
        {
            sessionVar["trigger"] = _trigger_widget->get_session();
        }

        StoreSession ss(_session);
        QJsonArray decodeJson;
        ss.gen_decoders_json(decodeJson);
        sessionVar["decoder"] = decodeJson;

        if (_device_agent->get_work_mode() == DSO)
        {
            sessionVar["measure"] = _view->get_viewstatus()->get_session();
        }

        if (gvar_opts != NULL)
            g_variant_unref(gvar_opts);

        return true;
    }

    bool MainWindow::load_config_from_json(QJsonDocument &doc, bool &haveDecoder)
    {
        haveDecoder = false;

        QJsonObject sessionObj = doc.object();

        int mode = _device_agent->get_work_mode();

        // check config file version
        if (!sessionObj.contains("Version"))
        {
            dsv_dbg("Profile version is not exists!");
            return false;
        }

        int format_ver = sessionObj["Version"].toInt();

        if (format_ver < 2)
        {
            dsv_err("Profile version is error!");
            return false;
        }

        if (sessionObj.contains("CollectMode") && _device_agent->is_hardware()){
            int collect_mode = sessionObj["CollectMode"].toInt();
            _session->set_collect_mode((DEVICE_COLLECT_MODE)collect_mode);
        }

        int conf_dev_mode = sessionObj["DeviceMode"].toInt();

        if (_device_agent->is_hardware())
        {
            QString driverName = _device_agent->driver_name();
            QString sessionDevice = sessionObj["Device"].toString();            
            // check device and mode
            if (driverName != sessionDevice || mode != conf_dev_mode)
            {
                MsgBox::Show(NULL, L_S(STR_PAGE_MSG, S_ID(IDS_MSG_PROFILE_NOT_COMPATIBLE), "Profile is not compatible with current device or mode!"), this);
                return false;
            }
        }

        // load device settings
        GVariant *gvar_opts = _device_agent->get_config_list(NULL, SR_CONF_DEVICE_SESSIONS);
        gsize num_opts;

        if (gvar_opts != NULL)
        {
            const int *const options = (const int32_t *)g_variant_get_fixed_array(
                gvar_opts, &num_opts, sizeof(int32_t));

            for (unsigned int i = 0; i < num_opts; i++)
            {
                const struct sr_config_info *info = _device_agent->get_config_info(options[i]);

                if (!sessionObj.contains(info->name))
                    continue;

                GVariant *gvar = NULL;
                int id = 0;

                if (info->datatype == SR_T_BOOL){
                    gvar = g_variant_new_boolean(sessionObj[info->name].toInt());
                }
                else if (info->datatype == SR_T_UINT64){
                    //from string text.
                    gvar = g_variant_new_uint64(sessionObj[info->name].toString().toULongLong());         
                }
                else if (info->datatype == SR_T_UINT8){
                    if (sessionObj[info->name].toString() != "")
                        gvar = g_variant_new_byte(sessionObj[info->name].toString().toUInt());
                    else
                        gvar = g_variant_new_byte(sessionObj[info->name].toInt());                       
                }
                else if (info->datatype == SR_T_INT16){
                    gvar = g_variant_new_int16(sessionObj[info->name].toInt());
                }
                else if (info->datatype == SR_T_FLOAT){
                    if (sessionObj[info->name].toString() != "")
                        gvar = g_variant_new_double(sessionObj[info->name].toString().toDouble());
                    else
                        gvar = g_variant_new_double(sessionObj[info->name].toDouble()); 
                }
                else if (info->datatype == SR_T_CHAR){
                    gvar = g_variant_new_string(sessionObj[info->name].toString().toLocal8Bit().data());
                }
                else if (info->datatype == SR_T_LIST)
                { 
                    id = 0;

                    if (format_ver > 2){
                        // Is new version format.
                        id = sessionObj[info->name].toInt();
                    }
                    else{
                        const char *fd_key = sessionObj[info->name].toString().toLocal8Bit().data();
                        id = ds_dsl_option_value_to_code(conf_dev_mode, info->key, fd_key);
                        if (id == -1){
                            dsv_err("Convert failed, key:\"%s\", value:\"%s\""
                                ,info->name, fd_key);
                            id = 0; //set default value.
                        }
                        else{
                            dsv_info("Convert success, key:\"%s\", value:\"%s\", get code:%d"
                                ,info->name, fd_key, id);
                        }
                    }            
                    gvar = g_variant_new_int16(id);
                }

                if (gvar == NULL)
                {
                    dsv_warn("Warning: Profile failed to parse key:'%s'", info->name);
                    continue;
                }

                bool bFlag = _device_agent->set_config(info->key, gvar);
                if (!bFlag){
                    dsv_err("Set device config option failed, id:%d, code:%d", info->key, id);
                }   
            }
        }

        // load channel settings
        if (mode == DSO)
        {
            for (const GSList *l = _device_agent->get_channels(); l; l = l->next)
            {
                sr_channel *const probe = (sr_channel *)l->data;
                assert(probe);

                for (const QJsonValue &value : sessionObj["channel"].toArray())
                {
                    QJsonObject obj = value.toObject();
                    if (QString(probe->name) == obj["name"].toString() &&
                        probe->type == obj["type"].toDouble())
                    {
                        probe->vdiv = obj["vdiv"].toDouble();
                        probe->coupling = obj["coupling"].toDouble();
                        probe->vfactor = obj["vfactor"].toDouble();
                        probe->trig_value = obj["trigValue"].toDouble();
                        probe->map_unit = g_strdup(obj["mapUnit"].toString().toStdString().c_str());
                        probe->map_min = obj["mapMin"].toDouble();
                        probe->map_max = obj["mapMax"].toDouble();
                        probe->enabled = obj["enabled"].toBool();
                        break;
                    }
                }
            }
        }
        else
        {
            for (const GSList *l = _device_agent->get_channels(); l; l = l->next)
            {
                sr_channel *const probe = (sr_channel *)l->data;
                assert(probe);
                bool isEnabled = false;

                for (const QJsonValue &value : sessionObj["channel"].toArray())
                {
                    QJsonObject obj = value.toObject();

                    if ((probe->index == obj["index"].toInt()) &&
                        (probe->type == obj["type"].toInt()))
                    {
                        isEnabled = true;
                        QString chan_name = obj["name"].toString().trimmed();
                        if (chan_name == ""){
                            chan_name = QString::number(probe->index);
                        }
                        
                        probe->enabled = obj["enabled"].toBool();
                        probe->name = g_strdup(chan_name.toStdString().c_str());
                        probe->vdiv = obj["vdiv"].toDouble();
                        probe->coupling = obj["coupling"].toDouble();
                        probe->vfactor = obj["vfactor"].toDouble();
                        probe->trig_value = obj["trigValue"].toDouble();
                        probe->map_unit = g_strdup(obj["mapUnit"].toString().toStdString().c_str());
                        probe->map_min = obj["mapMin"].toDouble();
                        probe->map_max = obj["mapMax"].toDouble();

                        if (obj.contains("mapDefault"))
                        {
                            probe->map_default = obj["mapDefault"].toBool();
                        }

                        break;
                    }
                }
                if (!isEnabled)
                    probe->enabled = false;
            }
        }

        _session->reload();

        // load signal setting
        if (mode == DSO)
        {
            for (auto s : _session->get_signals())
            {
                for (const QJsonValue &value : sessionObj["channel"].toArray())
                {
                    QJsonObject obj = value.toObject();

                    if (s->get_name() ==  obj["name"].toString() &&
                        s->get_type() ==  obj["type"].toDouble())
                    {
                        s->set_colour(QColor(obj["colour"].toString()));
                       
                        if (s->signal_type() == SR_CHANNEL_DSO)
                        {   
                            view::DsoSignal *dsoSig = (view::DsoSignal*)s;
                            dsoSig->load_settings();
                            dsoSig->set_zero_ratio(obj["zeroPos"].toDouble());
                            dsoSig->set_trig_ratio(obj["trigValue"].toDouble());
                            dsoSig->commit_settings();
                        }
                        break;
                    }
                }
            }
        }
        else
        {
            for (auto s : _session->get_signals())
            {
                for (const QJsonValue &value : sessionObj["channel"].toArray())
                {
                    QJsonObject obj = value.toObject();
                    if ((s->get_index() == obj["index"].toInt()) &&
                        (s->get_type() == obj["type"].toInt()))
                    {
                        QString chan_name = obj["name"].toString().trimmed();
                        if (chan_name == ""){
                            chan_name = QString::number(s->get_index());
                        }

                        s->set_colour(QColor(obj["colour"].toString()));
                        s->set_name(chan_name);

                        view::LogicSignal *logicSig = NULL;
                        if ((logicSig = dynamic_cast<view::LogicSignal *>(s)))
                        {
                            logicSig->set_trig(obj["strigger"].toDouble());
                        }
 
                        if (s->signal_type() == SR_CHANNEL_DSO)
                        {
                            view::DsoSignal *dsoSig = (view::DsoSignal*)s;
                            dsoSig->load_settings();
                            dsoSig->set_zero_ratio(obj["zeroPos"].toDouble());
                            dsoSig->set_trig_ratio(obj["trigValue"].toDouble());
                            dsoSig->commit_settings();
                        }
 
                        if (s->signal_type() == SR_CHANNEL_ANALOG)
                        {   
                            view::AnalogSignal *analogSig = (view::AnalogSignal*)s;
                            analogSig->set_zero_ratio(obj["zeroPos"].toDouble());
                            analogSig->commit_settings();
                        }
                        
                        break;
                    }
                }
            }
        }

        // update UI settings
        _sampling_bar->update_sample_rate_list();
        _trigger_widget->device_updated();
        _view->header_updated();

        // load trigger settings
        if (sessionObj.contains("trigger"))
        {
            _trigger_widget->set_session(sessionObj["trigger"].toObject());
        }

        // load decoders
        if (sessionObj.contains("decoder"))
        {
            QJsonArray deArray = sessionObj["decoder"].toArray();
            if (deArray.empty() == false)
            {
                haveDecoder = true;
                StoreSession ss(_session);
                ss.load_decoders(_protocol_widget, deArray);
                _view->update_all_trace_postion();
            }
        }

        // load measure
        if (sessionObj.contains("measure"))
        {
            auto *bottom_bar = _view->get_viewstatus();
            bottom_bar->load_session(sessionObj["measure"].toArray(), format_ver);
        }

        if (gvar_opts != NULL)
            g_variant_unref(gvar_opts);

        load_channel_view_indexs(doc);

        return true;
    }

    void MainWindow::load_channel_view_indexs(QJsonDocument &doc)
    {
        QJsonObject sessionObj = doc.object();

        int mode = _device_agent->get_work_mode();
        if (mode != LOGIC)
            return;

        std::vector<int> view_indexs;

        for (const QJsonValue &value : sessionObj["channel"].toArray()){
            QJsonObject obj = value.toObject();

            if (obj.contains("view_index")){  
                view_indexs.push_back(obj["view_index"].toInt());
            }
        }

         if (view_indexs.size()){
            int i = 0;

            for (auto s : _session->get_signals()){
                s->set_view_index(view_indexs[i]);
                i++;
            }

            _view->update_all_trace_postion();
        }
    }
    
    bool MainWindow::on_store_session(QString name)
    {
        return save_config_to_file(name);
    }

    bool MainWindow::save_config_to_file(QString name)
    {
        if (name == ""){
            dsv_err("Session file name is empty.");
            assert(false);
        }

        std::string file_name = dsv::path::ToUnicodePath(name);
        dsv_info("Store session to file: \"%s\"", file_name.c_str());

        QFile sf(name);
        if (!sf.open(QIODevice::WriteOnly | QIODevice::Text))
        {
            dsv_warn("Warning: Couldn't open profile to write!");
            return false;
        }

        QTextStream outStream(&sf);
        encoding::set_utf8(outStream);

        QJsonObject sessionVar;
        if (!gen_config_json(sessionVar)){
            return false;
        }

        QJsonDocument sessionDoc(sessionVar);
        outStream << QString::fromUtf8(sessionDoc.toJson());
        sf.close();
        return true;
    }

    bool MainWindow::genSessionData(std::string &str)
    {
        QJsonObject sessionVar;
        if (!gen_config_json(sessionVar))
        {
            return false;
        }

        QJsonDocument sessionDoc(sessionVar);
        QString data = QString::fromUtf8(sessionDoc.toJson());
        str.append(data.toLocal8Bit().data());
        return true;
    }

    void MainWindow::restore_dock()
    { 
        // default dockwidget size
        AppConfig &app = AppConfig::Instance();
        QByteArray st = app.frameOptions.windowState;
        if (!st.isEmpty())
        {
            try
            {
                restoreState(st);
            }
            catch (...)
            {
                MsgBox::Show(NULL, L_S(STR_PAGE_MSG, S_ID(IDS_MSG_RESTORE_WINDOW_ERROR), "restore window status error!"));
            }
        }

        // Resotre the dock pannel.
        if (_device_agent->have_instance())
            _trig_bar->reload();
    }

    bool MainWindow::eventFilter(QObject *object, QEvent *event)
    {
        (void)object;
    
        if (event->type() == QEvent::KeyPress)
        {
            const auto &sigs = _session->get_signals();
            QKeyEvent *ke = (QKeyEvent *)event;
            
            int modifier = ke->modifiers();
            if(modifier & Qt::ControlModifier || 
               modifier & Qt::ShiftModifier || 
               modifier & Qt::AltModifier)
            {
                return true;
            }

            high_resolution_clock::time_point key_press_time = high_resolution_clock::now();
            milliseconds timeInterval = std::chrono::duration_cast<milliseconds>(key_press_time - _last_key_press_time);
            int64_t time_keep =  timeInterval.count();
            if (time_keep < 200){
                return true;
            }
            _last_key_press_time = key_press_time;           
            
            switch (ke->key())
            {
            case Qt::Key_S:
                _sampling_bar->run_or_stop();
                break;

            case Qt::Key_I:
                _sampling_bar->run_or_stop_instant();
                break;

            case Qt::Key_T:
                _trig_bar->trigger_clicked();
                break;

            case Qt::Key_D:
                _trig_bar->protocol_clicked();
                break;

            case Qt::Key_M:
                _trig_bar->measure_clicked();
                break;

            case Qt::Key_R:
                _trig_bar->search_clicked();
                break;

            case Qt::Key_O:
                _sampling_bar->config_device();
                break;

            case Qt::Key_PageUp:
                _view->set_scale_offset(_view->scale(),
                                        _view->offset() - _view->get_view_width());
                break;
            case Qt::Key_PageDown:
                _view->set_scale_offset(_view->scale(),
                                        _view->offset() + _view->get_view_width());

                break;

            case Qt::Key_Left:
                _view->zoom(1);
                break;

            case Qt::Key_Right:
                _view->zoom(-1);
                break;

            case Qt::Key_0:
                for (auto s : sigs)
                {
                    if (s->signal_type() == SR_CHANNEL_DSO)
                    {
                        view::DsoSignal *dsoSig = (view::DsoSignal*)s;
                        if (dsoSig->get_index() == 0)
                            dsoSig->set_vDialActive(!dsoSig->get_vDialActive());
                        else
                            dsoSig->set_vDialActive(false);
                    }
                }
                _view->setFocus();
                update();
                break;

            case Qt::Key_1:
                for (auto s : sigs)
                {
                    if (s->signal_type() == SR_CHANNEL_DSO)
                    {
                        view::DsoSignal *dsoSig = (view::DsoSignal*)s;
                        if (dsoSig->get_index() == 1)
                            dsoSig->set_vDialActive(!dsoSig->get_vDialActive());
                        else
                            dsoSig->set_vDialActive(false);
                    }
                }
                _view->setFocus();
                update();
                break;

            case Qt::Key_Up:
                for (auto s : sigs)
                {
                    if (s->signal_type() == SR_CHANNEL_DSO){
                        view::DsoSignal *dsoSig = (view::DsoSignal*)s;
                        if (dsoSig->get_vDialActive())
                        {
                            dsoSig->go_vDialNext(true);
                            update();
                            break;
                        }
                    }
                }
                break;

            case Qt::Key_Down:
                for (auto s : sigs)
                {
                    if (s->signal_type() == SR_CHANNEL_DSO){
                        view::DsoSignal *dsoSig = (view::DsoSignal*)s;
                        if (dsoSig->get_vDialActive())
                        {
                            dsoSig->go_vDialPre(true);
                            update();
                            break;
                        }
                    }
                }
                break;

            default:
                QWidget::keyPressEvent((QKeyEvent *)event);
            }
            return true;
        }
        return false;
    }

    void MainWindow::switchLanguage(int language)
    {
        if (language == 0)
            return;
        
        AppConfig &app = AppConfig::Instance();

        if (app.frameOptions.language != language && language > 0)
        {
            app.frameOptions.language = language;
            app.SaveFrame();
            LangResource::Instance()->Load(language);     
        }        

        if (language == LAN_CN)
        {
            _qtTrans.load(":/qt_" + QString::number(language));
            qApp->installTranslator(&_qtTrans);
            _myTrans.load(":/my_" + QString::number(language));
            qApp->installTranslator(&_myTrans);
            retranslateUi();
        }
        else if (language == LAN_EN)
        {
            qApp->removeTranslator(&_qtTrans);
            qApp->removeTranslator(&_myTrans);
            retranslateUi();
        }
        else
        {
            dsv_err("%s%d", "Unknown language code:", language);
        }
    }

    void MainWindow::switchTheme(QString style)
    {
        AppConfig &app = AppConfig::Instance();

        if (app.frameOptions.style != style)
        {
            app.frameOptions.style = style;
            app.SaveFrame();
        }

        QString qssRes = ":/" + style + ".qss";
        QFile qss(qssRes);
        qss.open(QFile::ReadOnly | QFile::Text);
        qApp->setStyleSheet(qss.readAll());
        qss.close();

        data_updated();
    }

    void MainWindow::data_updated()
    {
        _event.data_updated(); // safe call
    }

    void MainWindow::on_data_updated()
    {
        _measure_widget->reCalc();
        _view->data_updated();
    }

    void MainWindow::on_open_doc()
    {
        openDoc();
    }

    void MainWindow::openDoc()
    {
        QDir dir(AppConfig::GetAppDataDir());
        AppConfig &app = AppConfig::Instance();
        int lan = app.frameOptions.language;
        QDesktopServices::openUrl(
            QUrl("file:///" + dir.absolutePath() + "/ug" + QString::number(lan) + ".pdf"));
    }

    void MainWindow::update_capture()
    {
        _view->update_hori_res();
    }

    void MainWindow::cur_snap_samplerate_changed()
    {
        _event.cur_snap_samplerate_changed(); // safe call
    }

    void MainWindow::on_cur_snap_samplerate_changed()
    {
        _measure_widget->cursor_update();
    }

    /*------------------on event end-------*/

    void MainWindow::signals_changed()
    {
        _event.signals_changed(); // safe call
    }

    void MainWindow::on_signals_changed()
    {
        _view->signals_changed(NULL);
    }

    void MainWindow::receive_trigger(quint64 trigger_pos)
    {
        _event.receive_trigger(trigger_pos); // save call
    }

    void MainWindow::on_receive_trigger(quint64 trigger_pos)
    {
        _view->receive_trigger(trigger_pos);
    }

    void MainWindow::frame_ended()
    {
        _event.frame_ended(); // save call
    }

    void MainWindow::on_frame_ended()
    {
        _view->receive_end();
    }

    void MainWindow::frame_began()
    {
        _event.frame_began(); // save call
    }

    void MainWindow::on_frame_began()
    {
        _view->frame_began();
    }

    void MainWindow::show_region(uint64_t start, uint64_t end, bool keep)
    {
        _view->show_region(start, end, keep);
    }

    void MainWindow::show_wait_trigger()
    {
        _view->show_wait_trigger();
    }

    void MainWindow::repeat_hold(int percent)
    {
        (void)percent;
        _view->repeat_show();
    }

    void MainWindow::decode_done()
    {
        _event.decode_done(); // safe call
    }

    void MainWindow::on_decode_done()
    {
        _protocol_widget->update_model();
    }

    void MainWindow::receive_data_len(quint64 len)
    {
        _event.receive_data_len(len); // safe call
    }

    void MainWindow::on_receive_data_len(quint64 len)
    {
        _view->set_receive_len(len);
    }

    void MainWindow::receive_header()
    {
    }

    void MainWindow::check_usb_device_speed()
    {
        // USB device speed check
        if (_device_agent->is_hardware())
        {
            int usb_speed = LIBUSB_SPEED_HIGH;
            _device_agent->get_config_int32(SR_CONF_USB_SPEED, usb_speed);

            bool usb30_support = false;

            if (_device_agent->get_config_bool(SR_CONF_USB30_SUPPORT, usb30_support))
            {
                dsv_info("The device's USB module version: %d.0", usb30_support ? 3 : 2);

                int cable_ver = 1;
                if (usb_speed == LIBUSB_SPEED_HIGH)
                    cable_ver = 2;
                else if (usb_speed == LIBUSB_SPEED_SUPER)
                    cable_ver = 3;

                dsv_info("The cable's USB port version: %d.0", cable_ver);

                if (usb30_support && usb_speed == LIBUSB_SPEED_HIGH){
                    QString str_err(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CHECK_USB_SPEED_ERROR),
                        "Plug the device into a USB 2.0 port will seriously affect its performance.\nPlease replug it into a USB 3.0 port."));
                    delay_prop_msg(str_err);
                }
            }
        }
    }

    void MainWindow::trigger_message(int msg)
    {
        _event.trigger_message(msg);
    }

    void MainWindow::on_trigger_message(int msg)
    {
        _session->broadcast_msg(msg);
    }

    void MainWindow::reset_all_view()
    {
        _sampling_bar->reload();
        _view->status_clear();
        _view->reload();
        _view->set_device();
        _trigger_widget->update_view();
        _trigger_widget->device_updated();
        _trig_bar->reload(); 
        _dso_trigger_widget->update_view();
        _measure_widget->reload();

        if (_device_agent->get_work_mode() == ANALOG)
            _view->get_viewstatus()->setVisible(false);
        else
            _view->get_viewstatus()->setVisible(true);
    }

    bool MainWindow::confirm_to_store_data()
    {   
        bool ret = false;
        _is_save_confirm_msg = true;       

        if (_session->have_hardware_data() && _session->is_first_store_confirm())
        {   
            // Only popup one time.
            ret =  MsgBox::Confirm(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_SAVE_CAPDATE), "Save captured data?"));

            if (!ret && _is_auto_switch_device)
            {
                dsv_info("The data save confirm end, auto switch to the new device.");
                _is_auto_switch_device = false;

                if (_session->is_working())
                    _session->stop_capture();

                _session->set_default_device();
            }
        }

        _is_save_confirm_msg = false;
        return ret;
    }

    void MainWindow::check_config_file_version()
    {
        auto device_agent = _session->get_device();
        if (device_agent->is_file() && device_agent->is_new_device())
        {
            if (device_agent->get_work_mode() == LOGIC)
            {   
                int version = -1; 
                if (device_agent->get_config_int16(SR_CONF_FILE_VERSION, version))
                {
                    if (version == 1)
                    {
                        QString strMsg(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CHECK_SESSION_FILE_VERSION_ERROR), 
                        "Current loading file has an old format. \nThis will lead to a slow loading speed. \nPlease resave it after loaded."));
                        MsgBox::Show(strMsg);
                    }
                }
            }
        }
    }

    void MainWindow::load_device_config()
    {   
        _title_ext_string = "";        
        int mode = _device_agent->get_work_mode();
        QString file;

        if (_device_agent->is_hardware())
        { 
            QString ses_name = gen_config_file_path(true);

            bool bExist = false;

            QFile sf(ses_name);
            if (!sf.exists()){
                dsv_info("Try to load the low version profile.");
                ses_name =  gen_config_file_path(false);
            }
            else{
                bExist = true;
            }

            if (!bExist)
            {
                QFile sf2(ses_name);
                if (!sf2.exists()){
                    dsv_info("Try to load the default profile.");
                    ses_name = _file_bar->genDefaultSessionFile();
                }
            } 

            file =  ses_name;
        }
        else if (_device_agent->is_demo())
        {
            QDir dir(AppConfig::GetFirmwareDir());
            if (dir.exists())
            {
                QString ses_name = dir.absolutePath() + "/" 
                            + _device_agent->driver_name() + QString::number(mode) + ".dsc";

                QFile sf(ses_name);
                if (sf.exists()){
                    file = ses_name;
                }
            }
        }

        if (file != ""){
            bool ret = load_config_from_file(file);
            if (ret && _device_agent->is_hardware()){
                _title_ext_string = file;
            }
        }
    }

    QJsonDocument MainWindow::get_config_json_from_data_file(QString file, bool &bSucesss)
    {
        QJsonDocument sessionDoc;
        QJsonParseError error;
        bSucesss = false;

        if (file == ""){
            dsv_err("File name is empty.");
            assert(false);
        }

        auto f_name = dsv::path::ConvertPath(file);
        ZipReader rd(f_name.c_str());
        auto *data = rd.GetInnterFileData("session");

        if (data != NULL)
        {
            QByteArray raw_bytes = QByteArray::fromRawData(data->data(), data->size());
            QString jsonStr(raw_bytes.data());
            QByteArray qbs = jsonStr.toUtf8();
            sessionDoc = QJsonDocument::fromJson(qbs, &error);

            if (error.error != QJsonParseError::NoError)
            {
                QString estr = error.errorString();
                dsv_err("File::get_session(), parse json error:\"%s\"!", estr.toUtf8().data());
            }
            else{
                bSucesss = true;
            }

            rd.ReleaseInnerFileData(data);
        }

        return sessionDoc;
    }

    QJsonArray MainWindow::get_decoder_json_from_data_file(QString file, bool &bSucesss)
    {
        QJsonArray dec_array;
        QJsonParseError error;

        bSucesss = false;

        if (file == ""){
            dsv_err("File name is empty.");
            assert(false);
        }

        /* read "decoders" */
        auto f_name = path::ConvertPath(file);
        ZipReader rd(f_name.c_str());
        auto *data = rd.GetInnterFileData("decoders");

        if (data != NULL)
        {
            QByteArray raw_bytes = QByteArray::fromRawData(data->data(), data->size());
            QString jsonStr(raw_bytes.data());
            QByteArray qbs = jsonStr.toUtf8();
            QJsonDocument sessionDoc = QJsonDocument::fromJson(qbs, &error);

            if (error.error != QJsonParseError::NoError)
            {
                QString estr = error.errorString();
                dsv_err("MainWindow::get_decoder_json_from_file(), parse json error:\"%s\"!", estr.toUtf8().data());
            }
            else{
                bSucesss = true;
            }

            dec_array = sessionDoc.array();
            rd.ReleaseInnerFileData(data);
        }

        return dec_array;
    }

    void MainWindow::update_toolbar_view_status()
    {
        _sampling_bar->update_view_status();
        _file_bar->update_view_status();
        _trig_bar->update_view_status();
    }

    void MainWindow::OnMessage(int msg)
    {
        switch (msg)
        {
        case DSV_MSG_DEVICE_LIST_UPDATED:
            _sampling_bar->update_device_list();
            break;

        case DSV_MSG_START_COLLECT_WORK_PREV:
            if (_device_agent->get_work_mode() == LOGIC)
                _trigger_widget->try_commit_trigger();
            else if (_device_agent->get_work_mode() == DSO)
                _dso_trigger_widget->check_setting();

            _view->capture_init();
            _view->on_state_changed(false);
            break;

        case DSV_MSG_START_COLLECT_WORK:
            update_toolbar_view_status();
            _view->on_state_changed(false);
            _protocol_widget->update_view_status();
            break;
        
        case DSV_MSG_COLLECT_END: 
            prgRate(0);
            _view->repeat_unshow();
            _view->on_state_changed(true);
            _protocol_widget->update_view_status(); 
            break;

        case DSV_MSG_END_COLLECT_WORK:
            update_toolbar_view_status();           
            break;

        case DSV_MSG_CURRENT_DEVICE_CHANGE_PREV:
            if (_msg != NULL){
                _msg->close();
                _msg = NULL;
            }

            _protocol_widget->del_all_protocol();
            _view->reload();
            break;

        case DSV_MSG_CURRENT_DEVICE_CHANGED:
        {
            reset_all_view();
            load_device_config();
            update_title_bar_text();
            _sampling_bar->update_device_list();
            
            _logo_bar->dsl_connected(_session->get_device()->is_hardware());
            update_toolbar_view_status();
            _session->device_event_object()->device_updated();

            if (_device_agent->is_hardware())
            {
                _session->on_load_config_end();
            }                
            
            if (_device_agent->get_work_mode() == LOGIC && _device_agent->is_file() == false)
                _view->auto_set_max_scale();

            if (_device_agent->is_file())
            {
                check_config_file_version();

                bool bDoneDecoder = false;
                bool bLoadSuccess = false;
                QJsonDocument doc = get_config_json_from_data_file(_device_agent->path(), bLoadSuccess);

                if (bLoadSuccess){
                    load_config_from_json(doc, bDoneDecoder);
                }

                if (!bDoneDecoder && _device_agent->get_work_mode() == LOGIC)
                {                    
                    QJsonArray deArray = get_decoder_json_from_data_file(_device_agent->path(), bLoadSuccess);

                    if (bLoadSuccess){
                        StoreSession ss(_session);
                        ss.load_decoders(_protocol_widget, deArray);
                    }                    
                }

                _view->update_all_trace_postion();                
                _session->start_capture(true);
            }
            else if (_device_agent->is_demo())
            {
                if(_device_agent->get_work_mode() == LOGIC)
                {
                    _pattern_mode = _device_agent->get_demo_operation_mode();
                    _protocol_widget->del_all_protocol();
                    _view->auto_set_max_scale();

                    if(_pattern_mode != "random"){
                       load_demo_decoder_config(_pattern_mode);
                    }
                }
            }
      
            calc_min_height();

            if (_device_agent->is_hardware() && _device_agent->is_new_device()){
                check_usb_device_speed();
            }
        }
        break;

        case DSV_MSG_DEVICE_OPTIONS_UPDATED:
            _trigger_widget->device_updated();
            _measure_widget->reload();
            _view->check_calibration();                      
            break;

        case DSV_MSG_DEVICE_DURATION_UPDATED:
            _trigger_widget->device_updated();
            _view->timebase_changed();
            break;

        case DSV_MSG_DEVICE_MODE_CHANGED:
            _view->mode_changed(); 
            reset_all_view();
            load_device_config();
            update_title_bar_text();

            update_toolbar_view_status();
            _sampling_bar->update_sample_rate_list();

            if (_device_agent->is_hardware())
                _session->on_load_config_end();
            
            if (_device_agent->get_work_mode() == LOGIC)
                _view->auto_set_max_scale();

            if(_device_agent->is_demo())
            {
                _pattern_mode = _device_agent->get_demo_operation_mode();
                _protocol_widget->del_all_protocol();

                if(_device_agent->get_work_mode() == LOGIC)
                {
                    if(_pattern_mode != "random"){
                        _device_agent->update();
                        load_demo_decoder_config(_pattern_mode);
                    }
                }
            }

            calc_min_height();           
            break;

        case DSV_MSG_NEW_USB_DEVICE:
            {
                if (_msg != NULL){
                    _msg->close();
                    _msg = NULL;
                }

                _sampling_bar->update_device_list();

                if (_session->get_device()->is_demo() == false)
                {
                    QString msgText = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_TO_SWITCH_DEVICE), "To switch the new device?");
                    
                    if (MsgBox::Confirm(msgText, "", &_msg, NULL) == false){ 
                        _msg = NULL;
                        return;
                    }
                    _msg = NULL;
                }

                // The store confirm is not processed.
                if (_is_save_confirm_msg){
                    dsv_info("New device attached:Waitting for the confirm box be closed.");
                    _is_auto_switch_device = true; 
                    return;
                }

                if (_session->is_saving()){
                    dsv_info("New device attached:Waitting for store the data. and will switch to new device.");
                    _is_auto_switch_device = true;
                    return;
                }

                int mode = _device_agent->get_work_mode();

                if (mode != DSO && confirm_to_store_data())
                {
                    _is_auto_switch_device = true;

                    if (_session->is_working())
                        _session->stop_capture();

                    on_save();
                }
                else
                {   
                    if (_session->is_working())
                        _session->stop_capture();
                    
                    _session->set_default_device();
                }
            }           
            break;

        case DSV_MSG_CURRENT_DEVICE_DETACHED:
            if (_msg != NULL){
                _msg->close();
                _msg = NULL;
            }

            // Save current config, and switch to the last device.
            _session->device_event_object()->device_updated();
            save_config();
            _view->hide_calibration();

            if (_session->is_saving()){
                dsv_info("Device detached:Waitting for store the data. and will switch to new device.");
                _is_auto_switch_device = true;
                return;
            }

            if (confirm_to_store_data()){
                _is_auto_switch_device = true;
                on_save();
            }
            else{
                _session->set_default_device();
            }
            break;

        case DSV_MSG_SAVE_COMPLETE:
            _session->clear_store_confirm_flag();

            if (_is_auto_switch_device)
            {
                _is_auto_switch_device = false;
                _session->set_default_device();
            }
            else
            {
                ds_device_handle devh = _sampling_bar->get_next_device_handle();
                if (devh != NULL_HANDLE)
                {
                    dsv_info("Auto switch to the selected device.");
                    _session->set_device(devh);
                }
            }
            break;

        case DSV_MSG_CLEAR_DECODE_DATA:
            if (_device_agent->get_work_mode() == LOGIC)
                _protocol_widget->reset_view();
            break;
        
        case DSV_MSG_STORE_CONF_PREV:
            if (_device_agent->is_hardware() && _session->have_hardware_data() == false){
                _sampling_bar->commit_settings();
            }
            break;

        case DSV_MSG_BEGIN_DEVICE_OPTIONS:
        case DSV_MSG_COLLECT_MODE_CHANGED:
            if(_device_agent->is_demo()){
                _pattern_mode = _device_agent->get_demo_operation_mode();
            }
            if (msg == DSV_MSG_COLLECT_MODE_CHANGED){
                _trigger_widget->device_updated();
                _view->update();
            }           
            break;  

        case DSV_MSG_END_DEVICE_OPTIONS:
        case DSV_MSG_DEMO_OPERATION_MODE_CHNAGED:
            if(_device_agent->is_demo() &&_device_agent->get_work_mode() == LOGIC){                
                QString pattern_mode = _device_agent->get_demo_operation_mode();       
                
                if(pattern_mode != _pattern_mode)
                {
                    _pattern_mode = pattern_mode; 

                    _device_agent->update();
                    _session->clear_view_data();
                    _session->init_signals();
                    update_toolbar_view_status();
                    _sampling_bar->update_sample_rate_list();
                    _protocol_widget->del_all_protocol();
                        
                    if(_pattern_mode != "random"){
                        _session->set_collect_mode(COLLECT_SINGLE);
                        load_demo_decoder_config(_pattern_mode);

                        if (msg == DSV_MSG_END_DEVICE_OPTIONS)
                            _session->start_capture(false); // Auto load data.
                    }
                }                
            }
            calc_min_height();            
            break;

        case DSV_MSG_APP_OPTIONS_CHANGED:
            update_title_bar_text();
            break;

        case DSV_MSG_FONT_OPTIONS_CHANGED:
            AppControl::Instance()->update_font_forms(); 
            break;          
        }
    }

    void MainWindow::calc_min_height()
    {
        if (_frame != NULL)
        {
            if (_device_agent->get_work_mode() == LOGIC)
            {
                int ch_num = _session->get_ch_num(-1);
                int win_height = Base_Height + Per_Chan_Height * ch_num;

                if (win_height < Min_Height)
                    _frame->setMinimumHeight(win_height);
                else
                    _frame->setMinimumHeight(Min_Height);
            }
            else{
                _frame->setMinimumHeight(Min_Height);
            }
        }  
    }

    void MainWindow::delay_prop_msg(QString strMsg)
    {
        _strMsg = strMsg;
        if (_strMsg != ""){
            _delay_prop_msg_timer.Start(500);
        }
    }

    void MainWindow::on_delay_prop_msg()
    {
        _delay_prop_msg_timer.Stop();

        if (_strMsg != ""){
            MsgBox::Show("", _strMsg, this, &_msg);
            _msg = NULL;
        }            
    }

    void MainWindow::update_title_bar_text()
    {
          // Set the title
        QString title = QApplication::applicationName() + " v" + QApplication::applicationVersion();
        AppConfig &app = AppConfig::Instance();

        if (_title_ext_string != "" && app.appOptions.displayProfileInBar){
            title += " [" + _title_ext_string + "]";
        }

        if (_lst_title_string != title){
            _lst_title_string = title;

            setWindowTitle(QApplication::translate("MainWindow", title.toLocal8Bit().data(), 0));
            _title_bar->setTitle(this->windowTitle());
        }        
    }

    void MainWindow::load_demo_decoder_config(QString optname)
    { 
        QString file = AppConfig::GetAppDataDir() + "/demo/logic/" + optname + ".demo";
        bool bLoadSurccess = false;

        QJsonArray deArray = get_decoder_json_from_data_file(file, bLoadSurccess);

        if (bLoadSurccess){
            StoreSession ss(_session);
            ss.load_decoders(_protocol_widget, deArray);
        }

        QJsonDocument doc = get_config_json_from_data_file(file, bLoadSurccess);
        if (bLoadSurccess){
            load_channel_view_indexs(doc);
        }
        
        _view->update_all_trace_postion();
    }

} //namespace com
} //namespace appcore
/****************************************************************************
** Meta object code from reading C++ file 'mainwindow.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "mainwindow.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'mainwindow.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEMainWindowENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEMainWindowENDCLASS = QtMocHelpers::stringData(
    "dsv::appcore::MainWindow",
    "prgRate",
    "",
    "progress",
    "switchTheme",
    "style",
    "restore_dock",
    "on_load_file",
    "file_name",
    "on_open_doc",
    "on_protocol",
    "visible",
    "on_trigger",
    "on_measure",
    "on_search",
    "on_screenShot",
    "on_save",
    "on_export",
    "on_load_session",
    "name",
    "on_store_session",
    "on_data_updated",
    "on_session_error",
    "on_signals_changed",
    "on_receive_trigger",
    "trigger_pos",
    "on_frame_ended",
    "on_frame_began",
    "on_decode_done",
    "on_receive_data_len",
    "len",
    "on_cur_snap_samplerate_changed",
    "on_trigger_message",
    "msg",
    "on_delay_prop_msg"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEMainWindowENDCLASS_t {
    uint offsetsAndSizes[70];
    char stringdata0[25];
    char stringdata1[8];
    char stringdata2[1];
    char stringdata3[9];
    char stringdata4[12];
    char stringdata5[6];
    char stringdata6[13];
    char stringdata7[13];
    char stringdata8[10];
    char stringdata9[12];
    char stringdata10[12];
    char stringdata11[8];
    char stringdata12[11];
    char stringdata13[11];
    char stringdata14[10];
    char stringdata15[14];
    char stringdata16[8];
    char stringdata17[10];
    char stringdata18[16];
    char stringdata19[5];
    char stringdata20[17];
    char stringdata21[16];
    char stringdata22[17];
    char stringdata23[19];
    char stringdata24[19];
    char stringdata25[12];
    char stringdata26[15];
    char stringdata27[15];
    char stringdata28[15];
    char stringdata29[20];
    char stringdata30[4];
    char stringdata31[31];
    char stringdata32[19];
    char stringdata33[4];
    char stringdata34[18];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEMainWindowENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEMainWindowENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEMainWindowENDCLASS = {
    {
        QT_MOC_LITERAL(0, 24),  // "dsv::appcore::MainWindow"
        QT_MOC_LITERAL(25, 7),  // "prgRate"
        QT_MOC_LITERAL(33, 0),  // ""
        QT_MOC_LITERAL(34, 8),  // "progress"
        QT_MOC_LITERAL(43, 11),  // "switchTheme"
        QT_MOC_LITERAL(55, 5),  // "style"
        QT_MOC_LITERAL(61, 12),  // "restore_dock"
        QT_MOC_LITERAL(74, 12),  // "on_load_file"
        QT_MOC_LITERAL(87, 9),  // "file_name"
        QT_MOC_LITERAL(97, 11),  // "on_open_doc"
        QT_MOC_LITERAL(109, 11),  // "on_protocol"
        QT_MOC_LITERAL(121, 7),  // "visible"
        QT_MOC_LITERAL(129, 10),  // "on_trigger"
        QT_MOC_LITERAL(140, 10),  // "on_measure"
        QT_MOC_LITERAL(151, 9),  // "on_search"
        QT_MOC_LITERAL(161, 13),  // "on_screenShot"
        QT_MOC_LITERAL(175, 7),  // "on_save"
        QT_MOC_LITERAL(183, 9),  // "on_export"
        QT_MOC_LITERAL(193, 15),  // "on_load_session"
        QT_MOC_LITERAL(209, 4),  // "name"
        QT_MOC_LITERAL(214, 16),  // "on_store_session"
        QT_MOC_LITERAL(231, 15),  // "on_data_updated"
        QT_MOC_LITERAL(247, 16),  // "on_session_error"
        QT_MOC_LITERAL(264, 18),  // "on_signals_changed"
        QT_MOC_LITERAL(283, 18),  // "on_receive_trigger"
        QT_MOC_LITERAL(302, 11),  // "trigger_pos"
        QT_MOC_LITERAL(314, 14),  // "on_frame_ended"
        QT_MOC_LITERAL(329, 14),  // "on_frame_began"
        QT_MOC_LITERAL(344, 14),  // "on_decode_done"
        QT_MOC_LITERAL(359, 19),  // "on_receive_data_len"
        QT_MOC_LITERAL(379, 3),  // "len"
        QT_MOC_LITERAL(383, 30),  // "on_cur_snap_samplerate_changed"
        QT_MOC_LITERAL(414, 18),  // "on_trigger_message"
        QT_MOC_LITERAL(433, 3),  // "msg"
        QT_MOC_LITERAL(437, 17)   // "on_delay_prop_msg"
    },
    "dsv::appcore::MainWindow",
    "prgRate",
    "",
    "progress",
    "switchTheme",
    "style",
    "restore_dock",
    "on_load_file",
    "file_name",
    "on_open_doc",
    "on_protocol",
    "visible",
    "on_trigger",
    "on_measure",
    "on_search",
    "on_screenShot",
    "on_save",
    "on_export",
    "on_load_session",
    "name",
    "on_store_session",
    "on_data_updated",
    "on_session_error",
    "on_signals_changed",
    "on_receive_trigger",
    "trigger_pos",
    "on_frame_ended",
    "on_frame_began",
    "on_decode_done",
    "on_receive_data_len",
    "len",
    "on_cur_snap_samplerate_changed",
    "on_trigger_message",
    "msg",
    "on_delay_prop_msg"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEappcoreSCOPEMainWindowENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
      25,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,  164,    2, 0x06,    1 /* Public */,

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       4,    1,  167,    2, 0x0a,    3 /* Public */,
       6,    0,  170,    2, 0x0a,    5 /* Public */,
       7,    1,  171,    2, 0x08,    6 /* Private */,
       9,    0,  174,    2, 0x08,    8 /* Private */,
      10,    1,  175,    2, 0x08,    9 /* Private */,
      12,    1,  178,    2, 0x08,   11 /* Private */,
      13,    1,  181,    2, 0x08,   13 /* Private */,
      14,    1,  184,    2, 0x08,   15 /* Private */,
      15,    0,  187,    2, 0x08,   17 /* Private */,
      16,    0,  188,    2, 0x08,   18 /* Private */,
      17,    0,  189,    2, 0x08,   19 /* Private */,
      18,    1,  190,    2, 0x08,   20 /* Private */,
      20,    1,  193,    2, 0x08,   22 /* Private */,
      21,    0,  196,    2, 0x08,   24 /* Private */,
      22,    0,  197,    2, 0x08,   25 /* Private */,
      23,    0,  198,    2, 0x08,   26 /* Private */,
      24,    1,  199,    2, 0x08,   27 /* Private */,
      26,    0,  202,    2, 0x08,   29 /* Private */,
      27,    0,  203,    2, 0x08,   30 /* Private */,
      28,    0,  204,    2, 0x08,   31 /* Private */,
      29,    1,  205,    2, 0x08,   32 /* Private */,
      31,    0,  208,    2, 0x08,   34 /* Private */,
      32,    1,  209,    2, 0x08,   35 /* Private */,
      34,    0,  212,    2, 0x08,   37 /* Private */,

 // signals: parameters
    QMetaType::Void, QMetaType::Int,    3,

 // slots: parameters
    QMetaType::Void, QMetaType::QString,    5,
    QMetaType::Void,
    QMetaType::Void, QMetaType::QString,    8,
    QMetaType::Void,
    QMetaType::Void, QMetaType::Bool,   11,
    QMetaType::Void, QMetaType::Bool,   11,
    QMetaType::Void, QMetaType::Bool,   11,
    QMetaType::Void, QMetaType::Bool,   11,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Bool, QMetaType::QString,   19,
    QMetaType::Bool, QMetaType::QString,   19,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::ULongLong,   25,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::ULongLong,   30,
    QMetaType::Void,
    QMetaType::Void, QMetaType::Int,   33,
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::appcore::MainWindow::staticMetaObject = { {
    QMetaObject::SuperData::link<QMainWindow::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEMainWindowENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEappcoreSCOPEMainWindowENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEMainWindowENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<MainWindow, std::true_type>,
        // method 'prgRate'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'switchTheme'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QString, std::false_type>,
        // method 'restore_dock'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_load_file'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QString, std::false_type>,
        // method 'on_open_doc'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_protocol'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>,
        // method 'on_trigger'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>,
        // method 'on_measure'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>,
        // method 'on_search'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>,
        // method 'on_screenShot'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_save'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_export'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_load_session'
        QtPrivate::TypeAndForceComplete<bool, std::false_type>,
        QtPrivate::TypeAndForceComplete<QString, std::false_type>,
        // method 'on_store_session'
        QtPrivate::TypeAndForceComplete<bool, std::false_type>,
        QtPrivate::TypeAndForceComplete<QString, std::false_type>,
        // method 'on_data_updated'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_session_error'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_signals_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_receive_trigger'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<quint64, std::false_type>,
        // method 'on_frame_ended'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_frame_began'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_decode_done'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_receive_data_len'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<quint64, std::false_type>,
        // method 'on_cur_snap_samplerate_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_trigger_message'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'on_delay_prop_msg'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::appcore::MainWindow::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<MainWindow *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->prgRate((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 1: _t->switchTheme((*reinterpret_cast< std::add_pointer_t<QString>>(_a[1]))); break;
        case 2: _t->restore_dock(); break;
        case 3: _t->on_load_file((*reinterpret_cast< std::add_pointer_t<QString>>(_a[1]))); break;
        case 4: _t->on_open_doc(); break;
        case 5: _t->on_protocol((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        case 6: _t->on_trigger((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        case 7: _t->on_measure((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        case 8: _t->on_search((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        case 9: _t->on_screenShot(); break;
        case 10: _t->on_save(); break;
        case 11: _t->on_export(); break;
        case 12: { bool _r = _t->on_load_session((*reinterpret_cast< std::add_pointer_t<QString>>(_a[1])));
            if (_a[0]) *reinterpret_cast< bool*>(_a[0]) = std::move(_r); }  break;
        case 13: { bool _r = _t->on_store_session((*reinterpret_cast< std::add_pointer_t<QString>>(_a[1])));
            if (_a[0]) *reinterpret_cast< bool*>(_a[0]) = std::move(_r); }  break;
        case 14: _t->on_data_updated(); break;
        case 15: _t->on_session_error(); break;
        case 16: _t->on_signals_changed(); break;
        case 17: _t->on_receive_trigger((*reinterpret_cast< std::add_pointer_t<quint64>>(_a[1]))); break;
        case 18: _t->on_frame_ended(); break;
        case 19: _t->on_frame_began(); break;
        case 20: _t->on_decode_done(); break;
        case 21: _t->on_receive_data_len((*reinterpret_cast< std::add_pointer_t<quint64>>(_a[1]))); break;
        case 22: _t->on_cur_snap_samplerate_changed(); break;
        case 23: _t->on_trigger_message((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 24: _t->on_delay_prop_msg(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (MainWindow::*)(int );
            if (_t _q_method = &MainWindow::prgRate; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
    }
}

const QMetaObject *dsv::appcore::MainWindow::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::appcore::MainWindow::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEMainWindowENDCLASS.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "ISessionCallback"))
        return static_cast< ISessionCallback*>(this);
    if (!strcmp(_clname, "IMainForm"))
        return static_cast< IMainForm*>(this);
    if (!strcmp(_clname, "ISessionDataGetter"))
        return static_cast< ISessionDataGetter*>(this);
    if (!strcmp(_clname, "IMessageListener"))
        return static_cast< IMessageListener*>(this);
    return QMainWindow::qt_metacast(_clname);
}

int dsv::appcore::MainWindow::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QMainWindow::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 25)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 25;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 25)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 25;
    }
    return _id;
}

// SIGNAL 0
void dsv::appcore::MainWindow::prgRate(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_SIGSESSION_H
#define DSVIEW_PV_SIGSESSION_H
 
#include <set>
#include <string>
#include <vector>
#include <stdint.h> 
#include <QString>
#include <thread>
#include <QDateTime>
#include <list>
#include <libsigrok.h>
#include "../view/mathtrace.h"
#include "../data/mathstack.h"
#include "../interface/icallbacks.h"
#include "../com/dstimer.h"
#include "deviceagent.h"
#include "eventobject.h"
#include "../data/logicsnapshot.h"
#include "../data/analogsnapshot.h"
#include "../data/dsosnapshot.h"
 
struct srd_decoder;
struct srd_channel;

typedef std::lock_guard<std::mutex> ds_lock_guard;

namespace dsv {
namespace data {
    class SignalData;
    class Snapshot;
    class AnalogSnapshot;
    class DsoSnapshot;
    class LogicSnapshot;
    class DecoderModel;
    class MathStack;
}

namespace decode {
    class Decoder;
    class DecoderStatus;
}

namespace view {
    class Signal;
    class GroupSignal;
    class DecodeTrace;
    class SpectrumTrace;
    class LissajousTrace;
    class MathTrace;
}

namespace com{
    class DsTimer;
}
}

using namespace dsv::view;
using namespace dsv::com;
using namespace dsv::decode;
using namespace dsv::data;

namespace dsv {
namespace appcore {

enum DEVICE_STATUS_TYPE
{
    ST_INIT = 0,
    ST_RUNNING = 1,
    ST_STOPPED = 2,
};

enum DEVICE_COLLECT_MODE
{
    COLLECT_SINGLE = 0,
    COLLECT_REPEAT = 1, 
    COLLECT_LOOP = 2,
}; 

class SessionData
{
public:
    SessionData(); 

    inline data::LogicSnapshot* get_logic(){
        return &logic;
    }

    inline data::AnalogSnapshot* get_analog(){
        return &analog;
    }

    inline data::DsoSnapshot* get_dso(){
        return &dso;
    }

    void clear();

public:
    uint64_t       _cur_snap_samplerate;
    uint64_t       _cur_samplelimits;

private:
    data::LogicSnapshot   logic;
    data::AnalogSnapshot  analog;
    data::DsoSnapshot     dso;
};

//created by MainWindow
class SigSession:
    public IMessageListener,
    public IDeviceAgentCallback
{
private:
    static constexpr float Oversampling = 2.0f;

public:
    static const int RefreshTime = 500;
    static const int RepeatHoldDiv = 20;
    static const int FeedInterval = 50;
    static const int WaitShowTime = 500;

   enum SESSION_ERROR_STATUS {
        No_err,
        Hw_err,
        Malloc_err, 
        Test_timeout_err,
        Pkt_data_err,
        Data_overflow
    };

private:
    SigSession(SigSession &o);
  
public:
    explicit SigSession();

	~SigSession(); 

    inline DeviceAgent* get_device(){
        return &_device_agent;
    }

    inline void set_callback(ISessionCallback *callback){
        _callback = callback;
    }

    bool init();
    void uninit();
    void Open();
    void Close();
    
    bool set_default_device();
    bool set_device(ds_device_handle dev_handle);
    bool set_file(QString name);
    void close_file(ds_device_handle dev_handle);
    bool start_capture(bool instant);
    bool stop_capture();
    bool switch_work_mode(int mode);

    uint64_t cur_samplerate();
    uint64_t cur_snap_samplerate();
    uint64_t cur_samplelimits();
    double cur_sampletime();
    double cur_snap_sampletime();
    double cur_view_time();

    inline bool re_start(){
        if (_is_working)
            stop_capture();
        return start_capture(_is_instant);
    } 

    inline QDateTime get_session_time(){
        return _session_time;
    }

    inline QDateTime get_trig_time(){
        return _trig_time;
    }

    inline bool is_triged(){
        return _is_triged;
    }

    inline uint64_t get_trigger_pos(){
        return _trigger_pos;
    }

    bool is_first_store_confirm();
    bool get_capture_status(bool &triggered, int &progress);

    inline void clear_store_confirm_flag(){
        _confirm_store_time_id = _work_time_id;
    }

	std::vector<view::Signal*>& get_signals(); 

    bool add_decoder(srd_decoder *const dec, bool silent, DecoderStatus *dstatus, 
                        std::list<dsv::decode::Decoder*> &sub_decoders, view::Trace* &out_trace);
    int get_trace_index_by_key_handel(void *handel);
    void remove_decoder(int index);
    void remove_decoder_by_key_handel(void *handel); 

    inline std::vector<view::DecodeTrace*>& get_decode_signals(){
        return _decode_traces;
    }

    void rst_decoder(int index); 
    void rst_decoder_by_key_handel(void *handel);

    inline dsv::data::DecoderModel* get_decoder_model(){
         return _decoder_model;
    }

    inline std::vector<view::SpectrumTrace*>& get_spectrum_traces(){
        return _spectrum_traces;
    }

    inline view::LissajousTrace* get_lissajous_trace(){
        return _lissajous_trace;
    }

    inline view::MathTrace* get_math_trace(){
        return _math_trace;
    }
 
    uint16_t get_ch_num(int type); 
 
    inline bool is_data_lock(){
        return _data_lock;
    }

    void data_auto_lock(int lock);
    void data_auto_unlock();
    bool get_data_auto_lock();
    void spectrum_rebuild();
    void lissajous_rebuild(bool enable, int xindex, int yindex, double percent);
    void lissajous_disable();

    void math_rebuild(bool enable,dsv::view::DsoSignal *dsoSig1,
                      dsv::view::DsoSignal *dsoSig2,
                      data::MathStack::MathType type);

    inline bool trigd(){
        return _trigger_flag;
    }

    inline uint8_t trigd_ch(){
        return _trigger_ch;
    }

    data::Snapshot* get_snapshot(int type);

    inline SESSION_ERROR_STATUS get_error(){
        return _error;
    }

    inline void set_error(SESSION_ERROR_STATUS state){
        _error = state;
    }

    void clear_error();

    inline uint64_t get_error_pattern(){
        return _error_pattern;
    }

    inline double get_repeat_intvl(){
        return _repeat_intvl;    
    }

    inline void set_repeat_intvl(double interval){
        _repeat_intvl = interval;
    }
   
    int get_repeat_hold();

    inline void set_save_start(uint64_t start){
        _save_start = start;
    }

    inline uint64_t get_save_start(){
        return _save_start;
    }

    inline void set_save_end(uint64_t end){
        _save_end = end;
    }

    inline uint64_t get_save_end(){
        return _save_end;
    }

    void clear_all_decoder(bool bUpdateView = true); 

    inline bool is_closed(){
        return _bClose;
    }

    inline bool is_instant(){
        return _is_instant;
    }

    inline bool is_working(){
        return _is_working || _device_status == ST_RUNNING;
    }

    inline bool is_init_status(){
        return _device_status == ST_INIT;
    }

    // The collect thread is running.
    inline bool is_running_status(){
        return _device_status == ST_RUNNING;
    }

    inline bool is_stopped_status(){
        return _device_status == ST_STOPPED;
    }

    void set_collect_mode(DEVICE_COLLECT_MODE m);

    inline int get_collect_mode(){
        return (int)_clt_mode;
    }

    inline bool is_repeat_mode(){
        return _clt_mode == COLLECT_REPEAT;
    }

    inline bool is_single_mode(){
        return _clt_mode == COLLECT_SINGLE;
    }

    inline bool is_loop_mode(){
        return _clt_mode == COLLECT_LOOP;
    }

    bool is_realtime_refresh();

    inline bool is_repeating(){
        return _clt_mode == COLLECT_REPEAT && !_is_instant;
    }

    inline void session_save(){
        _callback->session_save();
    }

    inline void show_region(uint64_t start, uint64_t end, bool keep){
        _callback->show_region(start, end, keep);
    }

    inline void decode_done(){
        _callback->decode_done();
    }

    inline bool is_saving(){
        return _is_saving;
    }

    inline void set_saving(bool flag){
        _is_saving = flag;
    }

    inline DeviceEventObject* device_event_object(){
        return &_device_event;
    }
   
    void reload();
    void refresh(int holdtime);  
    void check_update(); 

    inline void set_map_zoom(int index){
        _map_zoom = index;
    }

    inline int get_map_zoom(){
        return _map_zoom;
    }

    inline bool is_single_buffer(){
        return _view_data == _capture_data;
    }

    inline void update_view(){
        _callback->data_updated();
    }

    void auto_end();
    bool have_hardware_data();
    struct ds_device_base_info* get_device_list(int &out_count, int &actived_index);
    void add_msg_listener(IMessageListener *ln);
    void broadcast_msg(int msg);    
    bool have_new_realtime_refresh(bool keep);
    view::DecodeTrace* get_decoder_trace(int index);
    view::Signal* get_signal_by_index(int index);

    inline bool have_view_data(){
        return get_signal_snapshot()->have_data();
    }

    void on_load_config_end();
    void init_signals(); 

    inline bool is_doing_action(){
        return _is_action;
    }

    void clear_view_data();
    void set_trace_name(view::Trace *trace, QString name);
    void set_decoder_row_label(int index, QString label);

    inline void set_decoder_pannel(IDecoderPannel *pannel){
        _decoder_pannel = pannel;
    }

private:
    void set_cur_samplelimits(uint64_t samplelimits);
    void set_cur_snap_samplerate(uint64_t samplerate);
    void math_disable();

    bool exec_capture();
    void exit_capture();

    inline void data_updated(){
        _callback->data_updated();
    }

    inline void signals_changed(){
        _callback->signals_changed();
    }

    inline void set_receive_data_len(quint64 len){
        _callback->receive_data_len(len);
    }
  
    void add_decode_task(view::DecodeTrace *trace);
    void remove_decode_task(view::DecodeTrace *trace);
    void clear_all_decode_task(int &runningDex);

    inline void clear_all_decode_task2(){
        int run_dex = 0;
        clear_all_decode_task(run_dex);
    }
   
    void decode_task_proc();
    view::DecodeTrace* get_top_decode_task();    

    void capture_init(); 
    void nodata_timeout();
    void feed_timeout();    
    void clear_decode_result();
    void attach_data_to_signal(SessionData *data);

    bool action_start_capture(bool instant);
    bool action_stop_capture();

    inline void set_session_time(QDateTime time){
        _session_time = time;
    }
  
    //IMessageListener
    void OnMessage(int msg) override;

    //IDeviceAgentCallback
    void DeviceConfigChanged() override;

private:
    /**
     * Attempts to autodetect the format. Failing that
     * @param filename The filename of the input file.
     * @return A pointer to the 'struct sr_input_format' that should be
     * 	used, or NULL if no input format was selected or
     * 	auto-detected.
     */
    static sr_input_format* determine_input_file_format(const std::string &filename); 

    // data feed
	void feed_in_header(const sr_dev_inst *sdi);
	void feed_in_meta(const sr_dev_inst *sdi, const sr_datafeed_meta &meta);
    void feed_in_trigger(const ds_trigger_pos &trigger_pos);
	void feed_in_logic(const sr_datafeed_logic &o);

    void feed_in_dso(const sr_datafeed_dso &o);
	void feed_in_analog(const sr_datafeed_analog &o);    
	void data_feed_in(const struct sr_dev_inst *sdi,
		        const struct sr_datafeed_packet *packet); 

	static void data_feed_callback(const struct sr_dev_inst *sdi,
		        const struct sr_datafeed_packet *packet);

    static void device_lib_event_callback(int event);
    
    void on_device_lib_event(int event);
    Snapshot* get_signal_snapshot();
    void repeat_capture_wait_timeout();
    void repeat_wait_prog_timeout();
    void realtime_refresh_timeout();
    void trig_check_timeout();

    void clear_signals(); 

    inline void data_lock(){
        _data_lock = true;
    }

    inline void data_unlock(){
        _data_lock = false;
    }

    view::Trace* get_channel_by_index(int orgIndex);
    void make_channels_view_index(int start_dex = -1);
 
private:
    mutable std::mutex      _sampling_mutex;
    mutable std::mutex      _data_mutex;
    mutable std::mutex      _decode_task_mutex;  
    std::thread             _decode_thread;
    volatile bool           _is_decoding;
 
	std::vector<view::Signal*>      _signals; 
    std::vector<view::DecodeTrace*> _decode_traces;
    std::vector<view::DecodeTrace*> _decode_tasks;
    dsv::data::DecoderModel          *_decoder_model;
    std::vector<view::SpectrumTrace*> _spectrum_traces;
    view::LissajousTrace            *_lissajous_trace;
    view::MathTrace                 *_math_trace;
  
    DsTimer     _feed_timer;
    DsTimer     _out_timer;
    DsTimer     _repeat_timer;
    DsTimer     _repeat_wait_prog_timer;
    DsTimer     _refresh_rt_timer;
    DsTimer     _trig_check_timer;
   
    int         _noData_cnt;
    bool        _data_lock;
    bool        _data_updated;
    int         _data_auto_lock;

    QDateTime   _session_time;
    QDateTime   _trig_time;
    bool        _is_triged;
    uint64_t    _trigger_pos;
    bool        _trigger_flag;
    uint8_t     _trigger_ch;
    bool        _hw_replied;

    SESSION_ERROR_STATUS _error;
    uint64_t    _error_pattern;
    int         _map_zoom;  
    bool        _bClose;  
 
    uint64_t    _save_start;
    uint64_t    _save_end; 
    volatile bool  _is_working;
    double      _repeat_intvl; // The progress wait timer interval.
    int         _repeat_hold_prg; // The time sleep progress
    int         _repeat_wait_prog_step;
    bool        _is_saving;
    bool        _is_instant;
    volatile int  _device_status;
    int         _work_time_id;
    int         _capture_times; 
    int         _confirm_store_time_id;
    uint64_t    _rt_refresh_time_id;
    uint64_t    _rt_ck_refresh_time_id;
    DEVICE_COLLECT_MODE    _clt_mode;
    bool        _is_stream_mode;
    
    bool        _is_action;
    uint64_t    _dso_packet_count;
 

    ISessionCallback *_callback;
    DeviceAgent   _device_agent;
    std::vector<IMessageListener*> _msg_listeners;
    DeviceEventObject   _device_event;
    SessionData       *_view_data;
    SessionData       *_capture_data;
    std::vector<SessionData*> _data_list;
    IDecoderPannel  *_decoder_pannel;
   
private:
	// TODO: This should not be necessary. Multiple concurrent
	// sessions should should be supported and it should be
	// possible to associate a pointer with a ds_session.
	static SigSession *_session;
};

} //namespace com
} //namespace appcore

#endif // DSVIEW_PV_SIGSESSION_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2022 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "deviceagent.h"
#include <assert.h>
#include "../log.h"

namespace dsv {
namespace appcore {

DeviceAgent::DeviceAgent()
{
    _dev_handle = NULL_HANDLE;
    _di = NULL;
    _dev_type = 0;
    _callback = NULL;
    _is_new_device = false;
}

void DeviceAgent::update()
{
    _dev_handle = NULL_HANDLE;
    _dev_name = "";
    _path = "";
    _di = NULL;
    _dev_type = 0;
    _is_new_device = false;

    struct ds_device_full_info info;

    if (ds_get_actived_device_info(&info) == SR_OK)
    {
        _dev_handle = info.handle;
        _dev_type = info.dev_type;
        _di = info.di;
        _is_new_device = info.actived_times == 1;

        _dev_name = QString::fromLocal8Bit(info.name);
        _driver_name = QString::fromLocal8Bit(info.driver_name);

        if (info.path[0] != '\0'){
            _path = QString::fromLocal8Bit(info.path);
        } 
    }
}

 sr_dev_inst* DeviceAgent::inst()
 {
    assert(_dev_handle);
    return _di;
 }

bool DeviceAgent::enable_probe(const sr_channel *probe, bool enable)
{
    assert(_dev_handle);

    if (ds_enable_device_channel(probe, enable) == SR_OK){
        config_changed();
        return true;
    }
    return false;
}

bool DeviceAgent::enable_probe(int probe_index, bool enable)
{
     assert(_dev_handle);

     if (ds_enable_device_channel_index(probe_index, enable) == SR_OK){
        config_changed();
        return true;
    }
    return false;
}

bool DeviceAgent::set_channel_name(int ch_index, const char *name)
{
    assert(_dev_handle);
    
    if (ds_set_device_channel_name(ch_index, name) == SR_OK){
        config_changed();
        return true;
    }
    return false;
}

uint64_t DeviceAgent::get_sample_limit()
{
    assert(_dev_handle);

    uint64_t v;
    GVariant* gvar = NULL;

    ds_get_actived_device_config(NULL, NULL, SR_CONF_LIMIT_SAMPLES, &gvar);

	if (gvar != NULL) {
        v = g_variant_get_uint64(gvar);
		g_variant_unref(gvar);
	}
    else {
		v = 0U;
	}

	return v;
}

uint64_t DeviceAgent::get_sample_rate()
{
    assert(_dev_handle);

    uint64_t v;
    GVariant* gvar = NULL;

    ds_get_actived_device_config(NULL, NULL, SR_CONF_SAMPLERATE, &gvar);

	if (gvar != NULL) {
        v = g_variant_get_uint64(gvar);
		g_variant_unref(gvar);
	}
    else {
		v = 0U;
	}

	return v;
}

uint64_t DeviceAgent::get_time_base()
{
    assert(_dev_handle);

    uint64_t v;
    GVariant* gvar = NULL;

    ds_get_actived_device_config(NULL, NULL, SR_CONF_TIMEBASE, &gvar);

	if (gvar != NULL) {
        v = g_variant_get_uint64(gvar);
		g_variant_unref(gvar);
	}
    else {
		v = 0U;
	}

	return v;
}

double DeviceAgent::get_sample_time()
{
    assert(_dev_handle);

    uint64_t sample_rate = get_sample_rate();
    uint64_t sample_limit = get_sample_limit();
    double sample_time;

    if (sample_rate == 0)
        sample_time = 0;
    else
        sample_time = sample_limit * 1.0 / sample_rate;

    return sample_time;
}

const GSList* DeviceAgent::get_device_mode_list()
{
    assert(_dev_handle);
    return ds_get_actived_device_mode_list();
}

bool DeviceAgent::is_trigger_enabled()
{
    assert(_dev_handle);
    if (ds_trigger_is_enabled() > 0){
        return true;
    }
    return false;
}

bool DeviceAgent::start()
{
    assert(_dev_handle);

    if (ds_start_collect() == SR_OK){
        return true;
    }
    return false;
}

bool DeviceAgent::stop()
{
    assert(_dev_handle);

    if (ds_stop_collect() == SR_OK){
        return true;
    }
    return false;
}

void DeviceAgent::release()
{
    ds_release_actived_device();
}

bool DeviceAgent::have_enabled_channel()
{
    assert(_dev_handle);
    return ds_channel_is_enabled() > 0;
}

void DeviceAgent::config_changed()
{
    if (_callback != NULL){
        _callback->DeviceConfigChanged();
    }
}

bool DeviceAgent::channel_is_enable(int index)
{  
    for (const GSList *l = get_channels(); l; l = l->next)
    {
        const sr_channel *const probe = (const sr_channel *)l->data;
        if (probe->index == index)
            return probe->enabled;          
    }

    return false;
}
 
//---------------device config-----------/

int DeviceAgent::get_work_mode()
{
    return ds_get_actived_device_mode();
}

const struct sr_config_info *DeviceAgent::get_config_info(int key)
{
    return ds_get_actived_device_config_info(key);
}

bool DeviceAgent::get_device_status(struct sr_status &status, gboolean prg)
{   
    assert(_dev_handle);

    if (ds_get_actived_device_status(&status, prg) == SR_OK)
    {
        return true;
    }
    return false;
}

struct sr_config *DeviceAgent::new_config(int key, GVariant *data)
{
    return ds_new_config(key, data);
}

void DeviceAgent::free_config(struct sr_config *src)
{
    ds_free_config(src);
}

bool DeviceAgent::is_collecting()
{
    return ds_is_collecting() > 0;
}

GSList *DeviceAgent::get_channels()
{
    assert(_dev_handle);
    return ds_get_actived_device_channels();
}

 int DeviceAgent::get_hardware_operation_mode()
 {
    assert(_dev_handle);

    int mode_val = 0;
    if (get_config_int16(SR_CONF_OPERATION_MODE, mode_val)){                  
        return mode_val;
    }
    return -1;
 }

 bool DeviceAgent::is_stream_mode()
 { 
    return get_hardware_operation_mode() == LO_OP_STREAM;
 }

 bool DeviceAgent::check_firmware_version()
 {
    assert(_dev_handle);

    int st = -1;
    if (ds_get_actived_device_init_status(&st) == SR_OK){
        if (st == SR_ST_INCOMPATIBLE){
            return false;
        }
    }
    return true;
 }

 QString DeviceAgent::get_demo_operation_mode()
 {
    assert(_dev_handle);

    if (is_demo() == false){
        assert(false);
    }        
    
    QString pattern_mode;
    if(get_config_string(SR_CONF_PATTERN_MODE, pattern_mode) == false)
    {
        assert(false);
    }
    return pattern_mode;
 }

GVariant* DeviceAgent::get_config_list(const sr_channel_group *group, int key)
{
    assert(_dev_handle);

    GVariant *data = NULL;

    int ret = ds_get_actived_device_config_list(group, key, &data);
    if (ret != SR_OK){
        if (ret != SR_ERR_NA)
            dsv_detail("%s%d", "WARNING: Failed to get config list, key:", key); 
        
        if (data != NULL){
            dsv_warn("%s%d", "WARNING: Failed to get config list, but data is not null. key:", key); 
        }
        data = NULL;
    }

    return data;
}

GVariant* DeviceAgent::get_config(int key, const sr_channel *ch, const sr_channel_group *cg)
{
    assert(_dev_handle); 
    GVariant *data = NULL;
    
    int ret = ds_get_actived_device_config(ch, cg, key, &data);
    if (ret != SR_OK)
    {
        if (ret != SR_ERR_NA)
            dsv_err("%s%d", "ERROR:DeviceAgent::get_config, Failed to get value of config id:", key);
    }
    return data;
}

bool DeviceAgent::have_config(int key, const sr_channel *ch, const sr_channel_group *cg)
{
    GVariant *gvar = get_config(key, ch, cg);

    if (gvar != NULL){
        g_variant_unref(gvar);
        return true;
    }
    return false;
}

bool DeviceAgent::set_config(int key, GVariant *data, const sr_channel *ch, const sr_channel_group *cg)
 {
    assert(_dev_handle);

    int ret = ds_set_actived_device_config(ch, cg, key, data);
    if (ret != SR_OK)
    {
        if (ret != SR_ERR_NA)
            dsv_err("%s%d", "ERROR:DeviceAgent::set_config, Failed to set value of config id:", key);
        return false;
    }

    config_changed();
    return true;
 }

 bool DeviceAgent::get_config_int32(int key, int &value, const sr_channel *ch, const sr_channel_group *cg)
 {  
    GVariant* gvar = get_config(key, ch, cg);
    
    if (gvar != NULL) {
        value = g_variant_get_int32(gvar);
        g_variant_unref(gvar);
        return true;
    }

    return false;
 }

 bool DeviceAgent::set_config_int32(int key, int value, const sr_channel *ch, const sr_channel_group *cg)
 {
    assert(_dev_handle);

    GVariant *gvar = g_variant_new_int32(value);
    int ret = ds_set_actived_device_config(ch, cg, key, gvar);

    if (ret != SR_OK)
    {
        if (ret != SR_ERR_NA)
            dsv_err("%s%d", "ERROR: DeviceAgent::set_config_int32, Failed to set value of config id:", key);
        return false;
    }
    return true;
 }

 bool DeviceAgent::get_config_string(int key, QString &value, const sr_channel *ch, const sr_channel_group *cg)
 {
    GVariant* gvar = get_config(key, ch, cg);
    
    if (gvar != NULL) {
        const gchar *s = g_variant_get_string(gvar, NULL);
        value = QString(s);
        g_variant_unref(gvar);
        return true;
    }

    return false;
 }

 bool DeviceAgent::set_config_string(int key, const char *value, const sr_channel *ch, const sr_channel_group *cg)
 {
    assert(value);
    assert(_dev_handle);

    GVariant *gvar = g_variant_new_string(value);
    int ret = ds_set_actived_device_config(ch, cg, key, gvar);

    if (ret != SR_OK)
    {
        if (ret != SR_ERR_NA)
            dsv_err("%s%d", "ERROR: DeviceAgent::set_config_string, Failed to set value of config id:", key);
        return false;
    }
    return true;
 }

bool DeviceAgent::get_config_bool(int key, bool &value, const sr_channel *ch, const sr_channel_group *cg)
{
    GVariant* gvar = get_config(key, ch, cg);
    
    if (gvar != NULL) {
        gboolean v = g_variant_get_boolean(gvar);
        value = v > 0;
        g_variant_unref(gvar);
        return true;
    }

    return false;
}

bool DeviceAgent::set_config_bool(int key, bool value, const sr_channel *ch, const sr_channel_group *cg)
{
    assert(_dev_handle);

    GVariant *gvar = g_variant_new_boolean(value);
    int ret = ds_set_actived_device_config(ch, cg, key, gvar);

    if (ret != SR_OK)
    {
        if (ret != SR_ERR_NA)
            dsv_err("%s%d", "ERROR: DeviceAgent::set_config_bool, Failed to set value of config id:", key);
        return false;
    }
    return true;
}

bool DeviceAgent::get_config_uint64(int key, uint64_t &value, const sr_channel *ch, const sr_channel_group *cg)
{
    GVariant* gvar = get_config(key, ch, cg);
    
    if (gvar != NULL) {
        value = g_variant_get_uint64(gvar);
        g_variant_unref(gvar);
        return true;
    }

    return false;
}

bool DeviceAgent::set_config_uint64(int key, uint64_t value, const sr_channel *ch, const sr_channel_group *cg)
{
    assert(_dev_handle);

    GVariant *gvar = g_variant_new_uint64(value);
    int ret = ds_set_actived_device_config(ch, cg, key, gvar);

    if (ret != SR_OK)
    {
        if (ret != SR_ERR_NA)
            dsv_err("%s%d", "ERROR: DeviceAgent::set_config_uint64, Failed to set value of config id:", key);
        return false;
    }
    return true;
}

bool DeviceAgent::get_config_uint16(int key, int &value, const sr_channel *ch, const sr_channel_group *cg)
{
    GVariant* gvar = get_config(key, ch, cg);
    
    if (gvar != NULL) {
        value = g_variant_get_uint16(gvar);
        g_variant_unref(gvar);
        return true;
    }

    return false;
}

bool DeviceAgent::set_config_uint16(int key, int value, const sr_channel *ch, const sr_channel_group *cg)
{
    assert(_dev_handle);

    GVariant *gvar = g_variant_new_uint16(value);
    int ret = ds_set_actived_device_config(ch, cg, key, gvar);

    if (ret != SR_OK)
    {
        if (ret != SR_ERR_NA)
            dsv_err("%s%d", "ERROR: DeviceAgent::set_config_uint16, Failed to set value of config id:", key);
        return false;
    }
    return true;
}

bool DeviceAgent::get_config_uint32(int key, uint32_t &value, const sr_channel *ch, const sr_channel_group *cg)
{
    GVariant* gvar = get_config(key, ch, cg);
    
    if (gvar != NULL) {
        value = g_variant_get_uint32(gvar);
        g_variant_unref(gvar);
        return true;
    }

    return false;
}

bool DeviceAgent::set_config_uint32(int key, uint32_t value, const sr_channel *ch, const sr_channel_group *cg)
{
    assert(_dev_handle);

    GVariant *gvar = g_variant_new_uint32(value);
    int ret = ds_set_actived_device_config(ch, cg, key, gvar);

    if (ret != SR_OK)
    {
        if (ret != SR_ERR_NA)
            dsv_err("%s%d", "ERROR: DeviceAgent::set_config_uint32, Failed to set value of config id:", key);
        return false;
    }
    return true;
}

bool DeviceAgent::get_config_int16(int key, int &value, const sr_channel *ch, const sr_channel_group *cg)
{
    GVariant* gvar = get_config(key, ch, cg);
    
    if (gvar != NULL) {
        value = g_variant_get_int16(gvar);
        g_variant_unref(gvar);
        return true;
    }

    return false;
}

bool DeviceAgent::set_config_int16(int key, int value, const sr_channel *ch, const sr_channel_group *cg)
{
    assert(_dev_handle);

    GVariant *gvar = g_variant_new_int16(value);
    int ret = ds_set_actived_device_config(ch, cg, key, gvar);

    if (ret != SR_OK)
    {
        if (ret != SR_ERR_NA)
            dsv_err("%s%d", "ERROR: DeviceAgent::set_config_int16, Failed to set value of config id:", key);
        return false;
    }
    return true;
}

bool DeviceAgent::get_config_byte(int key, int &value, const sr_channel *ch, const sr_channel_group *cg)
{
    GVariant* gvar = get_config(key, ch, cg);
    
    if (gvar != NULL) {
        value = g_variant_get_byte(gvar);
        g_variant_unref(gvar);
        return true;
    }

    return false;
}

bool DeviceAgent::set_config_byte(int key, int value, const sr_channel *ch, const sr_channel_group *cg)
{
    assert(_dev_handle);

    GVariant *gvar = g_variant_new_byte((uint8_t)value);
    int ret = ds_set_actived_device_config(ch, cg, key, gvar);

    if (ret != SR_OK)
    {
        if (ret != SR_ERR_NA)
            dsv_err("%s%d", "ERROR: DeviceAgent::set_config_byte, Failed to set value of config id:", key);
        return false;
    }
    return true;
}

bool DeviceAgent::get_config_double(int key, double &value, const sr_channel *ch, const sr_channel_group *cg)
{
    GVariant* gvar = get_config(key, ch, cg);
    
    if (gvar != NULL) {
        value = g_variant_get_double(gvar);
        g_variant_unref(gvar);
        return true;
    }

    return false;
}

bool DeviceAgent::set_config_double(int key, double value, const sr_channel *ch, const sr_channel_group *cg)
{
    assert(_dev_handle);

    GVariant *gvar = g_variant_new_double(value);
    int ret = ds_set_actived_device_config(ch, cg, key, gvar);

    if (ret != SR_OK)
    {
        if (ret != SR_ERR_NA)
            dsv_err("%s%d", "ERROR: DeviceAgent::set_config_double, Failed to set value of config id:", key);
        return false;
    }
    return true;
}

} //namespace com
} //namespace appcore

//---------------device config end -----------/

/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_MAINFRAME_H
#define DSVIEW_PV_MAINFRAME_H

#include <QFrame>
#include <QGridLayout>
#include <QTimer>

#ifdef _WIN32
#include <QWinTaskbarButton>
#include <QWinTaskbarProgress>
#endif

#include "../widgets/border.h"

namespace dsv {

namespace toolbars {
    class TitleBar;
}

namespace dialogs {
    class DSMessageBox;
    class DSDialog;
}

namespace appcore {
 
class MainWindow;

class MainFrame : public QFrame
{
    Q_OBJECT

public:
    static const int Margin = 5;

    enum borderTypes{
        None,
        TopLeft,
        Left,
        BottomLeft,
        Bottom,
        BottomRight,
        Right,
        TopRight,
        Top
    }borderTypes;

public:
    MainFrame();

    void readSettings();

protected: 
    void resizeEvent(QResizeEvent *event);
    void closeEvent(QCloseEvent *event);
    bool eventFilter(QObject *object, QEvent *event);
    #ifdef _WIN32
    void showEvent(QShowEvent *event);
    #endif

public slots:
    void unfreezing();
    void showNormal();
    void showMaximized();
    void showMinimized();
    void show_doc();
    void setTaskbarProgress(int progress);

private:
    void hide_border();
    void show_border();
    void writeSettings();
    void saveWindowRegion();

private:
    toolbars::TitleBar *_titleBar;
    MainWindow *_mainWindow;

    QGridLayout *_layout;
    widgets::Border *_left;
    widgets::Border *_right;
    widgets::Border *_top;
    widgets::Border *_bottom;
    widgets::Border *_top_left;
    widgets::Border *_top_right;
    widgets::Border *_bottom_left;
    widgets::Border *_bottom_right;
 
    bool    _bDraging; 
    QRect   _dragStartGeometry;
    int     _hit_border;
    QTimer  _timer;
    bool    _freezing; 
    // Taskbar Progress Effert for Win7 and Above
#ifdef _WIN32
    QWinTaskbarButton *_taskBtn;
    QWinTaskbarProgress *_taskPrg;
#endif
};

} //namespace com
} //namespace appcore

#endif // DSVIEW_PV_MAINFRAME_H
/****************************************************************************
** Meta object code from reading C++ file 'eventobject.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "eventobject.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'eventobject.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEEventObjectENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEEventObjectENDCLASS = QtMocHelpers::stringData(
    "dsv::appcore::EventObject",
    "show_error",
    "",
    "error",
    "capture_state_changed",
    "state",
    "data_updated",
    "session_error",
    "signals_changed",
    "receive_trigger",
    "trigger_pos",
    "frame_ended",
    "frame_began",
    "decode_done",
    "receive_data_len",
    "len",
    "cur_snap_samplerate_changed",
    "trigger_message",
    "msg"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEEventObjectENDCLASS_t {
    uint offsetsAndSizes[38];
    char stringdata0[26];
    char stringdata1[11];
    char stringdata2[1];
    char stringdata3[6];
    char stringdata4[22];
    char stringdata5[6];
    char stringdata6[13];
    char stringdata7[14];
    char stringdata8[16];
    char stringdata9[16];
    char stringdata10[12];
    char stringdata11[12];
    char stringdata12[12];
    char stringdata13[12];
    char stringdata14[17];
    char stringdata15[4];
    char stringdata16[28];
    char stringdata17[16];
    char stringdata18[4];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEEventObjectENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEEventObjectENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEEventObjectENDCLASS = {
    {
        QT_MOC_LITERAL(0, 25),  // "dsv::appcore::EventObject"
        QT_MOC_LITERAL(26, 10),  // "show_error"
        QT_MOC_LITERAL(37, 0),  // ""
        QT_MOC_LITERAL(38, 5),  // "error"
        QT_MOC_LITERAL(44, 21),  // "capture_state_changed"
        QT_MOC_LITERAL(66, 5),  // "state"
        QT_MOC_LITERAL(72, 12),  // "data_updated"
        QT_MOC_LITERAL(85, 13),  // "session_error"
        QT_MOC_LITERAL(99, 15),  // "signals_changed"
        QT_MOC_LITERAL(115, 15),  // "receive_trigger"
        QT_MOC_LITERAL(131, 11),  // "trigger_pos"
        QT_MOC_LITERAL(143, 11),  // "frame_ended"
        QT_MOC_LITERAL(155, 11),  // "frame_began"
        QT_MOC_LITERAL(167, 11),  // "decode_done"
        QT_MOC_LITERAL(179, 16),  // "receive_data_len"
        QT_MOC_LITERAL(196, 3),  // "len"
        QT_MOC_LITERAL(200, 27),  // "cur_snap_samplerate_changed"
        QT_MOC_LITERAL(228, 15),  // "trigger_message"
        QT_MOC_LITERAL(244, 3)   // "msg"
    },
    "dsv::appcore::EventObject",
    "show_error",
    "",
    "error",
    "capture_state_changed",
    "state",
    "data_updated",
    "session_error",
    "signals_changed",
    "receive_trigger",
    "trigger_pos",
    "frame_ended",
    "frame_began",
    "decode_done",
    "receive_data_len",
    "len",
    "cur_snap_samplerate_changed",
    "trigger_message",
    "msg"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEappcoreSCOPEEventObjectENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
      12,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
      12,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   86,    2, 0x06,    1 /* Public */,
       4,    1,   89,    2, 0x06,    3 /* Public */,
       6,    0,   92,    2, 0x06,    5 /* Public */,
       7,    0,   93,    2, 0x06,    6 /* Public */,
       8,    0,   94,    2, 0x06,    7 /* Public */,
       9,    1,   95,    2, 0x06,    8 /* Public */,
      11,    0,   98,    2, 0x06,   10 /* Public */,
      12,    0,   99,    2, 0x06,   11 /* Public */,
      13,    0,  100,    2, 0x06,   12 /* Public */,
      14,    1,  101,    2, 0x06,   13 /* Public */,
      16,    0,  104,    2, 0x06,   15 /* Public */,
      17,    1,  105,    2, 0x06,   16 /* Public */,

 // signals: parameters
    QMetaType::Void, QMetaType::QString,    3,
    QMetaType::Void, QMetaType::Int,    5,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::ULongLong,   10,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::ULongLong,   15,
    QMetaType::Void,
    QMetaType::Void, QMetaType::Int,   18,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::appcore::EventObject::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEEventObjectENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEappcoreSCOPEEventObjectENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEEventObjectENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<EventObject, std::true_type>,
        // method 'show_error'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QString, std::false_type>,
        // method 'capture_state_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'data_updated'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'session_error'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'signals_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'receive_trigger'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<quint64, std::false_type>,
        // method 'frame_ended'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'frame_began'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'decode_done'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'receive_data_len'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<quint64, std::false_type>,
        // method 'cur_snap_samplerate_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'trigger_message'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>
    >,
    nullptr
} };

void dsv::appcore::EventObject::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<EventObject *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->show_error((*reinterpret_cast< std::add_pointer_t<QString>>(_a[1]))); break;
        case 1: _t->capture_state_changed((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 2: _t->data_updated(); break;
        case 3: _t->session_error(); break;
        case 4: _t->signals_changed(); break;
        case 5: _t->receive_trigger((*reinterpret_cast< std::add_pointer_t<quint64>>(_a[1]))); break;
        case 6: _t->frame_ended(); break;
        case 7: _t->frame_began(); break;
        case 8: _t->decode_done(); break;
        case 9: _t->receive_data_len((*reinterpret_cast< std::add_pointer_t<quint64>>(_a[1]))); break;
        case 10: _t->cur_snap_samplerate_changed(); break;
        case 11: _t->trigger_message((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (EventObject::*)(QString );
            if (_t _q_method = &EventObject::show_error; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (EventObject::*)(int );
            if (_t _q_method = &EventObject::capture_state_changed; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 1;
                return;
            }
        }
        {
            using _t = void (EventObject::*)();
            if (_t _q_method = &EventObject::data_updated; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 2;
                return;
            }
        }
        {
            using _t = void (EventObject::*)();
            if (_t _q_method = &EventObject::session_error; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 3;
                return;
            }
        }
        {
            using _t = void (EventObject::*)();
            if (_t _q_method = &EventObject::signals_changed; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 4;
                return;
            }
        }
        {
            using _t = void (EventObject::*)(quint64 );
            if (_t _q_method = &EventObject::receive_trigger; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 5;
                return;
            }
        }
        {
            using _t = void (EventObject::*)();
            if (_t _q_method = &EventObject::frame_ended; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 6;
                return;
            }
        }
        {
            using _t = void (EventObject::*)();
            if (_t _q_method = &EventObject::frame_began; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 7;
                return;
            }
        }
        {
            using _t = void (EventObject::*)();
            if (_t _q_method = &EventObject::decode_done; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 8;
                return;
            }
        }
        {
            using _t = void (EventObject::*)(quint64 );
            if (_t _q_method = &EventObject::receive_data_len; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 9;
                return;
            }
        }
        {
            using _t = void (EventObject::*)();
            if (_t _q_method = &EventObject::cur_snap_samplerate_changed; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 10;
                return;
            }
        }
        {
            using _t = void (EventObject::*)(int );
            if (_t _q_method = &EventObject::trigger_message; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 11;
                return;
            }
        }
    }
}

const QMetaObject *dsv::appcore::EventObject::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::appcore::EventObject::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEEventObjectENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int dsv::appcore::EventObject::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 12)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 12;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 12)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 12;
    }
    return _id;
}

// SIGNAL 0
void dsv::appcore::EventObject::show_error(QString _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}

// SIGNAL 1
void dsv::appcore::EventObject::capture_state_changed(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 1, _a);
}

// SIGNAL 2
void dsv::appcore::EventObject::data_updated()
{
    QMetaObject::activate(this, &staticMetaObject, 2, nullptr);
}

// SIGNAL 3
void dsv::appcore::EventObject::session_error()
{
    QMetaObject::activate(this, &staticMetaObject, 3, nullptr);
}

// SIGNAL 4
void dsv::appcore::EventObject::signals_changed()
{
    QMetaObject::activate(this, &staticMetaObject, 4, nullptr);
}

// SIGNAL 5
void dsv::appcore::EventObject::receive_trigger(quint64 _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 5, _a);
}

// SIGNAL 6
void dsv::appcore::EventObject::frame_ended()
{
    QMetaObject::activate(this, &staticMetaObject, 6, nullptr);
}

// SIGNAL 7
void dsv::appcore::EventObject::frame_began()
{
    QMetaObject::activate(this, &staticMetaObject, 7, nullptr);
}

// SIGNAL 8
void dsv::appcore::EventObject::decode_done()
{
    QMetaObject::activate(this, &staticMetaObject, 8, nullptr);
}

// SIGNAL 9
void dsv::appcore::EventObject::receive_data_len(quint64 _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 9, _a);
}

// SIGNAL 10
void dsv::appcore::EventObject::cur_snap_samplerate_changed()
{
    QMetaObject::activate(this, &staticMetaObject, 10, nullptr);
}

// SIGNAL 11
void dsv::appcore::EventObject::trigger_message(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 11, _a);
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEDeviceEventObjectENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEDeviceEventObjectENDCLASS = QtMocHelpers::stringData(
    "dsv::appcore::DeviceEventObject",
    "device_updated",
    ""
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEDeviceEventObjectENDCLASS_t {
    uint offsetsAndSizes[6];
    char stringdata0[32];
    char stringdata1[15];
    char stringdata2[1];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEDeviceEventObjectENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEDeviceEventObjectENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEDeviceEventObjectENDCLASS = {
    {
        QT_MOC_LITERAL(0, 31),  // "dsv::appcore::DeviceEventObject"
        QT_MOC_LITERAL(32, 14),  // "device_updated"
        QT_MOC_LITERAL(47, 0)   // ""
    },
    "dsv::appcore::DeviceEventObject",
    "device_updated",
    ""
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEappcoreSCOPEDeviceEventObjectENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   20,    2, 0x06,    1 /* Public */,

 // signals: parameters
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::appcore::DeviceEventObject::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEDeviceEventObjectENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEappcoreSCOPEDeviceEventObjectENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEDeviceEventObjectENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<DeviceEventObject, std::true_type>,
        // method 'device_updated'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::appcore::DeviceEventObject::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<DeviceEventObject *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->device_updated(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (DeviceEventObject::*)();
            if (_t _q_method = &DeviceEventObject::device_updated; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
    }
    (void)_a;
}

const QMetaObject *dsv::appcore::DeviceEventObject::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::appcore::DeviceEventObject::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEappcoreSCOPEDeviceEventObjectENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int dsv::appcore::DeviceEventObject::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 1;
    }
    return _id;
}

// SIGNAL 0
void dsv::appcore::DeviceEventObject::device_updated()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "appcontrol.h"

#include <libsigrok.h>
#include <libsigrokdecode.h>
#include <QDir>
#include <QCoreApplication>
#include <QWidget>
#include <string>
#include <assert.h>
#include "sigsession.h"
#include "../basedef.h"
#include "../config/appconfig.h"
#include "../log.h"
#include "../utility/path.h"
#include "../utility/encoding.h"

using namespace dsv::config;

namespace dsv {
namespace appcore {

AppControl::AppControl()
{
    _topWindow = NULL; 
    _session = new SigSession();
}

AppControl::AppControl(AppControl &o)
{
    (void)o;
}
 
AppControl::~AppControl()
{ 
   // DESTROY_OBJECT(_session);
}

AppControl* AppControl::Instance()
{
    static AppControl *ins = NULL;
    if (ins == NULL){
        ins = new AppControl();
    }
    return ins;
}

void AppControl::Destroy(){
     
} 

bool AppControl::Init()
{ 
    dsv::encoding::init();

    QString qs;
    std::string cs;

    qs = AppConfig::GetAppDataDir();
    cs = dsv::path::ToUnicodePath(qs);
    dsv_info("GetAppDataDir:\"%s\"", cs.c_str());
    cs = dsv::path::ConvertPath(qs);
    ds_set_user_data_dir(cs.c_str());

    qs = AppConfig::GetFirmwareDir();
    cs = dsv::path::ToUnicodePath(qs);
    dsv_info("GetFirmwareDir:\"%s\"", cs.c_str());

    qs = AppConfig::GetUserDataDir();
    cs = dsv::path::ToUnicodePath(qs);
    dsv_info("GetUserDataDir:\"%s\"", cs.c_str());

    qs = AppConfig::GetDecodeScriptDir();
    cs = dsv::path::ToUnicodePath(qs);
    dsv_info("GetDecodeScriptDir:\"%s\"", cs.c_str());
    //---------------end print directorys.

    _session->init();

    srd_log_set_context(dsv_log_context());

#if defined(_WIN32) && defined(DEBUG_INFO)
    //able run debug with qtcreator
    QString pythonHome = "c:/python";
    QDir pydir;
    if (pydir.exists(pythonHome)){
        const wchar_t *pyhome = reinterpret_cast<const wchar_t*>(pythonHome.utf16());
        srd_set_python_home(pyhome);
    }
  
#endif
    
    //the python script path of decoder
    char path[256] = {0};
    QString dir = AppConfig::GetDecodeScriptDir();   
    strcpy(path, dir.toUtf8().data());

    // Initialise libsigrokdecode
    if (srd_init(path) != SRD_OK)
    { 
        dsv_err("ERROR: libsigrokdecode init failed.");
        return false;
    }

    // Load the protocol decoders
    if (srd_decoder_load_all() != SRD_OK)
    {
        dsv_err("ERROR: load the protocol decoders failed.");
        return false;
    }
 
    return true;
}

bool AppControl::Start()
{  
    _session->Open(); 
    return true;
}

 void AppControl::Stop()
 {
    _session->Close();  
 }

void AppControl::UnInit()
{  
    // Destroy libsigrokdecode
    srd_exit();

    _session->uninit();
}

bool AppControl::TopWindowIsMaximized()
{
    if (_topWindow != NULL){
        return _topWindow->isMaximized();
    }
    return false;
}

void AppControl::add_font_form(IFontForm *form)
{
    assert(form);
    _font_forms.push_back(form);
}

void AppControl::remove_font_form(IFontForm *form)
{
    assert(form);
    
    for (auto it = _font_forms.begin(); it != _font_forms.end(); it++)
    {
        if ( *(it) == form){
            _font_forms.erase(it);
            break;
        }
    }
}

void AppControl::update_font_forms()
{
    for (auto f : _font_forms){
        f->update_font();
    }
}

} //namespace com
} //namespace appcore

/****************************************************************************
** Meta object code from reading C++ file 'mystyle.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "mystyle.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'mystyle.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSMyStyleENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSMyStyleENDCLASS = QtMocHelpers::stringData(
    "MyStyle"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSMyStyleENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[8];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSMyStyleENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSMyStyleENDCLASS_t qt_meta_stringdata_CLASSMyStyleENDCLASS = {
    {
        QT_MOC_LITERAL(0, 7)   // "MyStyle"
    },
    "MyStyle"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSMyStyleENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject MyStyle::staticMetaObject = { {
    QMetaObject::SuperData::link<QProxyStyle::staticMetaObject>(),
    qt_meta_stringdata_CLASSMyStyleENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSMyStyleENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSMyStyleENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<MyStyle, std::true_type>
    >,
    nullptr
} };

void MyStyle::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *MyStyle::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *MyStyle::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSMyStyleENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QProxyStyle::qt_metacast(_clname);
}

int MyStyle::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QProxyStyle::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2023 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DECODE_DISPLAY_DATA_FORMAT_H
#define DECODE_DISPLAY_DATA_FORMAT_H

#include <string.h>

namespace dsv{
namespace decode{


class DisplayDataFormat
{

public:
    enum
    {
        hex=0,
        dec=1,       
        oct=2,
        bin=3,
        ascii=4
    };

    static inline int Parse(const char *name)
    {
        if (strcmp(name, "dec") == 0){
            return (int)dec;
        }
        if (strcmp(name, "hex") == 0){
            return (int)hex;
        }
        if (strcmp(name, "oct") == 0){
            return (int)oct;
        }
        if (strcmp(name, "bin") == 0){
            return (int)bin;
        }
        if (strcmp(name, "ascii") == 0){
            return (int)ascii;
        }
        return (int)hex;
    }
};

#endif

} //namespace decode
} //namespace dsv/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "decoderstatus.h"

namespace dsv{
namespace decode{

DecoderStatus::DecoderStatus()
{
        m_bNumeric = false;
        m_format = 0;
        sdr_decoder_handle = NULL;
}

void DecoderStatus::clear()
{
        m_resTable.reset();
        m_bNumeric = false;
} 

} //namespace decode
} //namespace dsv
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2013 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2014 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DECODE_DECODER_H
#define DECODE_DECODER_H

#include <map>
#include <set>
#include <string>
#include <sstream>
#include <iostream>  
#include <glib.h>

struct srd_decoder;
struct srd_decoder_inst;
struct srd_channel;
struct srd_session;

namespace dsv{
namespace decode{

class Decoder
{
public:
	Decoder(const srd_decoder *const decoder);

public: 

	virtual ~Decoder();

	inline const srd_decoder* decoder(){
        return _decoder;
    }

	inline bool shown(){
        return _shown;
    }

	inline void show(bool show = true){
         _shown = show;
    }

    inline std::map<const srd_channel*, int>& channels(){
        return _probes;
    }

    void set_probes(std::map<const srd_channel*, int> probes);

	inline std::map<std::string, GVariant*>& options(){
        return _options;
    }

	void set_option(const char *id, GVariant *value);

	bool have_required_probes();

    srd_decoder_inst* create_decoder_inst(srd_session *session);

    void set_decode_region(uint64_t start, uint64_t end);

    inline uint64_t decode_start(){
        return _decode_start;
    }

    inline void reset_start(){
        _decode_start = _decode_start_back;
    }

    inline uint64_t decode_end(){
        return _decode_end;
    }

    bool commit();

    inline int get_channel_type(const srd_channel* ch){
        return ch->type;
    }

    inline const srd_decoder* get_dec_handel(){
        return _decoder;
    }

private:
	const srd_decoder *const _decoder;
 
    std::map<const srd_channel*, int>   _probes;
	std::map<std::string, GVariant*>    _options;
    std::map<const srd_channel*, int>   _probes_back;
    std::map<std::string, GVariant*>    _options_back;

    uint64_t        _decode_start;
    uint64_t        _decode_end;
    uint64_t        _decode_start_back;
    uint64_t        _decode_end_back;

    bool            _setted;
    bool            _shown;
};

} //namespace decode
} //namespace dsv

#endif 
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2014 Joel Holdsworth <joel@airwebreathe.org.uk>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "row.h"

#include <libsigrokdecode.h>
#include <assert.h>

namespace dsv{
namespace decode{

Row::Row() :
	_decoder(NULL),
    _row(NULL),
    _order(-1)
{
}

Row::Row(const srd_decoder *decoder, const srd_decoder_annotation_row *row, const int order) :
	_decoder(decoder),
    _row(row),
    _order(order)
{
} 

Row::Row(const Row &o)
{
	_decoder = o._decoder;
	_row = o._row;
	_order = o._order;
}

Row& Row::operator=(const Row &o)
{
	_decoder = o._decoder;
	_row = o._row;
	_order = o._order;
	return (*this);
}

QString Row::title() const
{
	if (_decoder && _decoder->name && _row && _row->desc)
		return QString("%1: %2")
			.arg(QString::fromUtf8(_decoder->name))
			.arg(QString::fromUtf8(_row->desc));

	if (_decoder && _decoder->name)
		return QString::fromUtf8(_decoder->name);

	if (_row && _row->desc)
		return QString::fromUtf8(_row->desc);

	return QString();
}

QString Row::title_id() const
{
	if (_decoder && _decoder->id && _row && _row->desc)
		return QString("%1: %2")
			.arg(QString::fromUtf8(_decoder->id))
			.arg(QString::fromUtf8(_row->desc));

	if (_decoder && _decoder->id)
		return QString::fromUtf8(_decoder->id);

	if (_row && _row->desc)
		return QString::fromUtf8(_row->desc);

	return QString();
}

bool Row::operator<(const Row &other) const
{
    assert(_decoder);

    return (_decoder < other._decoder) ||
        (_decoder == other._decoder && _order < other._order);
}

} //namespace decode
} //namespace dsv/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2014 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include <math.h>
#include <assert.h>

#include "rowdata.h"

using std::max;
using std::min;
using std::vector;

namespace dsv{
namespace decode{

std::mutex RowData::_global_visitor_mutex;

RowData::RowData() :
    _max_annotation(0),
    _min_annotation(0)
{
    _item_count = 0;
}

RowData::~RowData()
{
    //stack object can not destory the sources
}

void RowData::clear()
{
    std::lock_guard<std::mutex> lock(_global_visitor_mutex);

    //destroy objercts
    for (Annotation *p : _annotations){
        delete p;
    }
    _annotations.clear();
    _item_count = 0;
    _min_annotation = 0;
}

uint64_t RowData::get_max_sample()
{
    std::lock_guard<std::mutex> lock(_global_visitor_mutex); 

	if (_annotations.empty())
		return 0;
	return _annotations.back()->end_sample();
}

uint64_t RowData::get_max_annotation()
{
    return _max_annotation;
}

uint64_t RowData::get_min_annotation()
{
    if (_min_annotation == 0)
        return 10;
    else
        return _min_annotation;
}

void RowData::get_annotation_subset(std::vector<Annotation*> &dest,
		                        uint64_t start_sample, uint64_t end_sample)
{  
    std::lock_guard<std::mutex> lock(_global_visitor_mutex);

    for (Annotation *p : _annotations)
    {
        if (p->end_sample() > start_sample && p->start_sample() <= end_sample)
        {
            dest.push_back(p);
        }			               
    }
}

uint64_t RowData::get_annotation_index(uint64_t start_sample)
{
    std::lock_guard<std::mutex> lock(_global_visitor_mutex);
    uint64_t index = 0;

     for (Annotation *p : _annotations){
         if (p->start_sample() > start_sample)
             break;
         index++;
     }

    return index;
}

bool RowData::push_annotation(Annotation *a)
{ 
    assert(a);

    std::lock_guard<std::mutex> lock(_global_visitor_mutex);

    try {
      _annotations.push_back(a);
      _item_count = _annotations.size();
      _max_annotation = max(_max_annotation, a->end_sample() - a->start_sample());

      if (a->end_sample() != a->start_sample()){
        if (_min_annotation == 0){
            _min_annotation = a->end_sample() - a->start_sample();
        }
        else{
            _min_annotation = min(_min_annotation, a->end_sample() - a->start_sample());
        }
      }
          
      return true;
      
    } catch (const std::bad_alloc&) {
      return false;
    }
}
 

bool RowData::get_annotation(Annotation &ann, uint64_t index)
{
    std::lock_guard<std::mutex> lock(_global_visitor_mutex);

    if (index < _annotations.size()) {
        ann = *_annotations[index];
        return true;
    } else {
        return false;
    }
}

} //namespace decode
} //namespace dsv/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include <libsigrokdecode.h>

#include <vector>
#include <assert.h>

#include "annotation.h"
#include "annotationrestable.h"
#include <cstring>
#include <assert.h>
#include <string.h>
#include <stdlib.h>
#include "../config/appconfig.h"
#include "decoderstatus.h"
#include "../basedef.h"
 

namespace dsv {
namespace decode {
 
Annotation::Annotation(const srd_proto_data *const pdata, DecoderStatus *status)
{
	assert(pdata);
	const srd_proto_data_annotation *const pda =
		(const srd_proto_data_annotation*)pdata->data;
	assert(pda);
	assert(status);

	_start_sample =	pdata->start_sample;
	_end_sample	  =	pdata->end_sample;
	_format 	= pda->ann_class;
    _type 		= pda->ann_type;
	_resIndex 	= -1;
	_status 	= status;
 
	//make resource find key
	std::string key;

    char **annotations = pda->ann_text;
    while(annotations && *annotations) {
		if ((*annotations)[0] != '\n'){
			key.append(*annotations, strlen(*annotations));
		}		
		annotations++;  
	}
	
	if (pda->str_number_hex[0]){
		//append numeric string
		key.append(pda->str_number_hex, strlen(pda->str_number_hex));
	}
 
	AnnotationSourceItem *resItem = NULL;
    _resIndex = _status->m_resTable.MakeIndex(key, resItem);
     
     //is a new item
	if (resItem != NULL){ 
        char **annotations = pda->ann_text;
    	while(annotations && *annotations) {
			if ((*annotations)[0] != '\n'){
				resItem->src_lines.push_back(QString::fromUtf8(*annotations));
			}
			annotations++;  
		}
 
		//get numeric data
		if (pda->str_number_hex[0]){
			int str_len = strlen(pda->str_number_hex);

			if (str_len <= DECODER_MAX_DATA_BLOCK_LEN){
				resItem->str_number_hex = (char*)malloc(str_len + 1);
			
				if (resItem->str_number_hex != NULL){
					strcpy(resItem->str_number_hex, pda->str_number_hex);
					resItem->is_numeric = true;
				}
			}			
		}

		_status->m_bNumeric |= resItem->is_numeric;
	}
}

Annotation::Annotation()
{
    _start_sample = 0;
    _end_sample = 0;
	_resIndex = -1;
}
 
Annotation::~Annotation()
{     
}
  
const std::vector<QString>& Annotation::annotations() const
{  
	 AnnotationSourceItem *pobj = _status->m_resTable.GetItem(_resIndex);	 
	 assert(pobj);
	
     AnnotationSourceItem &resItem = *pobj;

	//get origin data, is not a numberic value
     if (!resItem.is_numeric){
        return resItem.src_lines;
     }

	//resItem.str_number_hex must be not null
	if (resItem.str_number_hex[0] == 0){
		assert(false);
	}
 
	 if (resItem.cur_display_format !=  _status->m_format){
		 resItem.cur_display_format = _status->m_format;
		 resItem.cvt_lines.clear();

		 if (resItem.src_lines.size() > 0)
		 { 
			 int 	text_format_buf_len = 0;
			 char  *text_format_buf = NULL;

			 //have custom string
			 for (QString &rd_src : resItem.src_lines)
			 {			
				 QString src = rd_src.replace("{$}", "%s");

				 const char *num_str = _status->m_resTable.format_numberic(resItem.str_number_hex, resItem.cur_display_format);
				 const char *src_str = src.toUtf8().data();
				
				 int textlen = strlen(src_str) + strlen(num_str);
				 assert(textlen > 0);

				 if (textlen >= text_format_buf_len)
				 {
					if (text_format_buf)
						free(text_format_buf);
					text_format_buf = (char*)malloc(textlen + 8);
					text_format_buf_len = textlen + 8;

					assert(text_format_buf);
				 }
				 
				 sprintf(text_format_buf, src_str, num_str);
				 resItem.cvt_lines.push_back(QString(text_format_buf));
			 }

			 if (text_format_buf)
				free(text_format_buf);
		 }
		 else{
			 //have only numberic value
			 const char *num_str = _status->m_resTable.format_numberic(resItem.str_number_hex, resItem.cur_display_format);
			 resItem.cvt_lines.push_back(QString(num_str));
		 }
	 }

	return resItem.cvt_lines;
}       

bool Annotation::is_numberic()
{
    AnnotationSourceItem *resItem = _status->m_resTable.GetItem(_resIndex);
	return resItem->is_numeric;
} 

} // namespace decode
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "annotationrestable.h"
#include <assert.h>
#include <stdlib.h> 
#include <math.h>
#include "../log.h"
#include "../basedef.h"
#include "displaydataformat.h"

namespace dsv {
namespace decode {
 
const char g_bin_cvt_table[] = "0000000100100011010001010110011110001001101010111100110111101111";
 
 char* bin2oct_string(char *buf, int size, const char *bin, int len){
	char *wr = buf + size - 1;
	*wr = 0; //end flag

	char *rd = (char*)bin + len - 1; //move to last byte
	char tmp[3]; 

	while (rd >= bin && wr > buf)
	{  
		wr--;
		int num = 0;

		while (rd >= bin && num < 3)
		{
			tmp[2-num] = *rd;			 
			rd--;
			num++;
		}

		//fill
		while (num < 3)
		{
			tmp[2-num] = '0';
			++num;
		}		

	    if (strncmp(tmp, "000", 3) == 0)
			*wr = '0';
		else if (strncmp(tmp, "001", 3) == 0)
			*wr = '1';
		else if (strncmp(tmp, "010", 3) == 0)
			*wr = '2';
		else if (strncmp(tmp, "011", 3) == 0)
			*wr = '3';
		else if (strncmp(tmp, "100", 3) == 0)
			*wr = '4';
		else if (strncmp(tmp, "101", 3) == 0)
			*wr = '5';
		else if (strncmp(tmp, "110", 3) == 0)
			*wr = '6';
		else if (strncmp(tmp, "111", 3) == 0)
			*wr = '7';
	} 

	return wr;
}

long long bin2long_string(const char *bin, int len)
{
	char *rd = (char *)bin + len - 1; //move to last byte
	int dex = 0;
	long long value = 0;
	long long bv = 0;

    while (rd >= bin)
	{
		if (*rd == '1')
		{
			bv = 1 << dex;
			value += bv;
		}
		rd--;
		++dex;
	}

	return value;
}

//-----------------------------------

AnnotationResTable::AnnotationResTable(){

  }

AnnotationResTable::~AnnotationResTable(){
	reset();
}
 
int AnnotationResTable::MakeIndex(const std::string &key, AnnotationSourceItem* &newItem)
{   
    auto fd = m_indexs.find(key);
    if (fd != m_indexs.end()){
        return (*fd).second;
    } 
  
    AnnotationSourceItem *item = new AnnotationSourceItem();
    m_resourceTable.push_back(item);

    item->cur_display_format = -1;
    item->is_numeric = false;
	item->str_number_hex = NULL;
    newItem = item;
   
    int dex = m_indexs.size();
    m_indexs[key] = dex;
    return dex;
}

AnnotationSourceItem* AnnotationResTable::GetItem(int index){
    if (index < 0 || index >= (int)m_resourceTable.size()){
        assert(false);
    }
    return m_resourceTable[index];
}

const char* AnnotationResTable::format_to_string(const char *hex_str, int fmt)
{ 
    //flow, convert to oct\dec\bin format
	 const char *data = hex_str;
	 if (data[0] == 0 || fmt == DisplayDataFormat::hex){
		 return data;
	 }
	
	 //convert to bin format
	 char *buf = g_bin_format_tmp_buffer + sizeof(g_bin_format_tmp_buffer) - 2;
	 buf[1] = 0; //set the end flag
	 buf[0] = 0;

	 int len = strlen(data);
	  //buffer is not enough
	 if (len > DECODER_MAX_DATA_BLOCK_LEN){
		 return data;
	 }

     char *rd = (char*)data + len - 1; //move to last byte
	 char c = 0;
	 int dex = 0;

	 while (rd >= data)
	 {
		 c = *rd;

 		 if (c >= '0' && c <= '9'){
			 dex = (int)(c - '0');	 
		 }
		 else if (c >= 'A' && c <= 'F'){
			 dex = (int)(c - 'A') + 10;
		 }
		 else if (c >= 'a' && c <= 'f'){
			 dex = (int)(c - 'a') + 10;
		 }
		 else{ 
			 dsv_err("is not a hex string");
			 assert(false);
		 }

         char *ptable = (char*)g_bin_cvt_table + dex * 4;

		 buf -= 4; //move to left for 4 bytes
		 buf[0] = ptable[0];
		 buf[1] = ptable[1];
		 buf[2] = ptable[2];
		 buf[3] = ptable[3];
	
		 rd--;
	 } 

	 //get bin format 
	 if (fmt == DisplayDataFormat::bin){
		  return buf;
	 }

	 //get oct format
	 if (fmt == DisplayDataFormat::oct){
		 char *oct_buf = bin2oct_string(g_oct_format_tmp_buffer, 
		                  sizeof(g_oct_format_tmp_buffer), buf,  len * 4);
		 return oct_buf;
	 }

	//64 bit integer
	 if (fmt == DisplayDataFormat::dec && len * 4 <= 64){
         long long lv = bin2long_string(buf, len * 4);
		 g_number_tmp_64[0] = 0;
    	 sprintf(g_number_tmp_64, "%lld", lv);
         return g_number_tmp_64;
	 }
	 
	 //ascii
	 if (fmt == DisplayDataFormat::ascii && len < 30 - 3){
		 if (len == 2){
             int lv = (int)bin2long_string(buf, len * 4);
			 //can display chars
			 if (lv >= 33 && lv <= 126){
				 sprintf(g_number_tmp_64, "%c", (char)lv);
				 return g_number_tmp_64;
			 }
         }
         g_number_tmp_64[0] = '[';
         strcpy(g_number_tmp_64 + 1, data);
         g_number_tmp_64[len+1] = ']';
         g_number_tmp_64[len+2] = 0;
         return g_number_tmp_64;
	 }

    return data;    
}

const char* AnnotationResTable::format_numberic(const char *hex_str, int fmt)
{
	 assert(hex_str);

	 if (hex_str[0] == 0 || fmt == DisplayDataFormat::hex){
		 return hex_str;
	 }

	 //check if have split letter
	 const char *rd = hex_str;
	 bool bMutil = false;
	 char c = 0;

	 while (*rd)
	 {
		 c = *rd;
		 rd++;

		 if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))
		 {
			continue;
		 }

		 bMutil = true;
		 break;
	 }

	 if (!bMutil){
		 return format_to_string(hex_str, fmt);
	 }

	 //convert each sub string 
	 char sub_buf[DECODER_MAX_DATA_BLOCK_LEN + 1];
	 char *sub_wr = sub_buf;
	 char *sub_end = sub_wr + DECODER_MAX_DATA_BLOCK_LEN;
	 char *all_buf = g_all_buf;
	 char *all_wr = all_buf;

	 rd = hex_str; 

	 while (*rd)
	 {
		  c = *rd;
		  rd++;

		  if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f')){
			  if (sub_wr == sub_end){
				  printf("conver error,sub string length is too long!\n");
				  return hex_str;
			  }

			  *sub_wr = c; //make sub string
			  sub_wr++;
			  continue;
		  }

		  //convert sub string
		  if (sub_wr != sub_buf){
			  *sub_wr = 0;
			  const char *sub_str = format_to_string(sub_buf, fmt);
			  unsigned int sublen = (unsigned int)strlen(sub_str);

			  if ((all_wr - all_buf) + sublen >  CONVERT_STR_MAX_LEN){
				printf("convert error,write buffer is full!\n");
				return hex_str;
			  }

			  strncpy(all_wr, sub_str, sublen);
			  all_wr += sublen;
			  sub_wr = sub_buf; //reset write buffer
		  }

		  //the split letter
		  if ((all_wr - all_buf) + 1 >  CONVERT_STR_MAX_LEN){
				printf("convert error,write buffer is full!\n");
				return hex_str;
		  }

		  *all_wr = c;
		  all_wr++;
	 }

	  //convert the last sub string
	 if (sub_wr != sub_buf)
	 {
		 *sub_wr = 0;
		 const char *sub_str = format_to_string(sub_buf, fmt);
		 unsigned int sublen = (unsigned int)strlen(sub_str);

		 if ((all_wr - all_buf) + sublen > CONVERT_STR_MAX_LEN)
		 {
			printf("convert error,write buffer is full!\n");
			return hex_str;
		 }

		 strncpy(all_wr, sub_str, sublen);
		 all_wr += sublen;		
	 }

	 *all_wr = 0;

	 return all_buf;
}

void AnnotationResTable::reset()
{
	//release all resource
	for (auto p : m_resourceTable){
		if (p->str_number_hex)
			free(p->str_number_hex);
		delete p;
	}
	m_resourceTable.clear();
	m_indexs.clear();
}

int AnnotationResTable::hexToDecimal(char * hex)
{
	assert(hex);
    int len = strlen(hex);

    double b = 16;
    int result = 0;
    char *p = hex;

    while(*p) {
        if(*p >= '0' && *p <= '9')
            result += (int)pow(b, --len) * (*p - '0');
        else if(*p >= 'a' && *p <= 'f')
            result += (int)pow(b, --len) * (*p - 'a' + 10);
        else if(*p >= 'A' && *p <= 'F')
            result += (int)pow(b, --len) * (*p - 'A' + 10);

        p++;
    }

    return result;
}

void AnnotationResTable::decimalToBinString(unsigned long long num, int bitSize, char *buffer, int buffer_size)
{

	assert(buffer);
	assert(buffer_size);
	 
	if (bitSize < 8)
		bitSize = 8;
	if (bitSize > 64)
		bitSize = 64;

	assert(bitSize < buffer_size);

	int v;
	char *wr = buffer + bitSize;
	*wr = 0;
	wr--;

	while (num > 0 && wr >= buffer)
	{
		v = num % 2;
		*wr = v ? '1' : '0';
		wr--;
		num = num / 2;
	}

	while (wr >= buffer)
	{
		*wr = '0';
		wr--;
	}
}

} //namespace decode
} //namespace dsv
 
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#include <map>
#include <string>
#include <vector>
#include <QString>

#ifndef DECODE_ANNOTATION_RES_TABLE_H
#define DECODE_ANNOTATION_RES_TABLE_H

#define DECODER_MAX_DATA_BLOCK_LEN 256
#define CONVERT_STR_MAX_LEN 150

namespace dsv {
namespace decode {

struct AnnotationSourceItem
{
    bool    is_numeric;
    char    *str_number_hex; //numerical value hex format string

    std::vector<QString> src_lines; //the origin source string lines
    std::vector<QString> cvt_lines; //the converted to bin/hex/oct format string lines
    int     cur_display_format; //current format  as bin/ex/oct..., init with -1
};
 
class AnnotationResTable
{ 
    public:
    AnnotationResTable();
    ~AnnotationResTable();

    public:
       int MakeIndex(const std::string &key, AnnotationSourceItem* &newItem);
       AnnotationSourceItem* GetItem(int index);

       inline int GetCount(){
           return m_resourceTable.size();} 

       const char* format_numberic(const char *hex_str, int fmt);

       void reset();

       static int hexToDecimal(char * hex);
       static void decimalToBinString(unsigned long long num, int bitSize, char *buffer, int buffer_size);

    private:
        const char* format_to_string(const char *hex_str, int fmt);

    private:
        std::map<std::string, int>          m_indexs;
        std::vector<AnnotationSourceItem*>  m_resourceTable;
        char g_bin_format_tmp_buffer[DECODER_MAX_DATA_BLOCK_LEN * 4 + 2];
        char g_oct_format_tmp_buffer[DECODER_MAX_DATA_BLOCK_LEN * 3 + 2];
        char g_number_tmp_64[30];
        char g_all_buf[CONVERT_STR_MAX_LEN + 1];
};

} //namespace decode
} //namespace dsv

#endif
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DECODE_DECODER_STATUS_H
#define DECODE_DECODER_STATUS_H

#include "annotationrestable.h"

namespace dsv{
namespace decode{

class DecoderStatus
{
public:
    DecoderStatus();

    void clear();  

public:
    bool    m_bNumeric; //when decoder get any numerical data,it will be set
    int     m_format; //protocol format code
    void    *sdr_decoder_handle;
    AnnotationResTable  m_resTable; 
};

} //namespace decode
} //namespace dsv

#endif //DECODE_DECODER_STATUS_H
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2014 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include <libsigrokdecode.h>
#include "decoder.h"
#include <assert.h>

namespace dsv{
namespace decode{

Decoder::Decoder(const srd_decoder *const dec):
    _decoder(dec)
{
	_shown = true;
	_setted = true;
	_decode_start = 0;
	_decode_end = 0;
	_decode_start_back = 0;
	_decode_end_back = 0;
}

Decoder::~Decoder()
{
    for (auto i = _options_back.begin(); i != _options_back.end(); i++){
        if ((*i).second)
            g_variant_unref((*i).second);
	}
}
  
void Decoder::set_probes(std::map<const srd_channel*, int> probes)
{
    _probes_back = probes;
    _setted = true;
}
  
void Decoder::set_option(const char *id, GVariant *value)
{
	assert(value);
    if (_options_back[id]) {
        g_variant_unref(_options_back[id]);
    }
	g_variant_ref(value);
    _options_back[id] = value;
    _setted = true;
}

void Decoder::set_decode_region(uint64_t start, uint64_t end)
{
    _decode_start_back = start;
    _decode_end_back = end;
	
    if (_decode_start != start || _decode_end != end){
		_setted = true;
	} 
}
  
//apply setting
bool Decoder::commit()
{
    if (_setted) {
        _probes = _probes_back;
        _options = _options_back;
        _decode_start = _decode_start_back;
        _decode_end = _decode_end_back;
        _setted = false;
        return true;
    } else {
        return false;
    }
}

bool Decoder::have_required_probes()
{
	for (GSList *l = _decoder->channels; l; l = l->next) {
		const srd_channel *const pdch = (const srd_channel*)l->data;
		assert(pdch);
		if (_probes.find(pdch) == _probes.end())
			return false;
	}

	return true;
}

srd_decoder_inst* Decoder::create_decoder_inst(srd_session *session)
{
	GHashTable *const opt_hash = g_hash_table_new_full(g_str_hash,
		g_str_equal, g_free, (GDestroyNotify)g_variant_unref);

	for (auto i = _options.begin(); i != _options.end(); i++)
	{
		GVariant *const value = (*i).second;
		g_variant_ref(value);
		g_hash_table_replace(opt_hash, (void*)g_strdup(
			(*i).first.c_str()), value);
	}

	srd_decoder_inst *const decoder_inst = srd_inst_new(
		session, _decoder->id, opt_hash);
	g_hash_table_destroy(opt_hash);

	if(!decoder_inst)
		return NULL;

	// Setup the probes
	GHashTable *const probes = g_hash_table_new_full(g_str_hash,
		g_str_equal, g_free, (GDestroyNotify)g_variant_unref);

    for(auto it = _probes.begin(); it != _probes.end(); it++)
	{
        GVariant *const gvar = g_variant_new_int32((*it).second);
		g_variant_ref_sink(gvar);
		g_hash_table_insert(probes, (*it).first->id, gvar);
	}

    srd_inst_channel_set_all(decoder_inst, probes);

	return decoder_inst;
}
 

} //namespace decode
} //namespace dsv
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2013 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DECODE_ANNOTATION_H
#define DECODE_ANNOTATION_H

#include <stdint.h>
#include <QString>
#include <vector>

struct srd_proto_data;

namespace dsv {
namespace decode {

class AnnotationResTable;
class DecoderStatus;

//create at DecoderStack.annotation_callback
class Annotation
{
public:
	Annotation(const srd_proto_data *const pdata, DecoderStatus *status);
    Annotation();
	~Annotation();

public:
	inline uint64_t start_sample() const{
		return _start_sample;
	}

	inline uint64_t end_sample() const{
		return _end_sample;
	}

	inline int format() const{
		return _format;
	}

    inline int type() const{
		return _type;
	}  

	bool is_numberic();

	const std::vector<QString>& annotations() const;

private:
	uint64_t 		_start_sample;
	uint64_t 		_end_sample;
	short 			_format;
	short 			_type;
	int 			_resIndex;
	DecoderStatus 	*_status; /*a global variable*/
};

} //namespace decode
} //namespace dsv

#endif // DSVIEW_PV_VIEW_DECODE_ANNOTATION_H
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2014 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DECODE_ROWDATA_H
#define DECODE_ROWDATA_H

#include <vector> 
#include <mutex>

#include "annotation.h"

namespace dsv{
namespace decode{

class RowData
{
public:
	RowData();
    ~RowData();

public:
	uint64_t get_max_sample();

    uint64_t get_max_annotation();
    uint64_t get_min_annotation();	

    uint64_t get_annotation_index(uint64_t start_sample);

    bool push_annotation(Annotation *a);

    inline uint64_t get_annotation_size(){
        return _item_count;
    }

    bool get_annotation(Annotation &ann, uint64_t index);

     /**
	 * Extracts sorted annotations between two period into a vector.
	 */
	void get_annotation_subset(std::vector<Annotation*> &dest,
		                        uint64_t start_sample, uint64_t end_sample);

    void clear();

private:
    uint64_t        _max_annotation;
    uint64_t        _min_annotation;
    uint64_t        _item_count;
	std::vector<Annotation*> _annotations;
    static std::mutex _global_visitor_mutex;
};

} //namespace decode
} //namespace dsv

#endif // DECODE_ROWDATA_H
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2014 Joel Holdsworth <joel@airwebreathe.org.uk>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DECODE_ROW_H
#define DECODE_ROW_H

#include <vector>

#include "annotation.h"

struct srd_decoder;
struct srd_decoder_annotation_row;

namespace dsv{
namespace decode{

//map find key data
class Row
{
public:
	Row();

	Row(const srd_decoder *decoder,
        const srd_decoder_annotation_row *row = NULL,
        const int order = -1);

	Row(const Row &o);

	Row& operator=(const Row &o);

public: 

	inline const srd_decoder* decoder() const{
		return _decoder;
	}

	inline const srd_decoder_annotation_row* row() const{
		return _row;
	}

    QString title() const;

	QString title_id() const;

    bool operator<(const Row &other)const;

private:
	const srd_decoder *_decoder;
	const srd_decoder_annotation_row *_row;
    int _order; 
};

} //namespace decode
} //namespace dsv

#endif // DECODE_ROW_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2022 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef _DSV_LOG_H_
#define _DSV_LOG_H_

#include <log/xlog.h>
#include <QString>

extern xlog_writer *dsv_log;

#define LOG_PREFIX "" 
#define dsv_err(fmt, args...) xlog_err(dsv_log, LOG_PREFIX fmt, ## args)
#define dsv_warn(fmt, args...) xlog_warn(dsv_log, LOG_PREFIX fmt, ## args)
#define dsv_info(fmt, args...) xlog_info(dsv_log, LOG_PREFIX fmt, ## args)
#define dsv_dbg(fmt, args...) xlog_dbg(dsv_log, LOG_PREFIX fmt, ## args)
#define dsv_detail(fmt, args...) xlog_detail(dsv_log, LOG_PREFIX fmt, ## args)

namespace dsv{

void dsv_log_init();
void dsv_log_uninit();

xlog_context* dsv_log_context();
void dsv_log_level(int l);

void dsv_log_enalbe_logfile(bool append);
void dsv_remove_log_file();
void dsv_clear_log_file();
void dsv_set_log_file_enable(bool flag);

QString get_dsv_log_path();

} //namespace dsv

#endif/****************************************************************************
** Meta object code from reading C++ file 'devmode.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "devmode.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'devmode.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDevModeENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDevModeENDCLASS = QtMocHelpers::stringData(
    "dsv::view::DevMode",
    "set_device",
    "",
    "on_mode_change",
    "on_close"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDevModeENDCLASS_t {
    uint offsetsAndSizes[10];
    char stringdata0[19];
    char stringdata1[11];
    char stringdata2[1];
    char stringdata3[15];
    char stringdata4[9];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDevModeENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDevModeENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDevModeENDCLASS = {
    {
        QT_MOC_LITERAL(0, 18),  // "dsv::view::DevMode"
        QT_MOC_LITERAL(19, 10),  // "set_device"
        QT_MOC_LITERAL(30, 0),  // ""
        QT_MOC_LITERAL(31, 14),  // "on_mode_change"
        QT_MOC_LITERAL(46, 8)   // "on_close"
    },
    "dsv::view::DevMode",
    "set_device",
    "",
    "on_mode_change",
    "on_close"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEviewSCOPEDevModeENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       3,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   32,    2, 0x0a,    1 /* Public */,
       3,    0,   33,    2, 0x0a,    2 /* Public */,
       4,    0,   34,    2, 0x0a,    3 /* Public */,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::view::DevMode::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDevModeENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEviewSCOPEDevModeENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDevModeENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<DevMode, std::true_type>,
        // method 'set_device'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_mode_change'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_close'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::view::DevMode::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<DevMode *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->set_device(); break;
        case 1: _t->on_mode_change(); break;
        case 2: _t->on_close(); break;
        default: ;
        }
    }
    (void)_a;
}

const QMetaObject *dsv::view::DevMode::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::view::DevMode::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDevModeENDCLASS.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "IFontForm"))
        return static_cast< IFontForm*>(this);
    return QWidget::qt_metacast(_clname);
}

int dsv::view::DevMode::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 3)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 3;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 3)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 3;
    }
    return _id;
}
QT_WARNING_POP
/****************************************************************************
** Meta object code from reading C++ file 'decodetrace.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "decodetrace.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'decodetrace.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDecodeTraceENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDecodeTraceENDCLASS = QtMocHelpers::stringData(
    "dsv::view::DecodeTrace",
    "decoded_progress",
    "",
    "progress",
    "on_new_decode_data",
    "on_decode_done"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDecodeTraceENDCLASS_t {
    uint offsetsAndSizes[12];
    char stringdata0[23];
    char stringdata1[17];
    char stringdata2[1];
    char stringdata3[9];
    char stringdata4[19];
    char stringdata5[15];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDecodeTraceENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDecodeTraceENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDecodeTraceENDCLASS = {
    {
        QT_MOC_LITERAL(0, 22),  // "dsv::view::DecodeTrace"
        QT_MOC_LITERAL(23, 16),  // "decoded_progress"
        QT_MOC_LITERAL(40, 0),  // ""
        QT_MOC_LITERAL(41, 8),  // "progress"
        QT_MOC_LITERAL(50, 18),  // "on_new_decode_data"
        QT_MOC_LITERAL(69, 14)   // "on_decode_done"
    },
    "dsv::view::DecodeTrace",
    "decoded_progress",
    "",
    "progress",
    "on_new_decode_data",
    "on_decode_done"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEviewSCOPEDecodeTraceENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       3,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   32,    2, 0x06,    1 /* Public */,

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       4,    0,   35,    2, 0x08,    3 /* Private */,
       5,    0,   36,    2, 0x08,    4 /* Private */,

 // signals: parameters
    QMetaType::Void, QMetaType::Int,    3,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::view::DecodeTrace::staticMetaObject = { {
    QMetaObject::SuperData::link<Trace::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDecodeTraceENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEviewSCOPEDecodeTraceENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDecodeTraceENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<DecodeTrace, std::true_type>,
        // method 'decoded_progress'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'on_new_decode_data'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_decode_done'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::view::DecodeTrace::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<DecodeTrace *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->decoded_progress((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 1: _t->on_new_decode_data(); break;
        case 2: _t->on_decode_done(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (DecodeTrace::*)(int );
            if (_t _q_method = &DecodeTrace::decoded_progress; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
    }
}

const QMetaObject *dsv::view::DecodeTrace::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::view::DecodeTrace::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDecodeTraceENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return Trace::qt_metacast(_clname);
}

int dsv::view::DecodeTrace::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = Trace::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 3)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 3;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 3)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 3;
    }
    return _id;
}

// SIGNAL 0
void dsv::view::DecodeTrace::decoded_progress(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_VIEW_RULER_H
#define DSVIEW_PV_VIEW_RULER_H

#include <QWidget>
#include <stdint.h>

namespace dsv {
namespace view {

class TimeMarker;
class View;

//the rule panel on the top
//created by View
class Ruler : public QWidget
{
	Q_OBJECT

private:
	static const int MinorTickSubdivision;
	static const int ScaleUnits[3];
    static const int MinPeriodScale;

	static const QString SIPrefixes[9];
    static const QString FreqPrefixes[9];
	static const int FirstSIPrefixPower;
    static const int pricision;

	static const int HoverArrowSize;
    static const int CursorSelWidth;

public:
    static const QColor CursorColor[8];

public:
	Ruler(View &parent);

    static QString format_time(double t, int prefix,
        unsigned precision = pricision);
    static QString format_freq(double period, unsigned precision = pricision);
    QString format_time(double t);
    static QString format_real_time(uint64_t delta_index, uint64_t sample_rate);
    static QString format_real_freq(uint64_t delta_index, uint64_t sample_rate);

    TimeMarker* get_grabbed_cursor();
    void set_grabbed_cursor(TimeMarker* grabbed_marker);
    void rel_grabbed_cursor();

    double get_min_period();

private:
	void paintEvent(QPaintEvent *event);

	void mouseMoveEvent(QMouseEvent *e);
    void mousePressEvent(QMouseEvent *event);
    void mouseReleaseEvent(QMouseEvent *event);
    void leaveEvent(QEvent *);

private:
    void draw_logic_tick_mark(QPainter &p);
    void draw_osc_tick_mark(QPainter &p);
	/**
	 * Draw a hover arrow under the cursor position.
	 */
	void draw_hover_mark(QPainter &p);

    void draw_cursor_sel(QPainter &p);

    int in_cursor_sel_rect(QPointF pos);

    QRectF get_cursor_sel_rect(int index);

private slots:
	void hover_point_changed();

private:
	View &_view;

    bool _cursor_sel_visible;
    bool _cursor_go_visible;
    int _cursor_sel_x;

	TimeMarker *_grabbed_marker;

    double _min_period;

    unsigned int _cur_prefix;
    bool _hitCursor;
    bool _curs_moved;
};

} // namespace view
} // namespace dsv

#endif // DSVIEW_PV_VIEW_RULER_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "dsosignal.h"
#include <QTimer>
#include <functional>
#include <QApplication>
#include <math.h>
#include "view.h"
#include "../basedef.h"
#include "../data/dsosnapshot.h"
#include "../appcore/sigsession.h" 
#include "../log.h"
#include "../appcore/appcontrol.h"
 
using namespace std;

namespace dsv {
namespace view {

const QString DsoSignal::vDialUnit[DsoSignal::vDialUnitCount] = {
    "mV",
    "V",
};

const QColor DsoSignal::SignalColours[4] = {
    QColor(238, 178, 17, 255),  // dsYellow
    QColor(0, 153, 37, 255),    // dsGreen
    QColor(213, 15, 37, 255),   // dsRed
    QColor(17, 133, 209, 255)  // dsBlue

};

const float DsoSignal::EnvelopeThreshold = 256.0f;

DsoSignal::DsoSignal(data::DsoSnapshot *data,
                     sr_channel *probe):
    Signal(probe),
    _data(data), 
    _hover_point(QPointF(-1, -1))
{
    QVector<uint64_t> vValue;
    QVector<QString> vUnit;

    for(uint64_t i = 0; i < vDialUnitCount; i++){
        vUnit.append(vDialUnit[i]);
    }
    
    _vDial = NULL;
    _period = 0;
    _pcount = 0;
    _scale = 0;
    _en_lock = false;
    _show = true;
    _vDialActive = false;
    _mValid = false;
    _level_valid = false;
    _autoV = false;
    _autoH = false;
    _autoV_over = false;
    _auto_cnt = 0;
    _hover_en = false;
    _hover_index = 0;
    _hover_value = 0;

    GVariant *gvar_list, *gvar_list_vdivs;

    gvar_list = session->get_device()->get_config_list(NULL, SR_CONF_PROBE_VDIV);
    
    if (gvar_list != NULL)
    {
        assert(gvar_list);
        if ((gvar_list_vdivs = g_variant_lookup_value(gvar_list,
                "vdivs", G_VARIANT_TYPE("at")))) {
            GVariant *gvar;
            GVariantIter iter;
            g_variant_iter_init(&iter, gvar_list_vdivs);

            while(NULL != (gvar = g_variant_iter_next_value(&iter))) {
                vValue.push_back(g_variant_get_uint64(gvar));
                g_variant_unref(gvar);
            }
            
            g_variant_unref(gvar_list_vdivs);
            g_variant_unref(gvar_list);
        }
    }
    _vDial = new dslDial(vValue.count(), vDialValueStep, vValue, vUnit);
    _colour = SignalColours[probe->index % countof(SignalColours)];

    load_settings();
}

DsoSignal::~DsoSignal()
{
    DESTROY_OBJECT(_vDial);  
}

void DsoSignal::set_scale(int height)
{
    _scale = height / (_ref_max - _ref_min) * _stop_scale;
}

void DsoSignal::set_enable(bool enable)
{  
    if (session->get_device()->is_hardware_logic() 
        && get_index() == 0){
        return;
    }

    _en_lock = true;
    bool cur_enable;
    bool ret;
    ret = session->get_device()->get_config_bool(SR_CONF_PROBE_EN, cur_enable, _probe, NULL);

    if (!ret) { 
        dsv_err("ERROR: config_get SR_CONF_PROBE_EN failed.");
        _en_lock = false;
        return;
    }
    if (cur_enable == enable) {
        _en_lock = false;
        return;
    }

    bool running =  false;

    if (session->is_running_status()) {
        running = true;
        session->stop_capture();
    }

    while(session->is_running_status())
        QCoreApplication::processEvents();

    set_vDialActive(false);
    session->get_device()->set_config_bool( SR_CONF_PROBE_EN,
                          enable, _probe, NULL);

    _view->update_hori_res();
    
    if (running) {
       session->stop_capture();
       session->start_capture(false);
    }

    _view->set_update(_viewport, true);
    _view->update();
    _en_lock = false;
}

void DsoSignal::set_vDialActive(bool active)
{
    if (enabled())
        _vDialActive = active;
}

bool DsoSignal::go_vDialPre(bool manul)
{  
    if (_autoV && manul)
        autoV_end(); 

    if (enabled() && !_vDial->isMin()) 
    {
        if (session->is_running_status())
            session->refresh(RefreshShort);

        const double pre_vdiv = _vDial->get_value();
        _vDial->set_sel(_vDial->get_sel() - 1);

        session->get_device()->set_config_uint64(SR_CONF_PROBE_VDIV,
                              _vDial->get_value(), _probe, NULL);

        if (session->is_stopped_status()) {
            set_stop_scale(_stop_scale * (pre_vdiv/_vDial->get_value()));
            set_scale(get_view_rect().height());
        }
        session->get_device()->set_config_uint16(SR_CONF_PROBE_OFFSET,
                              _zero_offset, _probe, NULL);

        _view->vDial_updated();
        _view->set_update(_viewport, true);
        _view->update();
        return true;
    }
    else {
        if (_autoV && !_autoV_over)
            autoV_end();
        return false;
    }
}

bool DsoSignal::go_vDialNext(bool manul)
{
    if (_autoV && manul)
        autoV_end(); 

    if (enabled() && !_vDial->isMax())
    {
        if (session->is_running_status())
            session->refresh(RefreshShort);

        const double pre_vdiv = _vDial->get_value();
        _vDial->set_sel(_vDial->get_sel() + 1);

        session->get_device()->set_config_uint64(SR_CONF_PROBE_VDIV,
                              _vDial->get_value(), _probe, NULL);

        if (session->is_stopped_status()) {
            set_stop_scale(_stop_scale * (pre_vdiv/_vDial->get_value()));
            set_scale(get_view_rect().height());
        }
        session->get_device()->set_config_uint16(SR_CONF_PROBE_OFFSET,
                              _zero_offset, _probe, NULL);

        _view->vDial_updated();
        _view->set_update(_viewport, true);
        _view->update();
        return true;
    } 
    else {
        if (_autoV && !_autoV_over)
            autoV_end();
        return false;
    }
}

bool DsoSignal::load_settings()
{
    int v;
    uint32_t ui32;
    bool ret;

    // dso channel bits
    ret = session->get_device()->get_config_byte(SR_CONF_UNIT_BITS, v);
    if (ret) {
        _bits = (uint8_t)v;
    } 
    else {
        _bits = DefaultBits; 
        dsv_warn("%s%d", "Warning: config_get SR_CONF_UNIT_BITS failed, set to %d(default).", DefaultBits);

        if (session->get_device()->is_hardware())
            return false;
    }

    ret = session->get_device()->get_config_uint32(SR_CONF_REF_MIN, ui32);
    if (ret) 
        _ref_min = (double)ui32;
    else
        _ref_min = 1;
    
    ret = session->get_device()->get_config_uint32(SR_CONF_REF_MAX, ui32);
    if (ret)
        _ref_max = (double)ui32;
    else
        _ref_max = ((1 << _bits) - 1);

    // -- vdiv
    uint64_t vdiv;
    uint64_t vfactor;
    ret = session->get_device()->get_config_uint64(SR_CONF_PROBE_VDIV, vdiv, _probe, NULL);
    if (!ret) {
        dsv_err("ERROR: config_get SR_CONF_PROBE_VDIV failed.");
        return false;
    }

    ret = session->get_device()->get_config_uint64(SR_CONF_PROBE_FACTOR, vfactor, _probe, NULL);
    if (!ret) {
        dsv_err("ERROR: config_get SR_CONF_PROBE_FACTOR failed.");
        return false;
    }

    _vDial->set_value(vdiv);
    _vDial->set_factor(vfactor);

    // -- coupling
    ret = session->get_device()->get_config_byte(SR_CONF_PROBE_COUPLING, v, _probe, NULL);
    if (ret) {
        _acCoupling = uint8_t(v);
    }
    else { 
        dsv_err("ERROR: config_get SR_CONF_PROBE_COUPLING failed.");
        return false;
    }
 
    // -- vpos
    ret = session->get_device()->get_config_uint16(SR_CONF_PROBE_OFFSET, _zero_offset, _probe, NULL);
    if (!ret) {
        dsv_err("ERROR: config_get SR_CONF_PROBE_OFFSET failed.");
        return false;
    }

    // -- trig_value
    ret = session->get_device()->get_config_byte(SR_CONF_TRIGGER_VALUE, _trig_value, _probe, NULL);
    if (ret) { 
        _trig_delta = get_trig_vrate() - get_zero_ratio();
    }
    else {
        dsv_err("ERROR: config_get SR_CONF_TRIGGER_VALUE failed.");

        if (session->get_device()->is_hardware())
            return false;
    }

    if (_view) {
        _view->set_update(_viewport, true);
        _view->update();
    }
    return true;
}

int DsoSignal::commit_settings()
{
    int ret;

    // -- enable
    ret = session->get_device()->set_config_bool(SR_CONF_PROBE_EN,
                                enabled(), _probe, NULL);

    // -- vdiv
    ret = session->get_device()->set_config_uint64(SR_CONF_PROBE_VDIV,
                                _vDial->get_value(), _probe, NULL);
    ret = session->get_device()->set_config_uint64(SR_CONF_PROBE_FACTOR,
                                _vDial->get_factor(), _probe, NULL);

    // -- coupling
    ret = session->get_device()->set_config_byte(SR_CONF_PROBE_COUPLING,
                                _acCoupling, _probe, NULL);

    // -- offset
    ret = session->get_device()->set_config_uint16(SR_CONF_PROBE_OFFSET,
                                _zero_offset, _probe, NULL);

    // -- trig_value
    session->get_device()->set_config_byte(SR_CONF_TRIGGER_VALUE,
                          _trig_value, _probe, NULL);

    return ret;
}

uint64_t DsoSignal::get_vDialValue()
{
    return _vDial->get_value();
}

uint16_t DsoSignal::get_vDialSel()
{
    return _vDial->get_sel();
}

void DsoSignal::set_acCoupling(uint8_t coupling)
{
    if (enabled()) {
        _acCoupling = coupling; 
        session->get_device()->set_config_byte(SR_CONF_PROBE_COUPLING,
                              _acCoupling, _probe, NULL);
    }
}

int DsoSignal::ratio2value(double ratio)
{
    return ratio * (_ref_max - _ref_min) + _ref_min;
}

int DsoSignal::ratio2pos(double ratio)
{
    return ratio * get_view_rect().height() + get_view_rect().top();
}

double DsoSignal::value2ratio(int value)
{
    return max(0.0, (value - _ref_min) / (_ref_max - _ref_min));
}

double DsoSignal::pos2ratio(int pos)
{
    return min(max(pos - get_view_rect().top(), 0), get_view_rect().height()) * 1.0 / get_view_rect().height();
}

double DsoSignal::get_trig_vrate()
{ 
    if (session->get_device()->is_hardware_logic())
        return value2ratio(_trig_value - ratio2value(0.5)) + get_zero_ratio();
    else
        return value2ratio(_trig_value);
}

void DsoSignal::set_trig_vpos(int pos, bool delta_change)
{
    assert(_view);
    if (enabled()) {
        set_trig_ratio(pos2ratio(pos), delta_change);
    }
}

void DsoSignal::set_trig_ratio(double ratio, bool delta_change)
{
    double delta = ratio; 

    if (session->get_device()->is_hardware_logic()) {
        delta = delta - get_zero_ratio();
        delta = min(delta, 0.5);
        delta = max(delta, -0.5);
        _trig_value = ratio2value(delta + 0.5);
    }
    else {
        if (delta < 0.06f)
            delta = 0.06f;
        if (delta > 0.945f)
            delta = 0.945f;

        _trig_value = ratio2value(delta);
    }
 
    if (delta_change)
        _trig_delta = get_trig_vrate() - get_zero_ratio();
    session->get_device()->set_config_byte(SR_CONF_TRIGGER_VALUE,
                          _trig_value, _probe, NULL);
}

int DsoSignal::get_zero_vpos()
{
    return ratio2pos(get_zero_ratio());
}

double DsoSignal::get_zero_ratio()
{
    return value2ratio(_zero_offset);
}

int DsoSignal::get_hw_offset()
{
    int hw_offset = 0;
    session->get_device()->get_config_uint16(SR_CONF_PROBE_HW_OFFSET, hw_offset, _probe, NULL);
    return hw_offset;
}

void DsoSignal::set_zero_vpos(int pos)
{
    if (enabled()) {
        set_zero_ratio(pos2ratio(pos));
        set_trig_ratio(_trig_delta + get_zero_ratio(), false);
    }
}

void DsoSignal::set_zero_ratio(double ratio)
{
    _zero_offset = ratio2value(ratio); 
    session->get_device()->set_config_uint16(SR_CONF_PROBE_OFFSET,
                          _zero_offset, _probe, NULL);
}

void DsoSignal::set_factor(uint64_t factor)
{
    if (enabled()) {
        uint64_t prefactor = 0; 
        bool ret;

        ret = session->get_device()->get_config_uint64(SR_CONF_PROBE_FACTOR, prefactor, _probe, NULL);
        if (!ret) { 
            dsv_err("ERROR: config_get SR_CONF_PROBE_FACTOR failed.");
            return;
        }

        if (prefactor != factor) {
            session->get_device()->set_config_uint64(SR_CONF_PROBE_FACTOR,
                                  factor, _probe, NULL);
            _vDial->set_factor(factor);
            _view->set_update(_viewport, true);
            _view->update();
        }
    }
}

uint64_t DsoSignal::get_factor()
{ 
    uint64_t factor; 

    bool ret = session->get_device()->get_config_uint64(SR_CONF_PROBE_FACTOR, factor, _probe, NULL);
    if (ret) {
        return factor;
    } 
    else { 
        dsv_err("ERROR: config_get SR_CONF_PROBE_FACTOR failed.");
        return 1;
    }
}

QString DsoSignal::get_measure(enum DSO_MEASURE_TYPE type)
{
    const QString mNone = "--";
    QString mString;

    if (_data->empty()){
        return mNone;
    }

    if (_mValid) {
        const int hw_offset = get_hw_offset();

        switch(type) {
        case DSO_MS_AMPT:
            if (_level_valid)
                mString = get_voltage(_high - _low, 2);
            else
                mString = mNone;
            break;
        case DSO_MS_VHIG:
            if (_level_valid)
                mString = get_voltage(hw_offset - _low, 2);
            else
                mString = mNone;
            break;
        case DSO_MS_VLOW:
            if (_level_valid)
                mString = get_voltage(hw_offset - _high, 2);
            else
                mString = mNone;
            break;
        case DSO_MS_VP2P:
            mString = get_voltage(_max - _min, 2);
            break;
        case DSO_MS_VMAX:
            mString = get_voltage(hw_offset - _min, 2);
            break;
        case DSO_MS_VMIN:
            mString = get_voltage(hw_offset - _max, 2);
            break;
        case DSO_MS_PERD:
            mString = get_time(_period);
            break;
        case DSO_MS_FREQ: 
            if (_period == 0)
                mString = mNone;
            else if (abs(_period) > 1000000)
                mString = QString::number(1000000000/_period, 'f', 2) + "Hz";
            else if (abs(_period) > 1000)
                mString = QString::number(1000000/_period, 'f', 2) + "kHz";
            else
                mString = QString::number(1000/_period, 'f', 2) + "MHz";
            break;
        case DSO_MS_VRMS:
            mString = get_voltage(_rms, 2);
            break;
        case DSO_MS_VMEA:
            mString = get_voltage(_mean, 2);
            break;
        case DSO_MS_NOVR:
            if (_level_valid && (_high - _low != 0) )
                mString = QString::number((_max - _high) * 100.0 / (_high - _low), 'f', 2) + "%";
            else
                mString = mNone;
            break;
        case DSO_MS_POVR:
            if (_level_valid && (_high - _low != 0) )
                mString = QString::number((_low - _min) * 100.0 / (_high - _low), 'f', 2) + "%";
            else
                mString = mNone;
            break;
        case DSO_MS_PDUT:
            if (_level_valid && _period != 0)
                mString = QString::number(_high_time / _period * 100, 'f', 2)+"%";
            else
                mString = mNone;
            break;
        case DSO_MS_NDUT:
            if (_level_valid && _period != 0)
                mString = QString::number(100 - _high_time / _period * 100, 'f', 2)+"%";
            else
                mString = mNone;
            break;
        case DSO_MS_PWDT:
            if (_level_valid)
                mString = get_time(_high_time);
            else
                mString = mNone;
            break;
        case DSO_MS_NWDT:
            if (_level_valid)
                mString = get_time(_period - _high_time);
            else
                mString = mNone;
            break;
        case DSO_MS_RISE:
            if (_level_valid)
                mString = get_time(_rise_time);
            else
                mString = mNone;
            break;
        case DSO_MS_FALL:
            if (_level_valid)
                mString = get_time(_fall_time);
            else
                mString = mNone;
            break;
        case DSO_MS_BRST:
            if (_level_valid)
                mString = get_time(_burst_time);
            else
                mString = mNone;
            break;
        case DSO_MS_PCNT:
            if (_level_valid)
                mString = (_pcount > 1000000 ? QString::number(_pcount/1000000, 'f', 6) + "M" :
                           _pcount > 1000 ? QString::number(_pcount/1000, 'f', 3) + "K" : QString::number(_pcount, 'f', 0));
            else
                mString = mNone;
            break;
        default:
            mString = "Error";
            break;
        }
    } else {
        mString = mNone;
    }
    return mString;
}

QRect DsoSignal::get_view_rect()
{
    assert(_viewport);
    return QRect(0, UpMargin,
                  _viewport->width() - RightMargin,
                  _viewport->height() - UpMargin - DownMargin);
}

void DsoSignal::paint_prepare()
{
    assert(_view);

    if (_data->empty() || !_data->has_data(get_index()))
        return; 

    if (session->trigd()) {
        if (get_index() == session->trigd_ch()) {
            uint8_t slope = DSO_TRIGGER_RISING;
            int v;
            bool ret;

            ret = session->get_device()->get_config_byte(SR_CONF_TRIGGER_SLOPE, v);
            if (ret) {
                slope = (uint8_t)v;
            }

            int64_t trig_index = _view->get_trig_cursor()->index();
            if (trig_index >= (int64_t)_data->get_sample_count())
                return;

            const uint8_t *const trig_samples = _data->get_samples(0, 0, get_index());
            for (uint16_t i = 0; i < TrigHRng; i++) {
                const int64_t i0 = trig_index - i - 1;
                const int64_t i1 = trig_index - i;
                if (i1 < 0)
                    break;
                const uint8_t t0 = trig_samples[i0];
                const uint8_t t1 = trig_samples[i1];
                if((slope == DSO_TRIGGER_RISING && t0 >= _trig_value && t1 <= _trig_value) ||
                   (slope == DSO_TRIGGER_FALLING && t0 <= _trig_value && t1 >= _trig_value)) {
                    const double xoff = (t1 == t0) ? 0 : (_trig_value - t0) * 1.0 / (t1 - t0);
                    _view->set_trig_hoff(i + 1 - xoff);
                    break;
                }
            }
        }
    } else {
        _view->set_trig_hoff(0);
    }
}

void DsoSignal::paint_back(QPainter &p, int left, int right, QColor fore, QColor back)
{
    assert(_view);

    if (!_show)
        return;

    int i, j;
    const int height = get_view_rect().height();
    const int width = right - left; 

    fore.setAlpha(View::BackAlpha);

    QPen solidPen(fore);
    solidPen.setStyle(Qt::SolidLine);
    p.setPen(solidPen);
    p.setBrush(back.black() > 0x80 ? back.darker() : back.lighter());
    p.drawRect(left, UpMargin, width, height);

    // draw zoom region
    fore.setAlpha(View::ForeAlpha);
    p.setPen(fore);

    const uint64_t sample_len = session->cur_samplelimits();
    const double samplerate = session->cur_snap_samplerate();
    const double samples_per_pixel = samplerate * _view->scale();
    const double shown_rate = min(samples_per_pixel * width * 1.0 / sample_len, 1.0);
    const double start = _view->offset() * samples_per_pixel;
    const double shown_offset = min(start / sample_len, 1.0) * width;
    const double shown_len = max(shown_rate * width, 6.0);
    const QPointF left_edge[] =  {QPoint(shown_offset + 3, UpMargin/2 - 6),
                                  QPoint(shown_offset, UpMargin/2 - 6),
                                  QPoint(shown_offset, UpMargin/2 + 6),
                                  QPoint(shown_offset + 3, UpMargin/2 + 6)};
    const QPointF right_edge[] = {QPoint(shown_offset + shown_len - 3, UpMargin/2 - 6),
                                  QPoint(shown_offset + shown_len , UpMargin/2 - 6),
                                  QPoint(shown_offset + shown_len , UpMargin/2 + 6),
                                  QPoint(shown_offset + shown_len - 3, UpMargin/2 + 6)};
    p.drawLine(left, UpMargin/2, shown_offset, UpMargin/2);
    p.drawLine(shown_offset + shown_len, UpMargin/2, left + width, UpMargin/2);
    p.drawPolyline(left_edge, countof(left_edge));
    p.drawPolyline(right_edge, countof(right_edge));
    p.setBrush(fore);
    p.drawRect(shown_offset, UpMargin/2 - 3, shown_len, 6);

    // draw divider
    fore.setAlpha(View::BackAlpha);
    QPen dashPen(fore);
    dashPen.setStyle(Qt::DashLine);
    p.setPen(dashPen);
    const double spanY =height * 1.0 / DS_CONF_DSO_VDIVS;
    for (i = 1; i <= DS_CONF_DSO_VDIVS; i++) {
        const double posY = spanY * i + UpMargin;
        if (i != DS_CONF_DSO_VDIVS)
            p.drawLine(left, posY, right, posY);
        const double miniSpanY = spanY / 5;
        for (j = 1; j < 5; j++) {
            p.drawLine(width / 2.0f - 5, posY - miniSpanY * j,
                       width / 2.0f + 5, posY - miniSpanY * j);
        }
    }
    const double spanX = width * 1.0 / DS_CONF_DSO_HDIVS;
    for (i = 1; i <= DS_CONF_DSO_HDIVS; i++) {
        const double posX = spanX * i;
        if (i != DS_CONF_DSO_HDIVS)
            p.drawLine(posX, UpMargin,posX, height + UpMargin);
        const double miniSpanX = spanX / 5;
        for (j = 1; j < 5; j++) {
            p.drawLine(posX - miniSpanX * j, height / 2.0f + UpMargin - 5,
                       posX - miniSpanX * j, height / 2.0f + UpMargin + 5);
        }
    }
    _view->set_back(true);
}

void DsoSignal::paint_mid(QPainter &p, int left, int right, QColor fore, QColor back)
{
    (void)fore;
    (void)back;

    if (!_show || right <= left){
        return;
    }

    assert(_data);
    assert(_view); 

    if (enabled()) {
        const int index = get_index();
        const int width = right - left;
        const float zeroY = get_zero_vpos();

        const double scale = _view->scale();
        assert(scale > 0);
        const int64_t offset = _view->offset();

        if (_data->empty() || !_data->has_data(index))
            return;

        const uint16_t enabled_channels = _data->get_channel_num();
        const double pixels_offset = offset;
        const double samplerate = _data->samplerate();

        assert(samplerate > 0);
       
        const int64_t last_sample = max((int64_t)(_data->get_sample_count() - 1), (int64_t)0);
        const double samples_per_pixel = samplerate * scale;
        const double start = offset * samples_per_pixel - _view->trig_hoff();
        const double end = start + samples_per_pixel * width;

        const int64_t start_sample = min(max((int64_t)floor(start),
            (int64_t)0), last_sample);
        const int64_t end_sample = min(max((int64_t)ceil(end) + 1,
            (int64_t)0), last_sample);
        const int hw_offset = get_hw_offset();

        if (samples_per_pixel < EnvelopeThreshold) {
            _data->enable_envelope(false);
            paint_trace(p, _data, zeroY, left,
                start_sample, end_sample, hw_offset,
                pixels_offset, samples_per_pixel, enabled_channels);
        } else {
            _data->enable_envelope(true);
            paint_envelope(p, _data, zeroY, left,
                start_sample, end_sample, hw_offset,
                pixels_offset, samples_per_pixel, enabled_channels);
        }

        sr_status status; 
        
        if (session->get_device()->get_device_status(status, false)) {
            _mValid = true;
            if (status.measure_valid) {
                _min = (index == 0) ? status.ch0_min : status.ch1_min;
                _max = (index == 0) ? status.ch0_max : status.ch1_max;

                _level_valid = (index == 0) ? status.ch0_level_valid : status.ch1_level_valid;
                _low = (index == 0) ? status.ch0_low_level : status.ch1_low_level;
                _high = (index == 0) ? status.ch0_high_level : status.ch1_high_level;

                const uint32_t count  = (index == 0) ? status.ch0_cyc_cnt : status.ch1_cyc_cnt;
                const bool plevel = (index == 0) ? status.ch0_plevel : status.ch1_plevel;
                const bool startXORend = (index == 0) ? (status.ch0_cyc_llen == 0) : (status.ch1_cyc_llen == 0);
                uint16_t total_channels = g_slist_length(session->get_device()->get_channels());

                if (total_channels == 1 && _data->is_file()){
                    total_channels++;
                }
                
                const double tfactor = (total_channels / enabled_channels) * SR_GHZ(1) * 1.0 / samplerate;
 
                double samples = (index == 0) ? status.ch0_cyc_tlen : status.ch1_cyc_tlen;
                _period = ((count == 0) ? 0 : samples / count) * tfactor;

                samples = (index == 0) ? status.ch0_cyc_flen : status.ch1_cyc_flen;
                _rise_time = ((count == 0) ? 0 : samples / ((plevel && startXORend) ? count : count + 1)) * tfactor;
                samples = (index == 0) ? status.ch0_cyc_rlen : status.ch1_cyc_rlen;
                _fall_time = ((count == 0) ? 0 : samples / ((!plevel && startXORend) ? count : count + 1)) * tfactor;

                samples = (index == 0) ? (status.ch0_plevel ? status.ch0_cyc_plen - status.ch0_cyc_llen :
                                                              status.ch0_cyc_tlen - status.ch0_cyc_plen + status.ch0_cyc_llen) :
                                         (status.ch1_plevel ? status.ch1_cyc_plen - status.ch1_cyc_llen :
                                                              status.ch1_cyc_tlen - status.ch1_cyc_plen + status.ch1_cyc_llen);
                _high_time = ((count == 0) ? 0 : samples / count) * tfactor;

                samples = (index == 0) ? status.ch0_cyc_tlen + status.ch0_cyc_llen : status.ch1_cyc_flen + status.ch1_cyc_llen;
                _burst_time = samples * tfactor;

                _pcount = count + (plevel & !startXORend);
                _rms = (index == 0) ? status.ch0_acc_square : status.ch1_acc_square;
                _rms = sqrt(_rms / _data->get_sample_count());
                _mean = (index == 0) ? status.ch0_acc_mean : status.ch1_acc_mean;
                _mean = hw_offset - _mean / _data->get_sample_count();
            }
        }
    }
}

void DsoSignal::paint_fore(QPainter &p, int left, int right, QColor fore, QColor back)
{
    if (!_show)
        return;

    assert(_view); 

    fore.setAlpha(View::BackAlpha);
    QPen pen(fore);
    pen.setStyle(Qt::DotLine);
    p.setPen(pen);
    p.drawLine(left, get_zero_vpos(), right, get_zero_vpos());

    fore.setAlpha(View::ForeAlpha);
    if(enabled()) {
        const QPointF mouse_point = _view->hover_point();
        const QRectF label_rect = get_trig_rect(left, right);
        const bool hover = label_rect.contains(mouse_point);

        // Paint the trig line
        const QPointF points[] = {
            QPointF(right, ratio2pos(get_trig_vrate())),
            label_rect.topLeft(),
            label_rect.topRight(),
            label_rect.bottomRight(),
            label_rect.bottomLeft()
        };

        p.setPen(Qt::transparent);
        p.setBrush(_colour);
        p.drawPolygon(points, countof(points));

        p.setPen(fore);
        const QPointF arrow_points[] = {
            QPoint(label_rect.left(), label_rect.center().y()),
            QPoint(label_rect.left(), label_rect.center().y()-1),
            QPoint(label_rect.left(), label_rect.center().y()+1),
            QPoint(label_rect.left(), label_rect.center().y()-2),
            QPoint(label_rect.left(), label_rect.center().y()+2),
            QPoint(label_rect.left(), label_rect.center().y()-3),
            QPoint(label_rect.left(), label_rect.center().y()+3),
            QPoint(label_rect.left(), label_rect.center().y()-4),
            QPoint(label_rect.left(), label_rect.center().y()+4),
            QPoint(label_rect.left()-1, label_rect.center().y()-3),
            QPoint(label_rect.left()-1, label_rect.center().y()+3),
            QPoint(label_rect.left()+1, label_rect.center().y()-3),
            QPoint(label_rect.left()+1, label_rect.center().y()+3),
            QPoint(label_rect.left()-1, label_rect.center().y()-2),
            QPoint(label_rect.left()-1, label_rect.center().y()+2),
            QPoint(label_rect.left()+1, label_rect.center().y()-2),
            QPoint(label_rect.left()+1, label_rect.center().y()+2),
            QPoint(label_rect.left()-2, label_rect.center().y()-2),
            QPoint(label_rect.left()-2, label_rect.center().y()+2),
            QPoint(label_rect.left()+2, label_rect.center().y()-2),
            QPoint(label_rect.left()+2, label_rect.center().y()+2),
        };
        if (hover || selected())
            p.drawPoints(arrow_points, countof(arrow_points));

        // paint the trig voltage
        int trigp = ratio2pos(get_trig_vrate());
        QString t_vol_s = get_voltage(get_zero_vpos() - trigp, 2, true);
        int vol_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
                                       Qt::AlignLeft | Qt::AlignTop, t_vol_s).width();
        const QRectF t_vol_rect = QRectF(right-vol_width, trigp-10, vol_width, 20);
        p.setPen(fore);
        p.drawText(t_vol_rect, Qt::AlignRight | Qt::AlignVCenter, t_vol_s);

        // paint the _trig_vpos line
        if (_view->get_dso_trig_moved()) {
            p.setPen(QPen(_colour, 1, Qt::DotLine));
            p.drawLine(left, trigp, right - p.boundingRect(t_vol_rect, Qt::AlignLeft, t_vol_s).width(), trigp);
        }

        // Paint the text
        p.setPen(fore);
        p.drawText(label_rect, Qt::AlignCenter | Qt::AlignVCenter, "T");

        // Paint measure
        if (session->is_stopped_status())
            paint_hover_measure(p, fore, back);

        // autoset
        auto_set();
    }
}

QRectF DsoSignal::get_trig_rect(int left, int right)
{
    (void)left;

    return QRectF(right + SquareWidth / 2,
                  ratio2pos(get_trig_vrate()) - SquareWidth / 2,
                  SquareWidth, SquareWidth);
}

void DsoSignal::paint_trace(QPainter &p,
    const dsv::data::DsoSnapshot *snapshot,
    int zeroY, int left, const int64_t start, const int64_t end, int hw_offset,
    const double pixels_offset, const double samples_per_pixel, uint64_t num_channels)
{
    (void)num_channels;

    const int64_t sample_count = end - start + 1;

    if (sample_count > 0) {
        dsv::data::DsoSnapshot *pshot = const_cast<dsv::data::DsoSnapshot*>(snapshot);
        const uint8_t *const samples_buffer = pshot->get_samples(start, end, get_index());;
        assert(samples_buffer);

        QColor trace_colour = _colour;
        trace_colour.setAlpha(View::ForeAlpha);
        p.setPen(trace_colour);

        QPointF *points = new QPointF[sample_count];
        QPointF *point = points;

        float top = get_view_rect().top();
        float bottom = get_view_rect().bottom();
        float right =  (float)get_view_rect().right();
        double  pixels_per_sample = 1.0/samples_per_pixel;

        uint8_t value; 
        float x = (start / samples_per_pixel - pixels_offset) + left + _view->trig_hoff()*pixels_per_sample;
        float y;
 
        for (int64_t sample = 0; sample < sample_count; sample++) {
            value = samples_buffer[sample];
            y = min(max(top, zeroY + (value - hw_offset) * _scale), bottom);
            if (x > right) {
                point--;
                const float lastY = point->y() + (y - point->y()) / (x - point->x()) * (right - point->x());
                point++;
                *point++ = QPointF(right, lastY);
                break;
            }
            *point++ = QPointF(x, y);
            x += pixels_per_sample;
        }

        p.drawPolyline(points, point - points);

        delete[] points;
    }
}

void DsoSignal::paint_envelope(QPainter &p,
    const dsv::data::DsoSnapshot *snapshot,
    int zeroY, int left, const int64_t start, const int64_t end, int hw_offset,
    const double pixels_offset, const double samples_per_pixel, uint64_t num_channels)
{
	using namespace Qt;
    using dsv::data::DsoSnapshot;

    data::DsoSnapshot *pshot = const_cast<data::DsoSnapshot*>(snapshot);

    DsoSnapshot::EnvelopeSection e;
    const uint16_t index = get_index() % num_channels;
    pshot->get_envelope_section(e, start, end, samples_per_pixel, index);

	if (e.length < 2)
		return;

    p.setPen(QPen(NoPen));
    //p.setPen(QPen(_colour, 2, Qt::SolidLine));
    QColor envelope_colour = _colour;
    envelope_colour.setAlpha(View::ForeAlpha);
    p.setBrush(envelope_colour);

	QRectF *const rects = new QRectF[e.length];
	QRectF *rect = rects;
    float top = get_view_rect().top();
    float bottom = get_view_rect().bottom();
    for(uint64_t sample = 0; sample < e.length-1; sample++) {
		const float x = ((e.scale * sample + e.start) /
            samples_per_pixel - pixels_offset) + left + _view->trig_hoff()/samples_per_pixel;
        const DsoSnapshot::EnvelopeSample *const s =
			e.samples + sample;

		// We overlap this sample with the next so that vertical
		// gaps do not appear during steep rising or falling edges
        const float b = min(max(top, ((max(s->max, (s+1)->min) - hw_offset) * _scale + zeroY)), bottom);
        const float t = min(max(top, ((min(s->min, (s+1)->max) - hw_offset) * _scale + zeroY)), bottom);

		float h = b - t;
		if(h >= 0.0f && h <= 1.0f)
			h = 1.0f;
		if(h <= 0.0f && h >= -1.0f)
			h = -1.0f;

		*rect++ = QRectF(x, t, 1.0f, h);
	}

	p.drawRects(rects, e.length);

	delete[] rects;
    //delete[] e.samples;
}

void DsoSignal::paint_type_options(QPainter &p, int right, const QPoint pt, QColor fore)
{ 
    p.setRenderHint(QPainter::Antialiasing, true);

    QColor foreBack = fore;
    foreBack.setAlpha(View::BackAlpha);
    int y = get_y();
    const QRectF vDial_rect = get_rect(DSO_VDIAL, y, right);
    const QRectF x1_rect = get_rect(DSO_X1, y, right);
    const QRectF x10_rect = get_rect(DSO_X10, y, right);
    const QRectF x100_rect = get_rect(DSO_X100, y, right);
    const QRectF acdc_rect = get_rect(DSO_ACDC, y, right);
    const QRectF chEn_rect = get_rect(DSO_CHEN, y, right);
    const QRectF auto_rect = get_rect(DSO_AUTO, y, right);

    QString pText;
    _vDial->paint(p, vDial_rect, _colour, pt, pText);
    QFontMetrics fm(p.font());
    const QRectF valueRect = QRectF(chEn_rect.left(), vDial_rect.top()-fm.height()-10, right, fm.height());
    p.drawText(valueRect, Qt::AlignCenter, pText);

    const char *strings[6] = {
        QT_TR_NOOP("EN"),
        QT_TR_NOOP("DIS"),
        QT_TR_NOOP("GND"),
        QT_TR_NOOP("DC"),
        QT_TR_NOOP("AC"),
        QT_TR_NOOP("AUTO"),
    };
    p.setPen(Qt::transparent);
    p.setBrush(chEn_rect.contains(pt) ? _colour.darker() : _colour);
    p.drawRect(chEn_rect);
    p.setPen(Qt::white);
    p.drawText(chEn_rect, Qt::AlignCenter | Qt::AlignVCenter, enabled() ? tr(strings[0]) : tr(strings[1]));

    p.setPen(Qt::transparent);
    p.setBrush(enabled() ? (acdc_rect.contains(pt) ? _colour.darker() : _colour) : foreBack);
    p.drawRect(acdc_rect);
    p.setPen(Qt::white);
    p.drawText(acdc_rect, Qt::AlignCenter | Qt::AlignVCenter, (_acCoupling == SR_GND_COUPLING) ? tr(strings[2]):
                                                              (_acCoupling == SR_DC_COUPLING) ? tr(strings[3]) : tr(strings[4]));

    if (session->get_device()->is_hardware()) {
        p.setPen(Qt::transparent);
        p.setBrush(enabled() ? (auto_rect.contains(pt) ? _colour.darker() : _colour) : foreBack);
        p.drawRect(auto_rect);
        p.setPen(Qt::white);
        p.drawText(auto_rect, Qt::AlignCenter | Qt::AlignVCenter, tr(strings[5]));
    }

    // paint the probe factor selector
    uint64_t factor;
    bool ret;

    ret = session->get_device()->get_config_uint64(SR_CONF_PROBE_FACTOR, factor, _probe, NULL);
    if (!ret) {
        dsv_err("ERROR: config_get SR_CONF_PROBE_FACTOR failed.");
        return;
    }

    p.setPen(Qt::transparent);
    p.setBrush((enabled() && (factor == 100)) ? (x100_rect.contains(pt) ? _colour.darker() : _colour)  : (x100_rect.contains(pt) ? _colour.darker() : foreBack));
    p.drawRect(x100_rect);
    p.setBrush((enabled() && (factor == 10)) ? (x10_rect.contains(pt) ? _colour.darker() : _colour)  : (x10_rect.contains(pt) ? _colour.darker() : foreBack));
    p.drawRect(x10_rect);
    p.setBrush((enabled() && (factor == 1)) ? (x1_rect.contains(pt) ? _colour.darker() : _colour)  : (x1_rect.contains(pt) ? _colour.darker() : foreBack));
    p.drawRect(x1_rect);

    p.setPen(Qt::white);
    p.drawText(x100_rect, Qt::AlignCenter | Qt::AlignVCenter, "x100");
    p.drawText(x10_rect, Qt::AlignCenter | Qt::AlignVCenter, "x10");
    p.drawText(x1_rect, Qt::AlignCenter | Qt::AlignVCenter, "x1");

    p.setRenderHint(QPainter::Antialiasing, false);
}

bool DsoSignal::mouse_press(int right, const QPoint pt)
{
    int y = get_y();
    const QRectF vDial_rect = get_rect(DSO_VDIAL, y, right);
    const QRectF chEn_rect = get_rect(DSO_CHEN, y, right);
    const QRectF acdc_rect = get_rect(DSO_ACDC, y, right);
    const QRectF auto_rect = get_rect(DSO_AUTO, y, right);
    const QRectF x1_rect = get_rect(DSO_X1, y, right);
    const QRectF x10_rect = get_rect(DSO_X10, y, right);
    const QRectF x100_rect = get_rect(DSO_X100, y, right);

    if (chEn_rect.contains(pt)) {
       if (session->get_device()->is_file() == false && !_en_lock) {
           set_enable(!enabled());
       }
       return true;
    }
    else if (enabled()) {
        if (vDial_rect.contains(pt) && pt.x() > vDial_rect.center().x()) {
            if (pt.y() > vDial_rect.center().y())
                go_vDialNext(true);
            else
                go_vDialPre(true);
        } 
        else if (session->get_device()->is_file() == false && acdc_rect.contains(pt)) {
           if (session->get_device()->is_hardware_logic())
               set_acCoupling((get_acCoupling()+1)%2);
           else
               set_acCoupling((get_acCoupling()+1)%2);
        }
        else if (auto_rect.contains(pt)) {
            if (session->get_device()->is_hardware())
                auto_start();
        }
        else if (x1_rect.contains(pt)) {
           set_factor(1);
        }
        else if (x10_rect.contains(pt)) {
           set_factor(10);
        }
        else if (x100_rect.contains(pt)) {
           set_factor(100);
        }
        else {
            return false;
        }

        return true;
    }
    return false;
}

bool DsoSignal::mouse_wheel(int right, const QPoint pt, const int shift)
{
    int y = get_y();
    const QRectF vDial_rect = get_rect(DSO_VDIAL, y, right);

    if (vDial_rect.contains(pt)) {
        if (shift > 0.5)
            go_vDialPre(true);
        else if (shift < -0.5)
            go_vDialNext(true);
        return true;
    } else {
        return false;
    }

    return true;
}

QRectF DsoSignal::get_rect(DsoSetRegions type, int y, int right)
{
    (void)right;

    if (type == DSO_VDIAL)
        return QRectF(
            get_leftWidth() + SquareWidth*0.5 + Margin,
            y - SquareWidth * SquareNum + SquareWidth * 3,
            SquareWidth * (SquareNum-1), SquareWidth * (SquareNum-1));
    else if (type == DSO_X1)
        return QRectF(
            get_leftWidth() + SquareWidth*0.5,
            y - SquareWidth * 2 - SquareWidth * (SquareNum-2) * 1 + SquareWidth * 3,
            SquareWidth * 1.75, SquareWidth);
    else if (type == DSO_X10)
        return QRectF(
            get_leftWidth() + SquareWidth*0.5,
            y - SquareWidth * 2 - SquareWidth * (SquareNum-2) * 0.5 + SquareWidth * 3,
            SquareWidth * 1.75, SquareWidth);
    else if (type == DSO_X100)
        return QRectF(
            get_leftWidth() + SquareWidth*0.5,
            y - SquareWidth * 2 - SquareWidth * (SquareNum-2) * 0 + SquareWidth * 3,
            SquareWidth * 1.75, SquareWidth);
    else if (type == DSO_CHEN)
        return QRectF(
            2,
            y - SquareWidth / 2 + SquareWidth * 3,
            SquareWidth * 1.75, SquareWidth);
    else if (type == DSO_ACDC)
        return QRectF(
            2+SquareWidth*1.75 + Margin,
            y - SquareWidth / 2 + SquareWidth * 3,
            SquareWidth * 1.75, SquareWidth);
    else if (type == DSO_AUTO)
        return QRectF(
            2+SquareWidth*3.5 + Margin*2,
            y - SquareWidth / 2 + SquareWidth * 3,
            SquareWidth * 1.75, SquareWidth);
    else
        return QRectF(0, 0, 0, 0);
}

void DsoSignal::paint_hover_measure(QPainter &p, QColor fore, QColor back)
{
    const int hw_offset = get_hw_offset();
    // Hover measure
    if (_hover_en && _hover_point != QPointF(-1, -1)) {
        QString hover_str = get_voltage(hw_offset - _hover_value, 2);
        const int hover_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
            Qt::AlignLeft | Qt::AlignTop, hover_str).width() + 10;
        const int hover_height = p.boundingRect(0, 0, INT_MAX, INT_MAX,
            Qt::AlignLeft | Qt::AlignTop, hover_str).height();
        QRectF hover_rect(_hover_point.x(), _hover_point.y()-hover_height/2, hover_width, hover_height);
        if (hover_rect.right() > get_view_rect().right())
            hover_rect.moveRight(_hover_point.x());
        if (hover_rect.top() < get_view_rect().top())
            hover_rect.moveTop(_hover_point.y());
        if (hover_rect.bottom() > get_view_rect().bottom())
            hover_rect.moveBottom(_hover_point.y());

        p.setPen(fore);
        p.setBrush(back);
        p.drawRect(_hover_point.x()-1, _hover_point.y()-1, HoverPointSize, HoverPointSize);
        p.drawText(hover_rect, Qt::AlignCenter | Qt::AlignTop | Qt::TextDontClip, hover_str);
    }

    auto &cursor_list = _view->get_cursorList();
    auto i = cursor_list.begin();

    while (i != cursor_list.end()) {
        float pt_value;

        int chan_index = (*i)->index();
        if (_data->has_data(chan_index) == false){
            i++;
            continue;
        }

        const QPointF pt = get_point(chan_index, pt_value);
        if (pt == QPointF(-1, -1)) {
            i++;
            continue;
        }
        
        QString pt_str = get_voltage(hw_offset - pt_value, 2);
        const int pt_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
            Qt::AlignLeft | Qt::AlignTop, pt_str).width() + 10;
        const int pt_height = p.boundingRect(0, 0, INT_MAX, INT_MAX,
            Qt::AlignLeft | Qt::AlignTop, pt_str).height();
        QRectF pt_rect(pt.x(), pt.y()-pt_height/2, pt_width, pt_height);
        if (pt_rect.right() > get_view_rect().right())
            pt_rect.moveRight(pt.x());
        if (pt_rect.top() < get_view_rect().top())
            pt_rect.moveTop(pt.y());
        if (pt_rect.bottom() > get_view_rect().bottom())
            pt_rect.moveBottom(pt.y());

        p.drawRect(pt.x()-1, pt.y()-1, 2, 2);
        p.drawLine(pt.x()-2, pt.y()-2, pt.x()+2, pt.y()+2);
        p.drawLine(pt.x()+2, pt.y()-2, pt.x()-2, pt.y()+2);
        p.drawText(pt_rect, Qt::AlignCenter | Qt::AlignTop | Qt::TextDontClip, pt_str);

        i++;
    }
}

void DsoSignal::auto_set()
{ 
    if (session->is_stopped_status()) {
        if (_autoV)
            autoV_end();
        if (_autoH)
            autoH_end();
    } 
    else {
        if (_autoH && _autoV && get_zero_ratio() != 0.5) {
            set_zero_ratio(0.5);
        }
        if (_mValid && !session->get_data_auto_lock()) {
            if (_autoH) {
                bool roll = false;
                session->get_device()->get_config_bool(SR_CONF_ROLL, roll);

                const double hori_res = _view->get_hori_res();
                if (_level_valid && ((!roll && _pcount < 3) || _period > 4*hori_res)) {
                    _view->zoom(-1);
                } else if (_level_valid && _pcount > 6 && _period < 1.5*hori_res) {
                    _view->zoom(1);
                } else if (_level_valid) {
                    autoH_end();
                }
            }
            if (_autoV) {
                const bool over_flag = _max == 0xff || _min == 0x0;
                const bool out_flag = _max >= 0xE0 || _min <= 0x20;
                const bool under_flag = _max <= 0xA0 && _min >= 0x60;
                if (over_flag) {
                    if (!_autoV_over)
                        _auto_cnt = 0;
                    _autoV_over = true;
                    go_vDialNext(false);
                } else if (out_flag) {
                    go_vDialNext(false);
                } else if (!_autoV_over && under_flag) {
                    go_vDialPre(false);
                } else if (!_autoH) {
                    autoV_end();
                }

                if (_autoV_over && under_flag) {
                    if (_auto_cnt++ > 16)
                        _autoV_over = false;
                } else {
                    _auto_cnt = 0;
                }

                if (_level_valid) {
                    _trig_value = (_min+_max)/2;
                    set_trig_vpos(ratio2pos(get_trig_vrate()));
                }
            }
            if (_autoH || _autoV)
                session->data_auto_lock(AutoLock);
        }
    }
}

void DsoSignal::autoV_end()
{
    _autoV = false;
    _autoV_over = false;
    _view->auto_trig(get_index());
    _trig_value = (_min+_max)/2;
    set_trig_vpos(ratio2pos(get_trig_vrate()));
    _view->set_update(_viewport, true);
    _view->update();
}

void DsoSignal::autoH_end()
{
    _autoH = false;
    _view->set_update(_viewport, true);
    _view->update();
}

void DsoSignal::auto_end()
{
    if (_autoV)
        autoV_end();
    if (_autoH)
        autoH_end();
}

void DsoSignal::auto_start()
{ 
    if (_autoV || _autoH)
        return;

    if (session->is_running_status()) {
        session->data_auto_lock(AutoLock);
        _autoV = true;
        _autoH = true;
        _view->auto_trig(get_index()); 
        _end_timer.TimeOut(AutoTime, std::bind(&DsoSignal::call_auto_end, this)); //start a timeout
    }
}

bool DsoSignal::measure(const QPointF &p)
{ 
    _hover_en = false;
    
    if (!enabled() || !show())
        return false;

    if (session->is_stopped_status() == false)
        return false;

    const QRectF window = get_view_rect();
    if (!window.contains(p))
        return false;

    if (_data->empty())
        return false;

    _hover_index = _view->pixel2index(p.x());
    if (_hover_index >= _data->get_sample_count())
        return false;

    int chan_index = get_index();
    if (_data->has_data(chan_index) == false){
        dsv_err("channel %d have no data.", chan_index);
        return false;
    }

    _hover_point = get_point(_hover_index, _hover_value);
    _hover_en = true;
    return true;
}

bool DsoSignal::get_hover(uint64_t &index, QPointF &p, double &value)
{
    if (_hover_en) {
        index = _hover_index;
        p = _hover_point;
        value = _hover_value;
        return true;
    }
    return false;
}

QPointF DsoSignal::get_point(uint64_t index, float &value)
{
    QPointF pt = QPointF(-1, -1);

    if (!enabled())
        return pt;

    if (_data->empty())
        return pt;

    if (index >= _data->get_sample_count())
        return pt;

    value = *_data->get_samples(index, index, get_index());
    const float top = get_view_rect().top();
    const float bottom = get_view_rect().bottom();
    const int hw_offset = get_hw_offset();
    const float x = _view->index2pixel(index);
    const float y = min(max(top, get_zero_vpos() + (value - hw_offset)* _scale), bottom);
    pt = QPointF(x, y);

    return pt;
}

double DsoSignal::get_voltage(uint64_t index)
{
    if (!enabled())
        return 1;

    if (_data->empty())
        return 1;

    if (index >= _data->get_sample_count())
        return 1;
    
    assert(_data);

    const double value = *_data->get_samples(index, index, get_index());
    const int hw_offset = get_hw_offset();
    uint64_t k = _data->get_measure_voltage_factor(this->get_index());
    float data_scale = _data->get_data_scale(this->get_index());

    return (hw_offset - value) * data_scale * 
             k *_vDial->get_factor() *
               DS_CONF_DSO_VDIVS / get_view_rect().height();
}

QString DsoSignal::get_voltage(double v, int p, bool scaled)
{
    if (_vDial == NULL){
        assert(false);
    }

    if (get_view_rect().height() == 0){
        assert(false);
    }

    assert(_data);

    uint64_t k = _data->get_measure_voltage_factor(this->get_index());
    float data_scale = _data->get_data_scale(this->get_index());

    if (scaled)
        v = v * k * _vDial->get_factor() * DS_CONF_DSO_VDIVS / get_view_rect().height();
    else
        v = v * data_scale * k * _vDial->get_factor() * DS_CONF_DSO_VDIVS / get_view_rect().height();
    
    return abs(v) >= 1000 ? QString::number(v/1000.0, 'f', p) + "V" : QString::number(v, 'f', p) + "mV";
}

QString DsoSignal::get_time(double t)
{
    QString str = (abs(t) > 1000000000 ? QString::number(t/1000000000, 'f', 2) + "S" :
                   abs(t) > 1000000 ? QString::number(t/1000000, 'f', 2) + "mS" :
                   abs(t) > 1000 ? QString::number(t/1000, 'f', 2) + "uS" : QString::number(t, 'f', 2) + "nS");
    return str;
}

void DsoSignal::call_auto_end(){
    session->auto_end();
}

void DsoSignal::set_data(data::DsoSnapshot *data)
{
    assert(data);
    _data = data;
}

} // namespace view
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "lissajoustrace.h"
#include <math.h>
#include <QTimer>
#include "view.h"
#include "../basedef.h"
#include "../data/dsosnapshot.h"
#include "../appcore/sigsession.h"
#include "../ui/langresource.h"
 
using namespace std;

namespace dsv {
namespace view {

LissajousTrace::LissajousTrace(bool enable,
                     data::DsoSnapshot *data,
                     int xIndex, int yIndex, int percent):
    Trace("Lissajous", xIndex, SR_CHANNEL_LISSAJOUS),
    _data(data),
    _enable(enable),
    _xIndex(xIndex),
    _yIndex(yIndex),
    _percent(percent)
{

}

LissajousTrace::~LissajousTrace()
{
}

void LissajousTrace::paint_back(QPainter &p, int left, int right, QColor fore, QColor back)
{
    assert(_view);

    fore.setAlpha(view::View::BackAlpha);
    const int height = _viewport->height();
    const int width = right - left;
    const int square = min(width, height);
    const QPoint leftTop = QPoint(width > square ? (width-square)/2 : 0,
                                  height > square ? (height-square)/2 : 0);
    _border = QRect(leftTop.x(), leftTop.y(), square, square);

    QPen solidPen(fore);
    solidPen.setStyle(Qt::SolidLine);
    p.setPen(solidPen);
    p.setBrush(back.black() > 0x80 ? back.darker() : back.lighter());
    p.drawRect(_border);

    QPen dashPen(fore);
    dashPen.setStyle(Qt::DashLine);
    p.setPen(dashPen);

    const double spanY =square / DIV_NUM;

    for (int i = 1; i < DIV_NUM; i++) {
        const double posY = _border.top() + spanY * i;
        p.drawLine(_border.left(), posY, _border.right(), posY);
    }

    const double spanX = square / DIV_NUM;

    for (int i = 1; i < DIV_NUM; i++) {
        const double posX = _border.left() + spanX * i;
        p.drawLine(posX, _border.top(), posX, _border.bottom());
    }

    fore.setAlpha(view::View::ForeAlpha);
    p.setPen(fore);
    p.drawText(_border.marginsRemoved(QMargins(10, 10, 10, 10)),
               L_S(STR_PAGE_DLG, S_ID(IDS_DLG_LISSAJOUS_FIGURE), "Lissajous Figure"), Qt::AlignTop | Qt::AlignLeft);

    _view->set_back(true);
}

void LissajousTrace::paint_mid(QPainter &p, int left, int right, QColor fore, QColor back)
{
    (void)fore;
    (void)back;
    (void)left;
    (void)right;

    assert(_data);
    assert(_view);
    assert(right >= left);

    if (enabled()) {

        if (_data->empty())
            return;

        int channel_num = _data->get_channel_num();
        if (channel_num < 2){
            p.setPen(view::View::Red);
            p.drawText(_border.marginsRemoved(QMargins(10, 30, 10, 30)),
                       L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CHAN_NUM_ERR2), "Requires the data of two channels."));
            return;
        }

        int left = _border.left();
        int bottom = _border.bottom();
        double scale = _border.width() / 255.0;
        uint64_t sample_count = _data->get_sample_count() * min(_percent / 100.0, 1.0);
        QPointF *points = new QPointF[sample_count];
        QPointF *point = points;

        if (_xIndex >= channel_num || _yIndex >= channel_num) {
            p.setPen(view::View::Red);
            p.drawText(_border.marginsRemoved(QMargins(10, 30, 10, 30)),
                       L_S(STR_PAGE_DLG, S_ID(IDS_DLG_DATA_SOURCE_ERROR), "Data source error."));
        }
        else {
            const uint8_t* chan_data_array[2];
            chan_data_array[_xIndex] = _data->get_samples(0, sample_count-1, _xIndex);
            chan_data_array[_yIndex] = _data->get_samples(0, sample_count-1, _yIndex);

            for (uint64_t i = 0; i < sample_count; i++) {
                const uint8_t* dx = chan_data_array[_xIndex];
                const uint8_t* dy = chan_data_array[_yIndex];

                *point++ = QPointF(left + dx[i] * scale,
                                    bottom - dy[i] * scale);
            }

            p.setPen(view::View::Blue);
            p.drawPolyline(points, point - points);
            delete[] points;
        }
    }
}

void LissajousTrace::paint_fore(QPainter &p, int left, int right, QColor fore, QColor back)
{
    (void)p;
    (void)left;
    (void)right;
    (void)fore;
    (void)back;

    assert(_view);
}

void LissajousTrace::paint_label(QPainter &p, int right, const QPoint pt, QColor fore)
{
    (void)p;
    (void)right;
    (void)pt;
    (void)fore;
}

} // namespace view
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "viewstatus.h"
#include <QHBoxLayout>
#include <QPainter>
#include <QStyleOption>
#include <QMouseEvent>
#include <QBitmap>
#include <QJsonObject>
#include <QJsonArray>
#include "../view/trace.h"
#include "../appcore/sigsession.h"
#include "view.h"
#include "trace.h"
#include "../dialogs/dsomeasure.h"
#include "../ui/langresource.h"
#include "../log.h"
#include "../config/appconfig.h"
#include "../appcore/appcontrol.h"
#include "../ui/fn.h"

using namespace std;
using namespace dsv::config;

namespace dsv {
namespace view {

ViewStatus::ViewStatus(SigSession *session, View &parent) :
    QWidget(&parent),
    _session(session),
    _view(parent),
    _hit_rect(-1),
    _last_sig_index(-1)
{
}

void ViewStatus::paintEvent(QPaintEvent *)
{
    QStyleOption opt;
 #if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
      opt.initFrom(this);
 #else
      opt.init(this);
 #endif

    QPainter p(this);
    style()->drawPrimitive(QStyle::PE_Widget, &opt, &p, this);
    QColor fore(QWidget::palette().color(QWidget::foregroundRole()));

    QFont font = p.font();
    float fSize = AppConfig::Instance().appOptions.fontSize;
    if (fSize > 10)
        fSize = 10;
    font.setPointSizeF(fSize);
    p.setFont(font);

    int mode = _session->get_device()->get_work_mode();

    if (mode == LOGIC) {
        fore.setAlpha(View::ForeAlpha);
        p.setPen(fore);
        p.drawText(this->rect(), Qt::AlignLeft | Qt::AlignVCenter, _rle_depth);
        p.drawText(this->rect(), Qt::AlignRight | Qt::AlignVCenter, _trig_time);

        p.setPen(Qt::NoPen);
        p.setBrush(View::Blue);
        p.drawRect(this->rect().left(), this->rect().bottom() - 3,
                   _session->get_repeat_hold() * this->rect().width() / 100, 3);

        p.setPen(View::Blue);
        p.drawText(this->rect(), Qt::AlignCenter | Qt::AlignVCenter, _capture_status);
    } 
    else if (mode == DSO) {
        fore.setAlpha(View::BackAlpha);

        for(size_t i = 0; i < _mrects.size(); i++) {
            int sig_index = std::get<1>(_mrects[i]);
            view::DsoSignal *dsoSig = NULL;

            for(auto s : _session->get_signals()) {
                if (s->signal_type() == SR_CHANNEL_DSO && s->enabled()) {
                    dsoSig = (view::DsoSignal*)s;
                    if (sig_index == dsoSig->get_index())
                        break;
                    else
                        dsoSig = NULL;
                }
            }

            bool active = dsoSig && dsoSig->enabled();
            const QRect rect = std::get<0>(_mrects[i]);
            p.setPen(Qt::NoPen);
            p.setBrush(active ? dsoSig->get_colour() : fore);
            p.drawRect(QRect(rect.topLeft(), QSize(10, rect.height())));

            QPixmap msPix(dsv::dialogs::DsoMeasure::get_ms_icon(std::get<2>(_mrects[i])));
            QBitmap msMask = msPix.createMaskFromColor(QColor("black"), Qt::MaskOutColor);
            msPix.fill(active ? dsoSig->get_colour() : fore);
            msPix.setMask(msMask);
            p.drawPixmap(QRect(rect.left()+10, rect.top(), rect.height(), rect.height()),
                         msPix);

            p.setPen(((int)i == _hit_rect) ? View::Blue :
                     active ? dsoSig->get_colour() : fore);
            p.setBrush(Qt::NoBrush);
            p.drawRect(rect);

            enum DSO_MEASURE_TYPE mtype = std::get<2>(_mrects[i]);

            if (active && (mtype != DSO_MS_BEGIN)) {
                QString title = dsv::dialogs::DsoMeasure::get_ms_text(std::get<2>(_mrects[i])) + ":";
                title += dsoSig->get_measure(mtype);
                int width = p.boundingRect(rect, title).width();
                p.drawText(QRect(rect.left()+10+rect.height(), rect.top(), width, rect.height()),
                           Qt::AlignLeft | Qt::AlignVCenter, title);
            }
            else {
                p.drawText(rect, Qt::AlignCenter | Qt::AlignVCenter, L_S(STR_PAGE_DLG, S_ID(IDS_DLG_MEASURE), "Measure") + QString::number(i));
            }
        }
    }
}

void ViewStatus::clear()
{
    _trig_time.clear();
    _rle_depth.clear();
    _capture_status.clear();
    update();
}

void ViewStatus::reload()
{
    const int COLUMN = 5;
    const int ROW = 2;
    const int MARGIN = 3;

    if (_session->get_device()->get_work_mode() == DSO)
    {
        const double width = _view.get_view_width() * 1.0 / COLUMN;
        const int height = (this->height() - 2*MARGIN) / ROW;

        for (size_t i  = 0; i < COLUMN*ROW; i++) {
            QRect rect(this->rect().left() + (i%COLUMN)*width,
                       this->rect().top() + (i/COLUMN+1)*MARGIN + (i/COLUMN)*height,
                       width-MARGIN, height);

            if (_mrects.size() <= i) {
                std::tuple<QRect, int, enum DSO_MEASURE_TYPE> rect_tuple;
                std::get<0>(rect_tuple) = rect;
                std::get<1>(rect_tuple) = -1;
                std::get<2>(rect_tuple) = DSO_MS_BEGIN;
                _mrects.push_back(rect_tuple);
            }
            else {
                std::get<0>(_mrects[i]) = rect;
            }
        }
    }
    update();
}

void ViewStatus::repeat_unshow()
{
    _capture_status.clear();
    update();
}

void ViewStatus::set_trig_time(QDateTime time)
{
    _trig_time = L_S(STR_PAGE_DLG, S_ID(IDS_DLG_TRIGGER_TIME), "Trigger Time: ") + time.toString("yyyy-MM-dd hh:mm:ss");
   // assert(0);
}

void ViewStatus::set_rle_depth(uint64_t depth)
{
    _rle_depth = QString::number(depth) + L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SAMPLES_CAPTURED), "Samples Captured!");
}

void ViewStatus::set_capture_status(bool triggered, int progess)
{
    if (triggered) {
        _capture_status = L_S(STR_PAGE_DLG, S_ID(IDS_DLG_TRIGGERED), "Triggered! ") + QString::number(progess) 
                        + L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CAPTURED), "% Captured");
    } else {
        _capture_status = L_S(STR_PAGE_DLG, S_ID(IDS_DLG_WAITING_FOR_TRIGGER), "Waiting for Trigger! ") + QString::number(progess) 
                        + L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CAPTURED), "% Captured");
    }
}

void ViewStatus::mousePressEvent(QMouseEvent *event)
{
    assert(event);

    if (_session->get_device()->get_work_mode() != DSO)
        return;

    if (event->button() == Qt::LeftButton) { 
        for(size_t i = 0; i < _mrects.size(); i++) {
            const QRect rect = std::get<0>(_mrects[i]);
            if (rect.contains(event->pos())) {
                _hit_rect = (int)i;
                dsv::dialogs::DsoMeasure dsoMeasureDialog(_session, _view, i, _last_sig_index);
                dsoMeasureDialog.exec();
                break;
            }
        }
        update();
    }
}

void ViewStatus::set_measure(unsigned int index, bool canceled,
                             int sig_index, enum DSO_MEASURE_TYPE ms_type)
{
    _hit_rect = -1;
    if (!canceled && index < _mrects.size()) {
        _last_sig_index = sig_index;
        std::get<1>(_mrects[index]) = sig_index;
        std::get<2>(_mrects[index]) = ms_type;
    }
    update();
}

QJsonArray ViewStatus::get_session()
{
    QJsonArray measureVar;
    for(int i = 0; i < (int)_mrects.size(); i++) {
        const int index = std::get<1>(_mrects[i]);
        if (index != -1) {
            QJsonObject m_obj;
            m_obj["site"] = i;
            m_obj["index"] = index;
            m_obj["type"] = (int)std::get<2>(_mrects[i]);
            measureVar.append(m_obj);
        }
    }

    return measureVar;
}

void ViewStatus::load_session(QJsonArray measure_array, int version)
{
    if (_session->get_device()->get_work_mode() != DSO){
        return;
    }

    for(int i = 0; i < (int)_mrects.size(); i++) 
    {
        std::get<1>(_mrects[i]) = -1;
        std::get<2>(_mrects[i]) = DSO_MS_BEGIN;
    }
 
    for (const QJsonValue &measure_value : measure_array) 
    { 
        QJsonObject m_obj = measure_value.toObject();
        int index = m_obj["site"].toInt();
        int sig_index = m_obj["index"].toInt();
       
        if (version >= 3){
            Signal *trace = NULL;

            for(auto s : _session->get_signals()){
                if (s->get_name().toInt() == sig_index){
                    trace = s;
                    break;
                }
            }

            if (trace == NULL)
                continue;
            sig_index = trace->get_index();
        }

        enum DSO_MEASURE_TYPE ms_type = DSO_MEASURE_TYPE(m_obj["type"].toInt());
        set_measure(index, false, sig_index, ms_type);
    }
}

} // namespace view
} // namespace dsv
/****************************************************************************
** Meta object code from reading C++ file 'trace.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "trace.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'trace.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPETraceENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEviewSCOPETraceENDCLASS = QtMocHelpers::stringData(
    "dsv::view::Trace",
    "visibility_changed",
    "",
    "text_changed",
    "colour_changed",
    "resize"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPETraceENDCLASS_t {
    uint offsetsAndSizes[12];
    char stringdata0[17];
    char stringdata1[19];
    char stringdata2[1];
    char stringdata3[13];
    char stringdata4[15];
    char stringdata5[7];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEviewSCOPETraceENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEviewSCOPETraceENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEviewSCOPETraceENDCLASS = {
    {
        QT_MOC_LITERAL(0, 16),  // "dsv::view::Trace"
        QT_MOC_LITERAL(17, 18),  // "visibility_changed"
        QT_MOC_LITERAL(36, 0),  // ""
        QT_MOC_LITERAL(37, 12),  // "text_changed"
        QT_MOC_LITERAL(50, 14),  // "colour_changed"
        QT_MOC_LITERAL(65, 6)   // "resize"
    },
    "dsv::view::Trace",
    "visibility_changed",
    "",
    "text_changed",
    "colour_changed",
    "resize"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEviewSCOPETraceENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       4,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       3,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   38,    2, 0x06,    1 /* Public */,
       3,    0,   39,    2, 0x06,    2 /* Public */,
       4,    0,   40,    2, 0x06,    3 /* Public */,

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       5,    0,   41,    2, 0x08,    4 /* Private */,

 // signals: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,

 // slots: parameters
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::view::Trace::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEviewSCOPETraceENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEviewSCOPETraceENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEviewSCOPETraceENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<Trace, std::true_type>,
        // method 'visibility_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'text_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'colour_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'resize'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::view::Trace::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<Trace *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->visibility_changed(); break;
        case 1: _t->text_changed(); break;
        case 2: _t->colour_changed(); break;
        case 3: _t->resize(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (Trace::*)();
            if (_t _q_method = &Trace::visibility_changed; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (Trace::*)();
            if (_t _q_method = &Trace::text_changed; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 1;
                return;
            }
        }
        {
            using _t = void (Trace::*)();
            if (_t _q_method = &Trace::colour_changed; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 2;
                return;
            }
        }
    }
    (void)_a;
}

const QMetaObject *dsv::view::Trace::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::view::Trace::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEviewSCOPETraceENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int dsv::view::Trace::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 4)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 4;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 4)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 4;
    }
    return _id;
}

// SIGNAL 0
void dsv::view::Trace::visibility_changed()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}

// SIGNAL 1
void dsv::view::Trace::text_changed()
{
    QMetaObject::activate(this, &staticMetaObject, 1, nullptr);
}

// SIGNAL 2
void dsv::view::Trace::colour_changed()
{
    QMetaObject::activate(this, &staticMetaObject, 2, nullptr);
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_VIEW_VIEWSTATUS_H
#define DSVIEW_PV_VIEW_VIEWSTATUS_H

#include <QWidget>
#include <QLabel>
#include <QDateTime>
#include <QPushButton>
#include <QToolButton> 
#include <libsigrok.h> 

namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
}
using namespace dsv::appcore;

namespace dsv {
namespace view {
class View;
class DsoSignal;

//created by View
class ViewStatus : public QWidget
{
    Q_OBJECT

public:
   ViewStatus(SigSession *session, View &parent);

public: 

    void paintEvent(QPaintEvent *);
    void mousePressEvent(QMouseEvent *);

    void set_measure(unsigned int index, bool canceled,
                     int sig_index, enum DSO_MEASURE_TYPE ms_type);

    QJsonArray get_session();
    void load_session(QJsonArray meausre_array, int version);
    void set_capture_status(bool triggered, int progess);

public slots:
    void clear();
    void reload();
    void repeat_unshow();
    void set_trig_time(QDateTime time);
    void set_rle_depth(uint64_t depth);    

private:
    SigSession *_session;
    View &_view;
    int _hit_rect;

    QString _trig_time;
    QString _rle_depth;
    QString _capture_status;

    int _last_sig_index;
    std::vector<std::tuple<QRect, int, enum DSO_MEASURE_TYPE>> _mrects;
};

} // namespace view
} // namespace dsv

#endif // DSVIEW_PV_VIEW_VIEWSTATUS_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_VIEW_MARKER_H
#define DSVIEW_PV_VIEW_MARKER_H

#include <QColor>
#include <QObject>
#include <QRectF>
#include <stdint.h>

class QPainter;
class QRect;

namespace dsv {
namespace view {

class View;

//the Cursor's base class
class TimeMarker : public QObject
{
	Q_OBJECT

protected:
	/**
	 * Constructor.
	 * @param view A reference to the view that owns this marker.
	 * @param colour A reference to the colour of this cursor.
	 * @param time The time to set the flag to.
	 */
    TimeMarker(View &view, QColor &colour, uint64_t index);

	/**
	 * Copy constructor
	 */
	TimeMarker(const TimeMarker &s);

public:
	/**
	 * Gets the time of the marker.
	 */
	double time();
    uint64_t index();

	/**
	 * Sets the time of the marker.
	 */
    void set_index(uint64_t index);

    /**
     * Gets/Sets colour of the marker
     */
    QColor colour();
    void set_colour(QColor color);

    /*
     *
     */
    bool grabbed();
    void set_grabbed(bool grabbed);

	/**
	 * Paints the marker to the viewport.
	 * @param p The painter to draw with.
	 * @param rect The rectangle of the viewport client area.
	 */
    virtual void paint(QPainter &p, const QRect &rect, const bool highlight, int order, bool trig_hoff = true);

	/**
	 * Gets the marker label rectangle.
	 * @param rect The rectangle of the ruler client area.
     * @param visible is this marker in visible area
	 * @return Returns the label rectangle.
	 */
    virtual QRect get_label_rect(const QRect &rect, bool &visible, bool has_hoff = true) = 0;

	/**
	 * Paints the marker's label to the ruler.
	 * @param p The painter to draw with.
	 * @param rect The rectangle of the ruler client area.
	 * @param prefix The SI prefix to paint time value with.
	 */
	virtual void paint_label(QPainter &p, const QRect &rect,
        unsigned int prefix, int index, bool has_hoff) = 0;

signals:
	void time_changed();

protected:
    View &_view;

    uint64_t _index;

	QSizeF _text_size;

private:
    bool _grabbed;
    QColor _colour;
};

} // namespace view
} // namespace dsv

#endif // DSVIEW_PV_VIEW_MARKER_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_VIEW_HEADER_H
#define DSVIEW_PV_VIEW_HEADER_H

#include <list>
#include <utility>
#include <QWidget>
#include <QLineEdit>

namespace dsv {
namespace view {

class Trace;
class View;

//the left panel of main graph
//created by View
class Header : public QWidget
{
	Q_OBJECT

public:
	Header(View &parent);

private:
    dsv::view::Trace* get_mTrace(int &action, const QPoint &pt);

private:
    void changeEvent(QEvent *event);
    void retranslateUi();
	void paintEvent(QPaintEvent *event);

private:
	void mousePressEvent(QMouseEvent * event);
	void mouseReleaseEvent(QMouseEvent *event);
	void mouseMoveEvent(QMouseEvent *event);
    void mouseDoubleClickEvent(QMouseEvent *event);
	void leaveEvent(QEvent *event);
    void wheelEvent(QWheelEvent *event);
    void contextMenuEvent(QContextMenuEvent *event);

    void changeName(QMouseEvent *event);
    void changeColor(QMouseEvent *event);

public:
    int get_nameEditWidth();
    void header_resize();

private slots:
	void on_action_set_name_triggered();

signals:
    void traces_moved();
    void header_updated();
    void vDial_changed(quint16);
    void acdc_changed(quint16);
    void ch_changed(quint16);

private:
	View &_view;

    bool _moveFlag;
    bool _colorFlag;
    bool _nameFlag;

	QPoint _mouse_point;
	QPoint _mouse_down_point;

    QLineEdit *nameEdit;

    std::list<std::pair<Trace*, int> > _drag_traces;

    Trace *_context_trace;
};

} // namespace view
} // namespace dsv

#endif // DSVIEW_PV_VIEW_HEADER_H
/****************************************************************************
** Meta object code from reading C++ file 'viewstatus.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "viewstatus.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'viewstatus.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewStatusENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewStatusENDCLASS = QtMocHelpers::stringData(
    "dsv::view::ViewStatus",
    "clear",
    "",
    "reload",
    "repeat_unshow",
    "set_trig_time",
    "time",
    "set_rle_depth",
    "uint64_t",
    "depth"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewStatusENDCLASS_t {
    uint offsetsAndSizes[20];
    char stringdata0[22];
    char stringdata1[6];
    char stringdata2[1];
    char stringdata3[7];
    char stringdata4[14];
    char stringdata5[14];
    char stringdata6[5];
    char stringdata7[14];
    char stringdata8[9];
    char stringdata9[6];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewStatusENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewStatusENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewStatusENDCLASS = {
    {
        QT_MOC_LITERAL(0, 21),  // "dsv::view::ViewStatus"
        QT_MOC_LITERAL(22, 5),  // "clear"
        QT_MOC_LITERAL(28, 0),  // ""
        QT_MOC_LITERAL(29, 6),  // "reload"
        QT_MOC_LITERAL(36, 13),  // "repeat_unshow"
        QT_MOC_LITERAL(50, 13),  // "set_trig_time"
        QT_MOC_LITERAL(64, 4),  // "time"
        QT_MOC_LITERAL(69, 13),  // "set_rle_depth"
        QT_MOC_LITERAL(83, 8),  // "uint64_t"
        QT_MOC_LITERAL(92, 5)   // "depth"
    },
    "dsv::view::ViewStatus",
    "clear",
    "",
    "reload",
    "repeat_unshow",
    "set_trig_time",
    "time",
    "set_rle_depth",
    "uint64_t",
    "depth"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEviewSCOPEViewStatusENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       5,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   44,    2, 0x0a,    1 /* Public */,
       3,    0,   45,    2, 0x0a,    2 /* Public */,
       4,    0,   46,    2, 0x0a,    3 /* Public */,
       5,    1,   47,    2, 0x0a,    4 /* Public */,
       7,    1,   50,    2, 0x0a,    6 /* Public */,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::QDateTime,    6,
    QMetaType::Void, 0x80000000 | 8,    9,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::view::ViewStatus::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewStatusENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEviewSCOPEViewStatusENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewStatusENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<ViewStatus, std::true_type>,
        // method 'clear'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'reload'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'repeat_unshow'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'set_trig_time'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QDateTime, std::false_type>,
        // method 'set_rle_depth'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<uint64_t, std::false_type>
    >,
    nullptr
} };

void dsv::view::ViewStatus::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<ViewStatus *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->clear(); break;
        case 1: _t->reload(); break;
        case 2: _t->repeat_unshow(); break;
        case 3: _t->set_trig_time((*reinterpret_cast< std::add_pointer_t<QDateTime>>(_a[1]))); break;
        case 4: _t->set_rle_depth((*reinterpret_cast< std::add_pointer_t<uint64_t>>(_a[1]))); break;
        default: ;
        }
    }
}

const QMetaObject *dsv::view::ViewStatus::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::view::ViewStatus::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewStatusENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int dsv::view::ViewStatus::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 5)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 5;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 5)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 5;
    }
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_ANALOGSIGNAL_H
#define DSVIEW_PV_ANALOGSIGNAL_H

#include "signal.h"

namespace dsv{
    namespace data {
        class AnalogSnapshot;
    }
}
using namespace dsv::data;

namespace dsv {
namespace view {

//when device is data acquisition model, to draw signal trace
class AnalogSignal : public Signal
{
    Q_OBJECT

private:
	static const QColor SignalColours[4];
	static const float EnvelopeThreshold;
    static const int NumSpanY = 5;
    static const int NumMiniSpanY = 5;
    static const int NumSpanX = 10;
    static const int HoverPointSize = 2;
    static const uint8_t DefaultBits = 8;

public:
    AnalogSignal(data::AnalogSnapshot *data,
                 sr_channel *probe);

    AnalogSignal(view::AnalogSignal* s, data::AnalogSnapshot *data,  sr_channel *probe);

	virtual ~AnalogSignal();

    inline void set_scale(int height){
        _scale = height / (_ref_max - _ref_min);
    }

    inline float get_scale(){
        return _scale;
    }

    inline int get_bits(){
        return _bits;
    }

    inline double get_ref_min(){
        return _ref_min;
    }

    inline double get_ref_max(){
        return _ref_max;
    }

    inline data::AnalogSnapshot* data(){
        return _data;
    }

    void set_data(data::AnalogSnapshot *data);

    int get_hw_offset();
    int commit_settings();

    bool measure(const QPointF &p);
    bool get_hover(uint64_t &index, QPointF &p, double &value);
    QPointF get_point(uint64_t index, float &value);
    QString get_voltage(double v, int p, bool scaled = false);

    /**
     * Probe options
     **/
    uint64_t get_vdiv();
    uint8_t get_acCoupling();
    bool get_mapDefault();
    QString get_mapUnit();
    double get_mapMin();
    double get_mapMax();
    uint64_t get_factor();
    
    void set_zero_vpos(int pos);
    int get_zero_vpos();
    void set_zero_ratio(double ratio);
    double get_zero_ratio();

    inline int get_zero_offset(){
        return _zero_offset;
    }
    
    int ratio2value(double ratio);
    int ratio2pos(double ratio);
    double value2ratio(int value);
    double pos2ratio(int pos);

    /**
     * Event
     **/
    void resize();

    /**
     * Paints the background layer of the trace with a QPainter
     * @param p the QPainter to paint into.
     * @param left the x-coordinate of the left edge of the signal
     * @param right the x-coordinate of the right edge of the signal
     **/
    void paint_back(QPainter &p, int left, int right, QColor fore, QColor back);

	/**
	 * Paints the signal with a QPainter
	 * @param p the QPainter to paint into.
	 * @param left the x-coordinate of the left edge of the signal.
	 * @param right the x-coordinate of the right edge of the signal.
	 **/
    void paint_mid(QPainter &p, int left, int right, QColor fore, QColor back);

    /**
     * Paints the signal with a QPainter
     * @param p the QPainter to paint into.
     * @param left the x-coordinate of the left edge of the signal.
     * @param right the x-coordinate of the right edge of the signal.
     **/
    void paint_fore(QPainter &p, int left, int right, QColor fore, QColor back);

private:
    void paint_trace(QPainter &p,
                     const dsv::data::AnalogSnapshot *snapshot,
                     int zeroY, const int start_pixel,
                     const uint64_t start_index, const int64_t sample_count,
                     const double samples_per_pixel, const int order,
                     const float top, const float bottom, const int width);

    void paint_envelope(QPainter &p,
                        const dsv::data::AnalogSnapshot *snapshot,
                        int zeroY, const int start_pixel,
                        const uint64_t start_index, const int64_t sample_count,
                        const double samples_per_pixel, const int order,
                        const float top, const float bottom, const int width);

    void paint_hover_measure(QPainter &p, QColor fore, QColor back);

private:
	AnalogSnapshot *_data;
    QRectF *_rects;
	float _scale;
    double _zero_vrate;
    int _zero_offset;
    int _bits;
    double _ref_min;
    double _ref_max;
    bool _hover_en;
    uint64_t _hover_index;
    QPointF _hover_point;
    float _hover_value;
};

} // namespace view
} // namespace dsv

#endif // DSVIEW_PV_ANALOGSIGNAL_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2014 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "devmode.h"
#include <assert.h> 
#include <QStyleOption>
#include <QMouseEvent>
#include <QPainter>
#include <QRect>
#include <QHBoxLayout>
#include "view.h"
#include "trace.h"
#include "../appcore/sigsession.h"
#include "../config/appconfig.h"
#include "../ui/msgbox.h"
#include "../log.h"
#include "../ui/langresource.h"
#include "../appcore/appcontrol.h"
#include "../ui/fn.h"

using namespace dsv::config;
  
namespace dsv {
namespace view {

static const struct dev_mode_name dev_mode_name_list[] =
{
    {LOGIC, "la.svg"},
    {ANALOG, "daq.svg"},
    {DSO, "osc.svg"},
};

DevMode::DevMode(QWidget *parent, SigSession *session) :
    QWidget(parent) 
{
    _bFile = false;

    _session = session;
    _device_agent = session->get_device();

    QHBoxLayout *layout = new QHBoxLayout(this);
    layout->setSpacing(0);
    layout->setContentsMargins(2, 0, 0, 0);

    _close_button = new QToolButton();
    _close_button->setObjectName("FileCloseButton");
    _close_button->setContentsMargins(0, 0, 0, 0);
    _close_button->setFixedWidth(10);
    _close_button->setFixedHeight(height());
    _close_button->setIconSize(QSize(10, 10));
    _close_button->setToolButtonStyle(Qt::ToolButtonIconOnly); 
    _close_button->setMinimumWidth(10);

    _mode_btn = new QToolButton();
    _mode_btn->setObjectName("ModeButton");
    _mode_btn->setIconSize(QSize(height() * 1.5, height()));
    _mode_btn->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
    _mode_btn->setContentsMargins(0, 0, 0, 0);  
    _mode_btn->setPopupMode(QToolButton::InstantPopup);
    _mode_btn->setSizePolicy(QSizePolicy::MinimumExpanding, QSizePolicy::Maximum);

   // _mode_btn->setArrowType(Qt::NoArrow);

    _pop_menu = new QMenu(this);
    _pop_menu->setContentsMargins(15,0,0,0);
    _mode_btn->setMenu(_pop_menu);

    layout->addWidget(_close_button);
    layout->addWidget(_mode_btn); 

    layout->setStretch(1, 100); 
    setLayout(layout);

    update_font();

    connect(_close_button, SIGNAL(clicked()), this, SLOT(on_close()));
}


void DevMode::changeEvent(QEvent *event)
{
    if (event->type() == QEvent::LanguageChange)
        set_device();
    else if (event->type() == QEvent::StyleChange)
        set_device();
    QWidget::changeEvent(event);
}

void DevMode::set_device()
{ 
     if (_device_agent->have_instance() == false){
        dsv_detail("DevMode::set_device, Have no device.");   
        return;
     }

    _bFile = false;
   
   //remove all action object
    for(std::map<QAction *, const sr_dev_mode *>::const_iterator i = _mode_list.begin();
        i != _mode_list.end(); i++) {
        (*i).first->setParent(NULL);
        _pop_menu->removeAction((*i).first);
        delete (*i).first;
    }
    _mode_list.clear();

    _close_button->setIcon(QIcon());
    _close_button->setDisabled(true); 

    QString iconPath = AppConfig::GetIconPath() + "/";
    auto dev_mode_list  = _device_agent->get_device_mode_list();

    for (const GSList *l = dev_mode_list; l; l = l->next)
    {
        const sr_dev_mode *mode = (const sr_dev_mode *)l->data;
        auto *mode_name = get_mode_name(mode->mode);
        QString icon_name = QString::fromLocal8Bit(mode_name->_logo);

        QAction *action = new QAction(this);
        action->setIcon(QIcon(iconPath + "square-" + icon_name));

        int md = mode->mode;

        if (md == LOGIC)
            action->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_DEVICE_MODE_LOGIC), "Logic Analyzer"));
        else if (md == ANALOG)
            action->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_DEVICE_MODE_ANALOG), "Data Acquisition"));
        else if (md == DSO)
            action->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_DEVICE_MODE_DSO), "Oscilloscope"));

        connect(action, SIGNAL(triggered()), this, SLOT(on_mode_change()));

        _mode_list[action] = mode;
        int cur_mode = _device_agent->get_work_mode();
          
        if (cur_mode == _mode_list[action]->mode)
        {
            QString icon_fname = iconPath + icon_name;
            _mode_btn->setIcon(QIcon(icon_fname));
            
            if (cur_mode == LOGIC)
                _mode_btn->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_DEVICE_MODE_LOGIC), "Logic Analyzer"));
            else if (cur_mode == ANALOG)
                _mode_btn->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_DEVICE_MODE_ANALOG), "Data Acquisition"));
            else if (cur_mode == DSO)
                _mode_btn->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_DEVICE_MODE_DSO), "Oscilloscope"));
        }
        _pop_menu->addAction(action);
    }

    if (_device_agent->is_file()){
        _close_button->setDisabled(false);
        _close_button->setIcon(QIcon(iconPath + "/close.svg"));
        _bFile = true;
    }

    update_font();
    update();    
}

void DevMode::paintEvent(QPaintEvent*)
{  
    using dsv::view::Trace;

    QStyleOption o;
    o.initFrom(this);
    QPainter painter(this);
    style()->drawPrimitive(QStyle::PE_Widget, &o, &painter, this);
}

void DevMode::on_mode_change()
{
    if (_device_agent->have_instance() == false){
        assert(false);
    }
    
    QAction *action = qobject_cast<QAction *>(sender());

    if (_device_agent->get_work_mode() == _mode_list[action]->mode){
        return;
    }

    QString iconPath = AppConfig::GetIconPath();

    for(auto i = _mode_list.begin();i != _mode_list.end(); i++)
    {
        if ((*i).first == action){

            int mode = (*i).second->mode;
            if (_device_agent->get_work_mode() == mode){
                dsv_info("Current mode is set.");
                break;
            }
            
            _session->stop_capture();            
            _session->session_save();                                    
            _session->switch_work_mode(mode);

            auto *mode_name = get_mode_name(mode);
            QString icon_fname = iconPath + "/" + QString::fromLocal8Bit(mode_name->_logo);
            
            _mode_btn->setIcon(QIcon(icon_fname));
            int cur_mode = mode_name->_mode;

            if (cur_mode == LOGIC)
                _mode_btn->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_DEVICE_MODE_LOGIC), "Logic Analyzer"));
            else if (cur_mode == ANALOG)
                _mode_btn->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_DEVICE_MODE_ANALOG), "Data Acquisition"));
            else if (cur_mode == DSO)
                _mode_btn->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_DEVICE_MODE_DSO), "Oscilloscope"));
               
            break;                
        }      
    }

    update_font();
}

void DevMode::on_close()
{
   if (_device_agent->have_instance() == false){
        assert(false);
    }

    if (_bFile && MsgBox::Confirm(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_CLOSE_DEVICE), "Are you sure to close the device?"))){
        _session->close_file(_device_agent->handle());
    }
}

void DevMode::mousePressEvent(QMouseEvent *event)
{
	assert(event);
	(void)event;
}

void DevMode::mouseReleaseEvent(QMouseEvent *event)
{
	assert(event);
        (void)event;
}

void DevMode::mouseMoveEvent(QMouseEvent *event)
{
	assert(event);
	_mouse_point = event->pos();
	update();
}

void DevMode::leaveEvent(QEvent*)
{
	_mouse_point = QPoint(-1, -1);
	update();
}

const struct dev_mode_name* DevMode::get_mode_name(int mode) 
{
    for(auto &o : dev_mode_name_list)
        if (mode == o._mode){
            return &o;
    }
    assert(false);
}

void DevMode::update_font()
{
    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
    
    auto buttons = this->findChildren<QToolButton*>();
    for(auto o : buttons)
    { 
        o->setFont(font);
    }

    for (auto it = _mode_list.begin(); it != _mode_list.end(); it++)
    { 
        (*it).first->setFont(font);
    }
}

} // namespace view
} // namespace dsv
/****************************************************************************
** Meta object code from reading C++ file 'dsosignal.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "dsosignal.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'dsosignal.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDsoSignalENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDsoSignalENDCLASS = QtMocHelpers::stringData(
    "dsv::view::DsoSignal"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDsoSignalENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[21];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDsoSignalENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDsoSignalENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDsoSignalENDCLASS = {
    {
        QT_MOC_LITERAL(0, 20)   // "dsv::view::DsoSignal"
    },
    "dsv::view::DsoSignal"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEviewSCOPEDsoSignalENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::view::DsoSignal::staticMetaObject = { {
    QMetaObject::SuperData::link<Signal::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDsoSignalENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEviewSCOPEDsoSignalENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDsoSignalENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<DsoSignal, std::true_type>
    >,
    nullptr
} };

void dsv::view::DsoSignal::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *dsv::view::DsoSignal::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::view::DsoSignal::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEDsoSignalENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return Signal::qt_metacast(_clname);
}

int dsv::view::DsoSignal::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = Signal::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_VIEW_VIEWPORT_H
#define DSVIEW_PV_VIEW_VIEWPORT_H

#include <stdint.h>
#include <QTime>
#include <QTimer>
#include <QWidget>
#include <QNativeGestureEvent>
#include <QElapsedTimer>
#include <chrono>
#include "view.h"
#include "../basedef.h"
#include "../interface/icallbacks.h"

class QPainter;
class QPaintEvent;
class QAction;

using std::chrono::high_resolution_clock;
using std::chrono::milliseconds;

namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
}
using namespace dsv::appcore;

namespace dsv {
namespace view {

class Signal;
class View;

//main graph view port, in the middle region
//draw the left and right rule scale
//created by View
class Viewport : public QWidget, public IFontForm
{
	Q_OBJECT

public:
    static const int HitCursorMargin = 10;
    static const double HitCursorTimeMargin;
    static const int DragTimerInterval = 100;
    static const int MinorDragOffsetUp = 100;
    static const int DsoMeasureStages = 3;
    static const double MinorDragRateUp;
    static const double DragDamping;
    static const int SnapMinSpace = 10;
    static const int WaitLoopTime = 400;
    enum ActionType {
        NO_ACTION,

        CURS_MOVE,

        LOGIC_EDGE,
        LOGIC_MOVE,
        LOGIC_ZOOM,
        LOGIC_JUMP,

        DSO_XM_STEP0,
        DSO_XM_STEP1,
        DSO_XM_STEP2,
        DSO_YM,
        DSO_TRIG_MOVE
    };

    enum MeasureType {
        NO_MEASURE,
        LOGIC_FREQ,
        LOGIC_EDGE_CNT,
        DSO_VALUE
    };

public:
    explicit Viewport(View &parent, View_type type);

    int get_total_height();
    QPoint get_mouse_point();
    QString get_measure(QString option);
    void set_measure_en(int enable);   
    void stop_trigger_timer();

    void clear_measure();
    void clear_dso_xm();
    void set_need_update(bool update);
    bool get_dso_trig_moved();
    void set_receive_len(quint64 length);
    void unshow_wait_trigger();
    void show_wait_trigger();

    void update_lang();

    //IFontForm
    void update_font() override;

protected:
    bool event(QEvent *event) override;
    void paintEvent(QPaintEvent *event) override;

private:
    void doPaint();
    void mousePressEvent(QMouseEvent *event) override;
    void mouseMoveEvent(QMouseEvent *event) override;
    void mouseReleaseEvent(QMouseEvent *event) override;
    void mouseDoubleClickEvent(QMouseEvent *event) override;
    void wheelEvent(QWheelEvent *event) override;
    void leaveEvent(QEvent *) override;
    void resizeEvent(QResizeEvent *e) override;
    bool gestureEvent(QNativeGestureEvent *event);

    void paintSignals(QPainter& p, QColor fore, QColor back);
    void paintProgress(QPainter& p, QColor fore, QColor back);
    void paintMeasure(QPainter &p, QColor fore, QColor back);
    void paintCursors(QPainter &p);

    void measure();
    void start_trigger_timer(int msec);

    void get_captured_progress(double &progress, int &progress100);

private slots:
    void on_trigger_timer();
    void on_drag_timer();
  
    void show_contextmenu(const QPoint& pos);
    void add_cursor_x();
    void add_cursor_y();

signals:
    void measure_updated();
    void prgRate(int progress);

private:
	View        &_view;
    View_type   _type;
    bool        _need_update;
    QPixmap     _pixmap;
    QMenu       *_cmenu;

    uint64_t    _sample_received;
    QPoint      _mouse_point;
    QPoint      _mouse_down_point;
    int64_t     _mouse_down_offset;
    double      _curScale;
    int64_t     _curOffset;
    int         _curSignalHeight;

    bool        _measure_en;
    ActionType  _action_type;
    MeasureType _measure_type;
    uint64_t    _cur_sample;
    uint64_t    _nxt_sample;
    uint64_t    _thd_sample;
    int64_t     _cur_preX;
    int64_t     _cur_aftX;
    int64_t     _cur_thdX;
    int         _cur_midY;
    int         _cur_preY;
    int         _cur_preY_top;
    int         _cur_preY_bottom;
    int         _cur_aftY;
    bool        _edge_hit;
    QString     _mm_width;
    QString     _mm_period;
    QString     _mm_freq;
    QString     _mm_duty;

    uint64_t    _edge_rising;
    uint64_t    _edge_falling;
    uint64_t    _edge_start;
    uint64_t    _edge_end;
    QString     _em_rising;
    QString     _em_falling;
    QString     _em_edges;

    QTimer      _trigger_timer;
    bool        _is_checked_trig;
    bool        _transfer_started;
    int         _timer_cnt;
    Signal      *_drag_sig;
    uint64_t    _hover_index;
    bool        _hover_hit;
    uint16_t    _hover_sig_index;
    double      _hover_sig_value;

    QElapsedTimer   _elapsed_time;
    QTimer          _drag_timer;
    int             _drag_strength;
    bool            _dso_xm_valid;
    int             _dso_xm_y;
    uint64_t        _dso_xm_index[DsoMeasureStages];

    bool            _dso_ym_valid;
    uint16_t        _dso_ym_sig_index;
    double          _dso_ym_sig_value;
    uint64_t        _dso_ym_index;
    int             _dso_ym_start;
    int             _dso_ym_end;
    int             _waiting_trig;
    bool            _dso_trig_moved;
    bool            _curs_moved;
    bool            _xcurs_moved;
    int             _clickX;

    high_resolution_clock::time_point _lst_wait_tigger_time;
    int             _tigger_wait_times;
    QAction         *_yAction;
    QAction         *_xAction;
};

} // namespace view
} // namespace dsv

#endif // DSVIEW_PV_VIEW_VIEWPORT_H
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_VIEW_SPECTRUMTRACE_H
#define DSVIEW_PV_VIEW_SPECTRUMTRACE_H

#include "trace.h"
#include <list>
#include <map>
 
struct srd_channel;

namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
    namespace data{
        class SpectrumStack;
    }
}
using namespace dsv::appcore;
using namespace dsv::data;

namespace dsv {
namespace view {

//when device is oscillcopse mode, to draw signal trace
//created by SigSession
class SpectrumTrace : public Trace
{
    Q_OBJECT

private:
    static const int UpMargin;
    static const int DownMargin;
    static const int RightMargin;
    static const QString FFT_ViewMode[2];

    static const QString FreqPrefixes[9];
    static const int FirstSIPrefixPower;
    static const int LastSIPrefixPower;
    static const int Pricision;
    static const int FreqMinorDivNum;
    static const int TickHeight;
    static const int VolDivNum;

    static const int DbvRanges[4];

    static const int HoverPointSize;

    static const double VerticalRate;

public:
    SpectrumTrace(SigSession *session,SpectrumStack *spectrum_stack, int index);
    ~SpectrumTrace();

    bool enabled();
    void set_enable(bool enable);

    void init_zoom();
    void zoom(double steps, int offset);
    bool zoom_hit();
    void set_zoom_hit(bool hit);

    void set_offset(double delta);
    double get_offset();

    void set_scale(double scale);
    double get_scale();

    void set_dbv_range(int range);
    int dbv_range();
    std::vector<int> get_dbv_ranges();

    int view_mode();
    void set_view_mode(unsigned int mode);
    std::vector<QString> get_view_modes_support();

    inline SpectrumStack* get_spectrum_stack(){
        return _spectrum_stack;
    }

    static QString format_freq(double freq, unsigned precision = Pricision);

    bool measure(const QPoint &p);

    /**
     * Paints the background layer of the trace with a QPainter
     * @param p the QPainter to paint into.
     * @param left the x-coordinate of the left edge of the signal.
     * @param right the x-coordinate of the right edge of the signal.
     **/
    void paint_back(QPainter &p, int left, int right, QColor fore, QColor back);

    /**
     * Paints the mid-layer of the trace with a QPainter
     * @param p the QPainter to paint into.
     * @param left the x-coordinate of the left edge of the signal
     * @param right the x-coordinate of the right edge of the signal
     **/
    void paint_mid(QPainter &p, int left, int right, QColor fore, QColor back);

    /**
     * Paints the foreground layer of the trace with a QPainter
     * @param p the QPainter to paint into.
     * @param left the x-coordinate of the left edge of the signal
     * @param right the x-coordinate of the right edge of the signal
     **/
    void paint_fore(QPainter &p, int left, int right, QColor fore, QColor back);

    QRect get_view_rect();

protected:
    void paint_type_options(QPainter &p, int right, const QPoint pt, QColor fore);


private:
    SigSession *_session;
    SpectrumStack *_spectrum_stack;

    bool _enable;
    int _view_mode;

    double _vmax;
    double _vmin;
    int _dbv_range;

    uint64_t _hover_index;
    bool _hover_en;
    QPointF _hover_point;
    double _hover_value;

    double _scale;
    double _offset;
};

} // namespace view
} // namespace dsv

#endif // DSVIEW_PV_VIEW_SPECTRUMTRACE_H
/****************************************************************************
** Meta object code from reading C++ file 'xcursor.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "xcursor.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'xcursor.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEXCursorENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEXCursorENDCLASS = QtMocHelpers::stringData(
    "dsv::view::XCursor",
    "value_changed",
    "",
    "on_signal_deleted",
    "o"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEXCursorENDCLASS_t {
    uint offsetsAndSizes[10];
    char stringdata0[19];
    char stringdata1[14];
    char stringdata2[1];
    char stringdata3[18];
    char stringdata4[2];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEXCursorENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEXCursorENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEXCursorENDCLASS = {
    {
        QT_MOC_LITERAL(0, 18),  // "dsv::view::XCursor"
        QT_MOC_LITERAL(19, 13),  // "value_changed"
        QT_MOC_LITERAL(33, 0),  // ""
        QT_MOC_LITERAL(34, 17),  // "on_signal_deleted"
        QT_MOC_LITERAL(52, 1)   // "o"
    },
    "dsv::view::XCursor",
    "value_changed",
    "",
    "on_signal_deleted",
    "o"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEviewSCOPEXCursorENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       2,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   26,    2, 0x06,    1 /* Public */,

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       3,    1,   27,    2, 0x08,    2 /* Private */,

 // signals: parameters
    QMetaType::Void,

 // slots: parameters
    QMetaType::Void, QMetaType::VoidStar,    4,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::view::XCursor::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEXCursorENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEviewSCOPEXCursorENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEXCursorENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<XCursor, std::true_type>,
        // method 'value_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_signal_deleted'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<void *, std::false_type>
    >,
    nullptr
} };

void dsv::view::XCursor::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<XCursor *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->value_changed(); break;
        case 1: _t->on_signal_deleted((*reinterpret_cast< std::add_pointer_t<void*>>(_a[1]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (XCursor::*)();
            if (_t _q_method = &XCursor::value_changed; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
    }
}

const QMetaObject *dsv::view::XCursor::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::view::XCursor::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEXCursorENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int dsv::view::XCursor::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 2)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 2;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 2)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 2;
    }
    return _id;
}

// SIGNAL 0
void dsv::view::XCursor::value_changed()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "header.h"  
#include <QColorDialog>
#include <QInputDialog>
#include <QMenu>
#include <QMouseEvent>
#include <QPainter>
#include <QRect>
#include <QStyleOption>
#include <QApplication>
#include <assert.h>
#include <algorithm>
#include <QFont>
#include "view.h"
#include "trace.h"
#include "dsosignal.h"
#include "logicsignal.h"
#include "analogsignal.h"
#include "groupsignal.h"
#include "decodetrace.h"
#include "../appcore/sigsession.h"
#include "../basedef.h"
#include "../ui/langresource.h"
#include "../appcore/appcontrol.h"
#include "../config/appconfig.h"
#include "../ui/fn.h"
 
using namespace std;
using namespace dsv::config;

namespace dsv {
namespace view {

Header::Header(View &parent) :
	QWidget(&parent),
    _view(parent)
{
    _moveFlag = false;
    _colorFlag = false;
    _nameFlag = false;
    _context_trace = NULL;
    
    nameEdit = new QLineEdit(this);
    nameEdit->setFixedWidth(100);
    nameEdit->hide();

	setMouseTracking(true);

    connect(nameEdit, SIGNAL(editingFinished()),
            this, SLOT(on_action_set_name_triggered()));

    retranslateUi();
}

void Header::changeEvent(QEvent *event)
{
    if (event->type() == QEvent::LanguageChange)
        retranslateUi();
    QWidget::changeEvent(event);
}

void Header::retranslateUi()
{
    update();
}


int Header::get_nameEditWidth()
{ 
    if (nameEdit->hasFocus())
        return nameEdit->width();
    else
        return 0;
}

dsv::view::Trace* Header::get_mTrace(int &action, const QPoint &pt)
{
    const int w = width();
    std::vector<Trace*> traces;
    _view.get_traces(ALL_VIEW, traces);

    for(auto t : traces)
    {
        if ((action = t->pt_in_rect(t->get_y(), w, pt)))
            return t;
    }

    return NULL;
}

void Header::paintEvent(QPaintEvent*)
{ 
    using dsv::view::Trace;

    QStyleOption o;
    o.initFrom(this);
    QPainter painter(this);
    style()->drawPrimitive(QStyle::PE_Widget, &o, &painter, this);

	const int w = width();
    std::vector<Trace*> traces;
    _view.get_traces(ALL_VIEW, traces);

    const bool dragging = !_drag_traces.empty();
    QColor fore(QWidget::palette().color(QWidget::foregroundRole()));
    fore.setAlpha(View::ForeAlpha);
 
    QFont font(painter.font());
    float fSize = AppConfig::Instance().appOptions.fontSize;
    if (fSize > 10)
        fSize = 10;
    font.setPointSizeF(fSize);
    painter.setFont(font);

    for(auto t : traces)
	{
        t->paint_label(painter, w, dragging ? QPoint(-1, -1) : _mouse_point, fore);
	}

	painter.end();
}

void Header::mouseDoubleClickEvent(QMouseEvent *event)
{
    assert(event);

    std::vector<Trace*> traces;

    _view.get_traces(ALL_VIEW, traces);

    if (event->button() & Qt::LeftButton) {
        _mouse_down_point = event->pos();

        // Save the offsets of any Traces which will be dragged
        for(auto t : traces){
            if (t->selected())
                _drag_traces.push_back(
                    make_pair(t, t->get_v_offset()));
        }

        // Select the Trace if it has been clicked
        for(auto t : traces){
            if (t->mouse_double_click(width(), event->pos()))
                break;
        }
    }

}

void Header::mousePressEvent(QMouseEvent *event)
{
	assert(event);

    std::vector<Trace*> traces;
    _view.get_traces(ALL_VIEW, traces);
    int action;

    const bool instant = _view.session().is_instant();
    if (instant && _view.session().is_running_status()) {
        return;
    }

	if (event->button() & Qt::LeftButton) {
		_mouse_down_point = event->pos();

        // Save the offsets of any Traces which will be dragged
        for(auto t : traces){
            if (t->selected())
                _drag_traces.push_back(
                    make_pair(t, t->get_v_offset()));
        }

        // Select the Trace if it has been clicked
        const auto mTrace = get_mTrace(action, event->pos());
        if (action == Trace::COLOR && mTrace) {
            _colorFlag = true;
        }
        else if (action == Trace::NAME && mTrace) {
            _nameFlag = true;
        }
        else if (action == Trace::LABEL && mTrace) {
            mTrace->select(true);

            if (~QApplication::keyboardModifiers() & Qt::ControlModifier)
                _drag_traces.clear();
            
            _drag_traces.push_back(make_pair(mTrace, mTrace->get_zero_vpos()));
            mTrace->set_old_v_offset(mTrace->get_v_offset());
        }

        for(auto t : traces){
            if (t->signal_type() == SR_CHANNEL_LOGIC && _view.session().is_working()){
                // Disable set trigger from left pannel when capturing.
                break;
            }
            if (t->mouse_press(width(), event->pos()))
                break;
        }

        if (~QApplication::keyboardModifiers() & Qt::ControlModifier) {
            // Unselect all other Traces because the Ctrl is not
            // pressed
            for(auto t : traces){
                if (t != mTrace)
                    t->select(false);
            }
        }
        update();
    }
}

void Header::mouseReleaseEvent(QMouseEvent *event)
{
	assert(event);

    // judge for color / name / trigger / move
    int action;
    const auto mTrace = get_mTrace(action, event->pos());

    if (mTrace){
        if (action == Trace::COLOR && _colorFlag) {
            _context_trace = mTrace;
            changeColor(event);
            _view.set_all_update(true);
        }
        else if (action == Trace::NAME && _nameFlag) {
            _context_trace = mTrace;
            changeName(event);
        }
    }

    // Make view index by Y value;
    int mode = _view.session().get_device()->get_work_mode();    
    if (_moveFlag && mode == LOGIC)
    {
        std::vector<Trace*> traces;

        for (auto s : _view.session().get_decode_signals()){
            traces.push_back(s);
        }

        for (auto s : _view.session().get_signals()){
            traces.push_back(s);
        }
    
        sort(traces.begin(), traces.end(), View::compare_trace_y);

        int index = 0;
        for (auto t : traces){
            t->set_view_index(index++);
        }
    }

    if (_moveFlag) {
        _drag_traces.clear();
        _view.signals_changed(mTrace);
        _view.set_all_update(true);

        std::vector<Trace*> traces;
        _view.get_traces(ALL_VIEW, traces);

        for(auto t : traces){
            t->select(false);
        }            
    }

    _colorFlag = false;
    _nameFlag = false;
    _moveFlag = false;

    _view.normalize_layout();
}

void Header::wheelEvent(QWheelEvent *event)
{
    assert(event);

    int x = 0;
    int y = 0;
    int delta = 0;
    bool isVertical = true;
    QPoint pos;
    (void)x;
    (void)y;
     
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
    x = (int)event->position().x();
    y = (int)event->position().y();    
    int anglex = event->angleDelta().x();
    int angley = event->angleDelta().y();

    pos.setX(x);
    pos.setY(y);

    if (anglex == 0 || ABS_VAL(angley) >= ABS_VAL(anglex)){
        delta = angley;
        isVertical = true;
    }
    else{
        delta = anglex;
        isVertical = false; //hori direction
    }
#else
    x = event->x();
    delta = event->delta();
    isVertical = event->orientation() == Qt::Vertical;
    pos = event->pos(); 
#endif

    if (isVertical)
    {
        std::vector<Trace*> traces;
        _view.get_traces(ALL_VIEW, traces);
        // Vertical scrolling
        double shift = 0;

#ifdef Q_OS_DARWIN
        static bool active = true;
        static int64_t last_time;
        if (event->source() == Qt::MouseEventSynthesizedBySystem)
        {
            if (active)
            {
                last_time = QDateTime::currentMSecsSinceEpoch();
                shift = delta > 1.5 ? -1 : delta < -1.5 ? 1 : 0;
            }
            int64_t cur_time = QDateTime::currentMSecsSinceEpoch();
            if (cur_time - last_time > 100)
                active = true;
            else
                active = false;
        }
        else
        {
            shift = -delta / 80.0;
        }
#else
        shift = delta / 80.0;
#endif

        for (auto t : traces)
        {
            if (t->mouse_wheel(width(), pos, shift))
                break;
        }

        update();
    }
}

void Header::changeName(QMouseEvent *event)
{
    if (_context_trace != NULL
        && _context_trace->get_type() != SR_CHANNEL_DSO
        && event->button() == Qt::LeftButton) 
    {
        header_resize();
        QFont font = this->font();
        float fsize = AppConfig::Instance().appOptions.fontSize;
        font.setPointSizeF(fsize <= 10 ? fsize: 10);
        nameEdit->setFont(font);

        nameEdit->setText(_context_trace->get_name());
        nameEdit->selectAll();
        nameEdit->setFocus();
        nameEdit->show();
        header_updated();
    }
}

void Header::changeColor(QMouseEvent *event)
{
    if ((event->button() == Qt::LeftButton)) {
        const QColor new_color = QColorDialog::getColor(_context_trace->get_colour(), this, L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SET_CHANNEL_COLOUR), "Set Channel Colour"));
        if (new_color.isValid())
            _context_trace->set_colour(new_color);
    }
}

void Header::mouseMoveEvent(QMouseEvent *event)
{
	assert(event);

    if (_view.session().is_working() && _view.session().get_device()->get_work_mode() == LOGIC){
        //Disable the hover status of trig button on left pannel.
        return;
    }

	_mouse_point = event->pos();

    // Move the Traces if we are dragging
    if (!_drag_traces.empty()) {
		const int delta = event->pos().y() - _mouse_down_point.y();

        for (auto i = _drag_traces.begin(); i != _drag_traces.end(); i++) {
            const auto t = (*i).first;
			if (t) {
                int y = (*i).second + delta;
                if (t->get_type() == SR_CHANNEL_DSO) {
                    DsoSignal *dsoSig = NULL;
                    if ((dsoSig = dynamic_cast<DsoSignal*>(t))) {
                        dsoSig->set_zero_vpos(y);
                        _moveFlag = true;
                        traces_moved();
                    }
                } else if (t->get_type() == SR_CHANNEL_MATH) {
                    MathTrace *mathTrace = NULL;
                    if ((mathTrace = dynamic_cast<MathTrace*>(t))) {
                       mathTrace->set_zero_vpos(y);
                       _moveFlag = true;
                       traces_moved();
                    }
                 } else if (t->get_type() == SR_CHANNEL_ANALOG) {
                    AnalogSignal *analogSig = NULL;
                    if ((analogSig = dynamic_cast<AnalogSignal*>(t))) {
                        analogSig->set_zero_vpos(y);
                        _moveFlag = true;
                        traces_moved();
                    }
                } else {
                    if (~QApplication::keyboardModifiers() & Qt::ControlModifier) {
                        const int y_snap =
                            ((y + View::SignalSnapGridSize / 2) /
                                View::SignalSnapGridSize) *
                                View::SignalSnapGridSize;
                        if (y_snap != t->get_v_offset()) {
                            _moveFlag = true;
                            t->set_v_offset(y_snap);
                        }
                    }
                }
			}
		}
	}
	update();
}

void Header::leaveEvent(QEvent*)
{
	_mouse_point = QPoint(-1, -1);
	update();
}

void Header::contextMenuEvent(QContextMenuEvent *event)
{
    (void)event;

    int action;

    const auto t = get_mTrace(action, _mouse_point);

    if (!t || !t->selected() || action != Trace::LABEL)
        return;
}

void Header::on_action_set_name_triggered()
{
    auto context_Trace = _context_trace;
    if (!context_Trace)
		return;

    if (nameEdit->isModified()) {
        QString v = nameEdit->text().trimmed();
        if (v == "")
            v = QString::number(context_Trace->get_index());
        
        _view.session().set_trace_name(context_Trace, v);
    }

    nameEdit->hide();
    header_updated();
}

void Header::header_resize()
{
    if (_context_trace) {
        const int y = _context_trace->get_y();
        nameEdit->move(QPoint(_context_trace->get_leftWidth(), y - nameEdit->height() / 2));
    }
}


} // namespace view
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2014 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "trace.h"
#include <assert.h>
#include <math.h> 
#include <QFormLayout>
#include <QLineEdit>
#include <QApplication>
#include "view.h"
#include "../appcore/sigsession.h"
#include "../basedef.h"
#include "../config/appconfig.h"
#include "../appcore/appcontrol.h"

using namespace dsv::config;

namespace dsv {
namespace view {

const QColor Trace::PROBE_COLORS[8] = {
    QColor(0x50, 0x50, 0x50),	// Black
    QColor(0x8F, 0x52, 0x02),	// Brown
    QColor(0xCC, 0x00, 0x00),	// Red
    QColor(0xF5, 0x79, 0x00),	// Orange
    QColor(0xED, 0xD4, 0x00),	// Yellow
    QColor(0x73, 0xD2, 0x16),	// Green
    QColor(0x34, 0x65, 0xA4),	// Blue
    QColor(0x75, 0x50, 0x7B),	// Violet
};
const int Trace::LabelHitPadding = 2;

Trace::Trace(QString name, uint16_t index, int type) :
    _view(NULL),
	_name(name),
    _v_offset(INT_MAX),
    _type(type),
    _sec_index(0),
    _totalHeight(30),
    _typeWidth(SquareNum)
{
    _index_list.push_back(index);
    _view_index = -1;
    _selected = false;
}

Trace::Trace(QString name, std::list<int> index_list, int type, int sec_index) :
    _view(NULL),
    _name(name),
    _v_offset(INT_MAX),
    _type(type),
    _index_list(index_list),
    _sec_index(sec_index),
    _totalHeight(30),
    _typeWidth(SquareNum)
{
    _view_index = -1;
    _selected = false;
}

Trace::Trace(const Trace &t) :
    _view(t._view),
    _name(t._name),
    _colour(t._colour),
    _v_offset(t._v_offset),
    _type(t._type),
    _index_list(t._index_list),
    _sec_index(t._sec_index),
    _old_v_offset(t._old_v_offset),
    _totalHeight(t._totalHeight),
    _typeWidth(t._typeWidth),
    _text_size(t._text_size)
{
    _view_index = -1;
    _selected = false;
}


int Trace::get_name_width()
{
    QFont font;
    float fSize = AppConfig::Instance().appOptions.fontSize;
    font.setPointSizeF(fSize <= 10 ? fSize : 10);
    QFontMetrics fm(font);

    return fm.boundingRect(get_name()).width();
}

void Trace::set_name(QString name)
{
	_name = name;
}

int Trace::get_index()
{
    if(_index_list.size() == 0){
        assert(false);
    }
    
    return _index_list.front();
}

void Trace::set_index_list(const std::list<int> &index_list)
{
    if (index_list.size() == 0){
        assert(false);
    }

    _index_list = index_list;
}

int Trace::get_zero_vpos()
{
    return _v_offset;
}

void Trace::resize()
{
}

void Trace::set_view(dsv::view::View *view)
{
	assert(view);
	_view = view;
    connect(_view, SIGNAL(resize()), this, SLOT(resize()));
}

void Trace::set_viewport(dsv::view::Viewport *viewport)
{
    assert(viewport);
    _viewport = viewport;
}
 
void Trace::paint_prepare()
{
    assert(_view);
    _view->set_trig_hoff(0);
}

void Trace::paint_back(QPainter &p, int left, int right, QColor fore, QColor back)
{
    (void)back;

    fore.setAlpha(View::BackAlpha);
    QPen pen(fore);
    pen.setStyle(Qt::DotLine);
    p.setPen(pen);
    const double sigY = get_y();
    p.drawLine(left, sigY, right, sigY);
}

void Trace::paint_mid(QPainter &p, int left, int right, QColor fore, QColor back)
{
	(void)p;
	(void)left;
	(void)right;
    (void)fore;
    (void)back;
}

void Trace::paint_fore(QPainter &p, int left, int right, QColor fore, QColor back)
{
	(void)p;
	(void)left;
	(void)right;
    (void)fore;
    (void)back;
}

void Trace::paint_label(QPainter &p, int right, const QPoint pt, QColor fore)
{
    if (_type == SR_CHANNEL_FFT && !enabled())
        return;

    compute_text_size(p);
    const int y = get_y();

    const QRectF color_rect = get_rect("color", y, right);
    const QRectF name_rect  = get_rect("name",  y, right);
    const QRectF label_rect = get_rect("label", get_zero_vpos(), right);

    // Paint the ColorButton
    QColor foreBack = fore;
    foreBack.setAlpha(View::BackAlpha);
    p.setPen(Qt::transparent);
    p.setBrush(enabled() ? (_colour.isValid() ? _colour : fore) : foreBack);
    p.drawRect(color_rect);
    
    if (_type == SR_CHANNEL_DSO ||
        _type == SR_CHANNEL_MATH) {
        p.setPen(enabled() ?  Qt::white: foreBack);
        p.drawText(color_rect, Qt::AlignCenter | Qt::AlignVCenter, _name);
    }

    if (_type != SR_CHANNEL_DSO) {
        // Paint the signal name
        p.setPen(enabled() ?  fore: foreBack);
        p.drawText(name_rect, Qt::AlignLeft | Qt::AlignVCenter, _name);
    }

    // Paint the trigButton
    paint_type_options(p, right, pt, fore);

    // Paint the label
    if (enabled()) {
        const QPointF points[] = {
            label_rect.topLeft(),
            label_rect.topRight(),
            QPointF(right, get_zero_vpos()),
            label_rect.bottomRight(),
            label_rect.bottomLeft()
        };

        p.setPen(Qt::transparent);
        if (_type == SR_CHANNEL_DSO ||
            _type == SR_CHANNEL_FFT ||
            _type == SR_CHANNEL_ANALOG ||
            _type == SR_CHANNEL_MATH) {
            p.setBrush(_colour);
            p.drawPolygon(points, countof(points));
        } else {
            QColor color = PROBE_COLORS[*_index_list.begin() % countof(PROBE_COLORS)];
            p.setBrush(color);
            p.drawPolygon(points, countof(points));
        }

        p.setPen(Qt::white);
        const QPointF arrow_points[] = {
            QPoint(label_rect.right(), label_rect.center().y()),
            QPoint(label_rect.right(), label_rect.center().y()-1),
            QPoint(label_rect.right(), label_rect.center().y()+1),
            QPoint(label_rect.right(), label_rect.center().y()-2),
            QPoint(label_rect.right(), label_rect.center().y()+2),
            QPoint(label_rect.right(), label_rect.center().y()-3),
            QPoint(label_rect.right(), label_rect.center().y()+3),
            QPoint(label_rect.right(), label_rect.center().y()-4),
            QPoint(label_rect.right(), label_rect.center().y()+4),
            QPoint(label_rect.right()-1, label_rect.center().y()-3),
            QPoint(label_rect.right()-1, label_rect.center().y()+3),
            QPoint(label_rect.right()+1, label_rect.center().y()-3),
            QPoint(label_rect.right()+1, label_rect.center().y()+3),
            QPoint(label_rect.right()-1, label_rect.center().y()-2),
            QPoint(label_rect.right()-1, label_rect.center().y()+2),
            QPoint(label_rect.right()+1, label_rect.center().y()-2),
            QPoint(label_rect.right()+1, label_rect.center().y()+2),
            QPoint(label_rect.right()-2, label_rect.center().y()-2),
            QPoint(label_rect.right()-2, label_rect.center().y()+2),
            QPoint(label_rect.right()+2, label_rect.center().y()-2),
            QPoint(label_rect.right()+2, label_rect.center().y()+2),
        };
        if (label_rect.contains(pt) || selected())
            p.drawPoints(arrow_points, countof(arrow_points));

        // Paint the text
        p.setPen(Qt::white);
        if (_type == SR_CHANNEL_GROUP)
            p.drawText(label_rect, Qt::AlignCenter | Qt::AlignVCenter, "G");
        else if (_type == SR_CHANNEL_DECODER)
            p.drawText(label_rect, Qt::AlignCenter | Qt::AlignVCenter, "D");
        else if (_type == SR_CHANNEL_FFT)
            p.drawText(label_rect, Qt::AlignCenter | Qt::AlignVCenter, "F");
        else if (_type == SR_CHANNEL_MATH)
            p.drawText(label_rect, Qt::AlignCenter | Qt::AlignVCenter, "M");
        else
            p.drawText(label_rect, Qt::AlignCenter | Qt::AlignVCenter, QString::number(_index_list.front()));
    }
}

void Trace::paint_type_options(QPainter &p, int right, const QPoint pt, QColor fore)
{
    (void)p;
    (void)right;
    (void)pt;
    (void)fore;
}

bool Trace::mouse_double_click(int right, const QPoint pt)
{
    (void)right;
    (void)pt;
    return false;
}

bool Trace::mouse_press(int right, const QPoint pt)
{
    (void)right;
    (void)pt;
    return false;
}

bool Trace::mouse_wheel(int right, const QPoint pt, const int shift)
{
    (void)right;
    (void)pt;
    (void)shift;
    return false;
}

int Trace::pt_in_rect(int y, int right, const QPoint &point)
{
    const QRectF color = get_rect("color", y, right);
    const QRectF name  = get_rect("name", y, right);
    const QRectF label = get_rect("label", get_zero_vpos(), right);

    if (color.contains(point) && enabled())
        return COLOR;
    else if (name.contains(point) && enabled())
        return NAME;
    else if (label.contains(point) && enabled())
        return LABEL;
    else
        return 0;
}

void Trace::compute_text_size(QPainter &p)
{
    _text_size = QSize(
        p.boundingRect(QRectF(), 0, "99").width(),
        p.boundingRect(QRectF(), 0, "99").height());
}

QRect Trace::get_view_rect()
{
    assert(_view);
    return QRect(0, 0, _view->viewport()->width(), _view->viewport()->height());
}

QColor Trace::get_text_colour()
{
	return (_colour.lightness() > 64) ? Qt::black : Qt::white;
}

int Trace::rows_size()
{
    return 1;
}

QRectF Trace::get_rect(const char *s, int y, int right)
{
    const QSizeF color_size(get_leftWidth() - Margin, SquareWidth);
   // const QSizeF name_size(right - get_leftWidth() - get_rightWidth(), SquareWidth);
    const QSizeF name_size(right - get_leftWidth() - get_rightWidth(), SquareWidth);
    const QSizeF label_size(SquareWidth, SquareWidth);

    if (!strcmp(s, "name"))
        return QRectF(
            get_leftWidth(),
            y - name_size.height() / 2,
            name_size.width(), name_size.height());
    else if (!strcmp(s, "label"))
        return QRectF(
            right - 1.5f * label_size.width(),
            y - label_size.height() / 2,
            label_size.width(), label_size.height());
    else if (!strcmp(s, "color"))
        return QRectF(
            2,
            y - color_size.height() / 2,
            color_size.width(), color_size.height());
    else
        return QRectF(
            2,
            y - SquareWidth / 2,
            SquareWidth, SquareWidth);
}

} // namespace view
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_SIGNAL_H
#define DSVIEW_PV_SIGNAL_H
 
#include <QColor>
#include <QPainter>
#include <QPen>
#include <QRect>
#include <QString>
#include <stdint.h>
#include <list>
#include <libsigrok.h> 
#include "trace.h"

namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
    namespace data {
        class SignalData;
    }
}
using namespace dsv::appcore;
using namespace dsv::data;

namespace dsv {
namespace view {

//draw signal trace base class
class Signal : public Trace
{
    Q_OBJECT

signals:
    void sig_released(void *o);

protected:
    Signal(sr_channel * const probe);

    /**
     * Copy constructor
     */
    Signal(const Signal &s, sr_channel * const probe);

public: 
    /**
     * Returns true if the trace is visible and enabled.
     */
    bool enabled();

    /**
     * Sets the name of the signal.
     */
    void set_name(QString name);


protected: 
    sr_channel *const _probe;
    SigSession      *session;    
};

} // namespace view
} // namespace dsv

#endif // DSVIEW_PV_SIGNAL_H
/****************************************************************************
** Meta object code from reading C++ file 'analogsignal.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "analogsignal.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'analogsignal.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEAnalogSignalENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEAnalogSignalENDCLASS = QtMocHelpers::stringData(
    "dsv::view::AnalogSignal"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEAnalogSignalENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[24];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEAnalogSignalENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEAnalogSignalENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEAnalogSignalENDCLASS = {
    {
        QT_MOC_LITERAL(0, 23)   // "dsv::view::AnalogSignal"
    },
    "dsv::view::AnalogSignal"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEviewSCOPEAnalogSignalENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::view::AnalogSignal::staticMetaObject = { {
    QMetaObject::SuperData::link<Signal::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEAnalogSignalENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEviewSCOPEAnalogSignalENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEAnalogSignalENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<AnalogSignal, std::true_type>
    >,
    nullptr
} };

void dsv::view::AnalogSignal::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *dsv::view::AnalogSignal::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::view::AnalogSignal::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEAnalogSignalENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return Signal::qt_metacast(_clname);
}

int dsv::view::AnalogSignal::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = Signal::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

/*
#include "../basedef.h"
#include "groupsignal.h" 
#include "view.h"
#include <cmath>
 
using namespace std;

namespace dsv {
namespace view {

const QColor GroupSignal::SignalColours[4] = {
	QColor(0xC4, 0xA0, 0x00),	// Yellow
	QColor(0x87, 0x20, 0x7A),	// Magenta
	QColor(0x20, 0x4A, 0x87),	// Blue
	QColor(0x4E, 0x9A, 0x06)	// Green
};

const float GroupSignal::EnvelopeThreshold = 256.0f;

GroupSignal::GroupSignal(QString name,
                         std::list<int> probe_index_list, int group_index) :
    Trace(name, probe_index_list, SR_CHANNEL_GROUP, group_index)
{
    _colour = SignalColours[probe_index_list.front() % countof(SignalColours)];
    _scale = _totalHeight * 1.0f / std::pow(2.0, static_cast<double>(probe_index_list.size()));
}

GroupSignal::~GroupSignal()
{
}

bool GroupSignal::enabled()
{
    return true;
}

dsv::data::SignalData* GroupSignal::data()
{
    return NULL;
}

void GroupSignal::set_scale(float scale)
{
	_scale = scale;
}

void GroupSignal::paint_mid(QPainter &p, int left, int right, QColor fore, QColor back)
{
   
}

void GroupSignal::paint_trace(QPainter &p,
	int y, int left, const int64_t start, const int64_t end,
	const double pixels_offset, const double samples_per_pixel)
{
	 
}

void GroupSignal::paint_envelope(QPainter &p,
	int y, int left, const int64_t start, const int64_t end,
	const double pixels_offset, const double samples_per_pixel)
{ 

 
}

void GroupSignal::paint_type_options(QPainter &p, int right, const QPoint pt, QColor fore)
{ 
}

QRectF GroupSignal::get_rect(GroupSetRegions type, int y, int right)
{ 
}

} // namespace view
} // namespace dsv

*/
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2014 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_VIEW_DEVMODE_H
#define DSVIEW_PV_VIEW_DEVMODE_H
 
#include <list>
#include <utility>
#include <map>
#include <set>
#include <QWidget>
#include <QPushButton>
#include <QVector>
#include <QToolButton>
#include <QLabel>
#include <libsigrok.h> 
#include "../interface/icallbacks.h"

namespace dsv{
	namespace appcore{
    	class SigSession;
        class DeviceAgent;
	}
}
using namespace dsv::appcore;

namespace dsv {
namespace view {

struct dev_mode_name{
    int _mode;
    const char *_logo;
};

//devece work mode select list
class DevMode : public QWidget, public IFontForm
{
	Q_OBJECT

private:
    static const int GRID_COLS = 3;

public:
    DevMode(QWidget *parent, SigSession *session);

private:
	void paintEvent(QPaintEvent *event);
	void mousePressEvent(QMouseEvent * event);
	void mouseReleaseEvent(QMouseEvent *event);
	void mouseMoveEvent(QMouseEvent *event);
	void leaveEvent(QEvent *event);
    void changeEvent(QEvent *event);
    const struct dev_mode_name* get_mode_name(int mode);

    //IFontForm
    void update_font() override;

public slots:
    void set_device();
    void on_mode_change();
    void on_close(); 

private:
    SigSession *_session;
    std::map <QAction *, const sr_dev_mode *> _mode_list;
    QToolButton     *_mode_btn;
    QMenu           *_pop_menu;
    QPoint          _mouse_point;
    QToolButton     *_close_button;
    bool            _bFile;

    DeviceAgent     *_device_agent;
};

} // namespace view
} // namespace dsv

#endif // DSVIEW_PV_VIEW_DEVMODE_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "analogsignal.h"
#include <math.h>
#include "../data/analogsnapshot.h"
#include "view.h"
#include "../basedef.h"
#include "../log.h"
#include "../appcore/sigsession.h"

using namespace std;

#define byte(x) uint##x##_t

namespace dsv {
    namespace view {

        const QColor AnalogSignal::SignalColours[4] = {
            QColor(238, 178, 17, 255),  // dsYellow
            QColor(0, 153, 37, 255),    // dsGreen
            QColor(213, 15, 37, 255),   // dsRed
            QColor(17, 133, 209, 255)  // dsBlue
        };

        const float AnalogSignal::EnvelopeThreshold = 16.0f;

        AnalogSignal::AnalogSignal(data::AnalogSnapshot* data, sr_channel* probe) :
            Signal(probe),
            _data(data),
            _rects(NULL),
            _hover_en(false),
            _hover_index(0),
            _hover_point(QPointF(-1, -1)),
            _hover_value(0)
        {
            _typeWidth = 5;
            _colour = SignalColours[probe->index % countof(SignalColours)];

            uint32_t ui32;

            // channel bits
            bool ret = session->get_device()->get_config_byte(SR_CONF_UNIT_BITS, _bits);
            if (!ret) {
                _bits = DefaultBits;
                dsv_warn("%s%d", "Warning: config_get SR_CONF_UNIT_BITS failed, set to %d(default).", DefaultBits);
            }

            ret = session->get_device()->get_config_uint32(SR_CONF_REF_MIN, ui32);
            if (ret)
                _ref_min = (double)ui32;
            else
                _ref_min = 1;

            ret = session->get_device()->get_config_uint32(SR_CONF_REF_MAX, ui32);
            if (ret)
                _ref_max = (double)ui32;
            else
                _ref_max = ((1 << _bits) - 1);

            // -- vpos
            ret = session->get_device()->get_config_uint16(SR_CONF_PROBE_OFFSET, _zero_offset, _probe, NULL);
            if (!ret) {
                dsv_err("ERROR: config_get SR_CONF_PROBE_OFFSET failed.");
            }
        }

        AnalogSignal::AnalogSignal(view::AnalogSignal* s, dsv::data::AnalogSnapshot* data, sr_channel* probe) :
            Signal(*s, probe),
            _data(data),
            _rects(NULL),
            _hover_en(false),
            _hover_index(0),
            _hover_point(QPointF(-1, -1)),
            _hover_value(0)
        {
            _typeWidth = 5;
            _bits = s->get_bits();
            _ref_min = s->get_ref_min();
            _ref_max = s->get_ref_max();
            _zero_offset = s->get_zero_offset();

            _scale = s->get_scale();
        }

        AnalogSignal::~AnalogSignal()
        {
            if (_rects) {
                delete[] _rects;
                _rects = NULL;
            }
        }

        int AnalogSignal::get_hw_offset()
        {
            int hw_offset = 0;
            session->get_device()->get_config_uint16(SR_CONF_PROBE_HW_OFFSET, hw_offset, _probe, NULL);
            return hw_offset;
        }

        int AnalogSignal::commit_settings()
        {
            int ret;

            // -- enable
            ret = session->get_device()->set_config_bool(SR_CONF_PROBE_EN,
                enabled(), _probe);

            // -- vdiv
            ret = session->get_device()->set_config_uint64(SR_CONF_PROBE_VDIV,
                _probe->vdiv, _probe, NULL);

            // -- coupling
            ret = session->get_device()->set_config_byte(SR_CONF_PROBE_COUPLING,
                _probe->coupling, _probe, NULL);

            // -- offset
            ret = session->get_device()->set_config_uint16(SR_CONF_PROBE_OFFSET,
                _probe->offset, _probe, NULL);

            // -- trig_value
            session->get_device()->set_config_byte(SR_CONF_TRIGGER_VALUE,
                _probe->trig_value, _probe, NULL);

            return ret;
        }

        bool AnalogSignal::measure(const QPointF& p)
        {
            _hover_en = false;
            if (!enabled())
                return false;

            if (_view->session().is_stopped_status() == false)
                return false;

            const QRectF window = get_view_rect();
            if (!window.contains(p))
                return false;

            if (_data->have_data() == false)
                return false;

            const double scale = _view->scale();
            assert(scale > 0);
            const int64_t pixels_offset = _view->offset();
            const double samplerate = _view->session().cur_snap_samplerate();
            const double samples_per_pixel = samplerate * scale;

            _hover_index = floor((p.x() + pixels_offset) * samples_per_pixel + 0.5);
            if (_hover_index >= _data->get_sample_count())
                return false;

            _hover_point = get_point(_hover_index, _hover_value);
            _hover_en = true;
            return true;
        }

        bool AnalogSignal::get_hover(uint64_t& index, QPointF& p, double& value)
        {
            if (_hover_en) {
                index = _hover_index;
                p = _hover_point;
                value = _hover_value;
                return true;
            }
            return false;
        }

        QPointF AnalogSignal::get_point(uint64_t index, float& value)
        {
            QPointF pt = QPointF(-1, -1);

            if (!enabled())
                return pt;

            const int order = _data->get_ch_order(get_index());
            if (order == -1)
                return pt;

            const double scale = _view->scale();
            assert(scale > 0);
            const int64_t pixels_offset = _view->offset();
            const double samplerate = _view->session().cur_snap_samplerate();
            const double samples_per_pixel = samplerate * scale;

            if (index >= _data->get_sample_count())
                return pt;

            const uint64_t ring_index = (uint64_t)(_data->get_ring_start() + floor(index)) % _data->get_sample_count();
            value = *(_data->get_samples(ring_index) + order * _data->get_unit_bytes());

            const int height = get_totalHeight();
            const float top = get_y() - height * 0.5;
            const float bottom = get_y() + height * 0.5;
            const int hw_offset = get_hw_offset();
            const float x = (index / samples_per_pixel - pixels_offset);
            const float y = min(max(top, get_zero_vpos() + (value - hw_offset) * _scale), bottom);
            pt = QPointF(x, y);

            return pt;
        }

        /**
         * Probe options
         **/
        uint64_t AnalogSignal::get_vdiv()
        {
            uint64_t vdiv = 0;
            session->get_device()->get_config_uint64(SR_CONF_PROBE_VDIV, vdiv, _probe, NULL);
            return vdiv;
        }

        uint8_t AnalogSignal::get_acCoupling()
        {
            int coupling = 0;
            session->get_device()->get_config_byte(SR_CONF_PROBE_COUPLING, coupling, _probe, NULL);
            return coupling;
        }

        bool AnalogSignal::get_mapDefault()
        {
            bool isDefault = true;
            session->get_device()->get_config_bool(SR_CONF_PROBE_MAP_DEFAULT, isDefault, _probe, NULL);
            return isDefault;
        }

        QString AnalogSignal::get_mapUnit()
        {
            QString unit;
            session->get_device()->get_config_string(SR_CONF_PROBE_MAP_UNIT, unit, _probe, NULL);
            return unit;
        }

        double AnalogSignal::get_mapMin()
        {
            double min = -1;
            session->get_device()->get_config_double(SR_CONF_PROBE_MAP_MIN, min, _probe, NULL);
            return min;
        }

        double AnalogSignal::get_mapMax()
        {
            double max = 1;
            session->get_device()->get_config_double(SR_CONF_PROBE_MAP_MAX, max, _probe, NULL);
            return max;
        }

        uint64_t AnalogSignal::get_factor()
        {
            uint64_t factor;
            bool ret;
            ret = session->get_device()->get_config_uint64(SR_CONF_PROBE_FACTOR, factor, _probe, NULL);
            if (ret) {
                return factor;
            }
            else {
                dsv_err("ERROR: config_get SR_CONF_PROBE_FACTOR failed.");
                return 1;
            }
        }

        int AnalogSignal::ratio2value(double ratio)
        {
            return ratio * (_ref_max - _ref_min) + _ref_min;
        }

        int AnalogSignal::ratio2pos(double ratio)
        {
            const int height = get_totalHeight();
            const int top = get_y() - height * 0.5;
            return ratio * height + top;
        }

        double AnalogSignal::value2ratio(int value)
        {
            return max(0.0, (value - _ref_min) / (_ref_max - _ref_min));
        }

        double AnalogSignal::pos2ratio(int pos)
        {
            const int height = get_totalHeight();
            const int top = get_y() - height / 2;
            return min(max(pos - top, 0), height) * 1.0 / height;
        }

        void AnalogSignal::set_zero_vpos(int pos)
        {
            if (enabled()) {
                set_zero_ratio(pos2ratio(pos));
            }
        }

        int AnalogSignal::get_zero_vpos()
        {
            return ratio2pos(get_zero_ratio());
        }

        void AnalogSignal::set_zero_ratio(double ratio)
        {
            if (_view->session().is_running_status())
                return;

            _zero_offset = ratio2value(ratio);
            session->get_device()->set_config_uint16(SR_CONF_PROBE_OFFSET,
                _zero_offset, _probe, NULL);
        }

        double AnalogSignal::get_zero_ratio()
        {
            return value2ratio(_zero_offset);
        }

        /**
         * Event
         **/
        void AnalogSignal::resize()
        {
            if (_rects) {
                delete[] _rects;
                _rects = NULL;
            }
        }

        /**
         * Paint
         **/
        void AnalogSignal::paint_back(QPainter& p, int left, int right, QColor fore, QColor back)
        {
            assert(_view);

            int i, j;
            const double height = get_totalHeight();
            const int DIVS = DS_CONF_DSO_VDIVS;
            const int minDIVS = 5;
            const double STEPS = height / (DIVS * minDIVS);
            const double mapSteps = (get_mapMax() - get_mapMin()) / DIVS;
            const QString mapUnit = get_mapUnit();

            QPen solidPen(fore);
            solidPen.setStyle(Qt::SolidLine);
            p.setPen(solidPen);
            p.setBrush(back);

            // paint rule
            double y = get_y() - height * 0.5;
            double mapValue = get_mapMax() + (get_zero_ratio() - 0.5) * (get_mapMax() - get_mapMin());
            for (i = 0; i < DIVS; i++) {
                p.drawLine(left, y, left + 10, y);
                if (i == 0 || i == DIVS / 2)
                    p.drawText(QRectF(left + 15, y - 10, 100, 20),
                        Qt::AlignLeft | Qt::AlignVCenter,
                        QString::number(mapValue, 'f', 2) + mapUnit);
                p.drawLine(right, y, right - 10, y);
                if (i == 0 || i == DIVS / 2)
                    p.drawText(QRectF(right - 115, y - 10, 100, 20),
                        Qt::AlignRight | Qt::AlignVCenter,
                        QString::number(mapValue, 'f', 2) + mapUnit);
                for (j = 0; j < minDIVS - 1; j++) {
                    y += STEPS;
                    p.drawLine(left, y, left + 5, y);
                    p.drawLine(right, y, right - 5, y);
                }
                y += STEPS;
                mapValue -= mapSteps;
            }
            p.drawLine(left, y, left + 10, y);
            p.drawText(QRectF(left + 15, y - 10, 100, 20),
                Qt::AlignLeft | Qt::AlignVCenter,
                QString::number(mapValue, 'f', 2) + mapUnit);
            p.drawLine(right, y, right - 10, y);
            p.drawText(QRectF(right - 115, y - 10, 100, 20),
                Qt::AlignRight | Qt::AlignVCenter,
                QString::number(mapValue, 'f', 2) + mapUnit);
        }

        void AnalogSignal::paint_mid(QPainter& p, int left, int right, QColor fore, QColor back)
        {
            (void)fore;
            (void)back;

            assert(_data);
            assert(_view);
            assert(right >= left);

            const int height = get_totalHeight();
            const float top = get_y() - height * 0.5;
            const float bottom = get_y() + height * 0.5;
            const float zeroY = ratio2pos(get_zero_ratio());
            const int width = right - left + 1;

            const double scale = _view->scale();
            assert(scale > 0);
            const int64_t offset = _view->offset();

            const int order = _data->get_ch_order(get_index());
            if (order == -1)
                return;

            const double pixels_offset = offset;
            const double samplerate = _data->samplerate();
            const int64_t cur_sample_count = _data->get_sample_count();
            const double samples_per_pixel = samplerate * scale;
            const uint64_t ring_start = _data->get_ring_start();

            int64_t start_pixel;
            uint64_t start_index;
            const double index_offset = pixels_offset * samples_per_pixel;
            start_index = (uint64_t)(ring_start + floor(index_offset)) % cur_sample_count;
            start_pixel = (floor(index_offset) - index_offset) / samples_per_pixel;

            int64_t show_length = min(floor(cur_sample_count - floor(index_offset)), ceil(width * samples_per_pixel + 1));
            if (show_length <= 0)
                return;

            if (samples_per_pixel < EnvelopeThreshold) {
                paint_trace(p, _data, zeroY,
                    start_pixel, start_index, show_length,
                    samples_per_pixel, order,
                    top, bottom, width);
            }
            else {
                paint_envelope(p, _data, zeroY,
                    start_pixel, start_index, show_length,
                    samples_per_pixel, order,
                    top, bottom, width);
            }
        }

        void AnalogSignal::paint_fore(QPainter& p, int left, int right, QColor fore, QColor back)
        {
            assert(_view);

            fore.setAlpha(View::BackAlpha);
            QPen pen(fore);
            pen.setStyle(Qt::DotLine);
            p.setPen(pen);
            p.drawLine(left, get_zero_vpos(), right, get_zero_vpos());

            fore.setAlpha(View::ForeAlpha);
            if (enabled()) {
                // Paint measure
                if (_view->session().is_stopped_status())
                    paint_hover_measure(p, fore, back);
            }
        }

        void AnalogSignal::paint_trace(QPainter& p,
            const dsv::data::AnalogSnapshot* snapshot,
            int zeroY, const int start_pixel,
            const uint64_t start_index, const int64_t sample_count,
            const double samples_per_pixel, const int order,
            const float top, const float bottom, const int width)
        {
            (void)width;

            dsv::data::AnalogSnapshot* pshot = const_cast<dsv::data::AnalogSnapshot*>(snapshot);

            int64_t channel_num = (int64_t)pshot->get_channel_num();
            if (sample_count > 0) {
                const uint8_t unit_bytes = pshot->get_unit_bytes();
                const uint8_t* const samples = pshot->get_samples(0);
                assert(samples);

                p.setPen(_colour);
                //p.setPen(QPen(_colour, 3, Qt::SolidLine));

                QPointF* points = new QPointF[sample_count];
                QPointF* point = points;
                uint64_t yindex = start_index;

                const int hw_offset = get_hw_offset();
                float x = start_pixel;
                double  pixels_per_sample = 1.0 / samples_per_pixel;
                for (int64_t sample = 0; sample < sample_count; sample++) {
                    uint64_t index = (yindex * channel_num + order) * unit_bytes;
                    float yvalue = samples[index];
                    for (uint8_t i = 1; i < unit_bytes; i++)
                        yvalue += (samples[++index] << i * 8);
                    yvalue = zeroY + (yvalue - hw_offset) * _scale;
                    yvalue = min(max(yvalue, top), bottom);
                    *point++ = QPointF(x, yvalue);
                    if (yindex == pshot->get_ring_end())
                        break;
                    yindex++;
                    yindex %= pshot->get_sample_count();
                    x += pixels_per_sample;
                }
                p.drawPolyline(points, point - points);
                delete[] points;
            }
        }

        void AnalogSignal::paint_envelope(QPainter& p,
            const dsv::data::AnalogSnapshot* snapshot,
            int zeroY, const int start_pixel,
            const uint64_t start_index, const int64_t sample_count,
            const double samples_per_pixel, const int order,
            const float top, const float bottom, const int width)
        {
            using namespace Qt;
            using dsv::data::AnalogSnapshot;
            dsv::data::AnalogSnapshot* pshot = const_cast<dsv::data::AnalogSnapshot*>(snapshot);

            AnalogSnapshot::EnvelopeSection e;
            pshot->get_envelope_section(e, start_index, sample_count,
                samples_per_pixel, order);
            if (e.samples_num == 0)
                return;

            p.setPen(QPen(NoPen));
            p.setBrush(_colour);

            if (!_rects)
                _rects = new QRectF[width + 10];
            QRectF* rect = _rects;
            int px = -1, pre_px;
            float y_min = zeroY, y_max = zeroY, pre_y_min = zeroY, pre_y_max = zeroY;
            int pcnt = 0;
            const double scale_pixels_per_samples = e.scale / samples_per_pixel;
            int64_t end_v = pshot->get_ring_end();
            const uint64_t ring_end = max((int64_t)0, end_v / e.scale - 1);
            const int hw_offset = get_hw_offset();

            float x = start_pixel;
            for (uint64_t sample = 0; sample < e.length; sample++) {
                const uint64_t ring_index = (e.start + sample) % (_view->session().cur_samplelimits() / e.scale);
                if (sample != 0 && ring_index == ring_end)
                    break;

                const AnalogSnapshot::EnvelopeSample* const ev =
                    e.samples + ((e.start + sample) % e.samples_num);

                const float b = min(max((float)(zeroY + (ev->max - hw_offset) * _scale + 0.5), top), bottom);
                const float t = min(max((float)(zeroY + (ev->min - hw_offset) * _scale + 0.5), top), bottom);

                pre_px = px;
                if (px != floor(x)) {
                    if (pre_px != -1) {
                        // We overlap this sample with the previous so that vertical
                        // gaps do not appear during steep rising or falling edges
                        if (pre_y_min > y_max)
                            *rect++ = QRectF(pre_px, y_min, 1.0f, pre_y_min - y_min + 1);
                        else if (pre_y_max < y_min)
                            *rect++ = QRectF(pre_px, pre_y_max, 1.0f, y_max - pre_y_max + 1);
                        else
                            *rect++ = QRectF(pre_px, y_min, 1.0f, y_max - y_min + 1);
                        pre_y_min = y_min;
                        pre_y_max = y_max;
                        pcnt++;
                    }
                    else {
                        pre_y_max = min(max(b, top), bottom);
                        pre_y_min = min(max(t, top), bottom);
                    }
                    px = x;
                    y_max = min(max(b, top), bottom);
                    y_min = min(max(t, top), bottom);
                }
                if (px == pre_px) {
                    y_max = max(b, y_max);
                    y_min = min(t, y_min);
                }
                x += scale_pixels_per_samples;
            }

            p.drawRects(_rects, pcnt);
        }

        void AnalogSignal::paint_hover_measure(QPainter& p, QColor fore, QColor back)
        {
            const int hw_offset = get_hw_offset();
            const int height = get_totalHeight();
            const float top = get_y() - height * 0.5;
            const float bottom = get_y() + height * 0.5;

            // Hover measure
            if (_hover_en && _hover_point != QPointF(-1, -1)) {
                QString hover_str = get_voltage(hw_offset - _hover_value, 2);
                if (_hover_point.y() <= top || _hover_point.y() >= bottom)
                    hover_str += "/out";
                const int hover_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
                    Qt::AlignLeft | Qt::AlignTop, hover_str).width() + 10;
                const int hover_height = p.boundingRect(0, 0, INT_MAX, INT_MAX,
                    Qt::AlignLeft | Qt::AlignTop, hover_str).height();
                QRectF hover_rect(_hover_point.x(), _hover_point.y() - hover_height / 2, hover_width, hover_height);
                if (hover_rect.right() > get_view_rect().right())
                    hover_rect.moveRight(_hover_point.x());
                if (hover_rect.top() < get_view_rect().top())
                    hover_rect.moveTop(_hover_point.y());
                if (hover_rect.bottom() > get_view_rect().bottom())
                    hover_rect.moveBottom(_hover_point.y());

                p.setPen(fore);
                p.setBrush(back);
                p.drawRect(_hover_point.x() - 1, _hover_point.y() - 1, HoverPointSize, HoverPointSize);
                p.drawText(hover_rect, Qt::AlignCenter | Qt::AlignTop | Qt::TextDontClip, hover_str);
            }

            auto& cursor_list = _view->get_cursorList();
            auto i = cursor_list.begin();

            while (i != cursor_list.end()) {
                float pt_value;
                const QPointF pt = get_point((*i)->index(), pt_value);
                if (pt == QPointF(-1, -1)) {
                    i++;
                    continue;
                }

                QString pt_str = get_voltage(hw_offset - pt_value, 2);
                if (pt.y() <= top || pt.y() >= bottom)
                    pt_str += "/out";
                const int pt_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
                    Qt::AlignLeft | Qt::AlignTop, pt_str).width() + 10;
                const int pt_height = p.boundingRect(0, 0, INT_MAX, INT_MAX,
                    Qt::AlignLeft | Qt::AlignTop, pt_str).height();
                QRectF pt_rect(pt.x(), pt.y() - pt_height / 2, pt_width, pt_height);
                if (pt_rect.right() > get_view_rect().right())
                    pt_rect.moveRight(pt.x());
                if (pt_rect.top() < get_view_rect().top())
                    pt_rect.moveTop(pt.y());
                if (pt_rect.bottom() > get_view_rect().bottom())
                    pt_rect.moveBottom(pt.y());

                p.drawRect(pt.x() - 1, pt.y() - 1, 2, 2);
                p.drawLine(pt.x() - 2, pt.y() - 2, pt.x() + 2, pt.y() + 2);
                p.drawLine(pt.x() + 2, pt.y() - 2, pt.x() - 2, pt.y() + 2);
                p.drawText(pt_rect, Qt::AlignCenter | Qt::AlignTop | Qt::TextDontClip, pt_str);

                i++;
            }
        }

        QString AnalogSignal::get_voltage(double v, int p, bool scaled)
        {
            const double mapRange = (get_mapMax() - get_mapMin()) * 1000;
            const QString mapUnit = get_mapUnit();

            if (scaled)
                v = v / get_totalHeight() * mapRange;
            else
                v = v * _scale / get_totalHeight() * mapRange;
            return abs(v) >= 1000 ? QString::number(v / 1000.0, 'f', p) + mapUnit : QString::number(v, 'f', p) + "m" + mapUnit;
        }

        void AnalogSignal::set_data(data::AnalogSnapshot* data)
        {
            assert(data);
            _data = data;
        }

    } // namespace view
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_LOGICSIGNAL_H
#define DSVIEW_PV_LOGICSIGNAL_H

#include "signal.h"
#include <vector> 

namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
    namespace data {
        class LogicSnapshot;
    }    
}
using namespace dsv::appcore;
using namespace dsv::data;

namespace dsv {
namespace view {

//when device is logic analyzer mode, to draw logic signal trace
//created by SigSession
class LogicSignal : public Signal
{
    Q_OBJECT

private:
	static const float Oversampling;

    static const int StateHeight;
    static const int StateRound;

    static const int TogMaxScale = 10;

public:
    enum LogicSetRegions{
        NONTRIG = 0,
        POSTRIG,
        HIGTRIG,
        NEGTRIG,
        LOWTRIG,
        EDGTRIG,
    };

public:
    LogicSignal(LogicSnapshot *data, sr_channel *probe);

    LogicSignal(view::LogicSignal*s, LogicSnapshot *data, sr_channel *probe);

	virtual ~LogicSignal();

    inline const sr_channel* probe(){
        return _probe;
    }

    inline LogicSnapshot* data(){
        return _data;
    }

    void set_data(LogicSnapshot* data);
    
    inline LogicSetRegions get_trig(){
        return _trig;
    }

    void set_trig(int trig);

    bool commit_trig();

	/**
	 * Paints the signal with a QPainter
	 * @param p the QPainter to paint into.
	 * @param left the x-coordinate of the left edge of the signal.
	 * @param right the x-coordinate of the right edge of the signal.
	 **/
    void paint_mid(QPainter &p, int left, int right, QColor fore, QColor back);

    bool measure(const QPointF &p, uint64_t &index0, uint64_t &index1, uint64_t &index2);

    bool edge(const QPointF &p, uint64_t &index, int radius);

    bool edges(const QPointF &p, uint64_t start, uint64_t &rising, uint64_t &falling);

    bool edges(uint64_t end, uint64_t start, uint64_t &rising, uint64_t &falling);

    bool mouse_press(int right, const QPoint pt);

    QRectF get_rect(LogicSetRegions type, int y, int right);

    void paint_mark(QPainter &p, int xstart, int xend, int type);

    void paint_mid_align_sample(QPainter &p, int left, int right, QColor fore, QColor back, uint64_t end_align_sample);

protected:
    void paint_type_options(QPainter &p, int right, const QPoint pt, QColor fore);

private:
	void paint_caps(QPainter &p, QLineF *const lines,
        std::vector< std::pair<uint64_t, bool> > &edges,
		bool level, double samples_per_pixel, double pixels_offset,
		float x_offset, float y_offset);

    void paint_mid_align(QPainter &p, int left, int right, QColor fore, QColor back, uint64_t end_align_sample);

private:
	LogicSnapshot* _data;
    std::vector<std::pair<uint16_t, bool> > _cur_edges;
    std::vector<std::pair<bool, bool>> _cur_pulses;
    LogicSetRegions _trig;
    uint64_t    _paint_align_sample_count;
};

} // namespace view
} // namespace dsv

#endif // DSVIEW_PV_LOGICSIGNAL_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_MATHTRACE_H
#define DSVIEW_PV_MATHTRACE_H

#include "trace.h" 

namespace dsv {

namespace data {
class DsoSnapshot;
class MathStack;
}

namespace view {

class DsoSignal;

class MathTrace : public Trace
{
    Q_OBJECT

public:
    enum MathSetRegions {
        DSO_NONE = -1,
        DSO_VDIAL,
    };

public:
    MathTrace(bool enable, dsv::data::MathStack *math_stack,
              view::DsoSignal *dsoSig1,
              view::DsoSignal *dsoSig2);

    virtual ~MathTrace();

    float get_scale();

    int get_name_width();

    /**
     *
     */
    void update_vDial();
    void go_vDialPre();
    void go_vDialNext();
    uint64_t get_vDialValue();
    uint16_t get_vDialSel();

    bool enabled();
    void set_enable(bool enable);
    void set_show(bool show);

    int get_zero_vpos();
    void set_zero_vpos(int pos);

    int src1();
    int src2();

    /**
      *
      */
    bool measure(const QPointF &p);
    QPointF get_point(uint64_t index, float &value);


    /**
     * Gets the mid-Y position of this signal.
     */
    double get_zero_ratio();

    /**
     * Sets the mid-Y position of this signal.
     */
    void set_zero_vrate(double rate);

    QString get_voltage(double v, int p);
    QString get_time(double t);

    /**
     * Paints the background layer of the trace with a QPainter
     * @param p the QPainter to paint into.
     * @param left the x-coordinate of the left edge of the signal
     * @param right the x-coordinate of the right edge of the signal
     **/
    void paint_back(QPainter &p, int left, int right, QColor fore, QColor back);

	/**
	 * Paints the signal with a QPainter
	 * @param p the QPainter to paint into.
	 * @param left the x-coordinate of the left edge of the signal.
	 * @param right the x-coordinate of the right edge of the signal.
	 **/
    void paint_mid(QPainter &p, int left, int right, QColor fore, QColor back);

    /**
     * Paints the signal with a QPainter
     * @param p the QPainter to paint into.
     * @param left the x-coordinate of the left edge of the signal.
     * @param right the x-coordinate of the right edge of the signal.
     **/
    void paint_fore(QPainter &p, int left, int right, QColor fore, QColor back);

    QRect get_view_rect();

    QRectF get_rect(MathSetRegions type, int y, int right);

    bool mouse_wheel(int right, const QPoint pt, const int shift);

    dsv::data::MathStack* get_math_stack();

protected:
    void paint_type_options(QPainter &p, int right, const QPoint pt, QColor fore);

private:
    void paint_trace(QPainter &p,
        int zeroY, int left, const int64_t start, const int64_t end,
        const double pixels_offset, const double samples_per_pixel);

    void paint_envelope(QPainter &p,
        int zeroY, int left, const int64_t start, const int64_t end,
        const double pixels_offset, const double samples_per_pixel);

    void paint_hover_measure(QPainter &p, QColor fore, QColor back);

private:
    dsv::data::MathStack *_math_stack;
    view::DsoSignal *_dsoSig1;
    view::DsoSignal *_dsoSig2;
    bool _enable;
    bool _show;

    dslDial *_vDial;
    double _ref_min;
    double _ref_max;
    float _scale;

    double _zero_vrate;
    float _hw_offset;

    bool _hover_en;
    uint64_t _hover_index;
    QPointF _hover_point;
    float _hover_voltage;
};

} // namespace view
} // namespace dsv

#endif // DSVIEW_PV_MATHTRACE_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_VIEW_XCURSOR_H
#define DSVIEW_PV_VIEW_XCURSOR_H

#include <QColor>
#include <QObject>
#include <QRectF> 
#include <stdint.h>

class QPainter;
class QRect;

namespace dsv {
namespace view {

class View;
class DsoSignal;

//created by View
class XCursor : public QObject
{
	Q_OBJECT
  
public:
    enum XCur_type {
        XCur_None = -2,
        XCur_All = -1,
        XCur_Y = 0,
        XCur_X0,
        XCur_X1
    };

public:
	/**
	 * Constructor.
	 * @param view A reference to the view that owns this marker.
	 * @param colour A reference to the colour of this cursor.
     * @param value0
     * @param value1
	 */
    XCursor(View &view, QColor &colour, double value0, double value1);

	/**
	 * Copy constructor
	 */
    XCursor(const XCursor &x);

public:
	/**
     * Gets/Set the value of the marker.
	 */
    double value(enum XCur_type type);
    void set_value(enum XCur_type type, double value);

    /**
     * Gets/Sets colour of the marker
     */
    QColor colour();
    void set_colour(QColor color);

    /**
     * Gets/Sets the mapping channel of the marker
     */
    DsoSignal* channel();
    void set_channel(DsoSignal *sig);

    /**
     * grab & move
     */
    enum XCur_type grabbed();
    void set_grabbed(enum XCur_type type, bool grabbed);
    void rel_grabbed();

	/**
	 * Paints the marker to the viewport.
	 * @param p The painter to draw with.
	 * @param rect The rectangle of the viewport client area.
	 */
    void paint(QPainter &p, const QRect &rect, enum XCur_type highlight, int order);

	/**
     * Gets the map label rectangle.
     * @param rect The rectangle of the xcursor area.
     * @return Returns the map label rectangle.
	 */
    QRect get_map_rect(const QRect &rect);

    /**
     * Gets the close label rectangle.
     * @param rect The rectangle of the xcursor area.
     * @return Returns the close label rectangle.
     */
    QRect get_close_rect(const QRect &rect);

	/**
     * Paints the labels to the xcursor.
	 * @param p The painter to draw with.
     * @param rect The rectangle of the xcursor area.
	 */
    void paint_label(QPainter &p, const QRect &rect);

signals:
    void value_changed();

private slots:
    void on_signal_deleted(void *o);

protected:
    View        &_view;
    DsoSignal   *_dsoSig;
    int         _sig_index;

    double _yvalue;
    double _value0;
    double _value1;

    QSizeF _v0_size;
    QSizeF _v1_size;

private:
    enum XCur_type _grabbed;
    QColor _colour;
};

} // namespace view
} // namespace dsv

#endif // DSVIEW_PV_VIEW_XCURSOR_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_VIEW_VIEW_H
#define DSVIEW_PV_VIEW_VIEW_H

#include <stdint.h>
#include <set>
#include <vector>   
#include <QScrollArea>
#include <QSizeF>
#include <QDateTime>
#include <QSplitter> 
#include "../toolbars/samplingbar.h"
#include "../data/signaldata.h"
#include "viewport.h"
#include "cursor.h"
#include "xcursor.h"
#include "signal.h"
#include "viewstatus.h"
#include "../basedef.h" 
#include "../interface/icallbacks.h"
 
 
namespace dsv {

namespace toolbars {
    class SamplingBar;
}

namespace dialogs {
    class Calibration;
    class Lissajous;
}

namespace appcore{
    class SigSession;
    class DeviceAgent;
}

namespace view {

class Header;
class DevMode;
class Ruler;
class Trace;
class Viewport;
class LissajousFigure;

//created by MainWindow
class View : public QScrollArea, public IFontForm{
	Q_OBJECT

private:
	static const int LabelMarginWidth;
	static const int RulerHeight;

	static const int MaxScrollValue;
    static const int MaxHeightUnit;

public:
    //static const int SignalHeight;
	static const int SignalMargin;
	static const int SignalSnapGridSize;

	static const QColor CursorAreaColour;
	static const QSizeF LabelPadding;
    static const QString Unknown_Str;

    static const int WellSamplesPerPixel = 2048;
    static constexpr double MaxViewRate = 1.0;
    static const int MaxPixelsPerSample = 100;

    static const int StatusHeight = 20;
    static const int DsoStatusHeight = 55;

    static const int ForeAlpha = 200;
    static const int BackAlpha = 100;
    static const QColor Red;
    static const QColor Orange;
    static const QColor Blue;
    static const QColor Green;
    static const QColor Purple;
    static const QColor LightBlue;
    static const QColor LightRed;

public:
    explicit View(SigSession *session, dsv::toolbars::SamplingBar *sampling_bar, QWidget *parent = 0);

    ~View();

	inline SigSession& session(){
        return *_session;
    }

	/**
	 * Returns the view time scale in seconds per pixel.
	 */
	inline double scale(){
        return _scale;
    }

    inline double get_minscale(){
        return _minscale;
    }

    inline double get_maxscale(){
        return _maxscale;
    }

    void set_scale(double scale);

    void auto_set_max_scale();

	/**
     * Returns the pixels offset of the left edge of the view
	 */
    inline int64_t offset(){
        return _offset;
    }

    /**
     * trigger position fix
     */
    inline double trig_hoff(){
        return _trig_hoff;
    }

    inline void set_trig_hoff(double hoff){
        _trig_hoff = hoff;
    }

    int64_t get_min_offset();
    int64_t get_max_offset();

    void capture_init();

	void zoom(double steps);
    bool zoom(double steps, int offset);

	/**
	 * Sets the scale and offset.
	 * @param scale The new view scale in seconds per pixel.
	 * @param offset The view time offset in seconds.
	 */
    void set_scale_offset(double scale, int64_t offset);
    void set_preScale_preOffset();

    void get_traces(int type, std::vector<Trace*> &traces);

	/**
	 * Returns true if cursors are displayed. false otherwise.
	 */
	inline bool cursors_shown(){
        return _show_cursors;
    }

    inline bool trig_cursor_shown(){
        return _show_trig_cursor;
    }

    inline bool search_cursor_shown(){
        return _show_search_cursor;
    }

    inline int get_spanY(){
        return _spanY;
    }

    inline int get_signalHeight(){
        return _signalHeight;
    }

    int headerWidth();

    inline Ruler* get_ruler(){
        return _ruler;
    }

	/**
	 * Shows or hides the cursors.
	 */
	void show_cursors(bool show = true);

    inline const QPoint& hover_point(){
        return _hover_point;
    }

	void normalize_layout();

    void show_trig_cursor(bool show = true);

    void show_search_cursor(bool show = true);

    /*
     * cursorList
     */
    inline std::list<Cursor*>& get_cursorList(){
        return _cursorList;
    }

    void add_cursor(QColor color, uint64_t index);
    void del_cursor(Cursor* cursor);
    void clear_cursors();
    void set_cursor_middle(int index);

    inline Cursor* get_trig_cursor(){
        return _trig_cursor;
    }

    inline Cursor* get_search_cursor(){
        return _search_cursor;
    }

    inline bool get_search_hit(){
        return _search_hit;
    }

    void set_search_pos(uint64_t search_pos, bool hit);

    inline uint64_t get_search_pos(){
        return _search_pos;
    }

    /*
     * horizental cursors
     */
    inline bool xcursors_shown(){
        return _show_xcursors;
    }

    inline void show_xcursors(bool show){
        _show_xcursors = show;
    }

    inline std::list<XCursor*>& get_xcursorList(){
        return _xcursorList;
    }

    void add_xcursor(QColor color, double value0, double value1);
    void del_xcursor(XCursor* xcursor);
 
    void set_update(Viewport *viewport, bool need_update);
    void set_all_update(bool need_update);

    uint64_t get_cursor_samples(int index);
    QString get_cm_time(int index);
    QString get_cm_delta(int index1, int index2);
    QString get_index_delta(uint64_t start, uint64_t end);

    void on_state_changed(bool stop);

    QRect get_view_rect();
    int get_view_width();
    int get_view_height();

    double get_hori_res();

    QString get_measure(QString option);

    void viewport_update();

    void show_captured_progress(bool triggered, int progress);

    bool get_dso_trig_moved();

    inline ViewStatus* get_viewstatus(){
        return _viewbottom;
    }

    /*
     * back paint status
     */
    inline bool back_ready(){
        return _back_ready;
    }

    inline void set_back(bool ready){
        _back_ready = ready;
    }

    /*
     * untils
     */
    double index2pixel(uint64_t index, bool has_hoff = true);
    uint64_t pixel2index(double pixel);

    int get_cursor_index_by_key(uint64_t key);

    void check_calibration();

    void update_view_port();

    inline void update_all_trace_postion(){
        signals_changed(NULL);
    }

    inline Viewport* get_time_view(){
        return _time_viewport;
    }

    //IFontForm
    void update_font() override;

signals:
	void hover_point_changed();
    void cursor_update();
    void xcursor_update();
    void cursor_moving();
    void cursor_moved();
    void measure_updated();
    void prgRate(int progress);
    void resize();
    void auto_trig(int index);   

private: 
    void get_scroll_layout(int64_t &length, int64_t &offset);
	
	void update_scroll();

    void update_margins();

    static bool compare_trace_v_offsets( const Trace *a, const Trace *b);

    void clear();
    void reconstruct();  
	bool eventFilter(QObject *object, QEvent *event);
	bool viewportEvent(QEvent *e);
	void resizeEvent(QResizeEvent *e);

public:
    static bool compare_trace_view_index(const Trace *a, const Trace *b);

    static bool compare_trace_y(const Trace *a, const Trace *b);

    void signals_changed(const Trace* eventTrace);
 
public slots:
    void reload();
    void set_measure_en(int enable);
  
    void data_updated();
    void update_scale_offset();
    void show_region(uint64_t start, uint64_t end, bool keep);
    // -- calibration
    void hide_calibration();
    void status_clear();
    void repeat_unshow();

    // -- repeat
    void repeat_show();
    // --
    void timebase_changed();
    // --
    void vDial_updated();
    // --
    void update_hori_res();

    //
    void header_updated();

    void receive_trigger(quint64 trig_pos);

    void receive_end();

    void frame_began();

    void mode_changed();

private slots:

	void h_scroll_value_changed(int value);
	void v_scroll_value_changed(int value);

	void marker_time_changed();

    void on_traces_moved();

   
    void set_trig_pos(int percent);
 
    // calibration for oscilloscope
    void show_calibration();
    // lissajous figure
    void show_lissajous(bool show);
    void on_measure_updated();

    void splitterMoved(int pos, int index);

public:
    void show_wait_trigger();
    void set_device();
    void set_receive_len(uint64_t len);
    int  get_body_width();
    int  get_body_height();

private:

	SigSession                  *_session;
    dsv::toolbars::SamplingBar   *_sampling_bar;

    QWidget                 *_viewcenter;
    ViewStatus              *_viewbottom;
    QSplitter               *_vsplitter;
    Viewport                *_time_viewport;
    Viewport                *_fft_viewport;
    Viewport                *_active_viewport;
    LissajousFigure         *_lissajous;
    std::list<QWidget *>    _viewport_list;
    std::map<int, int>      _trace_view_map;
	Ruler                   *_ruler;
	Header                  *_header;
    DevMode                 *_devmode;
    

	/// The view time scale in seconds per pixel.
	double      _scale;
    double      _preScale;
    double      _maxscale;
    double      _minscale;

    /// The pixels offset of the left edge of the view
    int64_t     _offset;
    int64_t     _preOffset;
    int         _spanY;
    int         _signalHeight;
    bool        _updating_scroll;

    // trigger position fix
    double      _trig_hoff;

	bool        _show_cursors;
    std::list<Cursor*> _cursorList;
    Cursor      *_trig_cursor;
    bool        _show_trig_cursor;
    Cursor      *_search_cursor;
    bool        _show_search_cursor;
    uint64_t    _search_pos;
    bool        _search_hit;

    bool        _show_xcursors;
    std::list<XCursor*> _xcursorList;

    QPoint      _hover_point;
    dialogs::Calibration *_cali;

    bool        _dso_auto;
    bool        _show_lissajous;
    bool        _back_ready;
    DeviceAgent *_device_agent;
};

} // namespace view
} // namespace dsv

#endif // DSVIEW_PV_VIEW_VIEW_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "view.h"
#include <assert.h>
#include <limits.h>
#include <cmath>
#include <QEvent>
#include <QMouseEvent>
#include <QScrollBar>
#include <algorithm>
#include "groupsignal.h"
#include "decodetrace.h"
#include "header.h"
#include "devmode.h"
#include "ruler.h"
#include "signal.h"
#include "dsosignal.h"
#include "viewport.h"
#include "spectrumtrace.h"
#include "lissajoustrace.h"
#include "analogsignal.h"
#include "../appcore/sigsession.h"
#include "../data/logicsnapshot.h"
#include "../dialogs/calibration.h"
#include "../dialogs/lissajousoptions.h"
#include "../basedef.h"
#include "../log.h"
#include "../config/appconfig.h"
#include "../appcore/appcontrol.h"


using namespace std;
using namespace dsv::config;

namespace dsv {
namespace view {

const int View::LabelMarginWidth = 70;
const int View::RulerHeight = 50;

const int View::MaxScrollValue = INT_MAX / 2;
const int View::MaxHeightUnit = 20;

//const int View::SignalHeight = 30;s
const int View::SignalMargin = 7;
const int View::SignalSnapGridSize = 10;

const QColor View::CursorAreaColour(220, 231, 243);
const QSizeF View::LabelPadding(4, 4);
const QString View::Unknown_Str = "########";

const QColor View::Red = QColor(213, 15, 37, 255);
const QColor View::Orange = QColor(238, 178, 17, 255);
const QColor View::Blue = QColor(17, 133, 209,  255);
const QColor View::Green = QColor(0, 153, 37, 255);
const QColor View::Purple = QColor(109, 50, 156, 255);
const QColor View::LightBlue = QColor(17, 133, 209, 200);
const QColor View::LightRed = QColor(213, 15, 37, 200);


View::View(SigSession *session, dsv::toolbars::SamplingBar *sampling_bar, QWidget *parent) :
    QScrollArea(parent),
    _sampling_bar(sampling_bar),
    _scale(10),
    _preScale(1e-6),
    _maxscale(1e9),
    _minscale(1e-15),
	_offset(0),
    _preOffset(0),
	_updating_scroll(false),
    _trig_hoff(0),
	_show_cursors(false),
    _search_hit(false),
    _show_xcursors(false),
    _hover_point(-1, -1),
    _dso_auto(true),
    _show_lissajous(false),
    _back_ready(false)
{  
   _trig_cursor = NULL;
   _search_cursor = NULL;

   _session = session;
   _device_agent = session->get_device();

    setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
  
    // trace viewport map
    _trace_view_map[SR_CHANNEL_LOGIC] = TIME_VIEW;
    _trace_view_map[SR_CHANNEL_GROUP] = TIME_VIEW;
    _trace_view_map[SR_CHANNEL_DECODER] = TIME_VIEW;
    _trace_view_map[SR_CHANNEL_ANALOG] = TIME_VIEW;
    _trace_view_map[SR_CHANNEL_DSO] = TIME_VIEW;
    _trace_view_map[SR_CHANNEL_FFT] = FFT_VIEW;
    _trace_view_map[SR_CHANNEL_LISSAJOUS] = TIME_VIEW;
    _trace_view_map[SR_CHANNEL_MATH] = TIME_VIEW;

    _active_viewport = NULL;
    _ruler = new Ruler(*this);
    _header = new Header(*this);
    _devmode = new DevMode(this, session);
    
    AppControl::Instance()->add_font_form(_devmode);

    setViewportMargins(headerWidth(), RulerHeight, 0, 0);

    // windows splitter
    _time_viewport = new Viewport(*this, TIME_VIEW);
    _time_viewport->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);
    _time_viewport->setMinimumHeight(100);
  
    _fft_viewport = new Viewport(*this, FFT_VIEW);
    _fft_viewport->setVisible(false);
    _fft_viewport->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);
    _fft_viewport->setMinimumHeight(100);
 
    _vsplitter = new QSplitter(this);
    _vsplitter->setOrientation(Qt::Vertical);
    _vsplitter->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);

    _viewport_list.push_back(_time_viewport);
    _vsplitter->addWidget(_time_viewport);
    _vsplitter->setCollapsible(0, false);
    _vsplitter->setStretchFactor(0, 2);
    _viewport_list.push_back(_fft_viewport);
    _vsplitter->addWidget(_fft_viewport);
    _vsplitter->setCollapsible(1, false);
    _vsplitter->setStretchFactor(1, 1);

    _viewcenter = new QWidget(this);
    _viewcenter->setContentsMargins(0,0,0,0);
    QGridLayout* layout = new QGridLayout(_viewcenter);
    layout->setSpacing(0);
    layout->setContentsMargins(0,0,0,0);
    _viewcenter->setLayout(layout);
    layout->addWidget(_vsplitter, 0, 0);
    _viewbottom = new ViewStatus(_session, *this);
    _viewbottom->setFixedHeight(StatusHeight);
    layout->addWidget(_viewbottom, 1, 0);

#ifdef Q_OS_DARWIN
    QWidget *lineSpan = new QWidget(this);
    lineSpan->setFixedHeight(10);
    layout->addWidget(lineSpan, 2, 0);
#endif

    setViewport(_viewcenter);

    _time_viewport->installEventFilter(this);
    _fft_viewport->installEventFilter(this);
	_ruler->installEventFilter(this);
	_header->installEventFilter(this);
    _devmode->installEventFilter(this);

    //tr
    _viewcenter->setObjectName("ViewArea_center");
    _ruler->setObjectName("ViewArea_ruler");
    _header->setObjectName("ViewArea_header");

    QColor fore(QWidget::palette().color(QWidget::foregroundRole()));
    fore.setAlpha(View::BackAlpha);

    _show_trig_cursor = false;
    _trig_cursor = new Cursor(*this, View::LightRed, 0);
    _show_search_cursor = false;
    _search_pos = 0;
    _search_cursor = new Cursor(*this, fore, _search_pos);

    _cali = new dsv::dialogs::Calibration(this);
    _cali->hide();

	connect(horizontalScrollBar(), SIGNAL(valueChanged(int)), this, SLOT(h_scroll_value_changed(int)));
	connect(verticalScrollBar(), SIGNAL(valueChanged(int)), this, SLOT(v_scroll_value_changed(int)));

    connect(_time_viewport, SIGNAL(measure_updated()),this, SLOT(on_measure_updated()));
    connect(_time_viewport, SIGNAL(prgRate(int)), this, SIGNAL(prgRate(int)));
    connect(_fft_viewport, SIGNAL(measure_updated()), this, SLOT(on_measure_updated()));

    connect(_vsplitter, SIGNAL(splitterMoved(int,int)), this, SLOT(splitterMoved(int, int)));
      
    connect(_header, SIGNAL(traces_moved()),this, SLOT(on_traces_moved()));
    connect(_header, SIGNAL(header_updated()),this, SLOT(header_updated()));
}

View::~View(){
    DESTROY_OBJECT(_trig_cursor);
    DESTROY_OBJECT(_search_cursor);
}

void View::show_wait_trigger()
{
    _time_viewport->show_wait_trigger();
}

void View::set_device()
{
    _devmode->set_device();
}

void View::capture_init()
{
    int mode = _device_agent->get_work_mode();

    if (mode == DSO)
        show_trig_cursor(true);
    else if (!_session->is_repeating())
        show_trig_cursor(false);
 
    _maxscale = _session->cur_sampletime() / (get_view_width() * MaxViewRate);
    if (mode == ANALOG)
        set_scale_offset(_maxscale, 0);
    
    status_clear();

    _trig_hoff = 0;
}

void View::zoom(double steps)
{
    zoom(steps, get_view_width() / 2);
}

void View::set_update(Viewport *viewport, bool need_update)
{
    viewport->set_need_update(need_update);
}

void View::set_all_update(bool need_update)
{
   _time_viewport->set_need_update(need_update);
   _fft_viewport->set_need_update(need_update);
}

double View::get_hori_res()
{
    return _sampling_bar->get_hori_res();
}

void View::update_hori_res()
{
    if (_device_agent->get_work_mode() == DSO) {
        _sampling_bar->hori_knob(0);
    }
}

bool View::zoom(double steps, int offset)
{
    bool ret = true;
    _preScale = _scale;
    _preOffset = _offset;

    if (_device_agent->get_work_mode() != DSO) {
        _scale *= std::pow(3.0/2.0, -steps);
        _scale = max(min(_scale, _maxscale), _minscale);
    } 
    else {
        if (_session->is_running_status() && _session->is_instant()){
            return ret;
        }

        double hori_res = -1;
        if(steps > 0.5)
            hori_res = _sampling_bar->hori_knob(-1);
        else if (steps < -0.5)
            hori_res = _sampling_bar->hori_knob(1);

        if (hori_res > 0) {
            const double scale = _session->cur_view_time() / get_view_width();
            _scale = max(min(scale, _maxscale), _minscale);
        } else {
            ret = false;
        }
    }

    _offset = floor((_offset + offset) * (_preScale / _scale) - offset);
    _offset = max (min(_offset, get_max_offset()), get_min_offset());

    if (_scale != _preScale || _offset != _preOffset) {
        _header->update();
        _ruler->update();
        viewport_update();
        update_scroll();
    }

    return ret;
}

void View::timebase_changed()
{
    if (_device_agent->get_work_mode() != DSO)
        return;

    double scale = this->scale();
    double hori_res = _sampling_bar->get_hori_res();
    if (hori_res > 0)
        scale = _session->cur_view_time() / get_view_width();
    set_scale_offset(scale, this->offset());
}

void View::set_scale_offset(double scale, int64_t offset)
{
    _preScale = _scale;
    _preOffset = _offset;

    _scale = max(min(scale, _maxscale), _minscale);
    _offset = floor(max(min(offset, get_max_offset()), get_min_offset()));

    if (_scale != _preScale || _offset != _preOffset) {
        update_scroll();
        _header->update();
        _ruler->update();
        viewport_update();
    }
}

void View::set_preScale_preOffset()
{ 
    set_scale_offset(_preScale, _preOffset);
}

void View::get_traces(int type, std::vector<Trace*> &traces)
{
    assert(_session);

    auto &sigs = _session->get_signals();
 
    const auto &decode_sigs = _session->get_decode_signals();
 
    const auto &spectrums = _session->get_spectrum_traces();
 
    for(auto t : sigs) {
        if (type == ALL_VIEW || _trace_view_map[t->get_type()] == type)
            traces.push_back(t);
    }
 
    for(auto t : decode_sigs) {
        if (type == ALL_VIEW || _trace_view_map[t->get_type()] == type)
            traces.push_back(t);
    }

    for(auto t : spectrums) {
        if (type == ALL_VIEW || _trace_view_map[t->get_type()] == type)
            traces.push_back(t);
    }

    auto lissajous = _session->get_lissajous_trace();
    if (lissajous && lissajous->enabled() &&
        (type == ALL_VIEW || _trace_view_map[lissajous->get_type()] == type)){
        traces.push_back(lissajous);
    }

    auto math = _session->get_math_trace();
    if (math && math->enabled() &&
        (type == ALL_VIEW || _trace_view_map[math->get_type()] == type)){
        traces.push_back(math);
    }

    sort(traces.begin(), traces.end(), compare_trace_v_offsets);
}

bool View::compare_trace_v_offsets(const Trace *a, const Trace *b)
{
    assert(a);
    assert(b);

    Trace *a1 = const_cast<Trace*>(a);
    Trace *b1 = const_cast<Trace*>(b);
    int v1 = 0;
    int v2 = 0;

    if (a1->get_type() != b1->get_type()){
        v1 = a1->get_type();
        v2 = b1->get_type();
    } 
    else if (a1->get_type() == SR_CHANNEL_DSO || a1->get_type() == SR_CHANNEL_ANALOG){
        v1 = a1->get_index();
        v2 = b1->get_index();
    } 
    else{
        v1 = a1->get_v_offset();
        v2 = b1->get_v_offset();
    }
    return v1 < v2;
}

bool View::compare_trace_view_index(const Trace *a, const Trace *b)
{
    assert(a);
    assert(b);

    Trace *a1 = const_cast<Trace*>(a);
    Trace *b1 = const_cast<Trace*>(b);
    return a1->get_view_index() < b1->get_view_index();
}

bool View::compare_trace_y(const Trace *a, const Trace *b)
{
    assert(a);
    assert(b);

    Trace *a1 = const_cast<Trace*>(a);
    Trace *b1 = const_cast<Trace*>(b);
    return a1->get_v_offset() < b1->get_v_offset();
}

void View::show_cursors(bool show)
{
	_show_cursors = show;
	_ruler->update();
    viewport_update();
}

void View::show_trig_cursor(bool show)
{
    _show_trig_cursor = show;
    _ruler->update();
    viewport_update();
}

void View::show_search_cursor(bool show)
{
    _show_search_cursor = show;
    _ruler->update();
    viewport_update();
}

void View::status_clear()
{
    _time_viewport->clear_dso_xm();
    _time_viewport->clear_measure();
    _viewbottom->clear();
}

void View::repeat_unshow()
{
    _viewbottom->repeat_unshow();
}

void View::frame_began()
{
    _search_hit = false;
    _search_pos = 0;
    set_search_pos(_search_pos, _search_hit);
}

void View::receive_end()
{
    if (_device_agent->get_work_mode() == LOGIC) {
        bool rle = false;
        uint64_t actual_samples;
        bool ret;

        ret = _device_agent->get_config_bool(SR_CONF_RLE, rle);
      
        if (ret && rle) {
            ret = _device_agent->get_config_uint64(SR_CONF_ACTUAL_SAMPLES, actual_samples);
            if (ret) {
                if (actual_samples != _session->cur_samplelimits()) {
                    _viewbottom->set_rle_depth(actual_samples);
                }
            }
        }       
    }
    _time_viewport->unshow_wait_trigger();
}

void View::receive_trigger(quint64 trig_pos)
{
    const double time = trig_pos * 1.0 / _session->cur_snap_samplerate();
    _trig_cursor->set_index(trig_pos);

    if (ds_trigger_get_en() ||
        _device_agent->is_virtual() ||
        _device_agent->get_work_mode() == DSO) {
        _show_trig_cursor = true;

        AppConfig &app = AppConfig::Instance();
        if (app.appOptions.trigPosDisplayInMid){
            set_scale_offset(_scale,  (time / _scale) - (get_view_width() / 2));
        }
    }

    _ruler->update();
    viewport_update();
}

void View::set_trig_pos(int percent)
{
    uint64_t index = _session->cur_samplelimits() * percent / 100;
    receive_trigger(index);
}

void View::set_search_pos(uint64_t search_pos, bool hit)
{ 
    QColor fore(QWidget::palette().color(QWidget::foregroundRole()));
    fore.setAlpha(View::BackAlpha);

    const double time = search_pos * 1.0 / _session->cur_snap_samplerate();
    _search_pos = search_pos;
    _search_hit = hit;
    _search_cursor->set_index(search_pos);
    _search_cursor->set_colour(hit ? View::Blue : fore);

    if (hit) {
        set_scale_offset(_scale,  (time / _scale) - (get_view_width() / 2));
        _ruler->update();
        viewport_update();
    }
}

void View::normalize_layout()
{   
    int v_min = INT_MAX;
    std::vector<Trace*> traces;
    get_traces(ALL_VIEW, traces);
	
    for(auto t : traces){
          v_min = min(t->get_v_offset(), v_min);
    }

	const int delta = -min(v_min, 0);

    for(auto t : traces){
        t->set_v_offset(t->get_v_offset() + delta);
    }        

    verticalScrollBar()->setSliderPosition(delta);
	v_scroll_value_changed(verticalScrollBar()->sliderPosition());
}

void View::get_scroll_layout(int64_t &length, int64_t &offset)
{
    length = ceil(_session->cur_snap_sampletime() / _scale);
    offset = _offset;
}

void View::update_scroll()
{
    assert(_viewcenter);

    const QSize areaSize = QSize(get_view_width(), get_view_height());

	// Set the horizontal scroll bar
    int64_t length = 0;
    int64_t offset = 0;
	get_scroll_layout(length, offset);
    length = max(length - areaSize.width(), (int64_t)0);

	horizontalScrollBar()->setPageStep(areaSize.width() / 2);

	_updating_scroll = true;

	if (length < MaxScrollValue) {
		horizontalScrollBar()->setRange(0, length);
		horizontalScrollBar()->setSliderPosition(offset);
	} else {
		horizontalScrollBar()->setRange(0, MaxScrollValue);
		horizontalScrollBar()->setSliderPosition(
            _offset * 1.0  / length * MaxScrollValue);
	}

	_updating_scroll = false;

	// Set the vertical scrollbar
	verticalScrollBar()->setPageStep(areaSize.height());
    verticalScrollBar()->setRange(0,0);
}

void View::update_scale_offset()
{
    if (_device_agent->get_work_mode() != DSO) {
        _maxscale = _session->cur_sampletime() / (get_view_width() * MaxViewRate);
        _minscale = (1.0 / _session->cur_snap_samplerate()) / MaxPixelsPerSample;
    } else {
        _scale = _session->cur_view_time() / get_view_width();
        _maxscale = 1e9;
        _minscale = 1e-15;
    }

    _scale = max(min(_scale, _maxscale), _minscale);
    _offset = max(min(_offset, get_max_offset()), get_min_offset());

    _preScale = _scale;
    _preOffset = _offset;

    _ruler->update();
    viewport_update();
}

void View::mode_changed()
{
    if (_device_agent->is_virtual())
        _scale = WellSamplesPerPixel * 1.0 / _session->cur_snap_samplerate();
    _scale = max(min(_scale, _maxscale), _minscale);
}

void View::signals_changed(const Trace* eventTrace)
{
    double actualMargin = SignalMargin;
    int total_rows = 0;
    int label_size = 0;
    uint8_t max_height = MaxHeightUnit;
    std::vector<Trace*> time_traces;
    std::vector<Trace*> fft_traces;
    std::vector<Trace*> traces;
    std::vector<Trace*> logic_traces;
    std::vector<Trace*> decoder_traces;

    (void)eventTrace;

    get_traces(ALL_VIEW, traces);

    for(auto t : traces) {
        if (_trace_view_map[t->get_type()] == TIME_VIEW){
            time_traces.push_back(t);
        }
        else if (_trace_view_map[t->get_type()] == FFT_VIEW){
            if (t->enabled())
                fft_traces.push_back(t);
        }

        if (t->get_type() == SR_CHANNEL_LOGIC)
            logic_traces.push_back(t);
        else if (t->get_type() == SR_CHANNEL_DECODER)
            decoder_traces.push_back(t);
    }

    if (!fft_traces.empty()) {
        if (!_fft_viewport->isVisible()) {
            _fft_viewport->setVisible(true);
            _fft_viewport->clear_measure();
            _viewport_list.push_back(_fft_viewport);
            _vsplitter->refresh();
        }

        for(auto t : fft_traces) {
            t->set_view(this);
            t->set_viewport(_fft_viewport);
            t->set_totalHeight(_fft_viewport->height());
            t->set_v_offset(_fft_viewport->geometry().bottom());
        }
    }
    else {
        _fft_viewport->setVisible(false);
        _vsplitter->refresh();

        // Find the _fft_viewport in the stack
        std::list< QWidget *>::iterator iter = _viewport_list.begin();

        for(unsigned int i = 0; i < _viewport_list.size(); i++, iter++){
            if ((*iter) == _fft_viewport)
                break;
        }

        // Delete the element
        if (iter != _viewport_list.end())
            _viewport_list.erase(iter);
    }

    if (!time_traces.empty() && _time_viewport) {
        for(auto t : time_traces) {
            if (dynamic_cast<DsoSignal*>(t) || t->enabled())
                total_rows += t->rows_size();
            if (t->rows_size() != 0)
                label_size++;
        }

        const double height = (_time_viewport->height()
                               - 2 * actualMargin * label_size) * 1.0 / total_rows;

        if (_device_agent->have_instance() == false){
            assert(false);
        }
        
        int mode = _device_agent->get_work_mode();

        if (mode == LOGIC) {
            int v;
            bool ret;

            ret = _device_agent->get_config_byte(SR_CONF_MAX_HEIGHT_VALUE, v);
            if (ret) {
                max_height = (v + 1) * MaxHeightUnit;
            }

            if (height < 2*actualMargin) {
                actualMargin /= 2;
                _signalHeight = max(1.0, (_time_viewport->height()
                                          - 2 * actualMargin * label_size) * 1.0 / total_rows);
            }
            else {
                _signalHeight = (height >= max_height) ? max_height : height;
            }
        }
        else if (_device_agent->get_work_mode() == DSO) {
            _signalHeight = (_header->height()
                             - horizontalScrollBar()->height()
                             - 2 * actualMargin * label_size) * 1.0 / total_rows;
        }
        else {
            _signalHeight = (int)((height <= 0) ? 1 : height);
        }

        _spanY = _signalHeight + 2 * actualMargin;
        int next_v_offset = actualMargin;
        
        //Make list by view-index;
        if (mode == LOGIC)
        {   
            time_traces.clear();

            std::vector<Trace*> all_traces;

            for(auto t : logic_traces){
                all_traces.push_back(t);
            }

            for(auto t : decoder_traces){
                if (t->get_view_index() != -1)
                    all_traces.push_back(t);
                else
                    time_traces.push_back(t);
            }

            sort(all_traces.begin(), all_traces.end(), compare_trace_view_index);    

            for(auto t : all_traces){
                time_traces.push_back(t);
            }
        }

        for(auto t : time_traces) {
            t->set_view(this);
            t->set_viewport(_time_viewport);

            if (t->rows_size() == 0)
                continue;

            const double traceHeight = _signalHeight*t->rows_size();
            t->set_totalHeight((int)traceHeight);
            t->set_v_offset(next_v_offset + 0.5 * traceHeight + actualMargin);
            next_v_offset += traceHeight + 2 * actualMargin;

            if (t->signal_type() == SR_CHANNEL_DSO)
            {
                auto sig = dynamic_cast<view::DsoSignal*>(t);
                sig->set_scale(sig->get_view_rect().height());              
            }
            else if (t->signal_type() == SR_CHANNEL_ANALOG)
            {
                auto sig = dynamic_cast<view::AnalogSignal*>(t);
                sig->set_scale(sig->get_view_rect().height());
            }
        }
        _time_viewport->clear_measure();
    }

    header_updated();
    normalize_layout();
    update_scale_offset();
    data_updated();
}

bool View::eventFilter(QObject *object, QEvent *event)
{
	const QEvent::Type type = event->type();
	if (type == QEvent::MouseMove) {
		const QMouseEvent *const mouse_event = (QMouseEvent*)event;
        if (object == _ruler || object == _time_viewport || object == _fft_viewport) {
            //_hover_point = QPoint(mouse_event->x(), 0);
            double cur_periods = (mouse_event->pos().x() + _offset) * _scale / _ruler->get_min_period();
            int integer_x = round(cur_periods) * _ruler->get_min_period() / _scale - _offset;
            double cur_deviate_x = qAbs(mouse_event->pos().x() - integer_x);
            if (_device_agent->get_work_mode() == LOGIC &&
                cur_deviate_x < 10)
                _hover_point = QPoint(integer_x, mouse_event->pos().y());
            else
                _hover_point = mouse_event->pos();
        } else if (object == _header)
			_hover_point = QPoint(0, mouse_event->y());
		else
			_hover_point = QPoint(-1, -1);

		hover_point_changed();
	} else if (type == QEvent::Leave) {
		_hover_point = QPoint(-1, -1);
		hover_point_changed();
	}

	return QObject::eventFilter(object, event);
}

bool View::viewportEvent(QEvent *e)
{
	switch(e->type()) {
	case QEvent::Paint:
	case QEvent::MouseButtonPress:
	case QEvent::MouseButtonRelease:
	case QEvent::MouseButtonDblClick:
	case QEvent::MouseMove:
	case QEvent::Wheel:
    case QEvent::Gesture:
		return false;

	default:
		return QAbstractScrollArea::viewportEvent(e);
	}
}

int View::headerWidth()
{
    int headerWidth = _header->get_nameEditWidth();

    std::vector<Trace*> traces;
    get_traces(ALL_VIEW, traces);

    if (!traces.empty()) 
    {
        for(auto t : traces){
            int w = t->get_name_width() + t->get_leftWidth() + t->get_rightWidth();
            headerWidth = max(w, headerWidth);
        }
    }

    setViewportMargins(headerWidth, RulerHeight, 0, 0);

    return headerWidth;
}

void View::resizeEvent(QResizeEvent*)
{
    reconstruct();
    setViewportMargins(headerWidth(), RulerHeight, 0, 0);
    update_margins();
    update_scroll();
    signals_changed(NULL);

    if (_device_agent->get_work_mode() == DSO)
        _scale = _session->cur_view_time() / get_view_width();

    if (_device_agent->get_work_mode() != DSO)
        _maxscale = _session->cur_sampletime() / (get_view_width() * MaxViewRate);
    else
        _maxscale = 1e9;

    _scale = min(_scale, _maxscale);

    _ruler->update();
    _header->header_resize();
    set_update(_time_viewport, true);
    set_update(_fft_viewport, true);
    resize();
}

void View::h_scroll_value_changed(int value)
{
	if (_updating_scroll)
		return;

    _preOffset = _offset;

	const int range = horizontalScrollBar()->maximum();
	if (range < MaxScrollValue)
        _offset = value;
	else {
        int64_t length = 0;
        int64_t offset = 0;
		get_scroll_layout(length, offset);
        _offset = floor(value * 1.0 / MaxScrollValue * length);
	}

    _offset = max(min(_offset, get_max_offset()), get_min_offset());

    if (_offset != _preOffset) {
        _ruler->update();
        viewport_update();
    }
}

void View::v_scroll_value_changed(int value)
{
    (void)value;
	_header->update();
    viewport_update();
}

void View::data_updated()
{
    setViewportMargins(headerWidth(), RulerHeight, 0, 0);
    update_margins();

	// Update the scroll bars
	update_scroll();

    // update scale & offset
    update_scale_offset();

	// Repaint the view
    _time_viewport->unshow_wait_trigger();
    set_update(_time_viewport, true);
    set_update(_fft_viewport, true);
    viewport_update();
    _ruler->update();
}

void View::update_margins()
{
    _ruler->setGeometry(_viewcenter->x(), 0,  get_view_width(), _viewcenter->y());

    _header->setGeometry(0, _viewcenter->y(), _viewcenter->x(), _viewcenter->height());

    _devmode->setGeometry(0, 0, _viewcenter->x(), _viewcenter->y());
}

void View::header_updated()
{
    headerWidth();
    update_margins();

    // Update the scroll bars
    update_scroll();

    viewport_update();
    _header->update();
}

void View::marker_time_changed()
{
	_ruler->update();
    viewport_update();
}

void View::on_traces_moved()
{
	update_scroll();
    set_update(_time_viewport, true);
    viewport_update();
}

void View::add_cursor(QColor color, uint64_t index)
{
    Cursor *newCursor = new Cursor(*this, color, index);
    _cursorList.push_back(newCursor);
    cursor_update();
}

void View::del_cursor(Cursor* cursor)
{
    assert(cursor);

    _cursorList.remove(cursor);
    delete cursor;
    cursor_update();
}

void View::clear_cursors()
{
    for (auto c : _cursorList){
        delete c;
    }
    _cursorList.clear();
}

void View::set_cursor_middle(int index)
{
    assert(index < (int)_cursorList.size());

    auto i = _cursorList.begin();
    while (index-- != 0)
            i++;
    set_scale_offset(_scale, (*i)->index() / (_session->cur_snap_samplerate() * _scale) - (get_view_width() / 2));
}

void View::on_measure_updated()
{
    _active_viewport = dynamic_cast<Viewport *>(sender());
    measure_updated();
}

QString View::get_measure(QString option)
{
    if (_active_viewport) {
        return _active_viewport->get_measure(option);
    }
    return Unknown_Str;
}

QString View::get_cm_time(int index)
{
    return _ruler->format_real_time(get_cursor_samples(index), _session->cur_snap_samplerate());
}

QString View::get_cm_delta(int index1, int index2)
{
    if (index1 == index2)
        return "0";

    uint64_t samples1 = get_cursor_samples(index1);
    uint64_t samples2 = get_cursor_samples(index2);
    uint64_t delta_sample = (samples1 > samples2) ? samples1 - samples2 : samples2 - samples1;
    return _ruler->format_real_time(delta_sample, _session->cur_snap_samplerate());
}

QString View::get_index_delta(uint64_t start, uint64_t end)
{
    if (start == end)
        return "0";

    uint64_t delta_sample = (start > end) ? start - end : end - start;
    return _ruler->format_real_time(delta_sample, _session->cur_snap_samplerate());
}

uint64_t View::get_cursor_samples(int index)
{
    assert(index < (int)_cursorList.size());

    uint64_t ret = 0;
    int curIndex = 0;
    for (list<Cursor*>::iterator i = _cursorList.begin();
         i != _cursorList.end(); i++) {
        if (index == curIndex) {
            ret = (*i)->index();
        }
        curIndex++;
    }
    return ret;
}

void View::set_measure_en(int enable)
{
    _time_viewport->set_measure_en(enable);
    _fft_viewport->set_measure_en(enable);
}

void View::on_state_changed(bool stop)
{
    if (stop) {
        _time_viewport->stop_trigger_timer();
        _fft_viewport->stop_trigger_timer();
    }
    update_scale_offset();
}

QRect View::get_view_rect()
{
    if (_device_agent->get_work_mode() == DSO) {
        const auto &sigs = _session->get_signals();
        if(sigs.size() > 0) {
            return sigs[0]->get_view_rect();
        }
    }

    return _viewcenter->rect();
}

int View::get_view_width()
{
    int view_width = 0;
    if (_device_agent->get_work_mode() == DSO) {
        for(auto s : _session->get_signals()) {
            view_width = max(view_width, s->get_view_rect().width());
        }
    }
    else {
        view_width = _viewcenter->width();
    }

    return view_width;
}

int View::get_view_height()
{
    int view_height = 0;
    if (_device_agent->get_work_mode() == DSO) {
        for(auto s : _session->get_signals()) {
            view_height = max(view_height, s->get_view_rect().height());
        }
    }
    else {
        view_height = _viewcenter->height();
    }

    return view_height;
}

int64_t View::get_min_offset()
{
    if (MaxViewRate > 1)
        return floor(get_view_width() * (1 - MaxViewRate));
    else
        return 0;
}

int64_t View::get_max_offset()
{
    return ceil((_session->cur_snap_sampletime() / _scale) -
                (get_view_width() * MaxViewRate));
}

// -- calibration dialog
void View::show_calibration()
{
    _cali->update_device_info();
    _cali->show();
}

void View::hide_calibration()
{
    _cali->hide();
}

void View::vDial_updated()
{
    if (_cali->isVisible()) {
        _cali->update_device_info();
    }
    auto math_trace = _session->get_math_trace();
    if (math_trace && math_trace->enabled()) {
        math_trace->update_vDial();
    }
}

// -- lissajous figure
void View::show_lissajous(bool show)
{
    _show_lissajous = show;
    signals_changed(NULL);
}

void View::show_region(uint64_t start, uint64_t end, bool keep)
{
    assert(start <= end);
    if (keep) {
        set_all_update(true);
        update();
    } else if (_session->get_map_zoom() == 0) {
        const double ideal_scale = (end-start) * 2.0 / _session->cur_snap_samplerate() / get_view_width();
        const double new_scale = max (min(ideal_scale, _maxscale), _minscale);
        const double new_off = (start + end)  * 0.5 / (_session->cur_snap_samplerate() * new_scale) - (get_view_width() / 2);
        set_scale_offset(new_scale, new_off);
    } else {
        const double new_scale = scale();
        const double new_off = (start + end)  * 0.5 / (_session->cur_snap_samplerate() * new_scale) - (get_view_width() / 2);
        set_scale_offset(new_scale, new_off);
    }
}

void View::viewport_update()
{
    _viewcenter->update();
    for(QWidget *viewport : _viewport_list)
        viewport->update();
}

void View::splitterMoved(int pos, int index)
{
    (void)pos;
    (void)index;
    signals_changed(NULL);
}

void View::reload()
{
    clear();

    /*
     * if headerwidth not change, viewport height will not be updated
     * lead to a wrong signal height
     */
    reconstruct();
}

void View::clear()
{
    show_trig_cursor(false);

    if (_device_agent->get_work_mode() != DSO) {
        show_xcursors(false);
    } else {
        if (!get_xcursorList().empty())
            show_xcursors(true);
    }
}

void View::reconstruct()
{
    if (_device_agent->get_work_mode() == DSO)
        _viewbottom->setFixedHeight(DsoStatusHeight);
    else
        _viewbottom->setFixedHeight(StatusHeight);
    _viewbottom->reload();
}

void View::repeat_show()
{
    _viewbottom->update();
}

void View::show_captured_progress(bool triggered, int progress)
{
    _viewbottom->set_capture_status(triggered, progress);
    _viewbottom->update();
}

bool View::get_dso_trig_moved()
{
    return _time_viewport->get_dso_trig_moved();
}

void View::add_xcursor(QColor color, double value0, double value1)
{
    XCursor *newXCursor = new XCursor(*this, color, value0, value1);
    _xcursorList.push_back(newXCursor);
    xcursor_update();
}

void View::del_xcursor(XCursor* xcursor)
{
    assert(xcursor);

    _xcursorList.remove(xcursor);
    delete xcursor;
    xcursor_update();
}

double View::index2pixel(uint64_t index, bool has_hoff)
{
    const double samples_per_pixel = session().cur_snap_samplerate() * scale();
    double pixels;
    if (has_hoff)
        pixels = index/samples_per_pixel - offset() + trig_hoff()/samples_per_pixel;
    else
        pixels = index/samples_per_pixel - offset();

    return pixels;
}

uint64_t View::pixel2index(double pixel)
{
    const double samples_per_pixel = session().cur_snap_samplerate() * scale();
    uint64_t index = (pixel + offset()) * samples_per_pixel - trig_hoff();

    return index;
}

void View::set_receive_len(uint64_t len)
{
    if (_time_viewport)
        _time_viewport->set_receive_len(len);
        
    if (_fft_viewport && _session->get_device()->get_work_mode() == DSO)
        _fft_viewport->set_receive_len(len);
}

int View::get_cursor_index_by_key(uint64_t key)
{
    int dex = 0;
    for (auto c : _cursorList){
        if (c->get_key() == key){
            return dex;
        }
        ++dex;
    }
    return -1;
}

void View::check_calibration()
{
     if (_device_agent->get_work_mode() == DSO){
        bool cali = false;
        _device_agent->get_config_bool(SR_CONF_CALI, cali);
            
        if (cali) {
            show_calibration();
        }           
    }
}

void View::set_scale(double scale)
{
    if (scale < _minscale)
        scale = _minscale;
    if (scale > _maxscale)
        scale = _maxscale;

     if (_scale != scale)
     {
        _scale = scale;
        _header->update();
        _ruler->update();
        viewport_update();
        update_scroll();
    }
}

void View::auto_set_max_scale()
{
    _maxscale = _session->cur_sampletime() / (get_view_width() * MaxViewRate);
    set_scale(_maxscale);
}

int  View::get_body_width()
{
    if (_time_viewport != NULL)
        return _time_viewport->width();
    return 0;
}

int  View::get_body_height()
{
     if (_time_viewport != NULL)
        return _time_viewport->height();
    return 0;
}

 void View::update_view_port()
 {
    if (_time_viewport)
        _time_viewport->update();
 }

 void View::update_font()
 {
    headerWidth();
 }

} // namespace view
} // namespace dsv
/****************************************************************************
** Meta object code from reading C++ file 'header.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "header.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'header.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEHeaderENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEHeaderENDCLASS = QtMocHelpers::stringData(
    "dsv::view::Header",
    "traces_moved",
    "",
    "header_updated",
    "vDial_changed",
    "acdc_changed",
    "ch_changed",
    "on_action_set_name_triggered"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEHeaderENDCLASS_t {
    uint offsetsAndSizes[16];
    char stringdata0[18];
    char stringdata1[13];
    char stringdata2[1];
    char stringdata3[15];
    char stringdata4[14];
    char stringdata5[13];
    char stringdata6[11];
    char stringdata7[29];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEHeaderENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEHeaderENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEHeaderENDCLASS = {
    {
        QT_MOC_LITERAL(0, 17),  // "dsv::view::Header"
        QT_MOC_LITERAL(18, 12),  // "traces_moved"
        QT_MOC_LITERAL(31, 0),  // ""
        QT_MOC_LITERAL(32, 14),  // "header_updated"
        QT_MOC_LITERAL(47, 13),  // "vDial_changed"
        QT_MOC_LITERAL(61, 12),  // "acdc_changed"
        QT_MOC_LITERAL(74, 10),  // "ch_changed"
        QT_MOC_LITERAL(85, 28)   // "on_action_set_name_triggered"
    },
    "dsv::view::Header",
    "traces_moved",
    "",
    "header_updated",
    "vDial_changed",
    "acdc_changed",
    "ch_changed",
    "on_action_set_name_triggered"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEviewSCOPEHeaderENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       6,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       5,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   50,    2, 0x06,    1 /* Public */,
       3,    0,   51,    2, 0x06,    2 /* Public */,
       4,    1,   52,    2, 0x06,    3 /* Public */,
       5,    1,   55,    2, 0x06,    5 /* Public */,
       6,    1,   58,    2, 0x06,    7 /* Public */,

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       7,    0,   61,    2, 0x08,    9 /* Private */,

 // signals: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::UShort,    2,
    QMetaType::Void, QMetaType::UShort,    2,
    QMetaType::Void, QMetaType::UShort,    2,

 // slots: parameters
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::view::Header::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEHeaderENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEviewSCOPEHeaderENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEHeaderENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<Header, std::true_type>,
        // method 'traces_moved'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'header_updated'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'vDial_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<quint16, std::false_type>,
        // method 'acdc_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<quint16, std::false_type>,
        // method 'ch_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<quint16, std::false_type>,
        // method 'on_action_set_name_triggered'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::view::Header::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<Header *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->traces_moved(); break;
        case 1: _t->header_updated(); break;
        case 2: _t->vDial_changed((*reinterpret_cast< std::add_pointer_t<quint16>>(_a[1]))); break;
        case 3: _t->acdc_changed((*reinterpret_cast< std::add_pointer_t<quint16>>(_a[1]))); break;
        case 4: _t->ch_changed((*reinterpret_cast< std::add_pointer_t<quint16>>(_a[1]))); break;
        case 5: _t->on_action_set_name_triggered(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (Header::*)();
            if (_t _q_method = &Header::traces_moved; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (Header::*)();
            if (_t _q_method = &Header::header_updated; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 1;
                return;
            }
        }
        {
            using _t = void (Header::*)(quint16 );
            if (_t _q_method = &Header::vDial_changed; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 2;
                return;
            }
        }
        {
            using _t = void (Header::*)(quint16 );
            if (_t _q_method = &Header::acdc_changed; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 3;
                return;
            }
        }
        {
            using _t = void (Header::*)(quint16 );
            if (_t _q_method = &Header::ch_changed; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 4;
                return;
            }
        }
    }
}

const QMetaObject *dsv::view::Header::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::view::Header::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEHeaderENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int dsv::view::Header::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 6)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 6;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 6)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 6;
    }
    return _id;
}

// SIGNAL 0
void dsv::view::Header::traces_moved()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}

// SIGNAL 1
void dsv::view::Header::header_updated()
{
    QMetaObject::activate(this, &staticMetaObject, 1, nullptr);
}

// SIGNAL 2
void dsv::view::Header::vDial_changed(quint16 _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 2, _a);
}

// SIGNAL 3
void dsv::view::Header::acdc_changed(quint16 _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 3, _a);
}

// SIGNAL 4
void dsv::view::Header::ch_changed(quint16 _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 4, _a);
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "xcursor.h"
#include <QPainter>
#include "view.h"
#include "ruler.h"
#include "dsosignal.h"
#include "../log.h"
#include "../appcore/sigsession.h"

using namespace std;

namespace dsv {
namespace view {

XCursor::XCursor(View &view, QColor &colour,
    double value0, double value1) :
	_view(view),
    _yvalue(0.5),
    _value0(value0),
    _value1(value1),
    _grabbed(XCur_None),
	_colour(colour)
{
    _dsoSig = NULL;
    _sig_index = -1;
    
    for(auto s : _view.session().get_signals()) {        
        if (s->signal_type() == SR_CHANNEL_DSO){
            DsoSignal *dsoSig = (DsoSignal*)s;
            if (dsoSig->enabled()) {
                _dsoSig = dsoSig;
                break;
            }
        }
    }

    if (_dsoSig != NULL){
        connect(_dsoSig, SIGNAL(sig_released(void*)), this, SLOT(on_signal_deleted(void*)));
        _sig_index = _dsoSig->get_index();
    }
}

XCursor::XCursor(const XCursor &x) :
	QObject(),
    _view(x._view)
{
    _dsoSig = x._dsoSig;
    _yvalue = x._yvalue;
    _value0 = x._value0;
    _value1 = x._value1;
    _grabbed = XCur_None;
    _colour = x._colour;
    _sig_index = -1;

    if (_dsoSig != NULL){
        connect(_dsoSig, SIGNAL(sig_released(void*)), this, SLOT(on_signal_deleted(void*)));
        _sig_index = _dsoSig->get_index();
    }
}

QColor XCursor::colour()
{
    return _colour;
}

void XCursor::set_colour(QColor color)
{
    _colour = color;
}

/**
 * Gets/Sets the mapping channel of the marker
 */
DsoSignal* XCursor::channel()
{
    return _dsoSig;
}

void XCursor::set_channel(DsoSignal *sig)
{
    _dsoSig = sig;

    if (_dsoSig != NULL){
        connect(_dsoSig, SIGNAL(sig_released(void*)), this, SLOT(on_signal_deleted(void*)));
        _sig_index = _dsoSig->get_index();
    }
}

void XCursor::on_signal_deleted(void *o)
{
    if (o == _dsoSig){
        _dsoSig = NULL;
    }   
}

enum XCursor::XCur_type XCursor::grabbed()
{
    return _grabbed;
}

void XCursor::set_grabbed(XCur_type type, bool grabbed)
{
    if (_grabbed == XCur_None && grabbed)
        _grabbed = type;
    else if (_grabbed == type && !grabbed)
        _grabbed = XCur_None;
}

void XCursor::rel_grabbed()
{
    _grabbed = XCur_None;
}

double XCursor::value(XCur_type type)
{
    if (type == XCur_Y)
        return _yvalue;
    else if (type == XCur_X0)
        return _value0;
    else if (type == XCur_X1)
        return _value1;
    else
        return 0;
}

void XCursor::set_value(XCur_type type, double value)
{
    if (type == XCur_Y)
        _yvalue = value;
    else if (type == XCur_X0)
        _value0 = value;
    else if (type == XCur_X1)
        _value1 = value;
    value_changed();
}

void XCursor::paint(QPainter &p, const QRect &rect, XCur_type highlight,  int order)
{   
    // Attach the channel
    if (_dsoSig == NULL && _sig_index != -1){
        auto sig = _view.session().get_signal_by_index(_sig_index);
        if (sig != NULL){
            _dsoSig = dynamic_cast<DsoSignal*>(sig);

            if (_dsoSig != NULL){
                connect(_dsoSig, SIGNAL(sig_released(void*)), this, SLOT(on_signal_deleted(void*)));
            }
        }
    }

    const int arrow = 3;
    const int x = rect.left() + _yvalue * rect.width();
    const int y0 = rect.top() + _value0 * rect.height();
    const int y1 = rect.top() + _value1 * rect.height();
    QColor color = (order == -1) ? _colour : Ruler::CursorColor[order%8];
    const bool hit0 = (_grabbed == XCur_X0) | (_grabbed == XCur_None && (highlight == XCur_X0 || highlight == XCur_All));
    p.setPen(hit0 ? QPen(color.lighter(), 2, Qt::DashLine) : QPen(color, 1, Qt::DashLine));
    p.drawLine(QPoint(0, y0), QPoint(rect.right()-_v0_size.width(), y0));
    const bool hit1 = (_grabbed == XCur_X1) | (_grabbed == XCur_None && (highlight == XCur_X1 || highlight == XCur_All));
    p.setPen(hit1 ? QPen(color.lighter(), 2, Qt::DashLine) : QPen(color, 1, Qt::DashLine));
    p.drawLine(QPoint(0, y1), QPoint(rect.right()-_v1_size.width(), y1));

    if (_dsoSig) {
        if ((_grabbed == XCur_Y) | (_grabbed == XCur_None && (highlight == XCur_Y || highlight == XCur_All)))
            p.setPen(QPen(_dsoSig->get_colour(), 2, Qt::DashLine));
        else
            p.setPen(QPen(_dsoSig->get_colour(), 1, Qt::DashLine));
        p.drawLine(QPoint(x, y0), QPoint(x, y1));
        p.drawLine(QPoint(x-arrow, y0 + ((y0 > y1) ? -arrow : arrow)), QPoint(x, y0));
        p.drawLine(QPoint(x+arrow, y0 + ((y0 > y1) ? -arrow : arrow)), QPoint(x, y0));
        p.drawLine(QPoint(x-arrow, y1 + ((y0 > y1) ? arrow : -arrow)), QPoint(x, y1));
        p.drawLine(QPoint(x+arrow, y1 + ((y0 > y1) ? arrow : -arrow)), QPoint(x, y1));

        QString vol = " :" + _dsoSig->get_voltage(qAbs(y0 - y1), 2, true);
        const QSizeF delta_size = p.boundingRect(rect, Qt::AlignLeft | Qt::AlignTop, vol).size();
        const QRectF delta_rect = QRectF(x, (y0+y1-delta_size.height())/2, delta_size.width(), delta_size.height());
        p.drawText(delta_rect, Qt::AlignCenter, vol);

        vol = _dsoSig->get_voltage((_dsoSig->get_zero_ratio() - _value0)*rect.height(), 2, true);
        _v0_size = p.boundingRect(rect, Qt::AlignLeft | Qt::AlignTop, vol).size();
        p.drawText(QRectF(rect.right()-_v0_size.width(), y0-_v0_size.height()/2, _v0_size.width(), _v0_size.height()),
                   Qt::AlignLeft | Qt::AlignVCenter,
                   vol);

        vol = _dsoSig->get_voltage((_dsoSig->get_zero_ratio() - _value1)*rect.height(), 2, true);
        _v1_size = p.boundingRect(rect, Qt::AlignLeft | Qt::AlignTop, vol).size();
        p.drawText(QRectF(rect.right()-_v1_size.width(), y1-_v1_size.height()/2, _v1_size.width(), _v1_size.height()),
                   Qt::AlignLeft | Qt::AlignVCenter,
                   vol);
    }

    paint_label(p, rect);
}

/**
 * Gets the map label rectangle.
 * @param rect The rectangle of the xcursor area.
 * @return Returns the map label rectangle.
 */
QRect XCursor::get_map_rect(const QRect &rect)
{
    const int width = 10;
    const int64_t y = rect.top() + _value0 * rect.height() - width/2;
    return QRect(rect.right()+1, y, width, width);
}

/**
 * Gets the close label rectangle.
 * @param rect The rectangle of the xcursor area.
 * @return Returns the close label rectangle.
 */
QRect XCursor::get_close_rect(const QRect &rect)
{
    const int width = 10;
    const int64_t y = rect.top() + _value1 * rect.height() - width/2;
    return QRect(rect.right()+1, y, width, width);
}

/**
 * Paints the labels to the xcursor.
 * @param p The painter to draw with.
 * @param rect The rectangle of the xcursor area.
 */
void XCursor::paint_label(QPainter &p, const QRect &rect)
{
    if (_dsoSig) {
        QRect map_rect = get_map_rect(rect);
        p.setPen(Qt::NoPen);
        p.setBrush(_dsoSig->get_colour());
        p.drawRect(map_rect);
        p.setPen(Qt::white);
        p.drawText(map_rect, Qt::AlignCenter | Qt::AlignHCenter, QString::number(_dsoSig->get_index()));
    }

    QRect close = get_close_rect(rect);
    p.setPen(Qt::NoPen);

    if (close.contains(QPoint(_view.hover_point().x(), _view.hover_point().y())))
        p.setBrush(View::Red);
    else if (_dsoSig != NULL)
        p.setBrush(_dsoSig->get_colour());
    else
        p.setBrush(View::Blue);

    p.drawRect(close);
    p.setPen(Qt::black);
    p.drawLine(close.left() + 2, close.top() + 2, close.right() - 2, close.bottom() - 2);
    p.drawLine(close.left() + 2, close.bottom() - 2, close.right() - 2, close.top() + 2);
}

} // namespace view
} // namespace dsv
/****************************************************************************
** Meta object code from reading C++ file 'logicsignal.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "logicsignal.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'logicsignal.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPELogicSignalENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEviewSCOPELogicSignalENDCLASS = QtMocHelpers::stringData(
    "dsv::view::LogicSignal"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPELogicSignalENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[23];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEviewSCOPELogicSignalENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEviewSCOPELogicSignalENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEviewSCOPELogicSignalENDCLASS = {
    {
        QT_MOC_LITERAL(0, 22)   // "dsv::view::LogicSignal"
    },
    "dsv::view::LogicSignal"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEviewSCOPELogicSignalENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::view::LogicSignal::staticMetaObject = { {
    QMetaObject::SuperData::link<Signal::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEviewSCOPELogicSignalENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEviewSCOPELogicSignalENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEviewSCOPELogicSignalENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<LogicSignal, std::true_type>
    >,
    nullptr
} };

void dsv::view::LogicSignal::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *dsv::view::LogicSignal::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::view::LogicSignal::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEviewSCOPELogicSignalENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return Signal::qt_metacast(_clname);
}

int dsv::view::LogicSignal::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = Signal::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_VIEW_CURSOR_H
#define DSVIEW_PV_VIEW_CURSOR_H

#include <QSizeF>
#include <QString>
#include "timemarker.h"

class QPainter;

namespace dsv {
namespace view {

//created by View
class Cursor : public TimeMarker
{
	Q_OBJECT

public:
	static const QColor LineColour;
	static const QColor FillColour;
	static const QColor HighlightColour;
	static const QColor TextColour;

	static const int Offset;

	static const int ArrowSize;
    static const int CloseSize;

public:
	/**
	 * Constructor.
	 * @param view A reference to the view that owns this cursor pair.
	 * @param time The time to set the flag to.
	 * @param other A reference to the other cursor.
	 */
    Cursor(View &view, QColor color, uint64_t index);


public:
	/**
	 * Gets the marker label rectangle.
	 * @param rect The rectangle of the ruler client area.
	 * @return Returns the label rectangle.
	 */
    QRect get_label_rect(const QRect &rect, bool &visible, bool has_hoff = true);

    QRect get_close_rect(const QRect &rect);

	/**
	 * Paints the cursor's label to the ruler.
	 * @param p The painter to draw with.
	 * @param rect The rectangle of the ruler client area.
	 * @param prefix The index of the SI prefix to use.
	 */
    void paint_label(QPainter &p, const QRect &rect,
        unsigned int prefix, int index, bool has_hoff);

    void paint_fix_label(QPainter &p, const QRect &rect,
        unsigned int prefix, QChar label, QColor color, bool has_hoff);

public: 
	inline uint64_t get_key(){
		return (uint64_t)this;
	}
 
	inline uint64_t get_index()
	{
		return _index;
	}

private:
	void compute_text_size(QPainter &p, unsigned int prefix);

private:
	const Cursor &_other;
	QSizeF 		_text_size;
};

} // namespace view
} // namespace dsv

#endif // DSVIEW_PV_VIEW_CURSOR_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_SV_GROUPSIGNAL_H
#define DSVIEW_SV_GROUPSIGNAL_H

/*
#include "signal.h"

#include <list> 

namespace dsv {

namespace view {

//created by SigSession
class GroupSignal : public Trace
{
private:
	static const QColor SignalColours[4];

	static const float EnvelopeThreshold;

    enum GroupSetRegions{
        NONEREG = -1,
        CHNLREG,
    };

public:
    GroupSignal(QString name,
                std::list<int> probe_index_list, int group_index);

    virtual ~GroupSignal();

    bool enabled();

    dsv::data::SignalData* data();

	void set_scale(float scale);

    void paint_mid(QPainter &p, int left, int right, QColor fore, QColor back);

    QRectF get_rect(GroupSetRegions type, int y, int right);

protected:
    void paint_type_options(QPainter &p, int right, const QPoint pt, QColor fore);

private:
    void paint_trace(QPainter &p,
		int y, int left, const int64_t start, const int64_t end,
		const double pixels_offset, const double samples_per_pixel);

    void paint_envelope(QPainter &p,
		int y, int left, const int64_t start, const int64_t end,
		const double pixels_offset, const double samples_per_pixel);

private: 
	float _scale;
};

} // namespace view
} // namespace dsv

*/

#endif // DSVIEW_PV_GROUPSIGNAL_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#include <math.h>
#include <QTimer>
#include "mathtrace.h"
#include "../data/dsosnapshot.h"
#include "../data/mathstack.h"
#include "view.h"
#include "../appcore/sigsession.h"
#include "dsosignal.h"
#include "../basedef.h"
  
using namespace std;

namespace dsv {
namespace view {

MathTrace::MathTrace(bool enable,data::MathStack *math_stack,
                     view::DsoSignal *dsoSig1,
                     view::DsoSignal *dsoSig2):
    Trace("M", dsoSig1->get_index(), SR_CHANNEL_MATH),
    _math_stack(math_stack),
    _dsoSig1(dsoSig1),
    _dsoSig2(dsoSig2),
    _enable(enable),
    _show(true),
    _scale(0),
    _zero_vrate(0.5),
    _hw_offset(0x80),
    _hover_en(false),
    _hover_index(0),
    _hover_point(QPointF(0, 0)),
    _hover_voltage(0)
{
    _vDial = _math_stack->get_vDial();
    update_vDial();
    _colour = View::Red;
    _ref_min = dsoSig1->get_ref_min();
    _ref_max = dsoSig1->get_ref_max();
}

MathTrace::~MathTrace()
{
    DESTROY_OBJECT(_math_stack);
}

bool MathTrace::enabled()
{
    return _enable;
}

void MathTrace::set_enable(bool enable)
{
    _enable = enable;
}

int MathTrace::src1()
{
    assert(_dsoSig1);
    return _dsoSig1->get_index();
}

int MathTrace::src2()
{   
    assert(_dsoSig2);
    return _dsoSig2->get_index();
}

float MathTrace::get_scale()
{
    return _scale;
}

int MathTrace::get_name_width()
{
    return 0;
}

void MathTrace::update_vDial()
{
    _vDial->set_value(_math_stack->default_vDialValue());
}

void MathTrace::go_vDialPre()
{
    if (enabled() && !_vDial->isMin()) {
        if (_view->session().is_running_status())
            _view->session().refresh(DsoSignal::RefreshShort);
        const double pre_vdiv = _vDial->get_value();
        _vDial->set_sel(_vDial->get_sel() - 1);

        if (_view->session().is_stopped_status())
            _scale *= pre_vdiv/_vDial->get_value();

        _view->set_update(_viewport, true);
        _view->update();
    }
}

void MathTrace::go_vDialNext()
{
    if (enabled() && !_vDial->isMax()) {
        if (_view->session().is_running_status())
            _view->session().refresh(DsoSignal::RefreshShort);
        const double pre_vdiv = _vDial->get_value();
        _vDial->set_sel(_vDial->get_sel() + 1);

        if (_view->session().is_stopped_status())
            _scale *= pre_vdiv/_vDial->get_value();

        _view->set_update(_viewport, true);
        _view->update();
    }
}

uint64_t MathTrace::get_vDialValue()
{
    return _vDial->get_value();
}

uint16_t MathTrace::get_vDialSel()
{
    return _vDial->get_sel();
}

double MathTrace::get_zero_ratio()
{
    return _zero_vrate;
}

void MathTrace::set_zero_vrate(double rate)
{
    _zero_vrate = rate;
    _hw_offset = _zero_vrate * (_ref_max - _ref_min) + _ref_min;
}

int MathTrace::get_zero_vpos()
{
    return _zero_vrate * get_view_rect().height() + DsoSignal::UpMargin;
}

void MathTrace::set_zero_vpos(int pos)
{
    if (enabled()) {
        set_zero_vrate(min(max(pos - DsoSignal::UpMargin, 0),
                           get_view_rect().height()) * 1.0 / get_view_rect().height());
    }
}

void MathTrace::set_show(bool show)
{
    _show = show;
}

QRect MathTrace::get_view_rect()
{
    assert(_viewport);
    return QRect(0, DsoSignal::UpMargin,
                  _viewport->width() - DsoSignal::RightMargin,
                  _viewport->height() - DsoSignal::UpMargin - DsoSignal::DownMargin);
}

void MathTrace::paint_back(QPainter &p, int left, int right, QColor fore, QColor back)
{
    (void)p;
    (void)left;
    (void)right;
    (void)fore;
    (void)back;
}

void MathTrace::paint_mid(QPainter &p, int left, int right, QColor fore, QColor back)
{
    (void)fore;
    (void)back;

    if (!_show)
        return;

    assert(_math_stack);
    assert(_view);
    assert(right >= left);

    if (enabled()) {
        const float top = get_view_rect().top();
        const int height = get_view_rect().height();
        const int width = right - left;
        const float zeroY = _zero_vrate * height + top;

        const double scale = _view->scale();
        assert(scale > 0);
        const int64_t offset = _view->offset();

        const double pixels_offset = offset;
        //const double samplerate = _view->session().cur_snap_samplerate();
        const double samplerate = _math_stack->samplerate();
        const int64_t last_sample = max((int64_t)(_math_stack->get_sample_num() - 1), (int64_t)0);
        const double samples_per_pixel = samplerate * scale;
        const double start = offset * samples_per_pixel - _view->trig_hoff();
        const double end = start + samples_per_pixel * width;

        const int64_t start_sample = min(max((int64_t)floor(start),
            (int64_t)0), last_sample);
        const int64_t end_sample = min(max((int64_t)ceil(end) + 1,
            (int64_t)0), last_sample);

        _scale = get_view_rect().height() * _math_stack->get_math_scale() * 1000.0 / get_vDialValue();

        if (samples_per_pixel < DsoSignal::EnvelopeThreshold) {
            _math_stack->enable_envelope(false);
            paint_trace(p, zeroY, left,
                start_sample, end_sample,
                pixels_offset, samples_per_pixel);
        } else {
            _math_stack->enable_envelope(true);
            paint_envelope(p, zeroY, left,
                start_sample, end_sample,
                pixels_offset, samples_per_pixel);
        }
    }
}

void MathTrace::paint_fore(QPainter &p, int left, int right, QColor fore, QColor back)
{
    if (!_show)
        return;

    assert(_view);

    fore.setAlpha(View::BackAlpha);
    QPen pen(fore);
    pen.setStyle(Qt::DotLine);
    p.setPen(pen);
    p.drawLine(left, get_zero_vpos(), right, get_zero_vpos());

    // Paint measure
    fore.setAlpha(View::ForeAlpha);
    if (_view->session().is_stopped_status())
        paint_hover_measure(p, fore, back);
}

void MathTrace::paint_trace(QPainter &p,
    int zeroY, int left, const int64_t start, const int64_t end,
    const double pixels_offset, const double samples_per_pixel)
{
    const int64_t sample_count = end - start + 1;

    if (sample_count > 0) {
        QColor trace_colour = _colour;
        trace_colour.setAlpha(View::ForeAlpha);
        p.setPen(trace_colour);

        if ((uint64_t)end >= _math_stack->get_sample_num())
            return;

        const double *const values = _math_stack->get_math(start);
        assert(values);

        QPointF *points = new QPointF[sample_count];
        QPointF *point = points;

        double top = get_view_rect().top();
        double bottom = get_view_rect().bottom();
        float x = (start / samples_per_pixel - pixels_offset) + left + _view->trig_hoff()/samples_per_pixel;
        double  pixels_per_sample = 1.0/samples_per_pixel;

        for (int64_t index = 0; index < sample_count; index++) {
            const float y = min(max(top, zeroY - (values[index] * _scale)), bottom);
            if (x > get_view_rect().right()) {
                point--;
                const float lastY = point->y() + (y - point->y()) / (x - point->x()) * (get_view_rect().right() - point->x());
                point++;
                *point++ = QPointF(get_view_rect().right(), lastY);
                break;
            }
            *point++ = QPointF(x, y);
            x += pixels_per_sample;
        }

        p.drawPolyline(points, point - points);
        delete[] points;
    }
}

void MathTrace::paint_envelope(QPainter &p,
    int zeroY, int left, const int64_t start, const int64_t end,
    const double pixels_offset, const double samples_per_pixel)
{
	using namespace Qt;

    data::MathStack::EnvelopeSection e;
    _math_stack->get_math_envelope_section(e, start, end, samples_per_pixel);

	if (e.length < 2)
		return;

    p.setPen(QPen(NoPen));
    QColor envelope_colour = _colour;
    envelope_colour.setAlpha(View::ForeAlpha);
    p.setBrush(envelope_colour);

	QRectF *const rects = new QRectF[e.length];
	QRectF *rect = rects;
    double top = get_view_rect().top();
    double bottom = get_view_rect().bottom();
    for(uint64_t sample = 0; sample < e.length-1; sample++) {
		const float x = ((e.scale * sample + e.start) /
            samples_per_pixel - pixels_offset) + left + _view->trig_hoff()/samples_per_pixel;
        const data::MathStack::EnvelopeSample *const s =
			e.samples + sample;

		// We overlap this sample with the next so that vertical
		// gaps do not appear during steep rising or falling edges
        const float b = min(max(top, zeroY - max(s->max, (s+1)->min) * _scale), bottom);
        const float t = min(max(top, zeroY - min(s->min, (s+1)->max) * _scale), bottom);

		float h = b - t;
		if(h >= 0.0f && h <= 1.0f)
			h = 1.0f;
		if(h <= 0.0f && h >= -1.0f)
			h = -1.0f;

		*rect++ = QRectF(x, t, 1.0f, h);
	}

	p.drawRects(rects, e.length);

	delete[] rects;
}

void MathTrace::paint_type_options(QPainter &p, int right, const QPoint pt, QColor fore)
{
    p.setRenderHint(QPainter::Antialiasing, true);

    QColor foreBack = fore;
    foreBack.setAlpha(View::BackAlpha);
    int y = get_y();
    const QRectF vDial_rect = get_rect(DSO_VDIAL, y, right);

    QString pText;
    _vDial->paint(p, vDial_rect, _colour, pt, pText);
    QFontMetrics fm(p.font());
    const QRectF valueRect = QRectF(0, vDial_rect.top()-fm.height()-10, right, fm.height());
    p.drawText(valueRect, Qt::AlignCenter, pText);

    p.setRenderHint(QPainter::Antialiasing, false);
}

bool MathTrace::mouse_wheel(int right, const QPoint pt, const int shift)
{
    int y = get_y();
    const QRectF vDial_rect = get_rect(DSO_VDIAL, y, right);

    if (vDial_rect.contains(pt)) {
        if (shift > 0.5)
            go_vDialPre();
        else if (shift < -0.5)
            go_vDialNext();
        return true;
    } else {
        return false;
    }

    return true;
}

QRectF MathTrace::get_rect(MathSetRegions type, int y, int right)
{
    (void)right;

    if (type == DSO_VDIAL)
        return QRectF(
            get_leftWidth() + SquareWidth*0.5 + Margin,
            y - SquareWidth * SquareNum + SquareWidth * 3,
            SquareWidth * (SquareNum-1), SquareWidth * (SquareNum-1));
    else
        return QRectF(0, 0, 0, 0);
}

void MathTrace::paint_hover_measure(QPainter &p, QColor fore, QColor back)
{
    // Hover measure
    if (_hover_en) {
        QString hover_str = get_voltage(_hover_voltage, 2);
        const int hover_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
            Qt::AlignLeft | Qt::AlignTop, hover_str).width() + 10;
        const int hover_height = p.boundingRect(0, 0, INT_MAX, INT_MAX,
            Qt::AlignLeft | Qt::AlignTop, hover_str).height();
        QRectF hover_rect(_hover_point.x(), _hover_point.y()-hover_height/2, hover_width, hover_height);
        if (hover_rect.right() > get_view_rect().right())
            hover_rect.moveRight(_hover_point.x());
        if (hover_rect.top() < get_view_rect().top())
            hover_rect.moveTop(_hover_point.y());
        if (hover_rect.bottom() > get_view_rect().bottom())
            hover_rect.moveBottom(_hover_point.y());

        p.setPen(fore);
        p.setBrush(back);
        p.drawRect(_hover_point.x()-1, _hover_point.y()-1,
                   DsoSignal::HoverPointSize, DsoSignal::HoverPointSize);
        p.drawText(hover_rect, Qt::AlignCenter | Qt::AlignTop | Qt::TextDontClip, hover_str);
    }

    auto &cursor_list = _view->get_cursorList();
    auto i = cursor_list.begin();

    while (i != cursor_list.end()) {
        float pt_value;
        const QPointF pt = get_point((*i)->index(), pt_value);
        QString pt_str = get_voltage(pt_value, 2);
        const int pt_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
            Qt::AlignLeft | Qt::AlignTop, pt_str).width() + 10;
        const int pt_height = p.boundingRect(0, 0, INT_MAX, INT_MAX,
            Qt::AlignLeft | Qt::AlignTop, pt_str).height();
        QRectF pt_rect(pt.x(), pt.y()-pt_height/2, pt_width, pt_height);
        if (pt_rect.right() > get_view_rect().right())
            pt_rect.moveRight(pt.x());
        if (pt_rect.top() < get_view_rect().top())
            pt_rect.moveTop(pt.y());
        if (pt_rect.bottom() > get_view_rect().bottom())
            pt_rect.moveBottom(pt.y());

        p.drawRect(pt.x()-1, pt.y()-1, 2, 2);
        p.drawLine(pt.x()-2, pt.y()-2, pt.x()+2, pt.y()+2);
        p.drawLine(pt.x()+2, pt.y()-2, pt.x()-2, pt.y()+2);
        p.drawText(pt_rect, Qt::AlignCenter | Qt::AlignTop | Qt::TextDontClip, pt_str);

        i++;
    }
}

bool MathTrace::measure(const QPointF &p)
{
    _hover_en = false;
    if (!enabled())
        return false;

    const QRectF window = get_view_rect();
    if (!window.contains(p))
        return false;

    _hover_index = _view->pixel2index(p.x());
    if (_hover_index >= _math_stack->get_sample_num())
        return false;

    _hover_point = get_point(_hover_index, _hover_voltage);
    _hover_en = true;
    return true;
}

QPointF MathTrace::get_point(uint64_t index, float &value)
{
    QPointF pt = QPointF(0, 0);

    const float top = get_view_rect().top();
    const float bottom = get_view_rect().bottom();
    const float zeroP = _zero_vrate * get_view_rect().height() + top;
    const float x = _view->index2pixel(index);

    value = *_math_stack->get_math(index);
    float y = min(max(top, zeroP - (value * _scale)), bottom);
    pt = QPointF(x, y);
    return pt;
}

QString MathTrace::get_voltage(double v, int p)
{
    return abs(v) >= 1 ? QString::number(v, 'f', p) + _math_stack->get_unit(1) :
                         QString::number(v * 1000, 'f', p) + _math_stack->get_unit(0);
}

QString MathTrace::get_time(double t)
{
    QString str = (abs(t) > 1000000000 ? QString::number(t/1000000000, 'f', 2) + "S" :
                   abs(t) > 1000000 ? QString::number(t/1000000, 'f', 2) + "mS" :
                   abs(t) > 1000 ? QString::number(t/1000, 'f', 2) + "uS" : QString::number(t, 'f', 2) + "nS");
    return str;
}

dsv::data::MathStack* MathTrace::get_math_stack()
{
   return _math_stack;
}


} // namespace view
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2014 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_VIEW_TRACE_H
#define DSVIEW_PV_VIEW_TRACE_H

#include <QColor>
#include <QPainter>
#include <QPen>
#include <QRect>
#include <QString>
#include <QObject>
#include <stdint.h>
#include "dsldial.h"

class QFormLayout;

namespace dsv {
namespace view {

class View;
class Viewport;

//base class
class Trace : public QObject
{
	Q_OBJECT

protected:
    static const int Margin = 3;
    static const int SquareNum = 5;
	static const int LabelHitPadding;

public:
    static const int SquareWidth = 20;
    static const int COLOR = 1;
    static const int NAME = 2;
    static const int LABEL = 8;

    static const QColor PROBE_COLORS[8];

protected:
    Trace(QString name, uint16_t index, int type);
    Trace(QString name, std::list<int> index_list, int type, int sec_index);

    /**
     * Copy constructor
     */
    Trace(const Trace &t);

public:
	/**
	 * Gets the name of this signal.
	 */
	inline QString get_name(){
        return _name;
    }

    virtual int get_name_width();

	/**
	 * Sets the name of the signal.
	 */
	virtual void set_name(QString name);

	/**
	 * Get the colour of the signal.
	 */
	inline QColor get_colour(){
        return _colour;
    }

	/**
	 * Set the colour of the signal.
	 */
	inline void set_colour(QColor colour){
        _colour = colour;
    }

	/**
	 * Gets the vertical layout offset of this signal.
	 */
	inline int get_v_offset(){
        return _v_offset;
    }

	/**
	 * Sets the vertical layout offset of this signal.
	 */
	inline void set_v_offset(int v_offset){
        _v_offset = v_offset;
    }

    /**
     * Gets trace type
     */
    inline int get_type(){
        return _type;
    }

    /**
     * Index process
     */
    int get_index();

    inline std::list<int> get_index_list(){
        return _index_list;
    }

    void set_index_list(const std::list<int> &index_list);

    inline int get_sec_index(){
        return _sec_index;
    }

    inline void set_sec_index(int sec_index){
        _sec_index = sec_index;
    }

    /**
     * Gets the height of this signal.
     */
    inline int get_totalHeight(){
        return _totalHeight;
    }

    /**
     * Sets the height of this signal.
     */
    inline void set_totalHeight(int height){
         _totalHeight = height;
    }

    /**
     * Geom
     */
    inline int get_leftWidth(){
        return SquareWidth/2 + Margin;
    }

    inline int get_rightWidth(){
        return 2 * Margin + _typeWidth * SquareWidth + 1.5 * SquareWidth;
    }

    inline int get_headerHeight(){
        return SquareWidth;
    }

    /**
     * Gets the old vertical layout offset of this signal.
     */
    inline int get_old_v_offset(){
        return _old_v_offset;
    }

    /**
     * Sets the old vertical layout offset of this signal.
     */
    inline void set_old_v_offset(int v_offset){
        _old_v_offset = v_offset;
    }

    virtual int get_zero_vpos();

	/**
	 * Returns true if the trace is visible and enabled.
	 */
    virtual bool enabled() = 0;

	virtual void set_view(dsv::view::View *view);

    inline dsv::view::View* get_view(){
        return _view;
    }

    virtual void set_viewport(dsv::view::Viewport *viewport);

    inline dsv::view::Viewport* get_viewport(){
        return _viewport;
    }

    /**
     * Paints prepare
     **/
    virtual void paint_prepare();

	/**
	 * Paints the background layer of the trace with a QPainter
	 * @param p the QPainter to paint into.
	 * @param left the x-coordinate of the left edge of the signal
	 * @param right the x-coordinate of the right edge of the signal
	 **/
    virtual void paint_back(QPainter &p, int left, int right, QColor fore, QColor back);

	/**
	 * Paints the mid-layer of the trace with a QPainter
	 * @param p the QPainter to paint into.
	 * @param left the x-coordinate of the left edge of the signal
	 * @param right the x-coordinate of the right edge of the signal
	 **/
    virtual void paint_mid(QPainter &p, int left, int right, QColor fore, QColor back);

	/**
	 * Paints the foreground layer of the trace with a QPainter
	 * @param p the QPainter to paint into.
	 * @param left the x-coordinate of the left edge of the signal
	 * @param right the x-coordinate of the right edge of the signal
	 **/
    virtual void paint_fore(QPainter &p, int left, int right, QColor fore, QColor back);

	/**
     * Paints the trace label.
	 * @param p the QPainter to paint into.
	 * @param right the x-coordinate of the right edge of the header
	 * 	area.
     * @param point the mouse point.
	 */
    virtual void paint_label(QPainter &p, int right, const QPoint pt, QColor fore);

	/**
	 * Gets the y-offset of the axis.
	 */
	inline int get_y(){
        return _v_offset;
    }

    /**
     * Determines if a point is in the header rect.
     * 1 - in color rect
     * 2 - in name rect
     * 3 - in posTrig rect
     * 4 - in higTrig rect
     * 5 - in negTrig rect
     * 6 - in lowTrig rect
     * 7 - in label rect
     * 0 - not
     * @param y the y-coordinate of the signal.
     * @param right the x-coordinate of the right edge of the header
     * 	area.
     * @param point the point to test.
     */
    int pt_in_rect(int y, int right,
        const QPoint &point);

    /**
     * Computes the outline rectangle of a label.
     * @param p the QPainter to lay out text with.
     * @param y the y-coordinate of the signal.
     * @param right the x-coordinate of the right edge of the header
     * 	area.
     * @return Returns the rectangle of the signal label.
     */
    QRectF get_rect(const char *s, int y, int right);

    virtual int rows_size();

    virtual QRect get_view_rect();

    virtual bool mouse_double_click(int right, const QPoint pt);

    virtual bool mouse_press(int right, const QPoint pt);

    virtual bool mouse_wheel(int right, const QPoint pt, const int shift);

    inline int signal_type(){
        return get_type();
    }

    inline void set_view_index(int index){
        _view_index = index;
    }

    inline int get_view_index(){
        return _view_index;
    }

    inline bool selected(){
        return _selected;
    }

    inline void select(bool flag){
        _selected = flag;
    }

protected:

	/**
	 * Gets the text colour.
	 * @remarks This colour is computed by comparing the lightness
	 * of the trace colour against a threshold to determine whether
	 * white or black would be more visible.
	 */
	QColor get_text_colour();

    /**
     * Paints optoins for different trace type.
     * @param p the QPainter to paint into.
     * @param right the x-coordinate of the right edge of the header
     * 	area.
     * @param point the mouse point.
     */
    virtual void paint_type_options(QPainter &p, int right, const QPoint pt, QColor fore);

private:

    /**
     * Computes an caches the size of the label text.
     */
    void compute_text_size(QPainter &p);

private slots:
    void resize();

signals:
	void visibility_changed();
	void text_changed();	
	void colour_changed();

protected:
	dsv::view::View *_view;
    dsv::view::Viewport *_viewport;

	QString _name;
	QColor _colour;
	int _v_offset;
    int _type;
    std::list<int> _index_list;
    int _sec_index;
    int _old_v_offset;
    int _totalHeight;
    int _typeWidth;
    int _view_index;

    QSizeF _text_size;  
    bool _selected;
};

} // namespace view
} // namespace dsv

#endif // DSVIEW_PV_VIEW_TRACE_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "signal.h"
#include <math.h> 
#include "view.h" 
#include "../basedef.h"
#include "../appcore/appcontrol.h"
#include "../appcore/sigsession.h"

namespace dsv {
namespace view {

Signal::Signal(sr_channel *probe) :
    Trace(probe->name, probe->index, probe->type),
    _probe(probe)
{
    session = AppControl::Instance()->GetSession();
}

Signal::Signal(const Signal &s, sr_channel *probe) :
    Trace((const Trace &)s), 
    _probe(probe)
{   
    session = AppControl::Instance()->GetSession();
}

bool Signal::enabled()
{
    return _probe->enabled;
}

void Signal::set_name(QString name)
{
    Trace::set_name(name);
    g_free(_probe->name);
    _probe->name = g_strdup(name.toUtf8().data());
}
} // namespace view
} // namespace dsv
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2014 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_VIEW_DECODETRACE_H
#define DSVIEW_PV_VIEW_DECODETRACE_H


#include <list>
#include <map>
#include <QSignalMapper>
#include <QFormLayout>
#include <QWidget>
#include <QString>
#include "trace.h"
#include "../prop/binding/decoderoptions.h"
#include "../dialogs/dsdialog.h"

struct srd_channel;
struct srd_decoder; 
class DsComboBox;

namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
	namespace data {
		class DecoderStack;
	}
	namespace decode {
		class Annotation;
		class Decoder;
		class Row;
	}
}
using namespace dsv::appcore;
using namespace dsv::data;
using namespace dsv::decode;

namespace dsv {
namespace view {

//create by  SigSession
class DecodeTrace : public Trace
{
	Q_OBJECT

private:
    enum DecodeSetRegions{
        NONEREG = -1,
        CHNLREG,
    };

private:
	static const QColor DecodeColours[4];
	static const QColor ErrorBgColour;
	static const QColor NoDecodeColour;

	static const int ArrowSize;
	static const double EndCapWidth;
	static const int DrawPadding;

	static const QColor Colours[16];
	static const QColor OutlineColours[16];

    static const int ControlRectWidth = 5;
    static const int MaxAnnType = 100;

    static const QString RegionStart;
    static const QString RegionEnd;

public:
	DecodeTrace(SigSession *session,
			DecoderStack *decoder_stack,
			int index);

public:
    ~DecodeTrace();

	bool enabled();

	inline DecoderStack* decoder()
	{
		return _decoder_stack;
	}

	void set_view(View *view);

	/**
	 * Paints the background layer of the trace with a QPainter
	 * @param p the QPainter to paint into.
	 * @param left the x-coordinate of the left edge of the signal.
	 * @param right the x-coordinate of the right edge of the signal.
	 **/
    void paint_back(QPainter &p, int left, int right, QColor fore, QColor back);

	/**
	 * Paints the mid-layer of the trace with a QPainter
	 * @param p the QPainter to paint into.
	 * @param left the x-coordinate of the left edge of the signal
	 * @param right the x-coordinate of the right edge of the signal
	 **/
    void paint_mid(QPainter &p, int left, int right, QColor fore, QColor back);

	/**
	 * Paints the foreground layer of the trace with a QPainter
	 * @param p the QPainter to paint into.
	 * @param left the x-coordinate of the left edge of the signal
	 * @param right the x-coordinate of the right edge of the signal
	 **/
    void paint_fore(QPainter &p, int left, int right, QColor fore, QColor back);
 
    int rows_size();

    QRectF get_rect(DecodeSetRegions type, int y, int right);

    /**
     * decode region
     **/
    void frame_ended();

    int get_progress();

	void* get_key_handel();

	bool create_popup(bool isnew);

protected:
    void paint_type_options(QPainter &p, int right, const QPoint pt, QColor fore);

private: 
 
    void draw_annotation(const Annotation &a, QPainter &p,
        QColor text_colour, int text_height, int left, int right,
        double samples_per_pixel, double pixels_offset, int y,
        size_t base_colour, double min_annWidth, QColor fore, QColor back, double &last_x);

    void draw_nodetail(QPainter &p,
        int text_height, int left, int right, int y,
        size_t base_colour, QColor fore, QColor back);

	void draw_instant(const Annotation &a, QPainter &p,
		QColor fill, QColor outline, QColor text_color, int h, double x,
        int y, double min_annWidth);

    void draw_range(const Annotation &a, QPainter &p,
        QColor fill, QColor outline, QColor text_color, int h, double start,
        double end, int y, QColor fore, QColor back);

	void draw_error(QPainter &p, const QString &message,
		int left, int right);

    void draw_unshown_row(QPainter &p, int y, int h, int left,
                          int right, QString info, QColor fore, QColor back);
 

signals:
    void decoded_progress(int progress);

private slots:
	void on_new_decode_data();   

    void on_decode_done(); 

public:
	volatile bool _delete_flag; //destroy it when deocde task end

private:
	SigSession 			*_session;
	DecoderStack 	*_decoder_stack;
	uint64_t 		_decode_start;
	uint64_t	 	_decode_end;	
	uint64_t		_decode_cursor1; // the cursor key, sample start index 
	uint64_t		_decode_cursor2;
	std::vector<QString> 	_cur_row_headings; 
};

} // namespace view
} // namespace dsv

#endif // DSVIEW_PV_VIEW_DECODETRACE_H
/****************************************************************************
** Meta object code from reading C++ file 'mathtrace.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "mathtrace.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'mathtrace.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEMathTraceENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEMathTraceENDCLASS = QtMocHelpers::stringData(
    "dsv::view::MathTrace"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEMathTraceENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[21];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEMathTraceENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEMathTraceENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEMathTraceENDCLASS = {
    {
        QT_MOC_LITERAL(0, 20)   // "dsv::view::MathTrace"
    },
    "dsv::view::MathTrace"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEviewSCOPEMathTraceENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::view::MathTrace::staticMetaObject = { {
    QMetaObject::SuperData::link<Trace::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEMathTraceENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEviewSCOPEMathTraceENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEMathTraceENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<MathTrace, std::true_type>
    >,
    nullptr
} };

void dsv::view::MathTrace::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *dsv::view::MathTrace::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::view::MathTrace::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEMathTraceENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return Trace::qt_metacast(_clname);
}

int dsv::view::MathTrace::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = Trace::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
/****************************************************************************
** Meta object code from reading C++ file 'signal.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "signal.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'signal.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPESignalENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEviewSCOPESignalENDCLASS = QtMocHelpers::stringData(
    "dsv::view::Signal",
    "sig_released",
    "",
    "o"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPESignalENDCLASS_t {
    uint offsetsAndSizes[8];
    char stringdata0[18];
    char stringdata1[13];
    char stringdata2[1];
    char stringdata3[2];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEviewSCOPESignalENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEviewSCOPESignalENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEviewSCOPESignalENDCLASS = {
    {
        QT_MOC_LITERAL(0, 17),  // "dsv::view::Signal"
        QT_MOC_LITERAL(18, 12),  // "sig_released"
        QT_MOC_LITERAL(31, 0),  // ""
        QT_MOC_LITERAL(32, 1)   // "o"
    },
    "dsv::view::Signal",
    "sig_released",
    "",
    "o"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEviewSCOPESignalENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   20,    2, 0x06,    1 /* Public */,

 // signals: parameters
    QMetaType::Void, QMetaType::VoidStar,    3,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::view::Signal::staticMetaObject = { {
    QMetaObject::SuperData::link<Trace::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEviewSCOPESignalENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEviewSCOPESignalENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEviewSCOPESignalENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<Signal, std::true_type>,
        // method 'sig_released'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<void *, std::false_type>
    >,
    nullptr
} };

void dsv::view::Signal::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<Signal *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->sig_released((*reinterpret_cast< std::add_pointer_t<void*>>(_a[1]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (Signal::*)(void * );
            if (_t _q_method = &Signal::sig_released; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
    }
}

const QMetaObject *dsv::view::Signal::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::view::Signal::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEviewSCOPESignalENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return Trace::qt_metacast(_clname);
}

int dsv::view::Signal::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = Trace::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 1;
    }
    return _id;
}

// SIGNAL 0
void dsv::view::Signal::sig_released(void * _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2014 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "dsldial.h"

#include <cassert>
#include <cmath>

namespace dsv {
namespace view {

dslDial::dslDial(const uint64_t div, const uint64_t step,
                 const QVector<uint64_t> value, const QVector<QString> unit)
{
    assert(div > 0);
    assert(step > 0);
    assert((uint64_t)value.count() == div);
    assert(unit.count() > 0);

    _div = div;
    _step = step;
    _value = value;
    _unit = unit;
    _sel = 0;
    _factor = 1;
}

dslDial::~dslDial()
{
}

void dslDial::paint(QPainter &p, QRectF dialRect, QColor dialColor, const QPoint pt, QString &pText)
{  
    p.setPen(dialColor);
    p.setBrush(dialColor);

    int dialMarginAngle = 15 * 16;
    int dialStartAngle = 75 * 16;
    int dialSpanAngle = -150 * 16;

    // draw dial arc
    p.drawArc(dialRect, dialStartAngle + dialMarginAngle,
              dialSpanAngle - dialMarginAngle * 2);
    // draw ticks
    p.save();
    p.translate(dialRect.center());
    p.rotate(270 - dialStartAngle/16);
    // draw pointer
    p.rotate(-dialSpanAngle/16.0/(_div-1)*_sel);
    p.drawEllipse(-3, -3, 6, 6);
    p.drawLine(3, 0, 0, dialRect.width()/2-3);
    p.drawLine(-3, 0, 0, dialRect.width()/2-3);
    p.rotate(+dialSpanAngle/16.0/(_div-1)*_sel);
    for (uint64_t i = 0; i < _div; i++) {
        // draw major ticks
        p.drawLine(0, dialRect.width()/2+3, 0, dialRect.width()/2+8);
        // draw minor ticks
        for (uint64_t j = 0; (j < 5) && (i < _div - 1); j++) {
            p.drawLine(0, dialRect.width()/2+3, 0, dialRect.width()/2+5);
            p.rotate(-dialSpanAngle/16/5.0/(_div-1));
        }
    }
    p.restore();
    // draw value
    uint64_t displayValue = _value[_sel]*_factor;
    uint64_t displayIndex = 0;
    while(displayValue / _step >= 1) {
        displayValue = displayValue / _step;
        displayIndex++;
    }
    //tr
    pText = QString::number(displayValue) + _unit[displayIndex] + "/div";

    // draw +/-
    if (dialRect.contains(pt) && pt.x() > dialRect.center().x()) {
        const int arcInc = 12;
        const QRectF hoverRect = QRectF(dialRect.left()-arcInc, dialRect.top()-arcInc,
                                        dialRect.width()+arcInc*2, dialRect.height()+arcInc*2);
        p.drawArc(hoverRect, dialStartAngle + dialSpanAngle/4, dialSpanAngle/2);
        p.save();
        p.translate(hoverRect.center());
        const bool inc = pt.y() > dialRect.center().y();
        if (inc)
            p.rotate(270-(dialStartAngle/16 + dialSpanAngle/16/4 + dialSpanAngle/16/2));
        else
            p.rotate(270-(dialStartAngle/16 + dialSpanAngle/16/4));
        p.drawLine(0, hoverRect.width()/2,
                   inc ? 10 : -10, hoverRect.width()/2 + 4);
        p.restore();
    }
}

void dslDial::set_sel(uint64_t sel)
{
    assert(sel < _div);

    _sel = sel;
}

uint64_t dslDial::get_sel()
{
    return _sel;
}

uint64_t dslDial::get_count()
{
    return _div;
}

bool dslDial::isMin()
{
    if(_sel == 0)
        return true;
    else
        return false;
}

bool dslDial::isMax()
{
    if(_sel == _div - 1)
        return true;
    else
        return false;
}

uint64_t dslDial::get_min()
{
    return _value[0];
}

uint64_t dslDial::get_max()
{
    return _value[_div-1];
}

uint64_t dslDial::get_value()
{    
    if (_sel >= (uint64_t)_value.count()){
        assert(false);
    }

    return _value[_sel];
}

uint64_t dslDial::get_value(uint64_t i)
{
    assert(i < _div);
    return _value[i];
}

void dslDial::set_value(uint64_t value)
{
    assert(_value.contains(value));
    _sel = _value.indexOf(value, 0);
}

void dslDial::set_factor(uint64_t factor)
{
    if (_factor != factor) {
        _factor = factor;
    }
}

uint64_t dslDial::get_factor()
{
    return _factor;
}

} // namespace view
} // namespace dsv
/****************************************************************************
** Meta object code from reading C++ file 'ruler.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "ruler.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'ruler.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPERulerENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEviewSCOPERulerENDCLASS = QtMocHelpers::stringData(
    "dsv::view::Ruler",
    "hover_point_changed",
    ""
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPERulerENDCLASS_t {
    uint offsetsAndSizes[6];
    char stringdata0[17];
    char stringdata1[20];
    char stringdata2[1];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEviewSCOPERulerENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEviewSCOPERulerENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEviewSCOPERulerENDCLASS = {
    {
        QT_MOC_LITERAL(0, 16),  // "dsv::view::Ruler"
        QT_MOC_LITERAL(17, 19),  // "hover_point_changed"
        QT_MOC_LITERAL(37, 0)   // ""
    },
    "dsv::view::Ruler",
    "hover_point_changed",
    ""
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEviewSCOPERulerENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   20,    2, 0x08,    1 /* Private */,

 // slots: parameters
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::view::Ruler::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEviewSCOPERulerENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEviewSCOPERulerENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEviewSCOPERulerENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<Ruler, std::true_type>,
        // method 'hover_point_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::view::Ruler::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<Ruler *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->hover_point_changed(); break;
        default: ;
        }
    }
    (void)_a;
}

const QMetaObject *dsv::view::Ruler::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::view::Ruler::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEviewSCOPERulerENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int dsv::view::Ruler::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 1;
    }
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_LISSAJOUSTRACE_H
#define DSVIEW_PV_LISSAJOUSTRACE_H

#include "trace.h"
  
namespace dsv {

namespace data {
class DsoSnapshot;
}

namespace view {

//when device is oscilloscope mode, it can use to draw Lissajous graph
//created by SigSession
class LissajousTrace : public Trace
{
    Q_OBJECT

private:
    static const int DIV_NUM = 10; 

public:
    LissajousTrace(bool enable, dsv::data::DsoSnapshot *data,
                   int xIndex, int yIndex, int percent);

    virtual ~LissajousTrace();

    inline bool enabled(){
        return _enable;
    }

    inline void set_enable(bool enable){
        _enable = enable;
    }

    inline int xIndex(){
        return _xIndex;
    }

    inline int yIndex(){
        return _yIndex;
    }

    inline int percent(){
        return _percent;
    }

    inline dsv::data::DsoSnapshot* get_data(){
        return _data;
    }

    inline void set_data(dsv::data::DsoSnapshot* data){
        _data = data;
    }

    inline int rows_size(){
        return 0;
    }

    /**
     * Paints the background layer of the trace with a QPainter
     * @param p the QPainter to paint into.
     * @param left the x-coordinate of the left edge of the signal
     * @param right the x-coordinate of the right edge of the signal
     **/
    void paint_back(QPainter &p, int left, int right, QColor fore, QColor back);

	/**
	 * Paints the signal with a QPainter
	 * @param p the QPainter to paint into.
	 * @param left the x-coordinate of the left edge of the signal.
	 * @param right the x-coordinate of the right edge of the signal.
	 **/
    void paint_mid(QPainter &p, int left, int right, QColor fore, QColor back);

    /**
     * Paints the signal with a QPainter
     * @param p the QPainter to paint into.
     * @param left the x-coordinate of the left edge of the signal.
     * @param right the x-coordinate of the right edge of the signal.
     **/
    void paint_fore(QPainter &p, int left, int right, QColor fore, QColor back);

    void paint_label(QPainter &p, int right, const QPoint pt, QColor fore);

private:
    dsv::data::DsoSnapshot *_data;

    bool _enable;
    int _xIndex;
    int _yIndex;
    int _percent;
    QRect _border;
};

} // namespace view
} // namespace dsv

#endif // DSVIEW_PV_LISSAJOUSTRACE_H
/****************************************************************************
** Meta object code from reading C++ file 'viewport.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "viewport.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'viewport.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewportENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewportENDCLASS = QtMocHelpers::stringData(
    "dsv::view::Viewport",
    "measure_updated",
    "",
    "prgRate",
    "progress",
    "on_trigger_timer",
    "on_drag_timer",
    "show_contextmenu",
    "pos",
    "add_cursor_x",
    "add_cursor_y"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewportENDCLASS_t {
    uint offsetsAndSizes[22];
    char stringdata0[20];
    char stringdata1[16];
    char stringdata2[1];
    char stringdata3[8];
    char stringdata4[9];
    char stringdata5[17];
    char stringdata6[14];
    char stringdata7[17];
    char stringdata8[4];
    char stringdata9[13];
    char stringdata10[13];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewportENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewportENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewportENDCLASS = {
    {
        QT_MOC_LITERAL(0, 19),  // "dsv::view::Viewport"
        QT_MOC_LITERAL(20, 15),  // "measure_updated"
        QT_MOC_LITERAL(36, 0),  // ""
        QT_MOC_LITERAL(37, 7),  // "prgRate"
        QT_MOC_LITERAL(45, 8),  // "progress"
        QT_MOC_LITERAL(54, 16),  // "on_trigger_timer"
        QT_MOC_LITERAL(71, 13),  // "on_drag_timer"
        QT_MOC_LITERAL(85, 16),  // "show_contextmenu"
        QT_MOC_LITERAL(102, 3),  // "pos"
        QT_MOC_LITERAL(106, 12),  // "add_cursor_x"
        QT_MOC_LITERAL(119, 12)   // "add_cursor_y"
    },
    "dsv::view::Viewport",
    "measure_updated",
    "",
    "prgRate",
    "progress",
    "on_trigger_timer",
    "on_drag_timer",
    "show_contextmenu",
    "pos",
    "add_cursor_x",
    "add_cursor_y"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEviewSCOPEViewportENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       7,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       2,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   56,    2, 0x06,    1 /* Public */,
       3,    1,   57,    2, 0x06,    2 /* Public */,

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       5,    0,   60,    2, 0x08,    4 /* Private */,
       6,    0,   61,    2, 0x08,    5 /* Private */,
       7,    1,   62,    2, 0x08,    6 /* Private */,
       9,    0,   65,    2, 0x08,    8 /* Private */,
      10,    0,   66,    2, 0x08,    9 /* Private */,

 // signals: parameters
    QMetaType::Void,
    QMetaType::Void, QMetaType::Int,    4,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::QPoint,    8,
    QMetaType::Void,
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::view::Viewport::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewportENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEviewSCOPEViewportENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewportENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<Viewport, std::true_type>,
        // method 'measure_updated'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'prgRate'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'on_trigger_timer'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_drag_timer'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'show_contextmenu'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<const QPoint &, std::false_type>,
        // method 'add_cursor_x'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'add_cursor_y'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::view::Viewport::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<Viewport *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->measure_updated(); break;
        case 1: _t->prgRate((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 2: _t->on_trigger_timer(); break;
        case 3: _t->on_drag_timer(); break;
        case 4: _t->show_contextmenu((*reinterpret_cast< std::add_pointer_t<QPoint>>(_a[1]))); break;
        case 5: _t->add_cursor_x(); break;
        case 6: _t->add_cursor_y(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (Viewport::*)();
            if (_t _q_method = &Viewport::measure_updated; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (Viewport::*)(int );
            if (_t _q_method = &Viewport::prgRate; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 1;
                return;
            }
        }
    }
}

const QMetaObject *dsv::view::Viewport::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::view::Viewport::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewportENDCLASS.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "IFontForm"))
        return static_cast< IFontForm*>(this);
    return QWidget::qt_metacast(_clname);
}

int dsv::view::Viewport::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 7)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 7;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 7)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 7;
    }
    return _id;
}

// SIGNAL 0
void dsv::view::Viewport::measure_updated()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}

// SIGNAL 1
void dsv::view::Viewport::prgRate(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 1, _a);
}
QT_WARNING_POP
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2014 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "decodetrace.h"
#include <libsigrokdecode.h>
#include <boost/functional/hash.hpp>
#include <QAction> 
#include <QFormLayout>
#include <QLabel>
#include <QMenu>
#include <QPushButton>
#include <QDialog>
#include <QDialogButtonBox>
#include <QScrollArea>
#include <QApplication>
#include "logicsignal.h"
#include "view.h"
#include "cursor.h"
#include "../appcore/sigsession.h"
#include "../data/decoderstack.h"
#include "../decode/decoder.h"
#include "../data/logicsnapshot.h"
#include "../decode/annotation.h"
#include "../widgets/decodergroupbox.h"
#include "../widgets/decodermenu.h"
#include "../toolbars/titlebar.h"
#include "../ui/dscombobox.h"
#include "../ui/msgbox.h"
#include "../appcore/appcontrol.h"
#include "../dialogs/decoderoptionsdlg.h"
#include "../ui/langresource.h"
#include "../config/appconfig.h"
#include "../log.h"
#include "../basedef.h" 

using namespace boost;
using namespace std;
 
namespace dsv {
namespace view {

const QColor DecodeTrace::DecodeColours[4] = {
	QColor(0xEF, 0x29, 0x29),	// Red
	QColor(0xFC, 0xE9, 0x4F),	// Yellow
	QColor(0x8A, 0xE2, 0x34),	// Green
	QColor(0x72, 0x9F, 0xCF)	// Blue
};

const QColor DecodeTrace::ErrorBgColour = QColor(0xEF, 0x29, 0x29);
const QColor DecodeTrace::NoDecodeColour = QColor(0x88, 0x8A, 0x85);

const int DecodeTrace::ArrowSize = 4;
const double DecodeTrace::EndCapWidth = 5;
const int DecodeTrace::DrawPadding = 100;

const QColor DecodeTrace::Colours[16] = {
	QColor(0xEF, 0x29, 0x29),
	QColor(0xF6, 0x6A, 0x32),
	QColor(0xFC, 0xAE, 0x3E),
	QColor(0xFB, 0xCA, 0x47),
	QColor(0xFC, 0xE9, 0x4F),
	QColor(0xCD, 0xF0, 0x40),
	QColor(0x8A, 0xE2, 0x34),
	QColor(0x4E, 0xDC, 0x44),
	QColor(0x55, 0xD7, 0x95),
	QColor(0x64, 0xD1, 0xD2),
	QColor(0x72, 0x9F, 0xCF),
	QColor(0xD4, 0x76, 0xC4),
	QColor(0x9D, 0x79, 0xB9),
	QColor(0xAD, 0x7F, 0xA8),
	QColor(0xC2, 0x62, 0x9B),
	QColor(0xD7, 0x47, 0x6F)
};

const QColor DecodeTrace::OutlineColours[16] = {
	QColor(0x77, 0x14, 0x14),
	QColor(0x7B, 0x35, 0x19),
	QColor(0x7E, 0x57, 0x1F),
	QColor(0x7D, 0x65, 0x23),
	QColor(0x7E, 0x74, 0x27),
	QColor(0x66, 0x78, 0x20),
	QColor(0x45, 0x71, 0x1A),
	QColor(0x27, 0x6E, 0x22),
	QColor(0x2A, 0x6B, 0x4A),
	QColor(0x32, 0x68, 0x69),
	QColor(0x39, 0x4F, 0x67),
	QColor(0x6A, 0x3B, 0x62),
	QColor(0x4E, 0x3C, 0x5C),
	QColor(0x56, 0x3F, 0x54),
	QColor(0x61, 0x31, 0x4D),
	QColor(0x6B, 0x23, 0x37)
};

const QString DecodeTrace::RegionStart = QT_TR_NOOP("Start");
const QString DecodeTrace::RegionEnd = QT_TR_NOOP("End  ");

DecodeTrace::DecodeTrace(SigSession *session,
	DecoderStack *decoder_stack, int index) :
	Trace(QString::fromUtf8(decoder_stack->stack().front()->decoder()->name), index, SR_CHANNEL_DECODER)
{
    assert(decoder_stack);

    _colour = DecodeColours[index % countof(DecodeColours)];
 
    _decode_start = 0;
    _decode_end  = INT64_MAX; 
    _decoder_stack = decoder_stack;
    _session = session;
    _delete_flag = false;
    _decode_cursor1 = 0;
    _decode_cursor2 = 0;

    connect(_decoder_stack, SIGNAL(new_decode_data()), this, SLOT(on_new_decode_data()));

    connect(_decoder_stack, SIGNAL(decode_done()), this, SLOT(on_decode_done()));
}

DecodeTrace::~DecodeTrace()
{   
    _cur_row_headings.clear(); 
  
    DESTROY_OBJECT(_decoder_stack);
}

bool DecodeTrace::enabled()
{
	return true;
}
  
void DecodeTrace::set_view(View *view)
{
	assert(view);
	Trace::set_view(view);
}

void DecodeTrace::paint_back(QPainter &p, int left, int right, QColor fore, QColor back)
{
    (void)back;

    QColor backFore = fore;
    backFore.setAlpha(View::BackAlpha);
    QPen pen(backFore);
    pen.setStyle(Qt::DotLine);
    p.setPen(pen);
    const double sigY = get_y() - (_totalHeight - _view->get_signalHeight())*0.5;
    p.drawLine(left, sigY, right, sigY);

    // --draw decode region control
    const double samples_per_pixel = _session->cur_snap_samplerate() * _view->scale();
    const double startX = _decode_start/samples_per_pixel - _view->offset();
    const double endX = _decode_end/samples_per_pixel - _view->offset();
    const double regionY = get_y() - _totalHeight*0.5 - ControlRectWidth;

    p.setBrush(View::Blue);
    p.drawLine(startX, regionY, startX, regionY + _totalHeight + ControlRectWidth);
    p.drawLine(endX, regionY, endX, regionY + _totalHeight + ControlRectWidth);
    const QPointF start_points[] = {
        QPointF(startX-ControlRectWidth, regionY),
        QPointF(startX+ControlRectWidth, regionY),
        QPointF(startX, regionY+ControlRectWidth)
    };
    const QPointF end_points[] = {
        QPointF(endX-ControlRectWidth, regionY),
        QPointF(endX+ControlRectWidth, regionY),
        QPointF(endX, regionY+ControlRectWidth)
    };
    p.drawPolygon(start_points, countof(start_points));
    p.drawPolygon(end_points, countof(end_points));

    // --draw headings
    const int row_height = _view->get_signalHeight();
    for (size_t i = 0; i < _cur_row_headings.size(); i++)
    {
        const int y = i * row_height + get_y() - _totalHeight * 0.5;

        p.setPen(QPen(Qt::NoPen));
        p.setBrush(QApplication::palette().brush(QPalette::WindowText));

        const QRect r(left + ArrowSize * 2, y,
            right - left, row_height / 2);
        const QString h(_cur_row_headings[i]);
        const int f = Qt::AlignLeft | Qt::AlignVCenter |
            Qt::TextDontClip;
        const QPointF points[] = {
            QPointF(left, r.center().y() - ArrowSize),
            QPointF(left + ArrowSize, r.center().y()),
            QPointF(left, r.center().y() + ArrowSize)
        };
        p.drawPolygon(points, countof(points));

        // Draw the text
        p.setPen(fore);
        p.drawText(r, f, h);
    }
}

void DecodeTrace::paint_mid(QPainter &p, int left, int right, QColor fore, QColor back)
{ 
    assert(_decoder_stack);
    const QString err = _decoder_stack->error_message();
    if (!err.isEmpty())
    {
        draw_error(p, err, left, right);
    }

    const double scale = _view->scale();
    assert(scale > 0);

    double samplerate = _decoder_stack->samplerate();

    _cur_row_headings.clear();

    // Show sample rate as 1Hz when it is unknown
    if (samplerate == 0.0)
        samplerate = 1.0;

    const int64_t pixels_offset = _view->offset();
    const double samples_per_pixel = samplerate * scale;

    uint64_t start_sample = (uint64_t)max((left + pixels_offset) *
        samples_per_pixel, 0.0);
    uint64_t end_sample = (uint64_t)max((right + pixels_offset) *
        samples_per_pixel, 0.0);

    for(auto dec : _decoder_stack->stack()) {
        start_sample = max(dec->decode_start(), start_sample);
        end_sample = min(dec->decode_end(), end_sample);
        break;
    }

    if (end_sample < start_sample)
        return;

    const int annotation_height = _view->get_signalHeight();

    // Iterate through the rows
    assert(_view);
    int y =  get_y() - (_totalHeight - annotation_height)*0.5;

    assert(_decoder_stack);

    for(auto dec :_decoder_stack->stack()) {
        if (dec->shown()) {
            const std::map<const Row, bool> rows = _decoder_stack->get_rows_gshow();
            for (std::map<const Row, bool>::const_iterator i = rows.begin();
                i != rows.end(); i++) {
                if ((*i).first.decoder() == dec->decoder() &&
                    _decoder_stack->has_annotations((*i).first)) {
                    if ((*i).second) {
                        const Row &row = (*i).first;

                        const uint64_t min_annotation =
                                _decoder_stack->get_min_annotation(row);
                        const double min_annWidth = min_annotation / samples_per_pixel;

                        const uint64_t max_annotation =
                                _decoder_stack->get_max_annotation(row);
                        const double max_annWidth = max_annotation / samples_per_pixel;
                        
                        if ((max_annWidth > 100) ||
                            (max_annWidth > 10 && (min_annWidth > 1 || samples_per_pixel < 50)) ||
                            (max_annWidth == 0 && samples_per_pixel < 10)) {
                            std::vector<Annotation*> annotations;
                            _decoder_stack->get_annotation_subset(annotations, row,
                                start_sample, end_sample);

                            if (!annotations.empty()) {
                                double last_x = -1;

                                for(Annotation *a : annotations){
                                    draw_annotation(*a, p, get_text_colour(),
                                        annotation_height, left, right,
                                        samples_per_pixel, pixels_offset, y,
                                        0, min_annWidth, fore, back, last_x);
                                }
                            }
                        }
                        else {
                            draw_nodetail(p, annotation_height, left, right, y, 0, fore, back);
                        }

                        y += annotation_height;
                        _cur_row_headings.push_back(row.title());
                    }
                }
            }
        } else {
            draw_unshown_row(p, y, annotation_height, left, right, L_S(STR_PAGE_DLG, S_ID(IDS_DLG_UNSHOWN), "Unshown"), fore, back);
            y += annotation_height;
            _cur_row_headings.push_back(dec->decoder()->name);
        }
    }
}

void DecodeTrace::paint_fore(QPainter &p, int left, int right, QColor fore, QColor back)
{ 
    (void)p;
    (void)left;
	(void)right;
    (void)fore;
    (void)back;
}
 
void DecodeTrace::draw_annotation(const Annotation &a,
    QPainter &p, QColor text_color, int h, int left, int right,
    double samples_per_pixel, double pixels_offset, int y,
    size_t base_colour, double min_annWidth, QColor fore, QColor back, double &last_x)
{
    const double start = max(a.start_sample() / samples_per_pixel -
        pixels_offset, (double)left);
    const double end = min(a.end_sample() / samples_per_pixel -
        pixels_offset, (double)right);

    const size_t colour = ((base_colour + a.type()) % MaxAnnType) % countof(Colours);
	const QColor &fill = Colours[colour];
	const QColor &outline = OutlineColours[colour];

	if (start > right + DrawPadding || end < left - DrawPadding){
		return;
    }

    if (end - last_x <= 0.5 && end - start < 1){
        return;
    }
    
    last_x = end;

    if (_decoder_stack->get_mark_index() == (int64_t)(a.start_sample()+ a.end_sample())/2) {
        p.setPen(View::Blue);
        int xpos = (start+end)/2;
        int ypos = get_y()+_totalHeight*0.5 + 1;
        const QPoint triangle[] = {
            QPoint(xpos, ypos),
            QPoint(xpos-1, ypos + 1),
            QPoint(xpos, ypos + 1),
            QPoint(xpos+1, ypos + 1),
            QPoint(xpos-2, ypos + 2),
            QPoint(xpos-1, ypos + 2),
            QPoint(xpos, ypos + 2),
            QPoint(xpos+1, ypos + 2),
            QPoint(xpos+2, ypos + 2),
        };
        p.drawPoints(triangle, 9);
    }

	if (a.start_sample() == a.end_sample()){
		draw_instant(a, p, fill, outline, text_color, h,
            start, y, min_annWidth);
    }
    else {
		draw_range(a, p, fill, outline, text_color, h,
            start, end, y, fore, back);
    
        if ((a.type()/100 == 2) && (end - start > 20)) {
            for(auto dec : _decoder_stack->stack()) {
                for (auto& iter : dec->channels()) {
                    int type = dec->get_channel_type(iter.first);
                    if ((type == SRD_CHANNEL_COMMON) ||
                        ((type%100 != a.type()%100) && (type%100 != 0)))
                        continue; 

                    const double mark_end = a.end_sample() / samples_per_pixel - pixels_offset;

                    for(auto s : _session->get_signals()) {
                        if((s->get_index() == iter.second) && s->signal_type() == SR_CHANNEL_LOGIC) {
                            view::LogicSignal *logicSig = (view::LogicSignal*)s;
                            logicSig->paint_mark(p, start, mark_end, type/100);
                            break;
                        }
                    }
                }
            }
        }
    }
}

void DecodeTrace::draw_nodetail(QPainter &p,
    int h, int left, int right, int y,
    size_t base_colour, QColor fore, QColor back)
{
    (void)base_colour;
    (void)back;

    const QRectF nodetail_rect(left, y - h/2 + 0.5, right - left, h);
    QString info = L_S(STR_PAGE_DLG, S_ID(ZOOM_IN_FOR_DETAILS), "Zoom in for details");
    int info_left = nodetail_rect.center().x() - p.boundingRect(QRectF(), 0, info).width();
    int info_right = nodetail_rect.center().x() + p.boundingRect(QRectF(), 0, info).width();
    int height = p.boundingRect(QRectF(), 0, info).height();

    p.setPen(fore);
    p.drawLine(left, y, info_left, y);
    p.drawLine(info_right, y, right, y);
    p.drawLine(info_left, y, info_left+5, y - height/2 + 0.5);
    p.drawLine(info_left, y, info_left+5, y + height/2 + 0.5);
    p.drawLine(info_right, y, info_right-5, y - height/2 + 0.5);
    p.drawLine(info_right, y, info_right-5, y + height/2 + 0.5);
    
    p.setPen(fore);
    p.drawText(nodetail_rect, Qt::AlignCenter | Qt::AlignVCenter, info);
}

void DecodeTrace::draw_instant(const Annotation &a, QPainter &p,
    QColor fill, QColor outline, QColor text_color, int h, double x, int y, double min_annWidth)
{
    (void)outline;

	const QString text = a.annotations().empty() ?
		QString() : a.annotations().back();
//	const double w = min((double)p.boundingRect(QRectF(), 0, text).width(),
//		0.0) + h;
    const double w = min(min_annWidth, (double)h);
	const QRectF rect(x - w / 2, y - h / 2, w, h);

    //p.setPen(outline);
    p.setPen(QPen(Qt::NoPen));
	p.setBrush(fill);
	p.drawRoundedRect(rect, h / 2, h / 2);

	p.setPen(text_color);
	p.drawText(rect, Qt::AlignCenter | Qt::AlignVCenter, text);
}

void DecodeTrace::draw_range(const Annotation &a, QPainter &p,
	QColor fill, QColor outline, QColor text_color, int h, double start,
    double end, int y, QColor fore, QColor back)
{
    (void)fore;

	const double top = y + .5 - h / 2;
	const double bottom = y + .5 + h / 2;
	const std::vector<QString> annotations = a.annotations();

    p.setPen(outline);
    p.setBrush(fill);

    // If the two ends are within 2 pixel, draw a vertical line
    if (start + 2.0 > end)
	{
		p.drawLine(QPointF(start, top), QPointF(start, bottom));
		return;
	}

    double cap_width = min((end - start) / 4, EndCapWidth);

	QPointF pts[] = {
		QPointF(start, y + .5f),
		QPointF(start + cap_width, top),
		QPointF(end - cap_width, top),
		QPointF(end, y + .5f),
		QPointF(end - cap_width, bottom),
		QPointF(start + cap_width, bottom)
	};

    p.setPen(back);
    p.drawConvexPolygon(pts, countof(pts));

	if (annotations.empty())
		return;

	QRectF rect(start + cap_width, y - h / 2,
		end - start - cap_width * 2, h);
	if (rect.width() <= 4)
		return;

	p.setPen(text_color);

	// Try to find an annotation that will fit
	QString best_annotation;
	int best_width = 0;

	for(auto &a : annotations) {
		const int w = p.boundingRect(QRectF(), 0, a).width();
		if (w <= rect.width() && w > best_width)
			best_annotation = a, best_width = w;
	}

	if (best_annotation.isEmpty())
		best_annotation = annotations.back();

    p.drawText(rect, Qt::AlignCenter, p.fontMetrics().elidedText(
        best_annotation, Qt::ElideRight, rect.width()));
}

void DecodeTrace::draw_error(QPainter &p, const QString &message,
	int left, int right)
{
	const int y = get_y();
    const int h = get_totalHeight();

    const QRectF text_rect(left, y - h/2 + 0.5, right - left, h);
    const QRectF bounding_rect = p.boundingRect(text_rect,
            Qt::AlignCenter, message);
    p.setPen(Qt::red);

    if (bounding_rect.width() < text_rect.width())
        p.drawText(text_rect, Qt::AlignCenter, L_S(STR_PAGE_DLG, S_ID(IDS_DLG_DECODETRACE_ERROR1), "Error:")+message);
    else
        p.drawText(text_rect, Qt::AlignCenter, L_S(STR_PAGE_DLG, S_ID(IDS_DLG_DECODETRACE_ERROR2), "Error: ..."));
}

void DecodeTrace::draw_unshown_row(QPainter &p, int y, int h, int left,
    int right, QString info, QColor fore, QColor back)
{
    (void)back;

    const QRectF unshown_rect(left, y - h/2 + 0.5, right - left, h);
    int info_left = unshown_rect.center().x() - p.boundingRect(QRectF(), 0, info).width();
    int info_right = unshown_rect.center().x() + p.boundingRect(QRectF(), 0, info).width();
    int height = p.boundingRect(QRectF(), 0, info).height();

    p.setPen(fore);
    p.drawLine(left, y, info_left, y);
    p.drawLine(info_right, y, right, y);
    p.drawLine(info_left, y, info_left+5, y - height/2 + 0.5);
    p.drawLine(info_left, y, info_left+5, y + height/2 + 0.5);
    p.drawLine(info_right, y, info_right-5, y - height/2 + 0.5);
    p.drawLine(info_right, y, info_right-5, y + height/2 + 0.5);

    p.setPen(fore);
    p.drawText(unshown_rect, Qt::AlignCenter | Qt::AlignVCenter, info);
}
  

void DecodeTrace::on_new_decode_data()
{
    decoded_progress(_decoder_stack->get_progress());

    if (_view && _view->session().is_stopped_status())
        _view->data_updated();
    if (_totalHeight/_view->get_signalHeight() != rows_size())
        _view->signals_changed(NULL);
}

int DecodeTrace::get_progress()
{
    return _decoder_stack->get_progress();
}

void DecodeTrace::on_decode_done()
{ 
    on_new_decode_data();
    _session->decode_done();
}
  
int DecodeTrace::rows_size()
{ 
    int size = 0;

    for(auto dec : _decoder_stack->stack()) {
        if (dec->shown()) {
            auto rows = _decoder_stack->get_rows_gshow();

            for (auto i = rows.begin(); i != rows.end(); i++) {
                Row _row = (*i).first;
                if (_row.decoder() == dec->decoder() &&
                    _decoder_stack->has_annotations((*i).first) &&
                    (*i).second)
                    size++;
            }
        } 
        else {
            size++;
        }
    }
    return size == 0 ? 1 : size;
}

void DecodeTrace::paint_type_options(QPainter &p, int right, const QPoint pt, QColor fore)
{
    (void)pt;

    int y = get_y();
    const QRectF group_index_rect = get_rect(CHNLREG, y, right);
    QString index_string;
    int last_index;
    p.setPen(QPen(fore, 1, Qt::DashLine));
    p.drawLine(group_index_rect.bottomLeft(), group_index_rect.bottomRight());
    std::list<int>::iterator i = _index_list.begin();
    last_index = (*i);
    index_string = QString::number(last_index);

    while (++i != _index_list.end()) {
        if ((*i) == last_index + 1 && index_string.indexOf("-") < 3 && index_string.indexOf("-") > 0)
            index_string.replace(QString::number(last_index), QString::number((*i)));
        else if ((*i) == last_index + 1)
            index_string = QString::number((*i)) + "-" + index_string;
        else
            index_string = QString::number((*i)) + "," + index_string;
        last_index = (*i);
    }
    
    p.setPen(fore);
    p.drawText(group_index_rect, Qt::AlignRight | Qt::AlignVCenter, index_string);
}

QRectF DecodeTrace::get_rect(DecodeSetRegions type, int y, int right)
{
    const QSizeF name_size(right - get_leftWidth() - get_rightWidth(), SquareWidth);

    if (type == CHNLREG)
        return QRectF(
            get_leftWidth() + name_size.width() + Margin,
            y - SquareWidth / 2,
            SquareWidth * SquareNum, SquareWidth);
    else
        return QRectF(0, 0, 0, 0);
}

void DecodeTrace::frame_ended()
{
    const uint64_t last_samples = _session->cur_samplelimits() - 1;

    if (_decode_start > last_samples) {
        _decode_start = 0;
        _decode_cursor1 = 0;
    }

    if (_decode_cursor2 == 0 ||
        _decode_end > last_samples) {
        _decode_end = last_samples;
        _decode_cursor2 = 0;
    }

    decoder()->frame_ended();

    for(auto dec : _decoder_stack->stack()) {
        dec->set_decode_region(_decode_start, _decode_end);
        dec->commit();
    }
}

void* DecodeTrace::get_key_handel()
{
    return _decoder_stack->get_key_handel();
}

//to show decoder's property setting dialog
bool DecodeTrace::create_popup(bool isnew)
{ 
    (void)isnew;
    
    int ret = false;  //setting have changed flag 

    while (true)
    {
        QWidget *top = AppControl::Instance()->GetTopWindow();
        dialogs::DecoderOptionsDlg dlg(top);
        dlg.set_cursor_range(_decode_cursor1, _decode_cursor2);
        dlg.load_options(this);

        int dlg_ret = dlg.exec();

        if (QDialog::Accepted == dlg_ret)
        {
            for(auto dec : _decoder_stack->stack())
            {
                if (dec->commit() || _decoder_stack->options_changed()) {
                    _decoder_stack->set_options_changed(true);
                    _decode_start = dec->decode_start();
                    _decode_end = dec->decode_end();
                    ret = true;
                }
            }

            dlg.get_cursor_range(_decode_cursor1, _decode_cursor2);
        }

        if (dlg.is_reload_form()){
            ret = false;
        }

        if (QDialog::Rejected == dlg_ret || dlg.is_reload_form() == false){
            break;
        }
    }
 
    return ret;
}

} // namespace view
} // namespace dsv
/****************************************************************************
** Meta object code from reading C++ file 'spectrumtrace.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "spectrumtrace.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'spectrumtrace.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPESpectrumTraceENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEviewSCOPESpectrumTraceENDCLASS = QtMocHelpers::stringData(
    "dsv::view::SpectrumTrace"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPESpectrumTraceENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[25];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEviewSCOPESpectrumTraceENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEviewSCOPESpectrumTraceENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEviewSCOPESpectrumTraceENDCLASS = {
    {
        QT_MOC_LITERAL(0, 24)   // "dsv::view::SpectrumTrace"
    },
    "dsv::view::SpectrumTrace"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEviewSCOPESpectrumTraceENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::view::SpectrumTrace::staticMetaObject = { {
    QMetaObject::SuperData::link<Trace::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEviewSCOPESpectrumTraceENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEviewSCOPESpectrumTraceENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEviewSCOPESpectrumTraceENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<SpectrumTrace, std::true_type>
    >,
    nullptr
} };

void dsv::view::SpectrumTrace::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *dsv::view::SpectrumTrace::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::view::SpectrumTrace::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEviewSCOPESpectrumTraceENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return Trace::qt_metacast(_clname);
}

int dsv::view::SpectrumTrace::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = Trace::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "logicsignal.h"
#include <libsigrokdecode.h>
#include <math.h>
#include "../data/logicsnapshot.h"
#include "view.h"
#include "../basedef.h"
#include "../log.h"
#include "../appcore/sigsession.h"

using namespace std;

namespace dsv {
namespace view {

//const float LogicSignal::Oversampling = 2.0f;
const float LogicSignal::Oversampling = 1.0f;
const int LogicSignal::StateHeight = 12;
const int LogicSignal::StateRound = 5;

LogicSignal::LogicSignal(data::LogicSnapshot *data,
                         sr_channel *probe) :
    Signal(probe),
    _data(data)
{
    _trig = NONTRIG; 
    _paint_align_sample_count = 0;
}

LogicSignal::LogicSignal(view::LogicSignal *s,
                         data::LogicSnapshot *data,
                         sr_channel *probe) :
    Signal(*s, probe),
    _data(data),
    _trig(s->get_trig())
{ 
    _paint_align_sample_count = 0;
}

LogicSignal::~LogicSignal()
{
    _cur_edges.clear();
    _cur_pulses.clear();
}

void LogicSignal::set_trig(int trig)
{
    if (trig > NONTRIG && trig <= EDGTRIG)
        _trig = (LogicSetRegions)trig;
    else
        _trig = NONTRIG;
}

bool LogicSignal::commit_trig()
{
    if (_trig == NONTRIG) {
        ds_trigger_probe_set(_index_list.front(), 'X', 'X');
        return false;
    } 
    else {
        ds_trigger_set_en(true);
        if (_trig == POSTRIG)
            ds_trigger_probe_set(_index_list.front(), 'R', 'X');
        else if (_trig == HIGTRIG)
            ds_trigger_probe_set(_index_list.front(), '1', 'X');
        else if (_trig == NEGTRIG)
            ds_trigger_probe_set(_index_list.front(), 'F', 'X');
        else if (_trig == LOWTRIG)
            ds_trigger_probe_set(_index_list.front(), '0', 'X');
        else if (_trig == EDGTRIG)
            ds_trigger_probe_set(_index_list.front(), 'C', 'X');
        return true;
    }
}

void LogicSignal::paint_mid(QPainter &p, int left, int right, QColor fore, QColor back)
{
    uint64_t end_align_sample = _data->get_ring_sample_count() - 1;
    paint_mid_align(p, left, right, fore, back, end_align_sample);
}

void LogicSignal::paint_mid_align_sample(QPainter &p, int left, int right, QColor fore, QColor back, uint64_t end_align_sample)
{
    paint_mid_align(p, left, right, fore, back, end_align_sample);
}

void LogicSignal::paint_mid_align(QPainter &p, int left, int right, QColor fore, QColor back, uint64_t end_align_sample)
{
	using dsv::view::View;

    (void)back;

	assert(_data);
    assert(_view);
	assert(right >= left);

    const int y = get_y() + _totalHeight * 0.5;
    const double scale = _view->scale();
    assert(scale > 0);
    const int64_t offset = _view->offset();

    const int high_offset = y - _totalHeight + 0.5f;
    const int low_offset = y + 0.5f;

    double samplerate = _data->samplerate();
    if (_data->empty() || samplerate == 0)
		return;
  
    if (!_data->has_data(_probe->index))
        return;

    if (end_align_sample >= _data->get_ring_sample_count())
        end_align_sample = _data->get_ring_sample_count() - 1;

    const int64_t last_sample = end_align_sample;
	const double samples_per_pixel = samplerate * scale;

    uint16_t width = right - left;
    const double start = offset * samples_per_pixel;
    const double end = (offset + width + 1) * samples_per_pixel;
    const uint64_t end_index = min(max((int64_t)floor(end), (int64_t)0), last_sample);
    const uint64_t start_index = max((uint64_t)floor(start), (uint64_t)0);
    
    if (start_index > end_index)
        return;

    width = min(width, (uint16_t)ceil((end_index + 1)/samples_per_pixel - offset));
    const uint16_t max_togs = width / TogMaxScale;

    const bool first_sample = _data->get_display_edges(_cur_pulses, _cur_edges,
                                                          start_index, end_index, width, max_togs,
                                                          offset,
                                                          samples_per_pixel, _probe->index);
    assert(_cur_pulses.size() >= width);

    int preX = 0;
    int preY = first_sample ? high_offset : low_offset;
    int x = preX;
    std::vector<QLine> wave_lines;
    
    if (_cur_edges.size() < max_togs) {
        std::vector<std::pair<uint16_t, bool>>::const_iterator i;
        for (i = _cur_edges.begin() + 1; i != _cur_edges.end() - 1; i++) {
            x = (*i).first;
            wave_lines.push_back(QLine(preX, preY, x, preY));
            wave_lines.push_back(QLine(x, high_offset, x, low_offset));
            preX = x;
            preY = (*i).second ? high_offset : low_offset;
        }
        x = (*i).first;
        wave_lines.push_back(QLine(preX, preY, x, preY));
    }
    else {
        std::vector<std::pair<bool, bool>>::const_iterator i = _cur_pulses.begin();
        while (i != _cur_pulses.end() - 1) {
            if ((*i).first) {
                wave_lines.push_back(QLine(preX, preY, x, preY));
                wave_lines.push_back(QLine(x, high_offset, x, low_offset));
                preX = x;
                preY = (*i).second ? high_offset : low_offset;
            }
            x++;
            i++;
        }
        wave_lines.push_back(QLine(preX, preY, x, preY));
    }

    p.setPen(_colour.isValid() ? _colour : fore);
    p.drawLines(wave_lines.data(), wave_lines.size());
}

void LogicSignal::paint_caps(QPainter &p, QLineF *const lines,
    std::vector< pair<uint64_t, bool> > &edges, bool level,
	double samples_per_pixel, double pixels_offset, float x_offset,
	float y_offset)
{
	QLineF *line = lines;

    uint64_t curX = 0;
    uint64_t nxtX = 0;
	for (std::vector<dsv::data::LogicSnapshot::EdgePair>::const_iterator i =
		edges.begin(); i != (edges.end() - 1); i++)
		if ((*i).second == level) {
            curX = ((*i).first / samples_per_pixel -
                    pixels_offset) + x_offset;
            nxtX = ((*(i+1)).first / samples_per_pixel -
                    pixels_offset) + x_offset;
            if (nxtX > curX)
                *line++ = QLineF(curX, y_offset, nxtX, y_offset);
		}

	p.drawLines(lines, line - lines);
}

void LogicSignal::paint_type_options(QPainter &p, int right, const QPoint pt, QColor fore)
{
    int y = get_y();
    const QRectF posTrig_rect  = get_rect(POSTRIG,  y, right);
    const QRectF higTrig_rect  = get_rect(HIGTRIG,  y, right);
    const QRectF negTrig_rect  = get_rect(NEGTRIG,  y, right);
    const QRectF lowTrig_rect  = get_rect(LOWTRIG,  y, right);
    const QRectF edgeTrig_rect = get_rect(EDGTRIG, y, right);

    p.setPen(Qt::NoPen);

    if (true)
    {   
        QColor color = View::Blue;

        if (session->is_loop_mode()){
            color = QColor(0x70, 0x70, 0x70,  255);
        }

        p.setBrush(posTrig_rect.contains(pt) ? color.lighter() :
                (_trig == POSTRIG) ? color : Qt::transparent);
        p.drawRect(posTrig_rect);
        p.setBrush(higTrig_rect.contains(pt) ? color.lighter() :
                (_trig == HIGTRIG) ? color : Qt::transparent);
        p.drawRect(higTrig_rect);
        p.setBrush(negTrig_rect.contains(pt) ? color.lighter() :
                (_trig == NEGTRIG) ? color : Qt::transparent);
        p.drawRect(negTrig_rect);
        p.setBrush(lowTrig_rect.contains(pt) ? color.lighter() :
                (_trig == LOWTRIG) ? color : Qt::transparent);
        p.drawRect(lowTrig_rect);
        p.setBrush(edgeTrig_rect.contains(pt) ? color.lighter() :
                (_trig == EDGTRIG) ? color : Qt::transparent);
        p.drawRect(edgeTrig_rect);
    }   

    p.setPen(QPen(fore, 1, Qt::DashLine));
    p.setBrush(Qt::transparent);
    p.drawLine(posTrig_rect.left(), posTrig_rect.bottom(),
               edgeTrig_rect.right(), edgeTrig_rect.bottom());

    p.setPen(QPen(fore, 2, Qt::SolidLine));
    p.setBrush(Qt::transparent);
    p.drawLine(posTrig_rect.left() + 5, posTrig_rect.bottom() - 5,
               posTrig_rect.center().x(), posTrig_rect.bottom() - 5);
    p.drawLine(posTrig_rect.center().x(), posTrig_rect.bottom() - 5,
               posTrig_rect.center().x(), posTrig_rect.top() + 5);
    p.drawLine(posTrig_rect.center().x(), posTrig_rect.top() + 5,
               posTrig_rect.right() - 5, posTrig_rect.top() + 5);

    p.drawLine(higTrig_rect.left() + 5, higTrig_rect.top() + 5,
               higTrig_rect.right() - 5, higTrig_rect.top() + 5);

    p.drawLine(negTrig_rect.left() + 5, negTrig_rect.top() + 5,
               negTrig_rect.center().x(), negTrig_rect.top() + 5);
    p.drawLine(negTrig_rect.center().x(), negTrig_rect.top() + 5,
               negTrig_rect.center().x(), negTrig_rect.bottom() - 5);
    p.drawLine(negTrig_rect.center().x(), negTrig_rect.bottom() - 5,
               negTrig_rect.right() - 5, negTrig_rect.bottom() - 5);

    p.drawLine(lowTrig_rect.left() + 5, lowTrig_rect.bottom() - 5,
               lowTrig_rect.right() - 5, lowTrig_rect.bottom() - 5);

    p.drawLine(edgeTrig_rect.left() + 5, edgeTrig_rect.top() + 5,
               edgeTrig_rect.center().x() - 2, edgeTrig_rect.top() + 5);
    p.drawLine(edgeTrig_rect.center().x() + 2 , edgeTrig_rect.top() + 5,
               edgeTrig_rect.right() - 5, edgeTrig_rect.top() + 5);
    p.drawLine(edgeTrig_rect.center().x(), edgeTrig_rect.top() + 7,
               edgeTrig_rect.center().x(), edgeTrig_rect.bottom() - 7);
    p.drawLine(edgeTrig_rect.left() + 5, edgeTrig_rect.bottom() - 5,
               edgeTrig_rect.center().x() - 2, edgeTrig_rect.bottom() - 5);
    p.drawLine(edgeTrig_rect.center().x() + 2, edgeTrig_rect.bottom() - 5,
               edgeTrig_rect.right() - 5, edgeTrig_rect.bottom() - 5);
}

bool LogicSignal::measure(const QPointF &p, uint64_t &index0, uint64_t &index1, uint64_t &index2)
{
    const float gap = abs(p.y() - get_y());
    if (gap < get_totalHeight() * 0.5) {

        if (_data->empty() || !_data->has_data(_probe->index))
            return false;

        const uint64_t end = _data->get_sample_count() - 1;
        uint64_t index = _data->samplerate() * _view->scale() * (_view->offset() + p.x());
        if (index > end)
            return false;

        bool sample = _data->get_sample(index, get_index());
        if (index == 0){
            index0 = index;
        }
        else {
            index--;
            if (_data->get_pre_edge(index, sample, 1, get_index()))
                index0 = index;
            else
                index0 = 0;
        }

        sample = _data->get_sample(index, get_index());
        index++;
        if (_data->get_nxt_edge(index, sample, end, 1, get_index())){
            index1 = index;
        }
        else {
            if (index0 == 0)
                return false;
            index1 = end + 1;
            index2 = 0;
            return true;
        }

        sample = _data->get_sample(index, get_index());
        index++;
        if (_data->get_nxt_edge(index, sample, end, 1, get_index()))
            index2 = index;
        else
            index2 = end + 1;

        return true;
    }
    return false;
}

bool LogicSignal::edge(const QPointF &p, uint64_t &index, int radius)
{
    uint64_t pre_index, nxt_index;
    const float gap = abs(p.y() - get_y());

    if (gap < get_totalHeight() * 0.5) {
        if (_data->empty() || !_data->has_data(_probe->index))
            return false;

        const uint64_t end = _data->get_sample_count() - 1;
        const double pos = _data->samplerate() * _view->scale() * (_view->offset() + p.x());
        index = floor(pos + 0.5);
        if (index > end)
            return false;

        bool sample = _data->get_sample(index, get_index());
        if (index == 0)
            pre_index = index;
        else {
            index--;
            if (_data->get_pre_edge(index, sample, 1, get_index()))
                pre_index = index;
            else
                pre_index = 0;
        }

        sample = _data->get_sample(index, get_index());
        index++;
        if (_data->get_nxt_edge(index, sample, end, 1, get_index()))
            nxt_index = index;
        else
            nxt_index = 0;

        if (pre_index == 0 || nxt_index == 0)
            return false;

        if (pos - pre_index > nxt_index - pos)
            index = nxt_index;
        else
            index = pre_index;

        if (radius > abs((index-pos) / _view->scale() / _data->samplerate()))
            return true;
    }
    return false;
}

bool LogicSignal::edges(const QPointF &p, uint64_t start, uint64_t &rising, uint64_t &falling)
{
    uint64_t end;
    const float gap = abs(p.y() - get_y());
    if (gap < get_totalHeight() * 0.5) {
        end = _data->samplerate() * _view->scale() * (_view->offset() + p.x());
        return edges(end, start, rising, falling);
    }
    return false;
}

bool LogicSignal::edges(uint64_t end, uint64_t start, uint64_t &rising, uint64_t &falling)
{  
    if (_data->empty() || !_data->has_data(_probe->index))
        return false;

    uint64_t index = min(start, end);
    const uint64_t sample_count = _data->get_sample_count();
    end = max(start, end);
    start = index;
    if (end > (sample_count - 1))
        return false;

    const int ch_index = get_index();
    bool sample = _data->get_sample(start, ch_index);

    rising = 0;
    falling = 0;
    do {
        if (_data->get_nxt_edge(index, sample, sample_count, 1, ch_index)) {
            if (index > end)
                break;
            rising += !sample;
            falling += sample;
            sample = !sample;
        } else {
            break;
        }
    } while(index <= end);

    return true;
}

bool LogicSignal::mouse_press(int right, const QPoint pt)
{
    int y = get_y();
    const QRectF posTrig = get_rect(POSTRIG, y, right);
    const QRectF higTrig = get_rect(HIGTRIG, y, right);
    const QRectF negTrig = get_rect(NEGTRIG, y, right);
    const QRectF lowTrig = get_rect(LOWTRIG, y, right);
    const QRectF edgeTrig = get_rect(EDGTRIG, y, right);

    if (posTrig.contains(pt))
        set_trig((_trig == POSTRIG) ? NONTRIG : POSTRIG);
    else if (higTrig.contains(pt))
        set_trig((_trig == HIGTRIG) ? NONTRIG : HIGTRIG);
    else if (negTrig.contains(pt))
        set_trig((_trig == NEGTRIG) ? NONTRIG : NEGTRIG);
    else if (lowTrig.contains(pt))
        set_trig((_trig == LOWTRIG) ? NONTRIG : LOWTRIG);
    else if (edgeTrig.contains(pt))
        set_trig((_trig == EDGTRIG) ? NONTRIG : EDGTRIG);
    else
        return false;

    return true;
}

QRectF LogicSignal::get_rect(LogicSetRegions type, int y, int right)
{
    const QSizeF name_size(right - get_leftWidth() - get_rightWidth(), SquareWidth);

    if (type == POSTRIG)
        return QRectF(
            get_leftWidth() + name_size.width() + Margin,
            y - SquareWidth / 2,
            SquareWidth, SquareWidth);
    else if (type == HIGTRIG)
        return QRectF(
            get_leftWidth() + name_size.width() + SquareWidth + Margin,
            y - SquareWidth / 2,
            SquareWidth, SquareWidth);
    else if (type == NEGTRIG)
        return QRectF(
            get_leftWidth() + name_size.width() + 2 * SquareWidth + Margin,
            y - SquareWidth / 2,
            SquareWidth, SquareWidth);
    else if (type == LOWTRIG)
        return QRectF(
            get_leftWidth() + name_size.width() + 3 * SquareWidth + Margin,
            y - SquareWidth / 2,
            SquareWidth, SquareWidth);
    else if (type == EDGTRIG)
        return QRectF(
            get_leftWidth() + name_size.width() + 4 * SquareWidth + Margin,
            y - SquareWidth / 2,
            SquareWidth, SquareWidth);
    else
        return QRectF(0, 0, 0, 0);
}


void LogicSignal::paint_mark(QPainter &p, int xstart, int xend, int type)
{
    const int ypos = get_y();
    const int msize = 3;
    p.setPen(p.brush().color());
    if (type == SRD_CHANNEL_SDATA) {
        p.drawEllipse(QPoint(xstart, ypos), msize, msize);
    } else if (type == SRD_CHANNEL_SCLK) {
        const QPoint triangle[] = {
            QPoint(xstart, ypos - 2),
            QPoint(xstart-1, ypos - 1),
            QPoint(xstart, ypos - 1),
            QPoint(xstart+1, ypos - 1),
            QPoint(xstart-2, ypos),
            QPoint(xstart-1, ypos),
            QPoint(xstart, ypos),
            QPoint(xstart+1, ypos),
            QPoint(xstart+2, ypos),
            QPoint(xstart-3, ypos + 1),
            QPoint(xstart-2, ypos + 1),
            QPoint(xstart-1, ypos + 1),
            QPoint(xstart, ypos + 1),
            QPoint(xstart+1, ypos + 1),
            QPoint(xstart+2, ypos + 1),
            QPoint(xstart+3, ypos + 1),
        };
        p.drawPoints(triangle, 16);
    } else if (type == SRD_CHANNEL_ADATA) {
        p.drawEllipse(QPoint((xstart+xend)/2, ypos), msize, msize);
    }
}

void LogicSignal::set_data(data::LogicSnapshot* data)
{
    assert(data);
    _data = data;
}

} // namespace view
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "ruler.h"
#include "cursor.h"
#include "view.h"
#include "viewport.h"
#include "../appcore/sigsession.h"
#include "dsosignal.h"
#include "../basedef.h"
#include <assert.h>
#include <math.h>
#include <limits.h>
#include <cmath>
#include <QMouseEvent>
#include <QPainter>
#include <QStyleOption>
#include "../appcore/appcontrol.h"
#include "../config/appconfig.h"
#include "../ui/fn.h"

using namespace std;
using namespace Qt;
using namespace dsv::config;

namespace dsv {
namespace view {

const int Ruler::MinorTickSubdivision = 4;
const int Ruler::ScaleUnits[3] = {1, 2, 5};
const int Ruler::MinPeriodScale = 10;

const QString Ruler::SIPrefixes[9] =
	{"f", "p", "n", QChar(0x03BC), "m", "", "k", "M", "G"};
const QString Ruler::FreqPrefixes[9] =
    {"P", "T", "G", "M", "K", "", "", "", ""};
const int Ruler::FirstSIPrefixPower = -15;
const int Ruler::pricision = 2;

const int Ruler::HoverArrowSize = 4;

const int Ruler::CursorSelWidth = 20;
const QColor Ruler::CursorColor[8] =
    {QColor(25, 189, 155, 200),
     QColor(46, 205, 113, 200),
     QColor(53, 152, 220, 200),
     QColor(154, 89, 181, 200),
     QColor(52, 73, 94, 200),
     QColor(242, 196, 15, 200),
     QColor(231, 126, 34, 200),
     QColor(232, 76, 61, 200)};

Ruler::Ruler(View &parent) :
	QWidget(&parent),
	_view(parent),
    _cursor_sel_visible(false),
    _cursor_go_visible(false),
    _cursor_sel_x(-1),
    _grabbed_marker(NULL),
    _hitCursor(false),
    _curs_moved(false)
{
	setMouseTracking(true);

	connect(&_view, SIGNAL(hover_point_changed()),
		this, SLOT(hover_point_changed()));
}

QString Ruler::format_freq(double period, unsigned precision)
{   
    if (period <= 0) {
        return View::Unknown_Str;
    } else {
        const int order = ceil(log10f(period));
        assert(order >= FirstSIPrefixPower);
        const int prefix = ceil((order - FirstSIPrefixPower) / 3.0f);
        const double multiplier = pow(10.0, max(-prefix * 3.0 - FirstSIPrefixPower, 0.0));

        /*
        QString s;
        QTextStream ts(&s);
        ts.setRealNumberPrecision(precision);
        ts << fixed << 1 / (period  * multiplier) <<
            FreqPrefixes[prefix] << "Hz";
        return s;
        */
       
        char buffer[20] = {0};
        char format[10] = {0};
        QString units = FreqPrefixes[prefix] + "Hz";
        sprintf(format, "%%.%df", (int)precision);       
        sprintf(buffer, format, 1 / (period * multiplier));
        strcat(buffer, units.toUtf8().data());
        return QString(buffer);
    }
}

QString Ruler::format_time(double t, int prefix,
    unsigned int precision)
{ 
    const double multiplier = pow(10.0, -prefix * 3 - FirstSIPrefixPower + 6.0);

    /*
	QString s;
	QTextStream ts(&s);
	ts.setRealNumberPrecision(precision);
    ts << fixed << forcesign << (t  * multiplier) / 1000000.0 <<
		SIPrefixes[prefix] << "s";
	return s;
    */

    char buffer[20] = {0};
    char format[10] = {0}; 
    QString units = SIPrefixes[prefix] + "s";
    double v = (t * multiplier) / 1000000.0;
    buffer[0] = v >= 0 ? '+' : '-';
    sprintf(format, "%%.%df", (int)precision);   
    sprintf(buffer + 1, format, v);
    strcat(buffer + 1, units.toUtf8().data());
    return QString(buffer);
}

QString Ruler::format_time(double t)
{
    return format_time(t, _cur_prefix);
}

QString Ruler::format_real_time(uint64_t delta_index, uint64_t sample_rate)
{
    uint64_t delta_time = std::pow(10, 12) / sample_rate * delta_index;

    if (delta_time == 0)
        return "0";

    int zero = 0;
    int prefix = (int)floor(log10(delta_time));
    while(delta_time == (delta_time/10*10)) {
        delta_time /= 10;
        zero++;
    }

    return format_time(delta_time / std::pow(10.0, 12-zero), prefix/3+1, prefix/3*3 > zero ? prefix/3*3 - zero : 0);
}

QString Ruler::format_real_freq(uint64_t delta_index, uint64_t sample_rate)
{
    const double delta_period = delta_index * 1.0 / sample_rate;
    return format_freq(delta_period);
}

TimeMarker* Ruler::get_grabbed_cursor()
{
    return _grabbed_marker;
}

void Ruler::set_grabbed_cursor(TimeMarker *grabbed_marker)
{
    _grabbed_marker = grabbed_marker;
    _grabbed_marker->set_grabbed(true);
}

void Ruler::rel_grabbed_cursor()
{
    if (_grabbed_marker) {
        _grabbed_marker->set_grabbed(false);
        _grabbed_marker = NULL;
    }
}

void Ruler::paintEvent(QPaintEvent*)
{   
    QStyleOption o;
    o.initFrom(this);
    QPainter p(this);
    style()->drawPrimitive(QStyle::PE_Widget, &o, &p, this);

    QFont font = p.font();
    float fSize = AppConfig::Instance().appOptions.fontSize;
    if (fSize > 10)
        fSize = 10;
    font.setPointSizeF(fSize);
    p.setFont(font);

    SigSession *session = AppControl::Instance()->GetSession();

    // Draw tick mark
    if (session->get_device()->get_work_mode() == DSO)
        draw_osc_tick_mark(p);
    else
        draw_logic_tick_mark(p);

    p.setRenderHint(QPainter::Antialiasing, true);
	// Draw the hover mark
	draw_hover_mark(p);

    // Draw cursor selection
    if (_cursor_sel_visible || _cursor_go_visible) {
        draw_cursor_sel(p);
    }

	p.end();
}

void Ruler::mouseMoveEvent(QMouseEvent *e)
{
    (void)e;

    if (_grabbed_marker) {
        int msx = _view.hover_point().x();
        if (msx < 0)
            msx = 0;   
        int body_width = _view.get_body_width();
        if (msx > body_width)
            msx = body_width;

        uint64_t index = _view.pixel2index(msx);
        _grabbed_marker->set_index(index);
        _view.cursor_moving();
        _curs_moved = true;
    }

    update();
    _view.viewport()->update();
}

void Ruler::leaveEvent(QEvent *)
{
    _cursor_sel_visible = false;
    _cursor_go_visible = false;
    update();
}

void Ruler::mousePressEvent(QMouseEvent *event)
{
    if (event->button() & Qt::LeftButton) {
        bool visible;
        auto &cursor_list = _view.get_cursorList();

        if (!_cursor_sel_visible && cursor_list.size()) {
            _view.show_cursors(true);
            auto i = cursor_list.begin();

            while (i != cursor_list.end()) {
                const QRect cursor_rect((*i)->get_label_rect(rect(), visible));
                if ((*i)->get_close_rect(cursor_rect).contains(event->pos())) {
                    _view.del_cursor(*i);

                    if (cursor_list.empty()) {
                        _cursor_sel_visible = false;
                        _view.show_cursors(false);
                    }
                    _hitCursor = true;
                    break;
                }

                if (cursor_rect.contains(event->pos())) {
                    set_grabbed_cursor(*i);
                    _cursor_sel_visible = false;
                    _cursor_go_visible = false;
                    _hitCursor = true;
                    break;
                }
                i++;
            }
        }
    }
}

void Ruler::mouseReleaseEvent(QMouseEvent *event)
{
    bool updatedCursor = false;

    if (event->button() & Qt::LeftButton) {
        if (!_hitCursor && !_grabbed_marker) {
            if (!_cursor_go_visible) {
                if (!_cursor_sel_visible) {
                    _cursor_sel_x = event->pos().x();
                    _cursor_sel_visible = true;                                    
                } 
                else {
                    int overCursor;
                    int msx = _cursor_sel_x;
                    if (msx < 0)
                        msx = 0;
                    
                    int body_width = _view.get_body_width();
                    if (msx > body_width)
                        msx = body_width;

                    auto &cursor_list = _view.get_cursorList();
                    uint64_t index = _view.pixel2index(_cursor_sel_x);
                    overCursor = in_cursor_sel_rect(event->pos());

                    if (overCursor == 0) {
                        _view.add_cursor(CursorColor[cursor_list.size() % 8], index);
                        _view.show_cursors(true);
                        updatedCursor = true;
                    }
                    else if (overCursor > 0) {
                        auto i = cursor_list.begin();

                        while (--overCursor != 0){
                            i++;
                        }

                        (*i)->set_index(index);
                        updatedCursor = true;
                        _view.cursor_moved();
                    }
                    _cursor_sel_visible = false;
                }
            } 
            else {
                int overCursor;
                overCursor = in_cursor_sel_rect(event->pos());
                if (overCursor > 0) {
                    _view.set_cursor_middle(overCursor - 1);
                }

                _cursor_go_visible = false;
            }
        }

        if (_curs_moved && _grabbed_marker) {
            rel_grabbed_cursor();
            _hitCursor = false;
            _curs_moved = false;
            _view.cursor_moved();
        }

        if (_hitCursor && !_grabbed_marker) {
            _hitCursor = false;
        }
    }

    if (event->button() & Qt::RightButton) {
        if (!_cursor_sel_visible) {
            if (!_cursor_go_visible) {
                _cursor_sel_x = event->pos().x();
                _cursor_go_visible = true;
            }
        } else {
            int overCursor;
            overCursor = in_cursor_sel_rect(event->pos());
            auto &cursor_list = _view.get_cursorList();

            if (overCursor > 0) {
                auto i = cursor_list.begin();

                while (--overCursor != 0){
                        i++;
                }

                _view.del_cursor(*i);
            }

            if (cursor_list.empty()) {
                _cursor_sel_visible = false;
                _view.show_cursors(false);
            }
        }
    }

    update();
    if (updatedCursor) {
        //const QRect reDrawRect = QRect(_cursor_sel_x - 1, 0, 3, _view.viewport()->height());
        //_view.viewport()->update(reDrawRect);
        _view.viewport()->update();
    }
}

void Ruler::draw_logic_tick_mark(QPainter &p)
{
    using namespace Qt;

    if (_view.session().get_device()->have_instance() == false){
        return;
    }

    const double SpacingIncrement = 32.0;
    const double MinValueSpacing = 16.0;
    const int ValueMargin = 5;
    const double abs_min_period = 10.0 / _view.session().cur_snap_samplerate();

    double min_width = SpacingIncrement;
    double typical_width;
    double tick_period = 0;
    double scale = _view.scale();
    int64_t offset = _view.offset();

    const uint64_t cur_period_scale = ceil((scale * min_width) / abs_min_period);

    // Find tick spacing, and number formatting that does not cause
    // value to collide.
    _min_period = cur_period_scale * abs_min_period;

    const int order = (int)floorf(log10f(scale * _view.get_view_width()));
    //const double order_decimal = pow(10, order);
    const unsigned int prefix = (order - FirstSIPrefixPower) / 3;
    _cur_prefix = prefix;
    assert(prefix < countof(SIPrefixes));
    typical_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
        AlignLeft | AlignTop, format_time(offset * scale,
        prefix)).width() + MinValueSpacing;
    do
    {
        tick_period += _min_period;

    } while(typical_width > tick_period / scale);

    const int text_height = p.boundingRect(0, 0, INT_MAX, INT_MAX,
        AlignLeft | AlignTop, "8").height();

    // Draw the tick marks
    QColor fore(QWidget::palette().color(QWidget::foregroundRole()));
    fore.setAlpha(View::ForeAlpha);
    p.setPen(fore);

    const double minor_tick_period = tick_period / MinPeriodScale;
    const int minor_order = (int)floorf(log10f(minor_tick_period));
    //const double minor_order_decimal = pow(10, minor_order);
    const unsigned int minor_prefix = (minor_order - FirstSIPrefixPower) / 3;
    assert(minor_prefix < countof(SIPrefixes));

    const double first_major_division =
        floor(offset * scale / tick_period);
    const double first_minor_division =
        floor(offset * scale / minor_tick_period + 1);
    const double t0 = first_major_division * tick_period;

    int division = (int)round(first_minor_division -
        first_major_division * MinPeriodScale) - 1;

    const int major_tick_y1 = text_height + ValueMargin * 3;
    const int tick_y2 = height();
    const int minor_tick_y1 = (major_tick_y1 + tick_y2) / 2;

    int x;

    const double inc_text_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
                                                 AlignLeft | AlignTop,
                                                 format_time(minor_tick_period,
                                                             minor_prefix)).width() + MinValueSpacing;
    do {
        const double t = t0 + division * minor_tick_period;
        const double major_t = t0 + floor(division / MinPeriodScale) * tick_period;

        x = t / scale - offset;

        if (division % MinPeriodScale == 0)
        {
            // Draw a major tick
            p.drawText(x, 2 * ValueMargin, 0, text_height,
                AlignCenter | AlignTop | TextDontClip,
                format_time(t, prefix));
            p.drawLine(QPoint(x, major_tick_y1),
                QPoint(x, tick_y2));
        }
        else
        {
            // Draw a minor tick
            if (minor_tick_period / scale > 2 * typical_width)
                p.drawText(x, 2 * ValueMargin, 0, text_height,
                    AlignCenter | AlignTop | TextDontClip,
                    format_time(t, prefix));
            //else if ((tick_period / scale > width() / 4) && (minor_tick_period / scale > inc_text_width))
            else if (minor_tick_period / scale > 1.1 * inc_text_width ||
                     tick_period / scale > _view.get_view_width())
                p.drawText(x, 2 * ValueMargin, 0, minor_tick_y1 + ValueMargin,
                    AlignCenter | AlignTop | TextDontClip,
                    format_time(t - major_t, minor_prefix));
            p.drawLine(QPoint(x, minor_tick_y1),
                QPoint(x, tick_y2));
        }

        division++;

    } while (x < rect().right());

    // Draw the cursors
    auto &cursor_list = _view.get_cursorList();

    if (cursor_list.size()) {
        auto i = cursor_list.begin();
        int index = 1;

        while (i != cursor_list.end()) {
            (*i)->paint_label(p, rect(), prefix, index, _view.session().is_stopped_status());
            index++;
            i++;
        }
    }

    if (_view.trig_cursor_shown()) {
        _view.get_trig_cursor()->paint_fix_label(p, rect(), prefix, 'T', _view.get_trig_cursor()->colour(), false);
    }
    if (_view.search_cursor_shown()) {
        _view.get_search_cursor()->paint_fix_label(p, rect(), prefix, 'S', _view.get_search_cursor()->colour(), true);
    }
}

void Ruler::draw_osc_tick_mark(QPainter &p)
{
    using namespace Qt;

    const double MinValueSpacing = 16.0;
    const int ValueMargin = 5;

    double typical_width;
    double tick_period = 0;
    double scale = _view.scale();
    int64_t offset = 0;

    // Find tick spacing, and number formatting that does not cause
    // value to collide.
    _min_period = _view.session().get_device()->get_time_base() * std::pow(10.0, -9.0);

    const int order = (int)floorf(log10f(scale * _view.get_view_width()));
    //const double order_decimal = pow(10, order);
    const unsigned int prefix = (order - FirstSIPrefixPower) / 3;
    _cur_prefix = prefix;
    assert(prefix < countof(SIPrefixes));
    typical_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
        AlignLeft | AlignTop, format_time(offset * scale,
        prefix)).width() + MinValueSpacing;
    do
    {
        tick_period += _min_period;

    } while(typical_width > tick_period / scale);

    const int text_height = p.boundingRect(0, 0, INT_MAX, INT_MAX,
        AlignLeft | AlignTop, "8").height();

    // Draw the tick marks
    QColor fore(QWidget::palette().color(QWidget::foregroundRole()));
    fore.setAlpha(View::ForeAlpha);
    p.setPen(fore);

    const double minor_tick_period = tick_period / MinPeriodScale;
    const int minor_order = (int)floorf(log10f(minor_tick_period));
    //const double minor_order_decimal = pow(10, minor_order);
    const unsigned int minor_prefix = (minor_order - FirstSIPrefixPower) / 3;
    assert(minor_prefix < countof(SIPrefixes));

    const double first_major_division =
        floor(offset * scale / tick_period);
    const double first_minor_division =
        floor(offset * scale / minor_tick_period + 1);
    const double t0 = first_major_division * tick_period;

    int division = (int)round(first_minor_division -
        first_major_division * MinPeriodScale) - 1;

    const int major_tick_y1 = text_height + ValueMargin * 3;
    const int tick_y2 = height();
    const int minor_tick_y1 = (major_tick_y1 + tick_y2) / 2;

    int x;

    const double inc_text_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
                                                 AlignLeft | AlignTop,
                                                 format_time(minor_tick_period,
                                                             minor_prefix)).width() + MinValueSpacing;
    do {
        const double t = t0 + division * minor_tick_period;
        const double major_t = t0 + floor(division / MinPeriodScale) * tick_period;

        x = t / scale - offset;

        if (division % MinPeriodScale == 0)
        {
            // Draw a major tick
            p.drawText(x, 2 * ValueMargin, 0, text_height,
                AlignCenter | AlignTop | TextDontClip,
                format_time(t, prefix));
            p.drawLine(QPoint(x, major_tick_y1), QPoint(x, tick_y2));
        }
        else
        {
            // Draw a minor tick
            if (minor_tick_period / scale > 2 * typical_width)
                p.drawText(x, 2 * ValueMargin, 0, text_height,
                    AlignCenter | AlignTop | TextDontClip,
                    format_time(t, prefix));
            //else if ((tick_period / scale > width() / 4) && (minor_tick_period / scale > inc_text_width))
            else if (minor_tick_period / scale > 1.1 * inc_text_width ||
                     tick_period / scale > _view.get_view_width())
                p.drawText(x, 2 * ValueMargin, 0, minor_tick_y1 + ValueMargin,
                    AlignCenter | AlignTop | TextDontClip,
                    format_time(t - major_t, minor_prefix));
            p.drawLine(QPoint(x, minor_tick_y1), QPoint(x, tick_y2));
        }

        division++;

    } while (x < rect().right());

    // Draw the cursors
    auto &cursor_list = _view.get_cursorList();

    if (!cursor_list.empty()) {
        auto i = cursor_list.begin();
        int index = 1;

        while (i != cursor_list.end()) {
            (*i)->paint_label(p, rect(), prefix, index, _view.session().is_stopped_status());
            index++;
            i++;
        }
    }
    
    if (_view.trig_cursor_shown()) {
        _view.get_trig_cursor()->paint_fix_label(p, rect(), prefix, 'T', _view.get_trig_cursor()->colour(), false);
    }
    if (_view.search_cursor_shown()) {
        _view.get_search_cursor()->paint_fix_label(p, rect(), prefix, 'S', _view.get_search_cursor()->colour(), true);
    }
}

void Ruler::draw_hover_mark(QPainter &p)
{
    const double x = _view.hover_point().x();

	if (x == -1 || _grabbed_marker)
		return;

    QColor fore(QWidget::palette().color(QWidget::foregroundRole()));
    p.setPen(fore);
    p.setBrush(fore);

	const int b = height() - 1;
    for (int i = 0; i < HoverArrowSize; i++)
        for (int j = -i; j <= i; j++)
            p.drawPoint(x-j, b-i);
}

void Ruler::draw_cursor_sel(QPainter &p)
{
    if (_cursor_sel_x == -1)
        return;

    p.setPen(QPen(Qt::NoPen));
    p.setBrush(View::Blue);

    const QPoint pos = QPoint(_view.hover_point().x(), _view.hover_point().y());
    if (in_cursor_sel_rect(pos) == 0)
        p.setBrush(View::Orange);

    const int y = height();
    const QRectF selRect = get_cursor_sel_rect(0);
    const QPointF del_points[] = {
        QPointF(_cursor_sel_x + CursorSelWidth / 2, (selRect.top() + CursorSelWidth / 2)),
        QPointF((selRect.left() + selRect.right()) / 2, selRect.top()),
        selRect.topLeft(),
        selRect.bottomLeft(),
        QPointF((selRect.left() + selRect.right()) / 2, selRect.bottom())
    };
    const QPointF points[] = {
        QPointF(_cursor_sel_x, y),
        selRect.bottomLeft(),
        selRect.topLeft(),
        selRect.topRight(),
        selRect.bottomRight()
    };
    p.drawPolygon((_cursor_go_visible ? del_points : points), countof(points));

    auto &cursor_list = _view.get_cursorList();

    if (!cursor_list.empty()) {
        int index = 1;
        auto i = cursor_list.begin();

        while (i != cursor_list.end()) {
            const QRectF cursorRect = get_cursor_sel_rect(index);
            p.setPen(QPen(Qt::black, 1, Qt::DotLine));
            p.drawLine(cursorRect.left(), cursorRect.top() + 3,
                       cursorRect.left(), cursorRect.bottom() - 3);
            p.setPen(QPen(Qt::NoPen));

            if (in_cursor_sel_rect(pos) == index)
                p.setBrush(View::Orange);
            else
                p.setBrush(CursorColor[(index - 1)%8]);

            p.drawRect(cursorRect);
            p.setPen(Qt::black);
            p.drawText(cursorRect, Qt::AlignCenter | Qt::AlignVCenter, QString::number(index));
            index++;
            i++;
        }
    }
}

int Ruler::in_cursor_sel_rect(QPointF pos)
{
    if (_cursor_sel_x == -1)
        return -1;

    auto &cursor_list = _view.get_cursorList();

    for (unsigned int i = 0; i < cursor_list.size() + 1; i++) {
        const QRectF cursorRect = get_cursor_sel_rect(i);
        if (cursorRect.contains(pos))
            return i;
    }

    return -1;
}

QRectF Ruler::get_cursor_sel_rect(int index)
{
    if (_cursor_sel_x == -1)
        return QRectF(-1, -1, 0, 0);
    const int y = height();
    return QRectF(_cursor_sel_x - (0.5 - index) * CursorSelWidth,
                  y - 1.3 * CursorSelWidth,
                  CursorSelWidth, CursorSelWidth);
}

void Ruler::hover_point_changed()
{
	update();
}

double Ruler::get_min_period()
{
    return _min_period / MinPeriodScale;
}

} // namespace view
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "cursor.h"
#include <QBrush>
#include <QPainter>
#include <QPointF>
#include <QRect>
#include <QRectF>
#include <assert.h>
#include <stdio.h>
#include "ruler.h"
#include "view.h"
#include "../basedef.h"
#include "../appcore/sigsession.h"

namespace dsv {
namespace view {

const QColor Cursor::LineColour(32, 74, 135);
const QColor Cursor::FillColour(52, 101, 164);
const QColor Cursor::HighlightColour(83, 130, 186);
const QColor Cursor::TextColour(Qt::white);

const int Cursor::Offset = 1;

const int Cursor::ArrowSize = 10;

const int Cursor::CloseSize = 10;

Cursor::Cursor(View &view, QColor color, uint64_t index) :
    TimeMarker(view, color, index),
    _other(*this)
{
}

QRect Cursor::get_label_rect(const QRect &rect, bool &visible, bool has_hoff)
{
    const double samples_per_pixel = _view.session().cur_snap_samplerate() * _view.scale();
    const double cur_offset = _index / samples_per_pixel;
    if (cur_offset < _view.offset() ||
        cur_offset > (_view.offset() + _view.width())) {
        visible = false;
        return QRect(-1, -1, 0, 0);
    }
    const int64_t x = _view.index2pixel(_index, has_hoff);

    const QSize label_size(
		_text_size.width() + View::LabelPadding.width() * 2,
		_text_size.height() + View::LabelPadding.height() * 2);
    const int top = rect.height() - label_size.height() -
		Cursor::Offset - Cursor::ArrowSize - 0.5f;
    const int height = label_size.height();

    visible = true;
    return QRect(x - label_size.width() / 2, top, label_size.width(), height);
}

QRect Cursor::get_close_rect(const QRect &rect)
{
    return QRect(rect.right() - CloseSize, rect.top(), CloseSize, CloseSize);
}

void Cursor::paint_label(QPainter &p, const QRect &rect,
    unsigned int prefix, int index, bool has_hoff)
{
    assert(index > 0);

    using dsv::view::Ruler;
    bool visible;

    compute_text_size(p, prefix);
    const QRect r(get_label_rect(rect, visible, has_hoff));
    if (!visible)
        return;
    const QRect close(get_close_rect(r));

    p.setPen(Qt::transparent);
    if (close.contains(QPoint(_view.hover_point().x(), _view.hover_point().y())))
        p.setBrush(Ruler::CursorColor[(index - 1) % 8]);
    else if (r.contains(QPoint(_view.hover_point().x(), _view.hover_point().y())))
        p.setBrush(View::Orange);
    else
        p.setBrush(Ruler::CursorColor[(index - 1) % 8]);
    p.drawRect(r);

    const QPoint points[] = {
        QPoint(r.left() + r.width() / 2 - ArrowSize, r.bottom()),
        QPoint(r.left() + r.width() / 2 + ArrowSize, r.bottom()),
        QPoint(r.left() + r.width() / 2, rect.bottom()),
    };
    p.drawPolygon(points, countof(points));

    if (close.contains(QPoint(_view.hover_point().x(), _view.hover_point().y())))
        p.setBrush(View::Red);
    else
        p.setBrush(View::Orange);
    p.drawRect(close);
    p.setPen(Qt::black);
    p.drawLine(close.left() + 2, close.top() + 2, close.right() - 2, close.bottom() - 2);
    p.drawLine(close.left() + 2, close.bottom() - 2, close.right() - 2, close.top() + 2);

	p.drawText(r, Qt::AlignCenter | Qt::AlignVCenter,
        Ruler::format_real_time(_index, _view.session().cur_snap_samplerate()));

    const QRect arrowRect = QRect(r.bottomLeft().x(), r.bottomLeft().y(), r.width(), ArrowSize);
    p.drawText(arrowRect, Qt::AlignCenter | Qt::AlignVCenter, QString::number(index));
}

void Cursor::paint_fix_label(QPainter &p, const QRect &rect,
    unsigned int prefix, QChar label, QColor color, bool has_hoff)
{
    using dsv::view::Ruler;
    bool visible;

    compute_text_size(p, prefix);
    const QRect r(get_label_rect(rect, visible, has_hoff));
    if (!visible)
        return;

    p.setPen(Qt::transparent);
    p.setBrush(color);
    p.drawRect(r);

    const QPoint points[] = {
        QPoint(r.left() + r.width() / 2 - ArrowSize, r.bottom()),
        QPoint(r.left() + r.width() / 2 + ArrowSize, r.bottom()),
        QPoint(r.left() + r.width() / 2, rect.bottom()),
    };
    p.drawPolygon(points, countof(points));

    p.setPen(Qt::white);
    if (has_hoff)
        p.drawText(r, Qt::AlignCenter | Qt::AlignVCenter,
            Ruler::format_real_time(_index, _view.session().cur_snap_samplerate()));

    const QRect arrowRect = QRect(r.bottomLeft().x(), r.bottomLeft().y(), r.width(), ArrowSize);
    p.drawText(arrowRect, Qt::AlignCenter | Qt::AlignVCenter, label);
}

void Cursor::compute_text_size(QPainter &p, unsigned int prefix)
{
    (void)prefix;
    _text_size = p.boundingRect(QRect(), 0,
        Ruler::format_real_time(_index, _view.session().cur_snap_samplerate())).size();
}
 
} // namespace view
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "timemarker.h"
#include <QPainter>
#include "view.h"
#include "ruler.h"

namespace dsv {
namespace view {

TimeMarker::TimeMarker(View &view, QColor &colour,
    uint64_t index) :
	_view(view),
    _index(index),
    _grabbed(false),
	_colour(colour)
{
}

TimeMarker::TimeMarker(const TimeMarker &s) :
	QObject(),
	_view(s._view),
    _index(s._index),
	_colour(s._colour)
{
}

QColor TimeMarker::colour()
{
    return _colour;
}

void TimeMarker::set_colour(QColor color)
{
    _colour = color;
}

bool TimeMarker::grabbed()
{
    return _grabbed;
}

void TimeMarker::set_grabbed(bool grabbed)
{
    _grabbed = grabbed;
}

uint64_t TimeMarker::index()
{
    return _index;
}

void TimeMarker::set_index(uint64_t index)
{
   _index = index;
    time_changed();
}

void TimeMarker::paint(QPainter &p, const QRect &rect, const bool highlight, int order, bool trig_hoff)
{
    const int64_t x = _view.index2pixel(_index, trig_hoff);
    if (x <= rect.right()) {
        QColor color = (order == -1) ? _colour : Ruler::CursorColor[order%8];
        p.setPen((_grabbed | highlight) ? QPen(color.lighter(), 2, Qt::DashLine) : QPen(color, 1, Qt::DashLine));
        p.drawLine(QPoint(x, 0), QPoint(x, rect.bottom()));
    }
}

} // namespace view
} // namespace dsv
/****************************************************************************
** Meta object code from reading C++ file 'view.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "view.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'view.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewENDCLASS = QtMocHelpers::stringData(
    "dsv::view::View",
    "hover_point_changed",
    "",
    "cursor_update",
    "xcursor_update",
    "cursor_moving",
    "cursor_moved",
    "measure_updated",
    "prgRate",
    "progress",
    "resize",
    "auto_trig",
    "index",
    "reload",
    "set_measure_en",
    "enable",
    "data_updated",
    "update_scale_offset",
    "show_region",
    "uint64_t",
    "start",
    "end",
    "keep",
    "hide_calibration",
    "status_clear",
    "repeat_unshow",
    "repeat_show",
    "timebase_changed",
    "vDial_updated",
    "update_hori_res",
    "header_updated",
    "receive_trigger",
    "trig_pos",
    "receive_end",
    "frame_began",
    "mode_changed",
    "h_scroll_value_changed",
    "value",
    "v_scroll_value_changed",
    "marker_time_changed",
    "on_traces_moved",
    "set_trig_pos",
    "percent",
    "show_calibration",
    "show_lissajous",
    "show",
    "on_measure_updated",
    "splitterMoved",
    "pos"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewENDCLASS_t {
    uint offsetsAndSizes[98];
    char stringdata0[16];
    char stringdata1[20];
    char stringdata2[1];
    char stringdata3[14];
    char stringdata4[15];
    char stringdata5[14];
    char stringdata6[13];
    char stringdata7[16];
    char stringdata8[8];
    char stringdata9[9];
    char stringdata10[7];
    char stringdata11[10];
    char stringdata12[6];
    char stringdata13[7];
    char stringdata14[15];
    char stringdata15[7];
    char stringdata16[13];
    char stringdata17[20];
    char stringdata18[12];
    char stringdata19[9];
    char stringdata20[6];
    char stringdata21[4];
    char stringdata22[5];
    char stringdata23[17];
    char stringdata24[13];
    char stringdata25[14];
    char stringdata26[12];
    char stringdata27[17];
    char stringdata28[14];
    char stringdata29[16];
    char stringdata30[15];
    char stringdata31[16];
    char stringdata32[9];
    char stringdata33[12];
    char stringdata34[12];
    char stringdata35[13];
    char stringdata36[23];
    char stringdata37[6];
    char stringdata38[23];
    char stringdata39[20];
    char stringdata40[16];
    char stringdata41[13];
    char stringdata42[8];
    char stringdata43[17];
    char stringdata44[15];
    char stringdata45[5];
    char stringdata46[19];
    char stringdata47[14];
    char stringdata48[4];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewENDCLASS = {
    {
        QT_MOC_LITERAL(0, 15),  // "dsv::view::View"
        QT_MOC_LITERAL(16, 19),  // "hover_point_changed"
        QT_MOC_LITERAL(36, 0),  // ""
        QT_MOC_LITERAL(37, 13),  // "cursor_update"
        QT_MOC_LITERAL(51, 14),  // "xcursor_update"
        QT_MOC_LITERAL(66, 13),  // "cursor_moving"
        QT_MOC_LITERAL(80, 12),  // "cursor_moved"
        QT_MOC_LITERAL(93, 15),  // "measure_updated"
        QT_MOC_LITERAL(109, 7),  // "prgRate"
        QT_MOC_LITERAL(117, 8),  // "progress"
        QT_MOC_LITERAL(126, 6),  // "resize"
        QT_MOC_LITERAL(133, 9),  // "auto_trig"
        QT_MOC_LITERAL(143, 5),  // "index"
        QT_MOC_LITERAL(149, 6),  // "reload"
        QT_MOC_LITERAL(156, 14),  // "set_measure_en"
        QT_MOC_LITERAL(171, 6),  // "enable"
        QT_MOC_LITERAL(178, 12),  // "data_updated"
        QT_MOC_LITERAL(191, 19),  // "update_scale_offset"
        QT_MOC_LITERAL(211, 11),  // "show_region"
        QT_MOC_LITERAL(223, 8),  // "uint64_t"
        QT_MOC_LITERAL(232, 5),  // "start"
        QT_MOC_LITERAL(238, 3),  // "end"
        QT_MOC_LITERAL(242, 4),  // "keep"
        QT_MOC_LITERAL(247, 16),  // "hide_calibration"
        QT_MOC_LITERAL(264, 12),  // "status_clear"
        QT_MOC_LITERAL(277, 13),  // "repeat_unshow"
        QT_MOC_LITERAL(291, 11),  // "repeat_show"
        QT_MOC_LITERAL(303, 16),  // "timebase_changed"
        QT_MOC_LITERAL(320, 13),  // "vDial_updated"
        QT_MOC_LITERAL(334, 15),  // "update_hori_res"
        QT_MOC_LITERAL(350, 14),  // "header_updated"
        QT_MOC_LITERAL(365, 15),  // "receive_trigger"
        QT_MOC_LITERAL(381, 8),  // "trig_pos"
        QT_MOC_LITERAL(390, 11),  // "receive_end"
        QT_MOC_LITERAL(402, 11),  // "frame_began"
        QT_MOC_LITERAL(414, 12),  // "mode_changed"
        QT_MOC_LITERAL(427, 22),  // "h_scroll_value_changed"
        QT_MOC_LITERAL(450, 5),  // "value"
        QT_MOC_LITERAL(456, 22),  // "v_scroll_value_changed"
        QT_MOC_LITERAL(479, 19),  // "marker_time_changed"
        QT_MOC_LITERAL(499, 15),  // "on_traces_moved"
        QT_MOC_LITERAL(515, 12),  // "set_trig_pos"
        QT_MOC_LITERAL(528, 7),  // "percent"
        QT_MOC_LITERAL(536, 16),  // "show_calibration"
        QT_MOC_LITERAL(553, 14),  // "show_lissajous"
        QT_MOC_LITERAL(568, 4),  // "show"
        QT_MOC_LITERAL(573, 18),  // "on_measure_updated"
        QT_MOC_LITERAL(592, 13),  // "splitterMoved"
        QT_MOC_LITERAL(606, 3)   // "pos"
    },
    "dsv::view::View",
    "hover_point_changed",
    "",
    "cursor_update",
    "xcursor_update",
    "cursor_moving",
    "cursor_moved",
    "measure_updated",
    "prgRate",
    "progress",
    "resize",
    "auto_trig",
    "index",
    "reload",
    "set_measure_en",
    "enable",
    "data_updated",
    "update_scale_offset",
    "show_region",
    "uint64_t",
    "start",
    "end",
    "keep",
    "hide_calibration",
    "status_clear",
    "repeat_unshow",
    "repeat_show",
    "timebase_changed",
    "vDial_updated",
    "update_hori_res",
    "header_updated",
    "receive_trigger",
    "trig_pos",
    "receive_end",
    "frame_began",
    "mode_changed",
    "h_scroll_value_changed",
    "value",
    "v_scroll_value_changed",
    "marker_time_changed",
    "on_traces_moved",
    "set_trig_pos",
    "percent",
    "show_calibration",
    "show_lissajous",
    "show",
    "on_measure_updated",
    "splitterMoved",
    "pos"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEviewSCOPEViewENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
      35,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       9,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,  224,    2, 0x06,    1 /* Public */,
       3,    0,  225,    2, 0x06,    2 /* Public */,
       4,    0,  226,    2, 0x06,    3 /* Public */,
       5,    0,  227,    2, 0x06,    4 /* Public */,
       6,    0,  228,    2, 0x06,    5 /* Public */,
       7,    0,  229,    2, 0x06,    6 /* Public */,
       8,    1,  230,    2, 0x06,    7 /* Public */,
      10,    0,  233,    2, 0x06,    9 /* Public */,
      11,    1,  234,    2, 0x06,   10 /* Public */,

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
      13,    0,  237,    2, 0x0a,   12 /* Public */,
      14,    1,  238,    2, 0x0a,   13 /* Public */,
      16,    0,  241,    2, 0x0a,   15 /* Public */,
      17,    0,  242,    2, 0x0a,   16 /* Public */,
      18,    3,  243,    2, 0x0a,   17 /* Public */,
      23,    0,  250,    2, 0x0a,   21 /* Public */,
      24,    0,  251,    2, 0x0a,   22 /* Public */,
      25,    0,  252,    2, 0x0a,   23 /* Public */,
      26,    0,  253,    2, 0x0a,   24 /* Public */,
      27,    0,  254,    2, 0x0a,   25 /* Public */,
      28,    0,  255,    2, 0x0a,   26 /* Public */,
      29,    0,  256,    2, 0x0a,   27 /* Public */,
      30,    0,  257,    2, 0x0a,   28 /* Public */,
      31,    1,  258,    2, 0x0a,   29 /* Public */,
      33,    0,  261,    2, 0x0a,   31 /* Public */,
      34,    0,  262,    2, 0x0a,   32 /* Public */,
      35,    0,  263,    2, 0x0a,   33 /* Public */,
      36,    1,  264,    2, 0x08,   34 /* Private */,
      38,    1,  267,    2, 0x08,   36 /* Private */,
      39,    0,  270,    2, 0x08,   38 /* Private */,
      40,    0,  271,    2, 0x08,   39 /* Private */,
      41,    1,  272,    2, 0x08,   40 /* Private */,
      43,    0,  275,    2, 0x08,   42 /* Private */,
      44,    1,  276,    2, 0x08,   43 /* Private */,
      46,    0,  279,    2, 0x08,   45 /* Private */,
      47,    2,  280,    2, 0x08,   46 /* Private */,

 // signals: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::Int,    9,
    QMetaType::Void,
    QMetaType::Void, QMetaType::Int,   12,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void, QMetaType::Int,   15,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, 0x80000000 | 19, 0x80000000 | 19, QMetaType::Bool,   20,   21,   22,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::ULongLong,   32,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::Int,   37,
    QMetaType::Void, QMetaType::Int,   37,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::Int,   42,
    QMetaType::Void,
    QMetaType::Void, QMetaType::Bool,   45,
    QMetaType::Void,
    QMetaType::Void, QMetaType::Int, QMetaType::Int,   48,   12,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::view::View::staticMetaObject = { {
    QMetaObject::SuperData::link<QScrollArea::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEviewSCOPEViewENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<View, std::true_type>,
        // method 'hover_point_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'cursor_update'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'xcursor_update'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'cursor_moving'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'cursor_moved'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'measure_updated'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'prgRate'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'resize'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'auto_trig'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'reload'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'set_measure_en'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'data_updated'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'update_scale_offset'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'show_region'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<uint64_t, std::false_type>,
        QtPrivate::TypeAndForceComplete<uint64_t, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>,
        // method 'hide_calibration'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'status_clear'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'repeat_unshow'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'repeat_show'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'timebase_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'vDial_updated'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'update_hori_res'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'header_updated'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'receive_trigger'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<quint64, std::false_type>,
        // method 'receive_end'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'frame_began'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'mode_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'h_scroll_value_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'v_scroll_value_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'marker_time_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_traces_moved'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'set_trig_pos'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'show_calibration'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'show_lissajous'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>,
        // method 'on_measure_updated'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'splitterMoved'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>
    >,
    nullptr
} };

void dsv::view::View::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<View *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->hover_point_changed(); break;
        case 1: _t->cursor_update(); break;
        case 2: _t->xcursor_update(); break;
        case 3: _t->cursor_moving(); break;
        case 4: _t->cursor_moved(); break;
        case 5: _t->measure_updated(); break;
        case 6: _t->prgRate((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 7: _t->resize(); break;
        case 8: _t->auto_trig((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 9: _t->reload(); break;
        case 10: _t->set_measure_en((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 11: _t->data_updated(); break;
        case 12: _t->update_scale_offset(); break;
        case 13: _t->show_region((*reinterpret_cast< std::add_pointer_t<uint64_t>>(_a[1])),(*reinterpret_cast< std::add_pointer_t<uint64_t>>(_a[2])),(*reinterpret_cast< std::add_pointer_t<bool>>(_a[3]))); break;
        case 14: _t->hide_calibration(); break;
        case 15: _t->status_clear(); break;
        case 16: _t->repeat_unshow(); break;
        case 17: _t->repeat_show(); break;
        case 18: _t->timebase_changed(); break;
        case 19: _t->vDial_updated(); break;
        case 20: _t->update_hori_res(); break;
        case 21: _t->header_updated(); break;
        case 22: _t->receive_trigger((*reinterpret_cast< std::add_pointer_t<quint64>>(_a[1]))); break;
        case 23: _t->receive_end(); break;
        case 24: _t->frame_began(); break;
        case 25: _t->mode_changed(); break;
        case 26: _t->h_scroll_value_changed((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 27: _t->v_scroll_value_changed((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 28: _t->marker_time_changed(); break;
        case 29: _t->on_traces_moved(); break;
        case 30: _t->set_trig_pos((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 31: _t->show_calibration(); break;
        case 32: _t->show_lissajous((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        case 33: _t->on_measure_updated(); break;
        case 34: _t->splitterMoved((*reinterpret_cast< std::add_pointer_t<int>>(_a[1])),(*reinterpret_cast< std::add_pointer_t<int>>(_a[2]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (View::*)();
            if (_t _q_method = &View::hover_point_changed; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (View::*)();
            if (_t _q_method = &View::cursor_update; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 1;
                return;
            }
        }
        {
            using _t = void (View::*)();
            if (_t _q_method = &View::xcursor_update; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 2;
                return;
            }
        }
        {
            using _t = void (View::*)();
            if (_t _q_method = &View::cursor_moving; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 3;
                return;
            }
        }
        {
            using _t = void (View::*)();
            if (_t _q_method = &View::cursor_moved; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 4;
                return;
            }
        }
        {
            using _t = void (View::*)();
            if (_t _q_method = &View::measure_updated; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 5;
                return;
            }
        }
        {
            using _t = void (View::*)(int );
            if (_t _q_method = &View::prgRate; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 6;
                return;
            }
        }
        {
            using _t = void (View::*)();
            if (_t _q_method = &View::resize; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 7;
                return;
            }
        }
        {
            using _t = void (View::*)(int );
            if (_t _q_method = &View::auto_trig; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 8;
                return;
            }
        }
    }
}

const QMetaObject *dsv::view::View::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::view::View::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEviewSCOPEViewENDCLASS.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "IFontForm"))
        return static_cast< IFontForm*>(this);
    return QScrollArea::qt_metacast(_clname);
}

int dsv::view::View::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QScrollArea::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 35)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 35;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 35)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 35;
    }
    return _id;
}

// SIGNAL 0
void dsv::view::View::hover_point_changed()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}

// SIGNAL 1
void dsv::view::View::cursor_update()
{
    QMetaObject::activate(this, &staticMetaObject, 1, nullptr);
}

// SIGNAL 2
void dsv::view::View::xcursor_update()
{
    QMetaObject::activate(this, &staticMetaObject, 2, nullptr);
}

// SIGNAL 3
void dsv::view::View::cursor_moving()
{
    QMetaObject::activate(this, &staticMetaObject, 3, nullptr);
}

// SIGNAL 4
void dsv::view::View::cursor_moved()
{
    QMetaObject::activate(this, &staticMetaObject, 4, nullptr);
}

// SIGNAL 5
void dsv::view::View::measure_updated()
{
    QMetaObject::activate(this, &staticMetaObject, 5, nullptr);
}

// SIGNAL 6
void dsv::view::View::prgRate(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 6, _a);
}

// SIGNAL 7
void dsv::view::View::resize()
{
    QMetaObject::activate(this, &staticMetaObject, 7, nullptr);
}

// SIGNAL 8
void dsv::view::View::auto_trig(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 8, _a);
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "viewport.h"
#include <QMouseEvent>
#include <QStyleOption>
#include <QPainterPath> 
#include <math.h>
#include <QWheelEvent>
#include "ruler.h"
#include "signal.h"
#include "dsosignal.h"
#include "logicsignal.h"
#include "analogsignal.h"
#include "spectrumtrace.h"
#include "../data/logicsnapshot.h"
#include "../appcore/sigsession.h"
#include "../dialogs/dsomeasure.h"
#include "decodetrace.h"
#include "../config/appconfig.h"
#include "../basedef.h"
#include "../appcore/appcontrol.h"
#include "../log.h" 
#include "../ui/langresource.h"
#include "../ui/fn.h"
#include "lissajoustrace.h"

using namespace std;
using namespace dsv::config;

namespace dsv {
namespace view {

const double Viewport::DragDamping = 1.05;
const double Viewport::MinorDragRateUp = 10;

Viewport::Viewport(View &parent, View_type type) :
    QWidget(&parent),
    _view(parent),
    _type(type),
    _need_update(false),
    _sample_received(0),
    _action_type(NO_ACTION),
    _measure_type(NO_MEASURE),
    _cur_sample(0),
    _nxt_sample(1),
    _cur_preX(0),
    _cur_aftX(1),
    _cur_midY(0),
    _hover_index(0),
    _hover_hit(false),
    _dso_xm_valid(false),
    _dso_ym_valid(false),
    _waiting_trig(0),
    _dso_trig_moved(false),
    _curs_moved(false),
    _xcurs_moved(false)
{
	setMouseTracking(true);
	setAutoFillBackground(true);
    setBackgroundRole(QPalette::Base);

    //setFixedSize(QSize(600, 400));
    _mm_width = View::Unknown_Str;
    _mm_period = View::Unknown_Str;
    _mm_freq = View::Unknown_Str;
    _mm_duty = View::Unknown_Str;
    _measure_en = true;
    _edge_hit = false;
    _transfer_started = false;
    _timer_cnt = 0;
    _clickX = 0;
    _sample_received = 0;
    _is_checked_trig = false;

    _lst_wait_tigger_time = high_resolution_clock::now();
    _tigger_wait_times = 0;

    // drag inertial
    _drag_strength = 0;
    _drag_timer.setSingleShot(true);
 
    _cmenu = new QMenu(this);
    QAction *yAction = _cmenu->addAction(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_ADD_Y_CURSOR), "Add Y-cursor"));
    QAction *xAction = _cmenu->addAction(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_ADD_X_CURSOR), "Add X-cursor"));
    _yAction = yAction;
    _xAction = xAction;
 
    setContextMenuPolicy(Qt::CustomContextMenu);
    this->update_font();

    connect(&_trigger_timer, SIGNAL(timeout()),this, SLOT(on_trigger_timer()));
    connect(&_drag_timer, SIGNAL(timeout()),this, SLOT(on_drag_timer())); 
    connect(yAction, SIGNAL(triggered(bool)), this, SLOT(add_cursor_y()));
    connect(xAction, SIGNAL(triggered(bool)), this, SLOT(add_cursor_x()));
    connect(this, SIGNAL(customContextMenuRequested(const QPoint&)),this, SLOT(show_contextmenu(const QPoint&)));
}

int Viewport::get_total_height()
{
	int h = 0;
    std::vector<Trace*> traces;
    _view.get_traces(_type, traces);

    for(auto t : traces) {
        h += (int)(t->get_totalHeight());
    }
    h += 2 * View::SignalMargin;

	return h;
}

QPoint Viewport::get_mouse_point()
{
    return _mouse_point;
}

bool Viewport::event(QEvent *event)
{
    if (event->type() == QEvent::NativeGesture)
        return gestureEvent(static_cast<QNativeGestureEvent*>(event));
    return QWidget::event(event);
}

void Viewport::paintEvent(QPaintEvent *event)
{
    (void)event; 

    doPaint();
}

void Viewport::doPaint()
{     
    using dsv::view::Signal;
   
    QStyleOption o;
    o.initFrom(this);
    QPainter p(this);
    style()->drawPrimitive(QStyle::PE_Widget, &o, &p, this);

    QFont font = p.font();
    float fSize = AppConfig::Instance().appOptions.fontSize;
    if (fSize > 10)
        fSize = 10;
    font.setPointSizeF(fSize);
    p.setFont(font);

    _view.session().check_update();
    QColor fore(QWidget::palette().color(QWidget::foregroundRole()));
    QColor back(QWidget::palette().color(QWidget::backgroundRole()));
    fore.setAlpha(View::ForeAlpha);
    _view.set_back(false);
  
    std::vector<Trace*> traces;
    _view.get_traces(_type, traces);

    for(auto t : traces){
        t->paint_back(p, 0, _view.get_view_width(), fore, back);
        if (_view.back_ready())
            break;
    } 

    int mode = _view.session().get_device()->get_work_mode();

    if (mode == LOGIC || _view.session().is_instant()) 
    {
        if (_view.session().is_init_status())
        {
            paintCursors(p);
        }
        else if (_view.session().is_stopped_status())
        {
            paintSignals(p, fore, back);
        }
        else if (_view.session().is_realtime_refresh())
        {  
            _view.session().have_new_realtime_refresh(false); // Try to reset refresh timer.

            if (_view.session().have_view_data() || _view.session().is_instant())
                paintSignals(p, fore, back);
            else
                paintProgress(p, fore, back);
        }
        else if (_view.session().is_running_status()){
            if (_view.session().is_repeat_mode())
            {
                paintSignals(p, fore, back);

                if (!_transfer_started){
                    bool triggered;
                    int captured_progress;
         
                    if (_view.session().get_capture_status(triggered, captured_progress)){
                        _view.show_captured_progress(triggered, captured_progress);
                    }
                }
            }
            else if (_type == TIME_VIEW) {
                _view.repeat_unshow();
                paintProgress(p, fore, back);
            }
        }     
    }
    else {
        paintSignals(p, fore, back);
    }

    for(auto t : traces){
        if (t->enabled())
            t->paint_fore(p, 0, _view.get_view_width(), fore, back);
    }

    if (_view.get_signalHeight() != _curSignalHeight)
            _curSignalHeight = _view.get_signalHeight();

	p.end();
}

void Viewport::paintCursors(QPainter &p)
{ 
    const QRect xrect = _view.get_view_rect();
    auto &cursor_list = _view.get_cursorList();

    if (_view.cursors_shown() && _type == TIME_VIEW) {
        auto i = cursor_list.begin();
        int index = 0;

        while (i != cursor_list.end()) {            
            const int64_t cursorX = _view.index2pixel((*i)->index());
            if (xrect.contains(_view.hover_point().x(), _view.hover_point().y()) &&
                    qAbs(cursorX - _view.hover_point().x()) <= HitCursorMargin)
                (*i)->paint(p, xrect, 1, index, _view.session().is_stopped_status());
            else
                (*i)->paint(p, xrect, 0, index, _view.session().is_stopped_status());
            i++;
            index++;
        }
    }
}

void Viewport::paintSignals(QPainter &p, QColor fore, QColor back)
{ 
    std::vector<Trace*> traces;
    _view.get_traces(_type, traces);

    if (_view.session().get_device()->get_work_mode() == LOGIC) 
    {
        bool bFirst = true;
        uint64_t end_align_sample;

        for(auto t : traces){
            if (t->enabled()){

                if (t->signal_type() == SR_CHANNEL_LOGIC)
                {
                    LogicSignal *logic_signal = (LogicSignal*)t;
                
                    if (bFirst)
                        end_align_sample = logic_signal->data()->get_ring_sample_count();
            
                    logic_signal->paint_mid_align_sample(p, 0, t->get_view_rect().right(), fore, back, end_align_sample);
                    bFirst = false;
                }
                else{
                    t->paint_mid(p, 0, t->get_view_rect().right(), fore, back);
                }               
            }                
        }
    } 
    else {
        if (_view.scale() != _curScale ||
            _view.offset() != _curOffset ||
            _view.get_signalHeight() != _curSignalHeight ||
            _need_update) {
            _curScale = _view.scale();
            _curOffset = _view.offset();
            _curSignalHeight = _view.get_signalHeight();

            _pixmap = QPixmap(size());
            _pixmap.fill(Qt::transparent);

            QPainter dbp(&_pixmap);

            bool isLissa = false;

            if (_view.session().get_device()->get_work_mode() == DSO)
            {
                auto lis_trace = _view.session().get_lissajous_trace();
                if (lis_trace && lis_trace->enabled()){
                    isLissa = true;
                }
            }
           
            for(auto t : traces)
            {
                if (t->enabled())
                {   
                    if (isLissa && t->signal_type() == SR_CHANNEL_DSO)
                        continue;
                    if (isLissa && t->signal_type() == SR_CHANNEL_MATH)
                        continue;
                    
                    t->paint_mid(dbp, 0, t->get_view_rect().right(), fore, back);
                }                    
            }
            _need_update = false;
        }
        p.drawPixmap(0, 0, _pixmap);
    }

    // plot cursors
    paintCursors(p);

    const QRect xrect = _view.get_view_rect();

    if (_view.xcursors_shown() && _type == TIME_VIEW) {
        auto &xcursor_list = _view.get_xcursorList();
        auto i = xcursor_list.begin();
        int index = 0;
        bool hovered = false;

        while (i != xcursor_list.end()) {
            const double cursorX  = xrect.left() + (*i)->value(XCursor::XCur_Y)*xrect.width();
            const double cursorY0 = xrect.top() + (*i)->value(XCursor::XCur_X0)*xrect.height();
            const double cursorY1 = xrect.top() + (*i)->value(XCursor::XCur_X1)*xrect.height();

            if (!hovered && ((*i)->get_close_rect(xrect).contains(_view.hover_point()) ||
                             (*i)->get_map_rect(xrect).contains(_view.hover_point()))) {
                (*i)->paint(p, xrect, XCursor::XCur_All, index);
                hovered = true;
            }
            else if(!hovered && xrect.contains(_view.hover_point())) {
                if (qAbs(cursorX - _view.hover_point().x()) <= HitCursorMargin &&
                    _view.hover_point().y() > min(cursorY0, cursorY1) &&
                    _view.hover_point().y() < max(cursorY0, cursorY1)) {
                    (*i)->paint(p, xrect, XCursor::XCur_Y, index);
                    hovered = true;
                }
                else if (qAbs(cursorY0 - _view.hover_point().y()) <= HitCursorMargin) {
                    (*i)->paint(p, xrect, XCursor::XCur_X0, index);
                    hovered = true;
                }
                else if (qAbs(cursorY1 - _view.hover_point().y()) <= HitCursorMargin) {
                    (*i)->paint(p, xrect, XCursor::XCur_X1, index);
                    hovered = true;
                }
                else {
                    (*i)->paint(p, xrect, XCursor::XCur_None, index);
                }
            }
            else {
                (*i)->paint(p, xrect, XCursor::XCur_None, index);
            }

            i++;
            index++;
        }
    }

    if (_type == TIME_VIEW) {
        if (_view.trig_cursor_shown()) {
            _view.get_trig_cursor()->paint(p, xrect, 0, -1, false);
        }
        if (_view.search_cursor_shown()) {
            const int64_t searchX = _view.index2pixel(_view.get_search_cursor()->index());
            if (xrect.contains(_view.hover_point().x(), _view.hover_point().y()) &&
                    qAbs(searchX - _view.hover_point().x()) <= HitCursorMargin)
                _view.get_search_cursor()->paint(p, xrect, 1, -1);
            else
                _view.get_search_cursor()->paint(p, xrect, 0, -1);
        }

        // plot zoom rect
        if (_action_type == LOGIC_ZOOM) {
            p.setPen(Qt::NoPen);
            p.setBrush(View::LightBlue);
            p.drawRect(QRectF(_mouse_down_point, _mouse_point));
        }

        //plot measure arrow
        paintMeasure(p, fore, back);

        //plot trigger information
        if (_view.session().get_device()->get_work_mode() == DSO
            && _view.session().is_running_status()) 
        {
            int type;
            bool roll = false;
            QString type_str="";
            bool ret = false;

            _view.session().get_device()->get_config_bool(SR_CONF_ROLL, roll);

            ret = _view.session().get_device()->get_config_byte(SR_CONF_TRIGGER_SOURCE, type);
            if (ret) {
                bool bDot = false;

                if (type == DSO_TRIGGER_AUTO && roll) {
                    type_str = L_S(STR_PAGE_DLG, S_ID(IDS_DLG_AUTO_ROLL), "Auto(Roll)");
                    
                    if (_view.session().is_instant()){
                        type_str += ", ";
                        type_str += L_S(STR_PAGE_DLG, S_ID(IDS_DLG_VIEW_CAPTURE), "Capturing");
                        bDot = true;
                    }
                } 
                else if (type == DSO_TRIGGER_AUTO && !_view.session().trigd()) {
                    type_str = L_S(STR_PAGE_DLG, S_ID(IDS_DLG_AUTO), "Auto");

                    if (_view.session().is_instant()){
                        type_str += ", ";
                        type_str += L_S(STR_PAGE_DLG, S_ID(IDS_DLG_VIEW_CAPTURE), "Capturing");
                        bDot = true;
                    }
                } 
                else if (_waiting_trig > 0) {
                    type_str = L_S(STR_PAGE_DLG, S_ID(IDS_DLG_WAITING_TRIG), "Waiting Trig"); 
                    bDot = true;
                } 
                else {
                    type_str = L_S(STR_PAGE_DLG, S_ID(IDS_DLG_TRIG_D), "Trig'd");
                }

                if (bDot)
                {
                    for (int i = 0; i < _tigger_wait_times; i++){
                        type_str += ".";
                    }

                    high_resolution_clock::time_point cur_time = high_resolution_clock::now();
                    milliseconds timeInterval = std::chrono::duration_cast<milliseconds>(cur_time - _lst_wait_tigger_time);
                    int64_t time_keep =  timeInterval.count();

                    if (time_keep >= 500){
                        _tigger_wait_times++;
                        _lst_wait_tigger_time = cur_time;
                    }

                    if (_tigger_wait_times > 4)
                        _tigger_wait_times = 0;
                }
            }
            p.setPen(fore);
            p.drawText(_view.get_view_rect(), Qt::AlignLeft | Qt::AlignTop, type_str);
        }
    }
}

void Viewport::get_captured_progress(double &progress, int &progress100)
{ 
    const uint64_t sample_limits = _view.session().cur_samplelimits();
    progress = -(_sample_received * 1.0 / sample_limits * 360 * 16);
    progress100 = ceil(progress / -3.6 / 16);
}

void Viewport::paintProgress(QPainter &p, QColor fore, QColor back)
{
    (void)back;

    if (_view.session().get_device()->get_work_mode() == LOGIC
        && _view.session().is_repeat_mode()){
        return;
    }

    using dsv::view::Signal;

    double progress = 0;
    int progress100 = 0;
    int captured_progress = 0;

    get_captured_progress(progress, progress100);
 
    p.setRenderHint(QPainter::Antialiasing, true);
    p.setPen(Qt::gray);
    p.setBrush(Qt::NoBrush);
    const QPoint cenPos = QPoint(_view.get_view_width() / 2, height() / 2);
    const int radius = min(0.3 * _view.get_view_width(), 0.3 * height());
    p.drawEllipse(cenPos, radius - 2, radius - 2);
    p.setPen(QPen(View::Green, 4, Qt::SolidLine));
    p.drawArc(cenPos.x() - radius, cenPos.y() - radius, 2* radius, 2 * radius, 180 * 16, progress);

    p.setPen(Qt::gray);

    const QPoint logoPoints[] = {
        QPoint(cenPos.x() - 0.75 * radius, cenPos.y()),
        QPoint(cenPos.x() - 0.75 * radius, cenPos.y() + 0.15 * radius),
        QPoint(cenPos.x() - 0.6 * radius, cenPos.y()),
        QPoint(cenPos.x() - 0.6 * radius, cenPos.y() + 0.3 * radius),
        QPoint(cenPos.x() - 0.45 * radius, cenPos.y()),
        QPoint(cenPos.x() - 0.45 * radius, cenPos.y() + 0.45 * radius),
        QPoint(cenPos.x() - 0.3 * radius, cenPos.y()),
        QPoint(cenPos.x() - 0.3 * radius, cenPos.y() + 0.3 * radius),
        QPoint(cenPos.x() - 0.15 * radius, cenPos.y()),
        QPoint(cenPos.x() - 0.15 * radius, cenPos.y() + 0.15 * radius),
        QPoint(cenPos.x() + 0.15 * radius, cenPos.y()),
        QPoint(cenPos.x() + 0.15 * radius, cenPos.y() - 0.15 * radius),
        QPoint(cenPos.x() + 0.3 * radius, cenPos.y()),
        QPoint(cenPos.x() + 0.3 * radius, cenPos.y() - 0.3 * radius),
        QPoint(cenPos.x() + 0.45 * radius, cenPos.y()),
        QPoint(cenPos.x() + 0.45 * radius, cenPos.y() - 0.45 * radius),
        QPoint(cenPos.x() + 0.6 * radius, cenPos.y()),
        QPoint(cenPos.x() + 0.6 * radius, cenPos.y() - 0.3 * radius),
        QPoint(cenPos.x() + 0.75 * radius, cenPos.y()),
        QPoint(cenPos.x() + 0.75 * radius, cenPos.y() - 0.15 * radius)
    };

    const int logoRadius = 10;
    p.drawLine(logoPoints[0], logoPoints[1]);
    p.drawLine(logoPoints[2], logoPoints[3]);
    p.drawLine(logoPoints[4], logoPoints[5]);
    p.drawLine(logoPoints[6], logoPoints[7]);
    p.drawLine(logoPoints[8], logoPoints[9]);
    p.drawLine(logoPoints[10], logoPoints[11]);
    p.drawLine(logoPoints[12], logoPoints[13]);
    p.drawLine(logoPoints[14], logoPoints[15]);
    p.drawLine(logoPoints[16], logoPoints[17]);
    p.drawLine(logoPoints[18], logoPoints[19]);
    p.drawEllipse(logoPoints[1].x() - 0.5 * logoRadius, logoPoints[1].y(),
            logoRadius, logoRadius);
    p.drawEllipse(logoPoints[3].x() - 0.5 * logoRadius, logoPoints[3].y(),
            logoRadius, logoRadius);
    p.drawEllipse(logoPoints[5].x() - 0.5 * logoRadius, logoPoints[5].y(),
            logoRadius, logoRadius);
    p.drawEllipse(logoPoints[7].x() - 0.5 * logoRadius, logoPoints[7].y(),
            logoRadius, logoRadius);
    p.drawEllipse(logoPoints[9].x() - 0.5 * logoRadius, logoPoints[9].y(),
            logoRadius, logoRadius);
    p.drawEllipse(logoPoints[11].x() - 0.5 * logoRadius, logoPoints[11].y() - logoRadius,
            logoRadius, logoRadius);
    p.drawEllipse(logoPoints[13].x() - 0.5 * logoRadius, logoPoints[13].y() - logoRadius,
            logoRadius, logoRadius);
    p.drawEllipse(logoPoints[15].x() - 0.5 * logoRadius, logoPoints[15].y() - logoRadius,
            logoRadius, logoRadius);
    p.drawEllipse(logoPoints[17].x() - 0.5 * logoRadius, logoPoints[17].y() - logoRadius,
            logoRadius, logoRadius);
    p.drawEllipse(logoPoints[19].x() - 0.5 * logoRadius, logoPoints[19].y() - logoRadius,
            logoRadius, logoRadius);

    if (!_transfer_started) {
        const int width = _view.get_view_width();
        const QPoint cenLeftPos = QPoint(width / 2 - 0.05 * width, height() / 2);
        const QPoint cenRightPos = QPoint(width / 2 + 0.05 * width, height() / 2);
        const int trigger_radius = min(0.02 * width, 0.02 * height());

        QColor foreBack = fore;
        foreBack.setAlpha(View::BackAlpha);
        p.setPen(Qt::NoPen);
        p.setBrush((_timer_cnt % 3) == 0 ? fore : foreBack);
        p.drawEllipse(cenLeftPos, trigger_radius, trigger_radius);
        p.setBrush((_timer_cnt % 3) == 1 ? fore : foreBack);
        p.drawEllipse(cenPos, trigger_radius, trigger_radius);
        p.setBrush((_timer_cnt % 3) == 2 ? fore : foreBack);
        p.drawEllipse(cenRightPos, trigger_radius, trigger_radius);

        bool triggered;
         
        if (_view.session().get_capture_status(triggered, captured_progress)){
            p.setPen(View::Blue); 

            QFont font = p.font();
            float fSize = AppConfig::Instance().appOptions.fontSize;
            if (fSize > 10)
                fSize = 10;
            font.setPointSizeF(fSize);
            p.setFont(font);

            QRect status_rect = QRect(cenPos.x() - radius, cenPos.y() + radius * 0.4, radius * 2, radius * 0.5);
            
            if (triggered) {
                p.drawText(status_rect,
                           Qt::AlignCenter | Qt::AlignVCenter,
                           L_S(STR_PAGE_DLG, S_ID(IDS_DLG_TRIGGERED), "Triggered! ") + QString::number(captured_progress) 
                           + L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CAPTURED), "% Captured"));
            }
            else {
                p.drawText(status_rect,
                           Qt::AlignCenter | Qt::AlignVCenter,
                           L_S(STR_PAGE_DLG, S_ID(IDS_DLG_WAITING_FOR_TRIGGER), "Waiting for Trigger! ") + QString::number(captured_progress) 
                           + L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CAPTURED), "% Captured"));
            }

            prgRate(captured_progress);
        }

    }
    else {         
        p.setPen(View::Green);
        QFont font=p.font();
        font.setPointSize(50);
        font.setBold(true);
        p.setFont(font);
        
        p.drawText(_view.get_view_rect(), Qt::AlignCenter | Qt::AlignVCenter, QString::number(progress100)+"%");
        prgRate(progress100);
    }

    p.setPen(QPen(View::Blue, 4, Qt::SolidLine));
    const int int_radius = max(radius - 4, 0);
    p.drawArc(cenPos.x() - int_radius, cenPos.y() - int_radius, 2* int_radius, 2 * int_radius, 180 * 16, -captured_progress*3.6*16);
    QFont font;
    p.setFont(font);

    p.setRenderHint(QPainter::Antialiasing, false);
}

void Viewport::mousePressEvent(QMouseEvent *event)
{
	assert(event);
    
    _clickX = event->globalPos().x();
	_mouse_down_point = event->pos();
	_mouse_down_offset = _view.offset();
    _drag_strength = 0;
    _elapsed_time.restart();

    if (_action_type == NO_ACTION
        && event->button() == Qt::RightButton
        && _view.session().is_stopped_status())
    {
        if (_view.session().get_device()->get_work_mode() == LOGIC) {
            _action_type = LOGIC_ZOOM;
        }
        else if (_view.session().get_device()->get_work_mode() == DSO) {
            if (_hover_hit) {
                const int64_t index = _view.pixel2index(event->pos().x());
                auto &cursor_list = _view.get_cursorList();
                _view.add_cursor(view::Ruler::CursorColor[cursor_list.size() % 8], index);
                _view.show_cursors(true);
            }
        }
    }
    if (_action_type == NO_ACTION &&
        event->button() == Qt::LeftButton &&
        _view.session().get_device()->get_work_mode() == DSO) {

       for(auto s : _view.session().get_signals()) 
       { 
            if (s->signal_type() == SR_CHANNEL_DSO && s->enabled()) {
                DsoSignal *dsoSig = (DsoSignal*)s;
                if (dsoSig->get_trig_rect(0, _view.get_view_width()).contains(_mouse_point)) {
                   _drag_sig = s;
                   _action_type = DSO_TRIG_MOVE;
                   dsoSig->select(true);
                   break;
                }
            }
        }
    }

    if (_action_type == NO_ACTION &&
        event->button() == Qt::LeftButton) {
        if (_action_type == NO_ACTION && _view.search_cursor_shown()) {
            const int64_t searchX = _view.index2pixel(_view.get_search_cursor()->index());
            if (_view.get_search_cursor()->grabbed()) {
                _view.get_ruler()->rel_grabbed_cursor();
            } else if (qAbs(searchX - event->pos().x()) <= HitCursorMargin) {
                _view.get_ruler()->set_grabbed_cursor(_view.get_search_cursor());
                _action_type = CURS_MOVE;
            }
        }
 
        if (_action_type == NO_ACTION && _view.cursors_shown()) {
            auto &cursor_list = _view.get_cursorList();
            auto i = cursor_list.begin();

            while (i != cursor_list.end()) {
                const int64_t cursorX = _view.index2pixel((*i)->index());
                if ((*i)->grabbed()) {
                    _view.get_ruler()->rel_grabbed_cursor();
                }
                else if (qAbs(cursorX - event->pos().x()) <= HitCursorMargin) {
                    _view.get_ruler()->set_grabbed_cursor(*i);
                    _action_type = CURS_MOVE;
                    break;
                }
                i++;
            }
        }

        if (_action_type == NO_ACTION && _view.xcursors_shown()) {
            auto &xcursor_list = _view.get_xcursorList();
            auto i = xcursor_list.begin();
            const QRect xrect = _view.get_view_rect();

            while (i != xcursor_list.end()) {
                const double cursorX  = xrect.left() + (*i)->value(XCursor::XCur_Y)*xrect.width();
                const double cursorY0 = xrect.top() + (*i)->value(XCursor::XCur_X0)*xrect.height();
                const double cursorY1 = xrect.top() + (*i)->value(XCursor::XCur_X1)*xrect.height();
                
                if ((*i)->get_close_rect(xrect).contains(_view.hover_point())) {
                    _view.del_xcursor(*i);
                    if (xcursor_list.empty())
                        _view.show_xcursors(false);
                    break;
                }
                else if ((*i)->get_map_rect(xrect).contains(_view.hover_point())) {
                    auto &sigs = _view.session().get_signals();
                    auto s = sigs.begin();
                    bool sig_looped = ((*i)->channel() == NULL);
                    bool no_dsoSig = true;

                    while (true) { 
                        if ((*s)->signal_type() == SR_CHANNEL_DSO && (*s)->enabled()) {
                            view::DsoSignal *dsoSig = (view::DsoSignal*)(*s);
                            no_dsoSig = false;
                            if (sig_looped) {
                                (*i)->set_channel(dsoSig);
                                break;
                            } else if (dsoSig == (*i)->channel()) {
                                sig_looped = true;
                            }
                        }

                        s++;
                        if (s == sigs.end()) {
                            if (no_dsoSig) {
                                (*i)->set_channel(NULL);
                                break;
                            }
                            sig_looped = true;
                            s = sigs.begin();
                        }
                    }
                    break;
                }else if ((*i)->grabbed() != XCursor::XCur_None) {
                    (*i)->set_grabbed((*i)->grabbed(), false);
                } else if (qAbs(cursorX - _view.hover_point().x()) <= HitCursorMargin &&
                           _view.hover_point().y() > min(cursorY0, cursorY1) &&
                           _view.hover_point().y() < max(cursorY0, cursorY1)) {
                    (*i)->set_grabbed(XCursor::XCur_Y, true);
                    _action_type = CURS_MOVE;
                    break;
                } else if (qAbs(cursorY0 - _view.hover_point().y()) <= HitCursorMargin) {
                    (*i)->set_grabbed(XCursor::XCur_X0, true);
                    _action_type = CURS_MOVE;
                    break;
                } else if (qAbs(cursorY1 - _view.hover_point().y()) <= HitCursorMargin) {
                    (*i)->set_grabbed(XCursor::XCur_X1, true);
                    _action_type = CURS_MOVE;
                    break;
                }
                i++;
            }
        }
    }
}

void Viewport::mouseMoveEvent(QMouseEvent *event)
{
	assert(event);
    _hover_hit = false;
    int mode = _view.session().get_device()->get_work_mode();

    if (event->buttons() & Qt::LeftButton) {
        if (_type == TIME_VIEW) {
            if (_action_type == NO_ACTION) {
                _view.set_scale_offset(_view.scale(),
                    _mouse_down_offset + (_mouse_down_point - event->pos()).x());
            }
            _drag_strength = (_mouse_down_point - event->pos()).x();
        }
        else if (_type == FFT_VIEW) {
            for(auto t: _view.session().get_spectrum_traces()) {
                if(t->enabled()) {
                    double delta = (_mouse_point - event->pos()).x();
                    t->set_offset(delta);
                    break;
                }
            }
        }
    }

    if (_type == TIME_VIEW) {
        if ((event->buttons() & Qt::LeftButton) ||
            !(event->buttons() | Qt::NoButton)) {
            if (_action_type == DSO_TRIG_MOVE) {
                if (_drag_sig && _drag_sig->signal_type() == SR_CHANNEL_DSO) {            
                    view::DsoSignal *dsoSig = (view::DsoSignal*)_drag_sig;
                    dsoSig->set_trig_vpos(event->pos().y());
                    _dso_trig_moved = true;
                }
            }
            
            if (_action_type == CURS_MOVE) {
                TimeMarker* grabbed_marker = _view.get_ruler()->get_grabbed_cursor();
                if (grabbed_marker) {
                    int curX = _view.hover_point().x();
                    uint64_t index0 = 0, index1 = 0, index2 = 0;
                    bool logic = false;

                   for(auto s : _view.session().get_signals()) {                     
                        if (mode == LOGIC && s->signal_type() == SR_CHANNEL_LOGIC) {
                            view::LogicSignal *logicSig = (view::LogicSignal*)s;
                            if (logicSig->measure(event->pos(), index0, index1, index2)) {
                                logic = true;
                                break;
                            }
                        }
                        if (mode == DSO && s->signal_type() == SR_CHANNEL_DSO) {
                            view::DsoSignal *dsoSig = (view::DsoSignal*)s;
                            curX = min(dsoSig->get_view_rect().right(), curX);
                            break;
                        }
                    }

                    const double pos = _view.pixel2index(curX);
                    const double pos_delta = pos - (uint64_t)pos;
                    const double curP = _view.index2pixel(index0);
                    const double curN = _view.index2pixel(index1);
                    if (logic && (curX - curP < SnapMinSpace || curN - curX < SnapMinSpace)) {
                        if (curX - curP < curN - curX)
                            grabbed_marker->set_index(index0);
                        else
                            grabbed_marker->set_index(index1);
                    } else if ( pos_delta < 0.5) {
                        grabbed_marker->set_index((uint64_t)floor(pos));
                    } else {
                        grabbed_marker->set_index((uint64_t)ceil(pos));
                    }

                    if (grabbed_marker == _view.get_search_cursor()) {
                        _view.set_search_pos(grabbed_marker->index(), false);
                    }

                    _view.cursor_moving();
                    _curs_moved = true;
                } else {
                    if (_view.xcursors_shown()) {
                        auto &xcursor_list = _view.get_xcursorList();
                        auto i = xcursor_list.begin();
                        const QRect xrect = _view.get_view_rect();

                        while (i != xcursor_list.end()) {
                            if ((*i)->grabbed() != XCursor::XCur_None) {
                                if ((*i)->grabbed() == XCursor::XCur_Y) {
                                    double rate = (_view.hover_point().x() - xrect.left()) * 1.0 / xrect.width();                                    
                                    (*i)->set_value((*i)->grabbed(), min(rate, 1.0));
                                }
                                else {
                                    int msy = _view.hover_point().y();
                                    int body_y = _view.get_body_height();
                                    if (msy > body_y)
                                        msy = body_y;
                                     
                                    double rate = (msy - xrect.top()) * 1.0 / xrect.height();
                                    (*i)->set_value((*i)->grabbed(), max(rate, 0.0));
                                }
                                _xcurs_moved = true;
                                break;
                            }
                            i++;
                        }
                    }
                }
            }
        }
        if (!(event->buttons() | Qt::NoButton)) {
            if (_action_type == DSO_XM_STEP1 || _action_type == DSO_XM_STEP2) {
                for(auto s : _view.session().get_signals()) {
                    if (!s->get_view_rect().contains(event->pos())) {
                        clear_dso_xm();
                    }
                    break;
                }
            }

            if (_action_type == DSO_YM)
                _dso_ym_end = event->pos().y();
        }
    }

    _mouse_point = event->pos();

    measure();
   
    update();
}

void Viewport::mouseReleaseEvent(QMouseEvent *event)
{
        assert(event);

        bool quickScroll = AppConfig::Instance().appOptions.quickScroll;
        bool isMaxWindow = AppControl::Instance()->TopWindowIsMaximized();
    
        if (_type != TIME_VIEW){
            update();
            return;
        }
  
        if ((_action_type == NO_ACTION) && (event->button() == Qt::LeftButton)) 
        {
            if (_view.session().get_device()->get_work_mode() == LOGIC
                && _view.session().is_stopped_status()) {
                //priority 1
                //try to quick scroll view...
                int curX = event->globalPos().x();
                int moveLong = ABS_VAL(curX - _clickX);                
                int maxWidth = this->geometry().width();
                float mvk = (float) moveLong / (float)maxWidth;

                if (quickScroll){
                    quickScroll = false; 
                    if (isMaxWindow && mvk > 0.4f){
                        quickScroll = true;
                    }
                    else if (!isMaxWindow && mvk > 0.25f){
                        quickScroll = true;
                    }
                }

                if (_action_type == NO_ACTION && quickScroll) {
                    const double strength = _drag_strength*DragTimerInterval*1.0/_elapsed_time.elapsed();
                    if (_elapsed_time.elapsed() < 200 &&
                        abs(_drag_strength) < MinorDragOffsetUp &&
                        abs(strength) > MinorDragRateUp) {
                        _drag_timer.start(DragTimerInterval);
                        _action_type = LOGIC_MOVE;
                    } else if (_elapsed_time.elapsed() < 200 &&
                               abs(strength) > DragTimerInterval) {
                        _drag_strength = strength * 5;
                        _drag_timer.start(DragTimerInterval);
                        _action_type = LOGIC_MOVE;
                    }
                }

                // priority 2
                if (_action_type == NO_ACTION) {
                    if (_mouse_down_point.x() == event->pos().x()) {
                        const auto &sigs = _view.session().get_signals();

                        for(auto s : sigs) { 
                            if (s->signal_type() == SR_CHANNEL_LOGIC) {
                                view::LogicSignal *logicSig = (view::LogicSignal*)s;
                                if (logicSig->edge(event->pos(), _edge_start, 10)) {
                                    _action_type = LOGIC_JUMP;
                                    _cur_preX = _view.index2pixel(_edge_start);
                                    _cur_preY = logicSig->get_y();
                                    _cur_preY_top = logicSig->get_y() - logicSig->get_totalHeight()/2 - 12;
                                    _cur_preY_bottom = logicSig->get_y() + logicSig->get_totalHeight()/2 + 2;
                                    _cur_aftX = _cur_preX;
                                    _cur_aftY = _cur_preY;
                                    break;
                                }
                            }
                        }
                    }
                }

                // priority 3
                if (_action_type == NO_ACTION) {
                    if (_mouse_down_point.x() == event->pos().x()) {
                        const auto  &sigs = _view.session().get_signals();

                        for(auto s : sigs) {
                            if (abs(event->pos().y() - s->get_y()) < _view.get_signalHeight()) {
                                _action_type = LOGIC_EDGE;
                                _edge_start = _view.pixel2index(event->pos().x());
                                break;
                            }
                        }
                    }
                }
            }
            else if (_view.session().get_device()->get_work_mode() == DSO) {
                // priority 0
                if (_action_type == NO_ACTION && _hover_hit) {
                    _action_type = DSO_YM;
                    _dso_ym_valid = true;
                    _dso_ym_sig_index = _hover_sig_index;
                    _dso_ym_sig_value = _hover_sig_value;
                    _dso_ym_index = _hover_index;
                    _dso_ym_start = event->pos().y();
                }
            }
        }
        else if (_action_type == DSO_YM) {
            if (event->button() == Qt::LeftButton) {
                _dso_ym_end = event->pos().y();
                _action_type = NO_ACTION;
            } else if (event->button() == Qt::RightButton) {
                _action_type = NO_ACTION;
                _dso_ym_valid = false;
            }
        }
        else if (_action_type == DSO_TRIG_MOVE) {
            if (_dso_trig_moved && event->button() == Qt::LeftButton) {
                _drag_sig = NULL;
                _action_type = NO_ACTION;
                _dso_trig_moved = false;

                std::vector<Trace*> traces;
                _view.get_traces(ALL_VIEW, traces);

                for(auto t : traces){
                     t->select(false);
                }                   
            }
        } 
        else if (_action_type == DSO_XM_STEP0) {
            if (event->button() == Qt::LeftButton) {
                _action_type = DSO_XM_STEP1;
                _dso_xm_valid = true;
            }
        }
        else if (_action_type == DSO_XM_STEP1) {
            if (event->button() == Qt::LeftButton) {
                _dso_xm_index[1] = _view.pixel2index(event->pos().x());
                const uint64_t max_index = max(_dso_xm_index[0], _dso_xm_index[1]);
                _dso_xm_index[0] = min(_dso_xm_index[0], _dso_xm_index[1]);
                _dso_xm_index[1] = max_index;

                _action_type = DSO_XM_STEP2;
            }
            else if (event->button() == Qt::RightButton) {
                clear_dso_xm();
                measure_updated();
            }
        }
        else if (_action_type == DSO_XM_STEP2) {
            if (event->button() == Qt::LeftButton) {
                _dso_xm_index[2] = _view.pixel2index(event->pos().x());
                uint64_t max_index = max(_dso_xm_index[1], _dso_xm_index[2]);
                _dso_xm_index[1] = min(_dso_xm_index[1], _dso_xm_index[2]);
                _dso_xm_index[2] = max_index;

                max_index = max(_dso_xm_index[0], _dso_xm_index[1]);
                _dso_xm_index[0] = min(_dso_xm_index[0], _dso_xm_index[1]);
                _dso_xm_index[1] = max_index;

                _action_type = NO_ACTION;
            }
            else if (event->button() == Qt::RightButton) {
                clear_dso_xm();
                measure_updated();
            }
        }
        else if (_action_type == CURS_MOVE) {
            if (_curs_moved && event->button() == Qt::LeftButton) {
                _action_type = NO_ACTION;
                _view.get_ruler()->rel_grabbed_cursor();
                _view.cursor_moved();
                _curs_moved = false;
            }
            if (_xcurs_moved && event->button() == Qt::LeftButton) {
                _action_type = NO_ACTION;
                auto &xcursor_list = _view.get_xcursorList();
                auto i = xcursor_list.begin();
                
                while (i != xcursor_list.end()) {
                    (*i)->rel_grabbed();
                    i++;
                }

                _xcurs_moved = false;
            }
        }
        else if (_action_type == LOGIC_EDGE) {
            _action_type = NO_ACTION;
            _edge_rising = 0;
            _edge_falling = 0;
        }
        else if (_action_type == LOGIC_JUMP) {
            _action_type = NO_ACTION;
            _edge_rising = 0;
            _edge_falling = 0;
            _edge_hit = false;
        }
        else if (_action_type == LOGIC_MOVE) {
            if (_mouse_down_point == event->pos()) {
                _drag_strength = 0;
                _drag_timer.stop();
                _action_type = NO_ACTION;
            }
            else {
                const double strength = _drag_strength*DragTimerInterval*1.0/_elapsed_time.elapsed();
                if (_elapsed_time.elapsed() < 200 &&
                    abs(_drag_strength) < MinorDragOffsetUp &&
                    abs(strength) > MinorDragRateUp) {
                    _drag_timer.start(DragTimerInterval);
                }
                else if (_elapsed_time.elapsed() < 200 &&
                           abs(strength) > DragTimerInterval) {
                    _drag_strength = strength * 5;
                    _drag_timer.start(DragTimerInterval);
                }
                else {
                    _drag_strength = 0;
                    _drag_timer.stop();
                    _action_type = NO_ACTION;
                }
            }
        }
        else if (_action_type == LOGIC_ZOOM) {
            if (event->pos().x() != _mouse_down_point.x()) {
                int64_t newOffset = _view.offset() + (min(event->pos().x(), _mouse_down_point.x()));
                const double newScale = max(min(_view.scale() * abs(event->pos().x() - _mouse_down_point.x()) / _view.get_view_width(),
                                                _view.get_maxscale()), _view.get_minscale());
                newOffset = floor(newOffset * (_view.scale() / newScale));
                if (newScale != _view.scale())
                    _view.set_scale_offset(newScale, newOffset);
            }
            _action_type = NO_ACTION;
        }
    
    update();
}

void Viewport::mouseDoubleClickEvent(QMouseEvent *event)
{
    assert (event);

    if (!_view.get_view_rect().contains(event->pos()))
        return;

    int mode = _view.session().get_device()->get_work_mode();

    if (mode == LOGIC)
    {
        if (event->button() == Qt::RightButton) {
            if (_view.scale() == _view.get_maxscale())
                _view.set_preScale_preOffset();
            else
                _view.set_scale_offset(_view.get_maxscale(), _view.get_min_offset());
        }
        else if (event->button() == Qt::LeftButton) {
            bool logic = false;
            uint64_t index;
            uint64_t index0 = 0, index1 = 0, index2 = 0;

            if (mode == LOGIC) {
                for(auto s : _view.session().get_signals()) {
                    if (s->signal_type() == SR_CHANNEL_LOGIC) {
                        view::LogicSignal *logicSig  = (view::LogicSignal*)s;
                        if (logicSig->measure(event->pos(), index0, index1, index2)) {
                            logic = true;
                            break;
                        }
                    }
                }
            }
            const double curX = event->pos().x();
            const double curP = _view.index2pixel(index0);
            const double curN = _view.index2pixel(index1);

            if (logic && (curX - curP < SnapMinSpace || curN - curX < SnapMinSpace)) {
                if (curX - curP < curN - curX)
                    index = index0;
                else
                    index = index1;
            }
            else {
                index = _view.pixel2index(curX);
            }

            auto &cursor_list = _view.get_cursorList();
            _view.add_cursor(view::Ruler::CursorColor[cursor_list.size() % 8], index);
            _view.show_cursors(true);
        }

        update();
    }
    else if (_view.session().get_device()->get_work_mode() == DSO
             && _view.session().is_init_status() == false
             && event->button() == Qt::LeftButton) {
        if (_dso_xm_valid) {
            clear_dso_xm();
            measure_updated();
        }
        else if (_action_type == NO_ACTION) {
            for(auto s : _view.session().get_signals()) {
                if (s->get_view_rect().contains(event->pos())) {
                    _dso_xm_index[0] = _view.pixel2index(event->pos().x());
                    _dso_xm_y = event->pos().y();
                    _action_type = DSO_XM_STEP0;
                }
                break;
            }
        }
    } else if (_view.session().get_device()->get_work_mode() == ANALOG) {
        if (event->button() == Qt::LeftButton) {
            uint64_t index;
            const double curX = event->pos().x();
            index = _view.pixel2index(curX);
            auto &cursor_list = _view.get_cursorList();
            _view.add_cursor(view::Ruler::CursorColor[cursor_list.size() % 8], index);
            _view.show_cursors(true);
        }
    }
}

void Viewport::wheelEvent(QWheelEvent *event)
{
    assert(event);

    int x = 0;  //mouse x pos
    int delta = 0;
    bool isVertical = true;

#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
    x = (int)event->position().x(); 
    int anglex = event->angleDelta().x();
    int angley = event->angleDelta().y();

    if (anglex == 0 || ABS_VAL(angley) >= ABS_VAL(anglex)){
        delta = angley;
        isVertical = true;
    }
    else{
        delta = anglex;
        isVertical = false; //hori direction
    }
#else
    x = event->x();
    delta = event->delta();
    isVertical = event->orientation() == Qt::Vertical;
#endif

    double zoom_scale = delta / 80;

    if (ABS_VAL(delta) <= 80){
        zoom_scale = delta > 0 ? 1.5 : -1.5;
    }

    if (_type == FFT_VIEW)
    {
        for (auto t : _view.session().get_spectrum_traces())
        { 
            if (t->enabled())
            {
                t->zoom(zoom_scale, x);
                break;
            }
        }
    }
    else if (_type == TIME_VIEW)
    {
        static bool bLstTime = false;

        if (isVertical)
        {
            // Vertical scrolling is interpreted as zooming in/out
#ifdef Q_OS_DARWIN
            static int64_t last_time;

            if (event->source() == Qt::MouseEventSynthesizedBySystem)
            {
                if (!bLstTime)
                {  
                    last_time = QDateTime::currentMSecsSinceEpoch();
                    bLstTime = true;
                }
                else{
                    int64_t cur_time = QDateTime::currentMSecsSinceEpoch();
                    if (cur_time - last_time > 50){
                        double scale = delta > 1.5 ? 1 : (delta < -1.5 ? -1 : 0);
                        _view.zoom(scale, x);
                        last_time = QDateTime::currentMSecsSinceEpoch();
                    }                   
                } 
            }
            else
            {
                _view.zoom(-zoom_scale, x);
            }
#else
            _view.zoom(zoom_scale, x);
#endif
        }
        else
        {   
            bLstTime = false;
            (void)bLstTime;

            // Horizontal scrolling is interpreted as moving left/right
            if (!(event->modifiers() & Qt::ShiftModifier))
                _view.set_scale_offset(_view.scale(), _view.offset() - delta);
        }
    }

    const auto &sigs = _view.session().get_signals();
    for (auto s : sigs)
    {
        if (s->signal_type() == SR_CHANNEL_DSO){   
            view::DsoSignal *dsoSig = (view::DsoSignal*)s;
            dsoSig->auto_end();
        }
    }

    measure();
}

bool Viewport::gestureEvent(QNativeGestureEvent *event)
{
    static double total_scale = 0;
    switch(event->gestureType()) {
        case Qt::BeginNativeGesture:
            break;
        case Qt::EndNativeGesture:
            total_scale = 0;
            break;
        case Qt::ZoomNativeGesture: {
            total_scale += event->value() * 2;
            if (_view.zoom(total_scale, _view.hover_point().x()))
                total_scale = 0;
            }
            break;
        case Qt::SmartZoomNativeGesture:
            _view.zoom(-1, _view.hover_point().x());
            break;
        default:
            return QWidget::event(event);
    }

    measure();
    return true;
}

void Viewport::leaveEvent(QEvent *)
{
    _mouse_point = QPoint(-1, -1);

    if (_action_type == LOGIC_EDGE) {
        _edge_rising = 0;
        _edge_falling = 0;
        _action_type = NO_ACTION;
    } else if (_action_type == LOGIC_JUMP) {
        _edge_rising = 0;
        _edge_falling = 0;
        _action_type = NO_ACTION;
    } else if (_action_type == LOGIC_MOVE) {
        _drag_strength = 0;
        _drag_timer.stop();
        _action_type = NO_ACTION;
    } else if (_action_type == DSO_XM_STEP1 || _action_type == DSO_XM_STEP2) {
        clear_dso_xm();
    } else if (_action_type == DSO_YM) {
        _dso_ym_valid = false;
        _action_type = NO_ACTION;
    }

    clear_measure();
}

void Viewport::resizeEvent(QResizeEvent*)
{

}

void Viewport::set_receive_len(quint64 length)
{
    if (length == 0) {
        _sample_received = 0;
        start_trigger_timer(333);
        _tigger_wait_times = 0;
        _is_checked_trig = false;
    }
    else {
        stop_trigger_timer();

        if (_sample_received + length > _view.session().cur_samplelimits())
            _sample_received = _view.session().cur_samplelimits();
        else
            _sample_received += length;
    }

    if (_view.session().get_device()->get_work_mode() == LOGIC)
    {   
        if (_view.session().get_device()->is_file() == false)
        {
            if (!_is_checked_trig && _view.session().is_triged()){
                _view.get_viewstatus()->set_trig_time(_view.session().get_trig_time());
                _view.get_viewstatus()->update();
                _is_checked_trig = true;
            }
        }

        if (_view.session().is_repeat_mode())
        {
            double progress = 0;
            int progress100 = 0;
            get_captured_progress(progress, progress100);
            _view.show_captured_progress(_transfer_started, progress100);

            if (_view.session().is_single_buffer()){
                if (_view.session().have_new_realtime_refresh(true) == false){
                    return;
                }
            }
            else{
                return;
            }
        }
        else if (_view.session().is_realtime_refresh())
        {
            if (_view.session().have_new_realtime_refresh(true) == false){
                return;
            }
        }      
    }

    // Received new data, and refresh the view.
    update();
}

void Viewport::clear_measure()
{
    _measure_type = NO_MEASURE;
    update();
}

void Viewport::clear_dso_xm()
{
    _dso_xm_valid = false;
    _mm_width = View::Unknown_Str;
    _mm_period = View::Unknown_Str;
    _mm_freq = View::Unknown_Str;
    _mm_duty = View::Unknown_Str;
    _action_type = NO_ACTION;
}

void Viewport::measure()
{
    if (_view.session().is_data_lock())
        return;
        
    if (_view.session().is_loop_mode() && _view.session().is_working())
        return;
        
    _measure_type = NO_MEASURE;
    if (_type == TIME_VIEW) {
        const uint64_t sample_rate = _view.session().cur_snap_samplerate();

        for(auto s : _view.session().get_signals()) {
            if (s->signal_type() == SR_CHANNEL_LOGIC) {
                view::LogicSignal *logicSig  = (view::LogicSignal*)s;
                if (_action_type == NO_ACTION) {
                    if (logicSig->measure(_mouse_point, _cur_sample, _nxt_sample, _thd_sample)) {
                        _measure_type = LOGIC_FREQ;

                        _mm_width = _view.get_ruler()->format_real_time(_nxt_sample - _cur_sample, sample_rate);
                        _mm_period = _thd_sample != 0 ? _view.get_ruler()->format_real_time(_thd_sample - _cur_sample, sample_rate) : View::Unknown_Str;
                        _mm_freq = _thd_sample != 0 ? _view.get_ruler()->format_real_freq(_thd_sample - _cur_sample, sample_rate) : View::Unknown_Str;

                        _cur_preX = _view.index2pixel(_cur_sample);
                        _cur_aftX = _view.index2pixel(_nxt_sample);
                        _cur_thdX = _view.index2pixel(_thd_sample);
                        _cur_midY = logicSig->get_y();

                        _mm_duty = _thd_sample != 0 ? QString::number((_nxt_sample - _cur_sample) * 100.0 / (_thd_sample - _cur_sample), 'f', 2)+"%" :
                                                     View::Unknown_Str;
                        break;
                    } else {
                        _measure_type = NO_MEASURE;
                        _mm_width = View::Unknown_Str;
                        _mm_period = View::Unknown_Str;
                        _mm_freq = View::Unknown_Str;
                        _mm_duty = View::Unknown_Str;
                    }
                } else if (_action_type == LOGIC_EDGE) {
                    if (logicSig->edges(_view.hover_point(), _edge_start, _edge_rising, _edge_falling)) {
                        _cur_preX = _view.index2pixel(_edge_start);
                        _cur_aftX = _view.hover_point().x();
                        _cur_midY = logicSig->get_y() - logicSig->get_totalHeight()/2 - 5;

                        _em_rising = L_S(STR_PAGE_DLG, S_ID(IDS_DLG_RISING), "Rising: ") + QString::number(_edge_rising);
                        _em_falling = L_S(STR_PAGE_DLG, S_ID(IDS_DLG_FALLING), "Falling: ") + QString::number(_edge_falling);
                        _em_edges = L_S(STR_PAGE_DLG, S_ID(IDS_DLG_Edges_1), "Edges: ") + QString::number(_edge_rising + _edge_falling);

                        break;
                    }
                } else if (_action_type == LOGIC_JUMP) {
                    if (logicSig->edge(_view.hover_point(), _edge_end, 10)) {
                        _cur_aftX = _view.index2pixel(_edge_end);
                        _cur_aftY = logicSig->get_y();
                        _edge_hit = true;
                        break;
                    } else {
                        _cur_preX = _view.index2pixel(_edge_start);
                        _cur_aftX = _view.hover_point().x();
                        _cur_aftY = _view.hover_point().y();
                        _edge_end = _view.pixel2index(_cur_aftX);
                        _edge_hit = false;
                    }
                }
            } 
            else if (s->signal_type() == SR_CHANNEL_DSO) {
                 view::DsoSignal *dsoSig = ( view::DsoSignal*)s;
                if (s->enabled()) {
                    if (_measure_en && dsoSig->measure(_view.hover_point())) {
                        _measure_type = DSO_VALUE;
                    }
                    else {
                        _measure_type = NO_MEASURE;
                    }
                }
            }
            else if (s->signal_type() == SR_CHANNEL_ANALOG) {
                view::AnalogSignal *analogSig = (view::AnalogSignal*)s;
                if (s->enabled()) {
                    if (_measure_en && analogSig->measure(_view.hover_point())) {
                        _measure_type = DSO_VALUE;
                    } else {
                        _measure_type = NO_MEASURE;
                    }
                }
            }
        }
        const auto mathTrace = _view.session().get_math_trace();
        if (mathTrace && mathTrace->enabled()) {
            if (_measure_en && mathTrace->measure(_view.hover_point())) {
                _measure_type = DSO_VALUE;
            } else {
                _measure_type = NO_MEASURE;
            }
        }
    }
    else if (_type == FFT_VIEW) {
        for(auto t : _view.session().get_spectrum_traces()) {
            if(t->enabled()) {
                t->measure(_mouse_point);
            }
        }
    }

    measure_updated();
}

void Viewport::paintMeasure(QPainter &p, QColor fore, QColor back)
{
    QColor active_color = back.black() > 0x80 ? View::Orange : View::Purple;
    _hover_hit = false;
    if (_action_type == NO_ACTION &&
        _measure_type == LOGIC_FREQ) {
        p.setPen(active_color);
        p.drawLine(QLineF(_cur_preX, _cur_midY, _cur_aftX, _cur_midY));
        p.drawLine(QLineF(_cur_preX, _cur_midY, _cur_preX + 2, _cur_midY - 2));
        p.drawLine(QLineF(_cur_preX, _cur_midY, _cur_preX + 2, _cur_midY + 2));
        p.drawLine(QLineF(_cur_aftX - 2, _cur_midY - 2, _cur_aftX, _cur_midY));
        p.drawLine(QLineF(_cur_aftX - 2, _cur_midY + 2, _cur_aftX, _cur_midY));
        if (_thd_sample != 0) {
            p.drawLine(QLineF(_cur_aftX, _cur_midY, _cur_thdX, _cur_midY));
            p.drawLine(QLineF(_cur_aftX, _cur_midY, _cur_aftX + 2, _cur_midY - 2));
            p.drawLine(QLineF(_cur_aftX, _cur_midY, _cur_aftX + 2, _cur_midY + 2));
            p.drawLine(QLineF(_cur_thdX - 2, _cur_midY - 2, _cur_thdX, _cur_midY));
            p.drawLine(QLineF(_cur_thdX - 2, _cur_midY + 2, _cur_thdX, _cur_midY));
        }

        if (_measure_en) {
            int typical_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
                Qt::AlignLeft | Qt::AlignTop, _mm_width).width();
            typical_width = max(typical_width, p.boundingRect(0, 0, INT_MAX, INT_MAX,
                Qt::AlignLeft | Qt::AlignTop, _mm_period).width());
            typical_width = max(typical_width, p.boundingRect(0, 0, INT_MAX, INT_MAX,
                Qt::AlignLeft | Qt::AlignTop, _mm_freq).width());
            typical_width = max(typical_width, p.boundingRect(0, 0, INT_MAX, INT_MAX,
                Qt::AlignLeft | Qt::AlignTop, _mm_duty).width());
            typical_width = typical_width + 100;

            const double width = _view.get_view_width();
            const double height = _view.viewport()->height();
            const double left = _view.hover_point().x();
            const double top = _view.hover_point().y();
            const double right = left + typical_width;
            const double bottom = top + 80;
            QPointF org_pos = QPointF(right > width ? left - typical_width : left, bottom > height ? top - 80 : top);
            QRectF measure_rect = QRectF(org_pos.x(), org_pos.y(), (double)typical_width, 80.0);
            QRectF measure1_rect = QRectF(org_pos.x(), org_pos.y(), (double)typical_width, 20.0);
            QRectF measure2_rect = QRectF(org_pos.x(), org_pos.y()+20, (double)typical_width, 20.0);
            QRectF measure3_rect = QRectF(org_pos.x(), org_pos.y()+40, (double)typical_width, 20.0);
            QRectF measure4_rect = QRectF(org_pos.x(), org_pos.y()+60, (double)typical_width, 20.0);

            p.setPen(Qt::NoPen);
            p.setBrush(View::LightBlue);
            p.drawRect(measure_rect);

            p.setPen(active_color);
            p.drawText(measure1_rect, Qt::AlignRight | Qt::AlignVCenter,
                       L_S(STR_PAGE_DLG, S_ID(IDS_DLG_WIDTH), "Width: ") + _mm_width);
            p.drawText(measure2_rect, Qt::AlignRight | Qt::AlignVCenter,
                       L_S(STR_PAGE_DLG, S_ID(IDS_DLG_PERIOD), "Period: ") + _mm_period);
            p.drawText(measure3_rect, Qt::AlignRight | Qt::AlignVCenter,
                       L_S(STR_PAGE_DLG, S_ID(IDS_DLG_FREQUENCY), "Frequency: ") + _mm_freq);
            p.drawText(measure4_rect, Qt::AlignRight | Qt::AlignVCenter,
                      L_S(STR_PAGE_DLG, S_ID(IDS_DLG_DUTY_CYCLE), "Duty Cycle: ") + _mm_duty);
        }
    } 

    if (_action_type == NO_ACTION &&
        _measure_type == DSO_VALUE) {

        for(auto s : _view.session().get_signals()) {
            if (s->signal_type() == SR_CHANNEL_DSO) {
                uint64_t index;
                double value;
                view::DsoSignal *dsoSig  = (view::DsoSignal*)s;
                QPointF hpoint;
                if (dsoSig->get_hover(index, hpoint, value)) {
                    p.setPen(QPen(fore, 1, Qt::DashLine));
                    p.setBrush(Qt::NoBrush);
                    p.drawLine(hpoint.x(), dsoSig->get_view_rect().top(),
                               hpoint.x(), dsoSig->get_view_rect().bottom());
                }
            } 
            else if (s->signal_type() == SR_CHANNEL_ANALOG) {
                uint64_t index;
                double value;
                QPointF hpoint;
                view::AnalogSignal* analogSig = (view::AnalogSignal*)s;
                if (analogSig->get_hover(index, hpoint, value)) {
                    p.setPen(QPen(fore, 1, Qt::DashLine));
                    p.setBrush(Qt::NoBrush);
                    p.drawLine(hpoint.x(), analogSig->get_view_rect().top(),
                               hpoint.x(), analogSig->get_view_rect().bottom());
                }
            }
        }
    }

    if (_dso_ym_valid) {
        for(auto s : _view.session().get_signals()) {          
            if (s->signal_type() == SR_CHANNEL_DSO) {
                view::DsoSignal *dsoSig = (view::DsoSignal*)s;
                if (dsoSig->get_index() == _dso_ym_sig_index) {
                    p.setPen(QPen(dsoSig->get_colour(), 1, Qt::DotLine));
                    const int text_height = p.boundingRect(0, 0, INT_MAX, INT_MAX,
                        Qt::AlignLeft | Qt::AlignTop, "W").height();
                    const int64_t x = _view.index2pixel(_dso_ym_index);
                    p.drawLine(x-10, _dso_ym_start,
                               x+10, _dso_ym_start);
                    p.drawLine(x, _dso_ym_start,
                               x, _dso_ym_end);
                    p.drawLine(0, _dso_ym_end,
                               _view.get_view_width(), _dso_ym_end);

                    // -- vertical delta value
                    double hrate = (_dso_ym_start - _dso_ym_end) * 1.0f / _view.get_view_height();
                    double value = hrate  * dsoSig->get_vDialValue() * dsoSig->get_factor() * DS_CONF_DSO_VDIVS;
                    QString value_str = abs(value) > 1000 ? QString::number(value/1000.0, 'f', 2) + "V" : QString::number(value, 'f', 2) + "mV";
                    int value_rect_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
                                                      Qt::AlignLeft | Qt::AlignVCenter, value_str).width();
                    p.drawText(QRect(x+10, abs(_dso_ym_start+_dso_ym_end)/2, value_rect_width, text_height),
                               value_str);

                    // -- start value
                    value_str = abs(_dso_ym_sig_value) > 1000 ? QString::number(_dso_ym_sig_value/1000.0, 'f', 2) + "V" : QString::number(_dso_ym_sig_value, 'f', 2) + "mV";
                    value_rect_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
                                                      Qt::AlignLeft | Qt::AlignVCenter, value_str).width();
                    int str_y = value > 0 ? _dso_ym_start : _dso_ym_start - text_height;
                    p.drawText(QRect(x-0.5*value_rect_width, str_y, value_rect_width, text_height),
                               value_str);

                    // -- end value
                    double end_value = _dso_ym_sig_value + value;
                    value_str = abs(end_value) > 1000 ? QString::number(end_value/1000.0, 'f', 2) + "V" : QString::number(end_value, 'f', 2) + "mV";
                    value_rect_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
                                                      Qt::AlignLeft | Qt::AlignVCenter, value_str).width();
                    str_y = value > 0 ? _dso_ym_end-text_height : _dso_ym_end;
                    p.drawText(QRect(x-0.5*value_rect_width, str_y, value_rect_width, text_height),
                               value_str);
                    break;
                }
            }
        }
    }

    if (_dso_xm_valid) {
        p.setPen(QPen(Qt::red, 1, Qt::DotLine));
        int measure_line_count = 6;
        const int text_height = p.boundingRect(0, 0, INT_MAX, INT_MAX,
            Qt::AlignLeft | Qt::AlignTop, "W").height();
        const uint64_t sample_rate = _view.session().cur_snap_samplerate();
        QLineF *line;
        QLineF *const measure_lines = new QLineF[measure_line_count];
        line = measure_lines;
        int64_t x[DsoMeasureStages];
        int dso_xm_stage = 0;
        if (_action_type == DSO_XM_STEP1)
            dso_xm_stage = 1;
        else if(_action_type == DSO_XM_STEP2)
            dso_xm_stage = 2;
        else
            dso_xm_stage = 3;

        for (int i = 0; i < dso_xm_stage; i++) {
            x[i] = _view.index2pixel(_dso_xm_index[i]);
        }
        measure_line_count = 0;
        if (dso_xm_stage > 0) {
            *line++ = QLine(x[0], _dso_xm_y - 10,
                           x[0], _dso_xm_y + 10);
            measure_line_count += 1;
        }
        if (dso_xm_stage > 1) {
            *line++ = QLine(x[1], _dso_xm_y - 10,
                           x[1], _dso_xm_y + 10);
            *line++ = QLine(x[0], _dso_xm_y,
                           x[1], _dso_xm_y);
            _mm_width = _view.get_ruler()->format_real_time(_dso_xm_index[1] - _dso_xm_index[0], sample_rate);

            // -- width show
            const QString w_ctr = "W="+_mm_width;
            int w_rect_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
                                              Qt::AlignLeft | Qt::AlignVCenter, w_ctr).width();
            p.drawText(QRect(x[0]+10, _dso_xm_y - text_height, w_rect_width, text_height), w_ctr);
            measure_line_count += 2;
        }
        if (dso_xm_stage > 2) {
            *line++ = QLineF(x[0], _dso_xm_y + 20,
                           x[0], _dso_xm_y + 40);
            *line++ = QLineF(x[0], _dso_xm_y + 30,
                           x[2], _dso_xm_y + 30);
            *line++ = QLineF(x[2], _dso_xm_y + 20,
                           x[2], _dso_xm_y + 40);
            _mm_period = _view.get_ruler()->format_real_time(_dso_xm_index[2] - _dso_xm_index[0], sample_rate);
            _mm_freq = _view.get_ruler()->format_real_freq(_dso_xm_index[2] - _dso_xm_index[0], sample_rate);
            _mm_duty = QString::number((_dso_xm_index[1] - _dso_xm_index[0]) * 100.0 / (_dso_xm_index[2] - _dso_xm_index[0]), 'f', 2)+"%";

            // -- period show
            const QString p_ctr = "P="+_mm_period;
            int p_rect_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
                                              Qt::AlignLeft | Qt::AlignVCenter, p_ctr).width();
            p.drawText(QRect(x[0]+10, _dso_xm_y + 30 - text_height, p_rect_width, text_height), p_ctr);

            // -- frequency show
            const QString f_ctr = "F="+_mm_freq;
            int f_rect_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
                                              Qt::AlignLeft | Qt::AlignVCenter, f_ctr).width();
            p.drawText(QRect(x[0]+20 + p_rect_width, _dso_xm_y + 30 - text_height, f_rect_width, text_height), f_ctr);

            // -- duty show
            const QString d_ctr = "D="+_mm_duty;
            int d_rect_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
                                              Qt::AlignLeft | Qt::AlignVCenter, d_ctr).width();
            p.drawText(QRect(x[1]+10, _dso_xm_y - 0.5*text_height, d_rect_width, text_height), d_ctr);

            measure_line_count += 3;
        }
        p.drawLines(measure_lines, measure_line_count);
        if (dso_xm_stage < DsoMeasureStages) {
            p.drawLine(x[dso_xm_stage-1], _dso_xm_y,
                       _mouse_point.x(), _dso_xm_y);
            p.drawLine(_mouse_point.x(), 0,
                       _mouse_point.x(), height());
        }
        measure_updated();
    }

    if (_action_type == LOGIC_EDGE && _view.session().have_view_data()) {
        p.setPen(active_color);
        p.drawLine(QLineF(_cur_preX, _cur_midY-5, _cur_preX, _cur_midY+5));
        p.drawLine(QLineF(_cur_aftX, _cur_midY-5, _cur_aftX, _cur_midY+5));
        p.drawLine(QLineF(_cur_preX, _cur_midY, _cur_aftX, _cur_midY));

        int typical_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
            Qt::AlignLeft | Qt::AlignTop, _em_edges).width();
        typical_width = max(typical_width, p.boundingRect(0, 0, INT_MAX, INT_MAX,
            Qt::AlignLeft | Qt::AlignTop, _em_rising).width());
        typical_width = max(typical_width, p.boundingRect(0, 0, INT_MAX, INT_MAX,
            Qt::AlignLeft | Qt::AlignTop, _em_falling).width());

        typical_width = typical_width + 60;

        const double width = _view.get_view_width();
        const double height = _view.viewport()->height();
        const double left = _view.hover_point().x();
        const double top = _view.hover_point().y();
        const double right = left + typical_width;
        const double bottom = top + 60;
        QPointF org_pos = QPointF(right > width ? left - typical_width : left, bottom > height ? top - 80 : top);
        QRectF measure_rect = QRectF(org_pos.x(), org_pos.y(), (double)typical_width, 60.0);
        QRectF measure1_rect = QRectF(org_pos.x(), org_pos.y(), (double)typical_width, 20.0);
        QRectF measure2_rect = QRectF(org_pos.x(), org_pos.y()+20, (double)typical_width, 20.0);
        QRectF measure3_rect = QRectF(org_pos.x(), org_pos.y()+40, (double)typical_width, 20.0);

        p.setPen(Qt::NoPen);
        p.setBrush(View::LightBlue);
        p.drawRect(measure_rect);

        p.setPen(active_color);
        p.drawText(measure1_rect, Qt::AlignRight | Qt::AlignVCenter, _em_edges);
        p.drawText(measure2_rect, Qt::AlignRight | Qt::AlignVCenter, _em_rising);
        p.drawText(measure3_rect, Qt::AlignRight | Qt::AlignVCenter, _em_falling);

    }

    if (_action_type == LOGIC_JUMP) {
        p.setPen(active_color);
        p.setBrush(Qt::NoBrush);
        const QPoint pre_points[] = {
            QPoint(_cur_preX, _cur_preY),
            QPoint(_cur_preX-1, _cur_preY-1),
            QPoint(_cur_preX+1, _cur_preY-1),
            QPoint(_cur_preX-1, _cur_preY+1),
            QPoint(_cur_preX+1, _cur_preY+1),
            QPoint(_cur_preX-2, _cur_preY-2),
            QPoint(_cur_preX+2, _cur_preY-2),
            QPoint(_cur_preX-2, _cur_preY+2),
            QPoint(_cur_preX+2, _cur_preY+2),
        };
        p.drawPoints(pre_points, countof(pre_points));
        if (abs(_cur_aftX - _cur_preX) + abs(_cur_aftY - _cur_preY) > 20) {
            if (_edge_hit) {
                const QPoint aft_points[] = {
                    QPoint(_cur_aftX, _cur_aftY),
                    QPoint(_cur_aftX-1, _cur_aftY-1),
                    QPoint(_cur_aftX+1, _cur_aftY-1),
                    QPoint(_cur_aftX-1, _cur_aftY+1),
                    QPoint(_cur_aftX+1, _cur_aftY+1),
                    QPoint(_cur_aftX-2, _cur_aftY-2),
                    QPoint(_cur_aftX+2, _cur_aftY-2),
                    QPoint(_cur_aftX-2, _cur_aftY+2),
                    QPoint(_cur_aftX+2, _cur_aftY+2),
                };
                p.drawPoints(aft_points, countof(aft_points));
            }
            int64_t delta = max(_edge_start, _edge_end) - min(_edge_start, _edge_end);
            QString delta_text = _view.get_index_delta(_edge_start, _edge_end) +
                                 "/" + QString::number(delta);
            QFontMetrics fm = this->fontMetrics();
           
            const int rectW = fm.boundingRect(delta_text).width() + 60;
            const int rectH = fm.height() + 10;
             
            const int rectY = (height() - _view.hover_point().y() < rectH + 20) ? _view.hover_point().y() - 10 - rectH : _view.hover_point().y() + 20;
            const int rectX = (width() - _view.hover_point().x() < rectW) ? _view.hover_point().x() - rectW : _view.hover_point().x();
            QRectF jump_rect = QRectF(rectX, rectY, rectW, rectH);

            p.setPen(Qt::NoPen);
            p.setBrush(View::LightBlue);
            p.drawRect(jump_rect);

            p.setPen(active_color);
            p.setBrush(Qt::NoBrush);
            p.drawText(jump_rect, Qt::AlignCenter | Qt::AlignVCenter, delta_text);

            QPainterPath path(QPoint(_cur_preX, _cur_preY));
            QPoint c1((_cur_preX+_cur_aftX)/2, _cur_preY);
            QPoint c2((_cur_preX+_cur_aftX)/2, _cur_aftY);
            path.cubicTo(c1, c2, QPoint(_cur_aftX, _cur_aftY));
            p.drawPath(path);
        }
    }
}

QString Viewport::get_measure(QString option)
{
    if(option.compare("width") == 0)
        return _mm_width;
    else if (option.compare("period") == 0)
        return _mm_period;
    else if (option.compare("frequency") == 0)
        return _mm_freq;
    else if (option.compare("duty") == 0)
        return _mm_duty;
    else
        return View::Unknown_Str;
}

void Viewport::set_measure_en(int enable)
{
    if (enable == 0)
        _measure_en = false;
    else
        _measure_en = true;
}

void Viewport::start_trigger_timer(int msec)
{
    assert(msec > 0);
    _transfer_started = false;
    _timer_cnt = 0;
    _trigger_timer.start(msec);
}

void Viewport::stop_trigger_timer()
{
    _transfer_started = true;
    _timer_cnt = 0;
    _trigger_timer.stop();
}

void Viewport::on_trigger_timer()
{
    _timer_cnt++;

    if (!_is_checked_trig)
    {
        if (_view.session().get_device()->get_work_mode() == LOGIC
            && _view.session().get_device()->is_file() == false)
        {
            if (_view.session().is_triged()){
                _is_checked_trig = true;
                _view.get_viewstatus()->set_trig_time(_view.session().get_trig_time());
                _view.get_viewstatus()->update();
            }
        }
        else{
            _is_checked_trig = true;
        }
    }

    update();  // To refresh the trigger status information.
}

void Viewport::on_drag_timer()
{   
    const int64_t offset = _view.offset();
    const double scale = _view.scale();

    if (_view.session().is_stopped_status()
        && _drag_strength != 0
        && offset < _view.get_max_offset()
        && offset > _view.get_min_offset()) 
    {
        _view.set_scale_offset(scale, offset + _drag_strength);
        _drag_strength /= DragDamping;
        if (_drag_strength != 0)
            _drag_timer.start(DragTimerInterval);
    }
    else if (offset == _view.get_max_offset() ||
             offset == _view.get_min_offset()) {
        _drag_strength = 0;
        _drag_timer.stop();
        _action_type = NO_ACTION;
    }
    else if (_action_type == NO_ACTION){
        _drag_strength = 0;
        _drag_timer.stop();
    }
}

void Viewport::set_need_update(bool update)
{
    _need_update = update;
}

void Viewport::show_wait_trigger()
{
    _waiting_trig %= (WaitLoopTime / SigSession::FeedInterval) * 4;
    _waiting_trig++;
    update();
}

void Viewport::unshow_wait_trigger()
{   
    _waiting_trig = 0;
    update();
}

bool Viewport::get_dso_trig_moved()
{
    return _dso_trig_moved;
}

void Viewport::show_contextmenu(const QPoint& pos)
{
    if(_cmenu &&
       _view.session().get_device()->get_work_mode() == DSO)
    {
        _cur_preX = pos.x();
        _cur_preY = pos.y();
        _cmenu->exec(QCursor::pos());
    }
}

void Viewport::add_cursor_y()
{
    uint64_t index;
    //const double curX = _menu_pos.x();
    index = _view.pixel2index(_cur_preX);
    auto &cursor_list = _view.get_cursorList();
    _view.add_cursor(view::Ruler::CursorColor[cursor_list.size() % 8], index);
    _view.show_cursors(true);
}

void Viewport::add_cursor_x()
{
    double ypos = (_cur_preY - _view.get_view_rect().top()) * 1.0 / _view.get_view_height();
    auto &cursor_list = _view.get_cursorList();
    _view.add_xcursor(view::Ruler::CursorColor[cursor_list.size() % 8], ypos, ypos);
    _view.show_xcursors(true);
}

void Viewport::update_font()
{
    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
    _yAction->setFont(font);
    _xAction->setFont(font);
}

void Viewport::update_lang()
{
    _yAction->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_ADD_Y_CURSOR), "Add Y-cursor"));
    _xAction->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_ADD_X_CURSOR), "Add X-cursor"));
}

} // namespace view
} // namespace dsv
/****************************************************************************
** Meta object code from reading C++ file 'lissajoustrace.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "lissajoustrace.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'lissajoustrace.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPELissajousTraceENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEviewSCOPELissajousTraceENDCLASS = QtMocHelpers::stringData(
    "dsv::view::LissajousTrace"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPELissajousTraceENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[26];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEviewSCOPELissajousTraceENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEviewSCOPELissajousTraceENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEviewSCOPELissajousTraceENDCLASS = {
    {
        QT_MOC_LITERAL(0, 25)   // "dsv::view::LissajousTrace"
    },
    "dsv::view::LissajousTrace"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEviewSCOPELissajousTraceENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::view::LissajousTrace::staticMetaObject = { {
    QMetaObject::SuperData::link<Trace::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEviewSCOPELissajousTraceENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEviewSCOPELissajousTraceENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEviewSCOPELissajousTraceENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<LissajousTrace, std::true_type>
    >,
    nullptr
} };

void dsv::view::LissajousTrace::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *dsv::view::LissajousTrace::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::view::LissajousTrace::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEviewSCOPELissajousTraceENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return Trace::qt_metacast(_clname);
}

int dsv::view::LissajousTrace::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = Trace::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_DSOSIGNAL_H
#define DSVIEW_PV_DSOSIGNAL_H

#include "signal.h"
#include "../com/dstimer.h"

using namespace dsv::com;
  
namespace dsv {

namespace data {
    class DsoSnapshot;
}

namespace view {

//when device is oscilloscope model,to draw trace
//created by SigSession
class DsoSignal : public Signal
{
    Q_OBJECT

public:
    static const int UpMargin = 30;
    static const int DownMargin = 0;
    static const int RightMargin = 30;
    static const float EnvelopeThreshold;
    static const int HoverPointSize = 2;
    static const int RefreshShort = 200;

private:
	static const QColor SignalColours[4];
    static const int HitCursorMargin = 3;
    static const uint64_t vDialValueStep = 1000;
    static const uint64_t vDialUnitCount = 2;
    static const QString vDialUnit[vDialUnitCount];

    static const uint8_t DefaultBits = 8;
    static const int TrigMargin = 16;
    static const int RefreshLong = 800;
    static const int AutoTime = 10000;
    static const int AutoLock = 3;

    static const int TrigHRng = 2;

public:
    enum DsoSetRegions {
        DSO_NONE = -1,
        DSO_VDIAL,
        DSO_CHEN,
        DSO_ACDC,
        DSO_AUTO,
        DSO_X1,
        DSO_X10,
        DSO_X100,
    };

private:
    static const uint16_t MS_RectRad = 5;
    static const uint16_t MS_IconSize = 16;
    static const uint16_t MS_RectWidth = 120;
    static const uint16_t MS_RectMargin = 10;
    static const uint16_t MS_RectHeight = 25;

public:
    DsoSignal(dsv::data::DsoSnapshot *data,
              sr_channel *probe);

    virtual ~DsoSignal();

    inline data::DsoSnapshot* data(){
        return _data;
    }

    void set_data(data::DsoSnapshot *data);

    void set_scale(int height);

    inline float get_scale(){
        return _scale;
    }

    inline uint8_t get_bits(){
        return _bits;
    }

    inline double get_ref_min(){
        return _ref_min;
    }

    inline double get_ref_max(){
        return _ref_max;
    }

    inline int get_name_width(){
        return 0;
    }

    void set_enable(bool enable);

    inline bool get_vDialActive(){
        return _vDialActive;
    }

    void set_vDialActive(bool active);
    bool go_vDialPre(bool manul);
    bool go_vDialNext(bool manul); 

    inline dslDial *get_vDial(){
        return _vDial;
    }

    uint64_t get_vDialValue();
    uint16_t get_vDialSel();

    inline uint8_t get_acCoupling(){
        return _acCoupling;
    }

    void set_acCoupling(uint8_t coupling);

    void set_trig_vpos(int pos, bool delta_change = true);
    void set_trig_ratio(double ratio, bool delta_change = true);
    double get_trig_vrate();

    void set_factor(uint64_t factor);
    uint64_t get_factor();

    inline void set_show(bool show){
        _show = show;
    }

    inline bool show(){
        return _show;
    }

    inline void set_mValid(bool valid){
        _mValid = valid;
    }

    bool load_settings();
    int commit_settings();

    /**
      *
      */
    bool measure(const QPointF &p);
    bool get_hover(uint64_t &index, QPointF &p, double &value);
    QPointF get_point(uint64_t index, float &value);

    /**
      * auto set the vertical and Horizontal scale
      */
    void auto_start();
    void autoV_end();
    void autoH_end();
    void auto_end();

    /**
     * Gets the mid-Y position of this signal.
     */
    int get_zero_vpos();
    double get_zero_ratio();
    int get_hw_offset();
    /**
     * Sets the mid-Y position of this signal.
     */
    void set_zero_vpos(int pos);
    void set_zero_ratio(double ratio);
    double get_voltage(uint64_t index);
    QString get_voltage(double v, int p, bool scaled = false);
    QString get_time(double t);

    /**
     *
     */
    int ratio2value(double ratio);
    int ratio2pos(double ratio);
    double value2ratio(int value);
    double pos2ratio(int pos);

    /**
     * paint prepare
     **/
    void paint_prepare();

    /**
     * Paints the background layer of the trace with a QPainter
     * @param p the QPainter to paint into.
     * @param left the x-coordinate of the left edge of the signal
     * @param right the x-coordinate of the right edge of the signal
     **/
    void paint_back(QPainter &p, int left, int right, QColor fore, QColor back);

	/**
	 * Paints the signal with a QPainter
	 * @param p the QPainter to paint into.
	 * @param left the x-coordinate of the left edge of the signal.
	 * @param right the x-coordinate of the right edge of the signal.
	 **/
    void paint_mid(QPainter &p, int left, int right, QColor fore, QColor back);

    /**
     * Paints the signal with a QPainter
     * @param p the QPainter to paint into.
     * @param left the x-coordinate of the left edge of the signal.
     * @param right the x-coordinate of the right edge of the signal.
     **/
    void paint_fore(QPainter &p, int left, int right, QColor fore, QColor back);

    QRect get_view_rect();

    QRectF get_trig_rect(int left, int right);

    QString get_measure(enum DSO_MEASURE_TYPE type);

    QRectF get_rect(DsoSetRegions type, int y, int right);

    bool mouse_press(int right, const QPoint pt);

    bool mouse_wheel(int right, const QPoint pt, const int shift);

    inline void set_stop_scale(float v){
        _stop_scale = v;
    }

protected:
    void paint_type_options(QPainter &p, int right, const QPoint pt, QColor fore);

private:
    void paint_trace(QPainter &p,
        const dsv::data::DsoSnapshot* snapshot,
        int zeroY, int left, const int64_t start, const int64_t end, int hw_offset,
        const double pixels_offset, const double samples_per_pixel,
        uint64_t num_channels);

    void paint_envelope(QPainter &p,
        const dsv::data::DsoSnapshot *snapshot,
        int zeroY, int left, const int64_t start, const int64_t end, int hw_offset,
        const double pixels_offset, const double samples_per_pixel,
        uint64_t num_channels);

    void paint_hover_measure(QPainter &p, QColor fore, QColor back);
    void auto_set();

    void call_auto_end();

private:
    dsv::data::DsoSnapshot *_data;
	float _scale;
    float _stop_scale = 1;
    bool _en_lock;
    bool _show;

    dslDial *_vDial;
    bool _vDialActive;
    uint8_t _acCoupling;
    uint8_t _bits;
    double _ref_min;
    double _ref_max;

    int _trig_value;
    double _trig_delta;
    int _zero_offset;

    bool _mValid;
    uint8_t _max;
    uint8_t _min;
    double _period;
    bool _level_valid;
    uint8_t _high;
    uint8_t _low;
    double _rms;
    double _mean;
    double _rise_time;
    double _fall_time;
    double _high_time;
    double _burst_time;
    uint32_t _pcount;

    bool _autoV;
    bool _autoH;
    bool _autoV_over;
    uint16_t _auto_cnt;

    bool _hover_en;
    uint64_t _hover_index;
    QPointF _hover_point;
    float _hover_value;
    DsTimer _end_timer;
};

} // namespace view
} // namespace dsv

#endif // DSVIEW_PV_DSOSIGNAL_H
/****************************************************************************
** Meta object code from reading C++ file 'cursor.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "cursor.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'cursor.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPECursorENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEviewSCOPECursorENDCLASS = QtMocHelpers::stringData(
    "dsv::view::Cursor"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPECursorENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[18];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEviewSCOPECursorENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEviewSCOPECursorENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEviewSCOPECursorENDCLASS = {
    {
        QT_MOC_LITERAL(0, 17)   // "dsv::view::Cursor"
    },
    "dsv::view::Cursor"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEviewSCOPECursorENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::view::Cursor::staticMetaObject = { {
    QMetaObject::SuperData::link<TimeMarker::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEviewSCOPECursorENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEviewSCOPECursorENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEviewSCOPECursorENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<Cursor, std::true_type>
    >,
    nullptr
} };

void dsv::view::Cursor::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *dsv::view::Cursor::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::view::Cursor::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEviewSCOPECursorENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return TimeMarker::qt_metacast(_clname);
}

int dsv::view::Cursor::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = TimeMarker::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_VIEW_DSLDIAL_H
#define DSVIEW_PV_VIEW_DSLDIAL_H

#include <QRect>
#include <QPainter>
#include <QObject>

namespace dsv {
namespace view {

//when device is oscilloscope model, to draw the dail on the left
//created by DsoSignal
class dslDial : public QObject
{
    //Q_OBJECT

public:
    dslDial(const uint64_t div, const uint64_t step,
            const QVector<uint64_t> value, const QVector<QString> unit);
    virtual ~dslDial();

public:
    /**
     * Paints the dial with a QPainter
     * @param p the QPainter to paint into.
     * @param dialRect the rectangle to draw the dial at.
     **/
    void paint(QPainter &p, QRectF dialRect, QColor dialColor,
               const QPoint pt, QString &pText);

    // set/get current select
    void set_sel(uint64_t sel);
    uint64_t get_sel();
    uint64_t get_count();

    // boundary detection
    bool isMin();
    bool isMax();
    uint64_t get_min();
    uint64_t get_max();

    // get current value
    uint64_t get_value();
    uint64_t get_value(uint64_t i);
    void set_value(uint64_t value);

    // set/get factor
    void set_factor(uint64_t factor);
    uint64_t get_factor();

private:
    uint64_t _div;
    uint64_t _step;
    QVector<uint64_t> _value;
    QVector<QString> _unit;
    uint64_t _sel;
    uint64_t _factor;
};

} // namespace view
} // namespace dsv

#endif // DSVIEW_PV_VIEW_DSLDIAL_H
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "spectrumtrace.h"
#include <algorithm>
#include <math.h>
#include <QTextStream>
#include <boost/functional/hash.hpp>
#include <stdlib.h>
#include "../appcore/sigsession.h"
#include "../data/dsosnapshot.h"
#include "dsosignal.h"
#include "viewport.h"
#include "../data/spectrumstack.h"
#include "../basedef.h"

using namespace boost;
using namespace std;

namespace dsv {
namespace view {

const int SpectrumTrace::UpMargin = 0;
const int SpectrumTrace::DownMargin = 0;
const int SpectrumTrace::RightMargin = 30;
const QString SpectrumTrace::FFT_ViewMode[2] = {
    "Linear RMS",
    "DBV RMS"
};

const QString SpectrumTrace::FreqPrefixes[9] =
    {"", "", "", "", "K", "M", "G", "T", "P"};
const int SpectrumTrace::FirstSIPrefixPower = -9;
const int SpectrumTrace::LastSIPrefixPower = 15;
const int SpectrumTrace::Pricision = 2;
const int SpectrumTrace::FreqMinorDivNum = 10;
const int SpectrumTrace::TickHeight = 15;
const int SpectrumTrace::VolDivNum = 5;

const int SpectrumTrace::DbvRanges[4] = {
    100,
    120,
    150,
    200,
};

const int SpectrumTrace::HoverPointSize = 3;
const double SpectrumTrace::VerticalRate = 1.0 / 2000.0;

SpectrumTrace::SpectrumTrace(SigSession *session,
    SpectrumStack *spectrum_stack, int index) :
    Trace("FFT("+QString::number(index)+")", index, SR_CHANNEL_FFT),
    _session(session),
    _spectrum_stack(spectrum_stack),
    _enable(false),
    _view_mode(0),
    _hover_en(false),
    _scale(1),
    _offset(0)
{
    _typeWidth = 0;

    for(auto s : _session->get_signals()) {
        if (s->signal_type() == SR_CHANNEL_DSO && index == s->get_index()){
            _colour = s->get_colour();
        }
    }
}

SpectrumTrace::~SpectrumTrace()
{
    DESTROY_OBJECT(_spectrum_stack);
}

bool SpectrumTrace::enabled()
{
    return _enable;
}

void SpectrumTrace::set_enable(bool enable)
{
    _enable = enable;
}

int SpectrumTrace::view_mode()
{
    return _view_mode;
}

void SpectrumTrace::set_view_mode(unsigned int mode)
{
    assert(mode < sizeof(FFT_ViewMode)/sizeof(FFT_ViewMode[0]));
    _view_mode = mode;
}

std::vector<QString> SpectrumTrace::get_view_modes_support()
{
    std::vector<QString> modes;
    for (unsigned int i = 0; i < sizeof(FFT_ViewMode)/sizeof(FFT_ViewMode[0]); i++) {
        modes.push_back(FFT_ViewMode[i]);
    }
    return modes;
}

void SpectrumTrace::init_zoom()
{
    _scale = 1;
    _offset = 0;
}

void SpectrumTrace::zoom(double steps, int offset)
{
    if (!_view)
        return;

    const int width = get_view_rect().width();
    double pre_offset = _offset + _scale*offset/width;
    _scale *= std::pow(3.0/2.0, -steps);
    _scale = max(min(_scale, 1.0), 100.0/_spectrum_stack->get_sample_num());
    _offset = pre_offset - _scale*offset/width;
    _offset = max(min(_offset, 1-_scale), 0.0);

    _view->set_update(_viewport, true);
    _view->update();
}

void SpectrumTrace::set_offset(double delta)
{
    int width = get_view_rect().width();
    _offset = _offset + (delta*_scale / width);
    _offset = max(min(_offset, 1-_scale), 0.0);

    _view->set_update(_viewport, true);
    _view->update();
}

double SpectrumTrace::get_offset()
{
    return _offset;
}

void SpectrumTrace::set_scale(double scale)
{
    _scale = max(min(scale, 1.0), 100.0/_spectrum_stack->get_sample_num());

    _view->set_update(_viewport, true);
    _view->update();
}

double SpectrumTrace::get_scale()
{
    return _scale;
}

void SpectrumTrace::set_dbv_range(int range)
{
    _dbv_range = range;
}

int SpectrumTrace::dbv_range()
{
    return _dbv_range;
}

std::vector<int> SpectrumTrace::get_dbv_ranges()
{
    std::vector<int> range;
    for (unsigned int i = 0; i < sizeof(DbvRanges)/sizeof(DbvRanges[0]); i++) {
        range.push_back(DbvRanges[i]);
    }
    return range;
}

QString SpectrumTrace::format_freq(double freq, unsigned precision)
{
    if (freq <= 0) {
        return "0Hz";
    } else {
        const int order = floor(log10f(freq));
        assert(order >= FirstSIPrefixPower);
        assert(order <= LastSIPrefixPower);
        const int prefix = floor((order - FirstSIPrefixPower)/ 3.0f);
        const double divider = pow(10.0, max(prefix * 3.0 + FirstSIPrefixPower, 0.0));

        /*
        QString s;
        QTextStream ts(&s);
        ts.setRealNumberPrecision(precision);
        ts << fixed << freq / divider << FreqPrefixes[prefix] << "Hz";
        return s;
        */

        char buffer[20] = {0};
        char format[10] = {0}; 
        QString units = FreqPrefixes[prefix] + "Hz";
        sprintf(format, "%%.%df", (int)precision);    
        sprintf(buffer, format, freq / divider);
        strcat(buffer, units.toUtf8().data());
        return QString(buffer);
    }
}

bool SpectrumTrace::measure(const QPoint &p)
{
    _hover_en = false;
    if(!_view || !enabled())
        return false;

    const QRect window = get_view_rect();
    if (!window.contains(p))
        return false;

    const std::vector<double> samples(_spectrum_stack->get_fft_spectrum());
    if(samples.empty())
        return false;

    const unsigned int full_size = (_spectrum_stack->get_sample_num()/2);
    const double view_off = full_size * _offset;
    const double view_size = full_size*_scale;
    const double sample_per_pixels = view_size/window.width();
    _hover_index = std::round(p.x() * sample_per_pixels + view_off);

    if (_hover_index < full_size)
        _hover_en = true;

    //_view->set_update(_viewport, true);
    _view->update();
    return true;
}


void SpectrumTrace::paint_back(QPainter &p, int left, int right, QColor fore, QColor back)
{
    if(!_view)
        return;

    const int height = get_view_rect().height();
    const int width = right - left;

    fore.setAlpha(View::BackAlpha);
    QPen solidPen(fore);
    solidPen.setStyle(Qt::SolidLine);
    p.setPen(solidPen);
    p.setBrush(back.black() > 0x80 ? back.darker() : back.lighter());
    p.drawRect(left, UpMargin, width, height);
}

void SpectrumTrace::paint_mid(QPainter &p, int left, int right, QColor fore, QColor back)
{
    (void)fore;
    (void)back;

    if(!_view)
        return;
    assert(right >= left);

    if (enabled()) {
        const std::vector<double> samples(_spectrum_stack->get_fft_spectrum());
        if(samples.empty())
            return;

        QColor trace_colour = _colour;
        trace_colour.setAlpha(View::ForeAlpha);
        p.setPen(trace_colour);

        const int full_size = (_spectrum_stack->get_sample_num()/2);
        const double view_off = full_size * _offset;
        const int view_start = floor(view_off);
        const int view_size = full_size*_scale;
        QPointF *points = new QPointF[samples.size()];
        QPointF *point = points;

        const bool dc_ignored = _spectrum_stack->dc_ignored();
        const double height = get_view_rect().height();
        const double width = right - left;
        const double pixels_per_sample = width/view_size;

        double vdiv = 0;
        double vfactor = 0;
        
        for(auto s : _session->get_signals()) {
            if (s->signal_type() == SR_CHANNEL_DSO) {
                view::DsoSignal *dsoSig = (view::DsoSignal*)s;
                if(dsoSig->get_index() == _spectrum_stack->get_index()) {
                    vdiv = dsoSig->get_vDialValue();
                    vfactor = dsoSig->get_factor();
                    break;
                }
            }
        }
        if (_view_mode == 0) {
            _vmin = 0;
            _vmax = (vdiv*DS_CONF_DSO_HDIVS*vfactor)*VerticalRate;
        } else {
            _vmax = 20*log10((vdiv*DS_CONF_DSO_HDIVS*vfactor)*VerticalRate);
            _vmin = _vmax - _dbv_range;
        }

        const double scale = height / (_vmax - _vmin);

        double x = (view_start-view_off)*pixels_per_sample;
        uint64_t sample = view_start;
        if (dc_ignored && sample == 0) {
            sample++;
            x += pixels_per_sample;
        }
        double min_mag = pow(10.0, _vmin/20);
        do{
            double mag = samples[sample];
            if (_view_mode != 0) {
                if (mag < min_mag)
                    mag = _vmin;
                else
                    mag = 20*log10(mag);
            }
            const double y = height - (scale * (mag - _vmin));
            *point++ = QPointF(x, y);
            x += pixels_per_sample;
            sample++;
        }while(x<right && sample < samples.size());

        p.drawPolyline(points, point - points);
        delete[] points;
    }
}

void SpectrumTrace::paint_fore(QPainter &p, int left, int right, QColor fore, QColor back)
{
    using namespace Qt;

    (void)back;

    if(!_view)
        return;
    assert(right >= left);

    (void)left;
    (void)right;
    const int text_height = p.boundingRect(0, 0, INT_MAX, INT_MAX,
        AlignLeft | AlignTop, "8").height();
    const double width = get_view_rect().width();
    const double height = get_view_rect().height();
    double blank_top = 0;
    double blank_right = width;

    // horizontal ruler
    const double NyFreq = _session->cur_snap_samplerate() / (2.0 * _spectrum_stack->get_sample_interval());
    const double deltaFreq = _session->cur_snap_samplerate() * 1.0 /
                            (_spectrum_stack->get_sample_num() * _spectrum_stack->get_sample_interval());
    const double FreqRange = NyFreq * _scale;
    const double FreqOffset = NyFreq * _offset;

    const int order = (int)floor(log10(FreqRange));
    const double multiplier = (pow(10.0, order) == FreqRange) ? FreqRange/10 : pow(10.0, order);
    const double freq_per_pixel = FreqRange / width;

    p.setPen(fore);
    p.setBrush(Qt::NoBrush);
    double tick_freq = multiplier * (int)floor(FreqOffset / multiplier);
    int division = (int)round(tick_freq * FreqMinorDivNum / multiplier);
    double x = (tick_freq - FreqOffset) / freq_per_pixel;
    do{
        if (division%FreqMinorDivNum == 0) {
            QString freq_str = format_freq(tick_freq);
            double typical_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
                AlignLeft | AlignTop, freq_str).width() + 10;
            p.drawLine(x, 1, x, TickHeight);
            if (x > typical_width/2 && (width-x) > typical_width/2)
                p.drawText(x-typical_width/2, TickHeight, typical_width, text_height,
                           AlignCenter | AlignTop | TextDontClip, freq_str);
        } else {
                p.drawLine(x, 1, x, TickHeight/2);
        }
        tick_freq += multiplier/FreqMinorDivNum;
        division++;
        x =  (tick_freq - FreqOffset) / freq_per_pixel;
    } while(x < width);
    blank_top = max(blank_top, (double)TickHeight + text_height);

    // delta Frequency
    QString freq_str =  QString::fromWCharArray(L" \u0394") + "Freq: " + format_freq(deltaFreq,4);
    p.drawText(0, 0, width, get_view_rect().height(),
               AlignRight | AlignBottom | TextDontClip, freq_str);
    double delta_left = width-p.boundingRect(0, 0, INT_MAX, INT_MAX,
                                             AlignLeft | AlignTop, freq_str).width();
    blank_right = min(delta_left, blank_right);

    // Vertical ruler
    const double vRange = _vmax - _vmin;
    const double vOffset = _vmin;
    const double vol_per_tick = vRange / VolDivNum;

    p.setPen(fore);
    p.setBrush(Qt::NoBrush);
    double tick_vol = vol_per_tick + vOffset;
    double y = height - height / VolDivNum;
    const QString unit = (_view_mode == 0) ? "" : "dbv";
    do{
        if (y > text_height && y < (height - text_height)) {
            QString vol_str = QString::number(tick_vol, 'f', Pricision) + unit;
            double vol_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
                AlignLeft | AlignTop, vol_str).width();
            p.drawLine(width, y, width-TickHeight/2, y);
            p.drawText(width-TickHeight-vol_width, y-text_height/2, vol_width, text_height,
                       AlignCenter | AlignTop | TextDontClip, vol_str);
            blank_right = min(width-TickHeight-vol_width, blank_right);
        }
        tick_vol += vol_per_tick;
        y -=  height / VolDivNum;
    } while(y > 0);

    // Hover measure
    if (_hover_en) {
        const std::vector<double> samples(_spectrum_stack->get_fft_spectrum());
        if(samples.empty())
            return;
        const int full_size = (_spectrum_stack->get_sample_num()/2);
        const double view_off = full_size * _offset;
        const int view_size = full_size*_scale;
        const double scale = height / (_vmax - _vmin);
        const double pixels_per_sample = width/view_size;
        double x = (_hover_index-view_off)*pixels_per_sample;
        double min_mag = pow(10.0, _vmin/20);
        _hover_value = samples[_hover_index];
        if (_view_mode != 0) {
            if (_hover_value < min_mag)
                _hover_value = _vmin;
            else
                _hover_value = 20*log10(_hover_value);
        }
        const double y = height - (scale * (_hover_value - _vmin));
        _hover_point = QPointF(x, y);

        p.setPen(QPen(fore, 1, Qt::DashLine));
        p.setBrush(Qt::NoBrush);
        p.drawLine(_hover_point.x(), 0, _hover_point.x(), height);

        QString hover_str = QString::number(_hover_value, 'f', 4) + unit + "@" + format_freq(deltaFreq * _hover_index, 4);
        const int hover_width = p.boundingRect(0, 0, INT_MAX, INT_MAX,
            AlignLeft | AlignTop, hover_str).width();
        const int hover_height = p.boundingRect(0, 0, INT_MAX, INT_MAX,
            AlignLeft | AlignTop, hover_str).height();
        QRectF hover_rect(_hover_point.x(), _hover_point.y()-hover_height, hover_width, hover_height);
        if (hover_rect.right() > blank_right)
            hover_rect.moveRight(min(_hover_point.x(), blank_right));
        if (hover_rect.top() < blank_top)
            hover_rect.moveTop(max(_hover_point.y(), blank_top));
        if (hover_rect.top() > 0)
            p.drawText(hover_rect, AlignCenter | AlignTop | TextDontClip, hover_str);

        p.setPen(Qt::NoPen);
        p.setBrush(fore);
        p.drawEllipse(_hover_point, HoverPointSize, HoverPointSize);
    }
}

void SpectrumTrace::paint_type_options(QPainter &p, int right, const QPoint pt, QColor fore)
{
    (void)p;
    (void)pt;
    (void)right;
    (void)fore;
}

QRect SpectrumTrace::get_view_rect()
{
    assert(_viewport);
    return QRect(0, UpMargin,
                  _viewport->width() - RightMargin,
                  _viewport->height() - UpMargin - DownMargin);
}

} // namespace view
} // namespace dsv
/****************************************************************************
** Meta object code from reading C++ file 'timemarker.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "timemarker.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'timemarker.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPETimeMarkerENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEviewSCOPETimeMarkerENDCLASS = QtMocHelpers::stringData(
    "dsv::view::TimeMarker",
    "time_changed",
    ""
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEviewSCOPETimeMarkerENDCLASS_t {
    uint offsetsAndSizes[6];
    char stringdata0[22];
    char stringdata1[13];
    char stringdata2[1];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEviewSCOPETimeMarkerENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEviewSCOPETimeMarkerENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEviewSCOPETimeMarkerENDCLASS = {
    {
        QT_MOC_LITERAL(0, 21),  // "dsv::view::TimeMarker"
        QT_MOC_LITERAL(22, 12),  // "time_changed"
        QT_MOC_LITERAL(35, 0)   // ""
    },
    "dsv::view::TimeMarker",
    "time_changed",
    ""
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEviewSCOPETimeMarkerENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   20,    2, 0x06,    1 /* Public */,

 // signals: parameters
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::view::TimeMarker::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEviewSCOPETimeMarkerENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEviewSCOPETimeMarkerENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEviewSCOPETimeMarkerENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<TimeMarker, std::true_type>,
        // method 'time_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::view::TimeMarker::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<TimeMarker *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->time_changed(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (TimeMarker::*)();
            if (_t _q_method = &TimeMarker::time_changed; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
    }
    (void)_a;
}

const QMetaObject *dsv::view::TimeMarker::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::view::TimeMarker::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEviewSCOPETimeMarkerENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int dsv::view::TimeMarker::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 1;
    }
    return _id;
}

// SIGNAL 0
void dsv::view::TimeMarker::time_changed()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}
QT_WARNING_POP
/****************************************************************************
** Meta object code from reading C++ file 'lissajousoptions.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "lissajousoptions.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'lissajousoptions.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPELissajousOptionsENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPELissajousOptionsENDCLASS = QtMocHelpers::stringData(
    "dsv::dialogs::LissajousOptions"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPELissajousOptionsENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[31];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPELissajousOptionsENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPELissajousOptionsENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPELissajousOptionsENDCLASS = {
    {
        QT_MOC_LITERAL(0, 30)   // "dsv::dialogs::LissajousOptions"
    },
    "dsv::dialogs::LissajousOptions"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdialogsSCOPELissajousOptionsENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dialogs::LissajousOptions::staticMetaObject = { {
    QMetaObject::SuperData::link<DSDialog::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPELissajousOptionsENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdialogsSCOPELissajousOptionsENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPELissajousOptionsENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<LissajousOptions, std::true_type>
    >,
    nullptr
} };

void dsv::dialogs::LissajousOptions::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *dsv::dialogs::LissajousOptions::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dialogs::LissajousOptions::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPELissajousOptionsENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return DSDialog::qt_metacast(_clname);
}

int dsv::dialogs::LissajousOptions::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = DSDialog::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_DSDIALOG_H
#define DSVIEW_PV_DSDIALOG_H

#include <QDialog>
#include <QWidget>
#include <QVBoxLayout>
#include <QDialogButtonBox>
#include "../toolbars/titlebar.h"
#include "../interface/icallbacks.h"

class QDialogButtonBox;
 
 
namespace dsv {
namespace dialogs {

    class Shadow;

//DSView any dialog base class
class DSDialog : public QDialog, IFontForm
{
	Q_OBJECT

public:
    DSDialog();
    DSDialog(QWidget *parent);
    DSDialog(QWidget *parent, bool hasClose);
    DSDialog(QWidget *parent, bool hasClose, bool bBaseButton);
    ~DSDialog();

    inline void SetCallback(IDlgCallback *callback){m_callback = callback;}
    inline QVBoxLayout *layout(){return _main_layout;}
    void setTitle(QString title);
    void reload(); 
    int exec();

    inline bool IsClickYes(){
        return _clickYes;
    }

    inline bool IsAccept(){
        return _clickYes;
    }

    void SetTitleSpace(int h);

    //IFontForm
    void update_font() override;

    void show();

protected:
    void accept();
    void reject();

private:
    void build_base(bool hasClose); 

private:
    QVBoxLayout         *_base_layout;
    QWidget             *_main_widget;
    QVBoxLayout         *_main_layout;
    toolbars::TitleBar  *_titlebar;
    Shadow              *_shadow;
    QDialogButtonBox    *_base_button; 
   
    QPoint              _startPos; 
    bool                 m_bBaseButton; 
    bool                _clickYes;
    QWidget             *_titleSpaceLine;

    IDlgCallback        *m_callback;
};

} // namespace dialogs
} // namespace dsv

#endif // DSVIEW_PV_DSDIALOG_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "protocollist.h"
#include <QFormLayout>
#include <QListWidget>
#include "../appcore/sigsession.h"
#include "../data/decoderstack.h"
#include "../decode/row.h"
#include "../view/decodetrace.h"
#include "../data/decodermodel.h"
#include "../ui/langresource.h"

using namespace boost;
using namespace std;

namespace dsv {
namespace dialogs {

ProtocolList::ProtocolList(QWidget *parent, SigSession *session) :
    DSDialog(parent),
    _session(session),
    _button_box(QDialogButtonBox::Ok,
        Qt::Horizontal, this)
{
    dsv::data::DecoderModel* decoder_model = _session->get_decoder_model();

    _map_zoom_combobox = new DsComboBox(this);
    _map_zoom_combobox->addItem(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_FIT_TO_WINDOW), "Fit to Window"));
    _map_zoom_combobox->addItem(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_FIXED), "Fixed"));
    int cur_map_zoom = _session->get_map_zoom();

    if (cur_map_zoom >= _map_zoom_combobox->count())
        _map_zoom_combobox->setCurrentIndex(0);
    else
        _map_zoom_combobox->setCurrentIndex(cur_map_zoom);

    connect(_map_zoom_combobox, SIGNAL(currentIndexChanged(int)), this, SLOT(on_set_map_zoom(int)));

    _protocol_combobox = new DsComboBox(this);
    auto &decode_sigs = _session->get_decode_signals();
    int index = 0;

    for(auto d : decode_sigs) {
        _protocol_combobox->addItem(d->get_name());
        if (decoder_model->getDecoderStack() == d->decoder())
            _protocol_combobox->setCurrentIndex(index);
        index++;
    }
    _protocol_combobox->addItem("", QVariant::fromValue(NULL));
    if (decoder_model->getDecoderStack() == NULL)
        _protocol_combobox->setCurrentIndex(index);

    _flayout = new QFormLayout();
    _flayout->setVerticalSpacing(5);
    _flayout->setFormAlignment(Qt::AlignLeft);
    _flayout->setLabelAlignment(Qt::AlignLeft);
    _flayout->setFieldGrowthPolicy(QFormLayout::AllNonFixedFieldsGrow);
    _flayout->addRow(new QLabel(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_MAP_ZOOM), "Map Zoom: "), this), _map_zoom_combobox);
    _flayout->addRow(new QLabel(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_DECODED_PROTOCOLS), "Decoded Protocols: "), this), _protocol_combobox);

    _layout = new QVBoxLayout();
    _layout->addLayout(_flayout);
    _layout->addWidget(&_button_box);

    setMinimumWidth(300);
    layout()->addLayout(_layout);
    setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_PROTOCOL_LIST_VIEWER), "Protocol List Viewer"));

    connect(&_button_box, SIGNAL(accepted()), this, SLOT(accept()));
    connect(_protocol_combobox, SIGNAL(currentIndexChanged(int)), this, SLOT(set_protocol(int)));
    set_protocol(_protocol_combobox->currentIndex());
    connect(_session->device_event_object(), SIGNAL(device_updated()), this, SLOT(reject()));

}

void ProtocolList::accept()
{
    using namespace Qt;

    QDialog::accept();
}

void ProtocolList::reject()
{
    using namespace Qt;

    QDialog::accept();
}

void ProtocolList::set_protocol(int index)
{
    (void)index;

    for(std::list<QCheckBox *>::const_iterator i = _show_checkbox_list.begin();
        i != _show_checkbox_list.end(); i++) {
        (*i)->setParent(NULL);
        _flayout->removeWidget((*i));
        delete (*i);
    }
    _show_checkbox_list.clear();
    for(std::list<QLabel *>::const_iterator i = _show_label_list.begin();
        i != _show_label_list.end(); i++) {
        (*i)->setParent(NULL);
        _flayout->removeWidget((*i));
        delete (*i);
    }
    _show_label_list.clear();

    dsv::data::DecoderStack *decoder_stack = NULL;
    const auto &decode_sigs = _session->get_decode_signals();
    int cur_index = 0;

    for(auto d : decode_sigs) {
        if (index == cur_index) {
            decoder_stack = d->decoder();
            break;
        }
        cur_index++;
    }

    if (!decoder_stack){
        _session->get_decoder_model()->setDecoderStack(NULL);
        return;
    }

    _session->get_decoder_model()->setDecoderStack(decoder_stack);
    int row_index = 0;
    const auto rows = decoder_stack->get_rows_lshow();

    for (auto i = rows.begin();i != rows.end(); i++) {
        QLabel *row_label = new QLabel((*i).first.title(), this);
        QCheckBox *row_checkbox = new QCheckBox(this);
        //row_checkbox->setChecked(false);
        _show_label_list.push_back(row_label);
        _show_checkbox_list.push_back(row_checkbox);
        _flayout->addRow(row_label, row_checkbox);

        row_checkbox->setChecked((*i).second);
        connect(row_checkbox, SIGNAL(clicked(bool)), this, SLOT(on_row_check(bool)));
        row_checkbox->setProperty("index", row_index);
        row_index++;
    }
}

void ProtocolList::on_row_check(bool show)
{
    QCheckBox *sc = dynamic_cast<QCheckBox*>(sender());
    QVariant id = sc->property("index");
    int index = id.toInt();

    dsv::data::DecoderStack *decoder_stack = NULL;
    const auto &decode_sigs = _session->get_decode_signals();
    int cur_index = 0;

    for(auto d : decode_sigs) {
        if (cur_index == _protocol_combobox->currentIndex()) {
            decoder_stack = d->decoder();
            break;
        }
        cur_index++;
    }

    if (!decoder_stack)
        return;

    std::map<const dsv::decode::Row, bool> rows = decoder_stack->get_rows_lshow();
    for (std::map<const dsv::decode::Row, bool>::const_iterator i = rows.begin();
        i != rows.end(); i++) {
        if (index-- == 0) {
            decoder_stack->set_rows_lshow((*i).first, show);
            break;
        }
    }

    _session->get_decoder_model()->setDecoderStack(decoder_stack);
}

 void ProtocolList::on_set_map_zoom(int index)
 {
     _session->set_map_zoom(index);
 }

} // namespace dialogs
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#include "about.h"

#include <QPixmap>
#include <QApplication>
#include <QTextBrowser>
#include <QFile>
#include <QDir>
#include <QTextStream>
#include <QScrollBar>
  
#include "../config/appconfig.h"
#include "../basedef.h"
#include "../utility/encoding.h"
#include "../ui/langresource.h"

using namespace dsv::config;

namespace dsv {
namespace dialogs {

About::About(QWidget *parent) :
    DSDialog(parent, true)
{
    setFixedHeight(600);
    setFixedWidth(800);

    #if defined(__x86_64__) || defined(_M_X64)
        QString arch = "x64";
    #elif defined(__i386) || defined(_M_IX86)
        QString arch = "x86";
    #elif defined(__arm__) || defined(_M_ARM)
        QString arch = "arm";
    #elif defined(__aarch64__)
        QString arch = "arm64";
    #else
        QString arch = "other";
    #endif

    QString version = tr("<font size=24>DSView %1 (%2)</font><br />")
                      .arg(QApplication::applicationVersion())
                      .arg(arch);

    QString site_url = QApplication::organizationDomain();
    if (site_url.startsWith("http") == false){
        site_url = "https://" + site_url;
    }

    QString url = tr("Website: <a href=\"%1\" style=\"color:#C0C0C0\">%1</a><br />"
                     "Github: <a href=\"%2\" style=\"color:#C0C0C0\">%2</a><br />"
                     "Copyright: <label href=\"#\" style=\"color:#C0C0C0\">%3</label><br />"
                     "<br /><br />")
                  .arg(site_url)
                  .arg("https://github.com/DreamSourceLab/DSView")
                  .arg(tr(" DreamSourceLab. All rights reserved."));

    QString thanks = tr("<font size=16>Special Thanks</font><br />"
                        "<a href=\"%1\" style=\"color:#C0C0C0\">All backers on kickstarter</a><br />"
                        "<a href=\"%2\" style=\"color:#C0C0C0\">All members of Sigrok project</a><br />"
                        "All contributors of all open-source projects</a><br />"
                        "<br /><br />")
                        .arg("https://www.kickstarter.com/projects/dreamsourcelab/dslogic-multifunction-instruments-for-everyone")
                        .arg("http://sigrok.org/");

    QString changlogs = tr("<font size=16>Changelogs</font><br />");

    QDir dir(AppConfig::GetAppDataDir());
    AppConfig &app = AppConfig::Instance(); 
    int lan = app.frameOptions.language;

    QString filename = dir.absolutePath() + "/NEWS" + QString::number(lan);
    QFile news(filename);
    if (news.open(QIODevice::ReadOnly)) {
   
        QTextStream stream(&news);
        encoding::set_utf8(stream);

        QString line;
        while (!stream.atEnd()){
            line = stream.readLine();
            changlogs += line + "<br />";
        }
    }
    news.close();    

    QPixmap pix(":/icons/dsl_logo.svg");
    QImage logo = pix.toImage();

    QTextBrowser *about = new QTextBrowser(this);
    about->setOpenExternalLinks(true);
    about->setFrameStyle(QFrame::NoFrame);
    QTextCursor cur = about->textCursor();
    cur.insertImage(logo);
    cur.insertHtml("<br /><br /><br />");
    cur.insertHtml(version+url+thanks+changlogs);
    about->moveCursor(QTextCursor::Start);

    QVBoxLayout *xlayout = new QVBoxLayout();
    xlayout->addWidget(about);

    layout()->addLayout(xlayout);
    setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_ABOUT), "About"));
}

About::~About()
{
}

} // namespace dialogs
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#include "shadow.h"
#include <QPainter>

QT_BEGIN_NAMESPACE
  extern Q_WIDGETS_EXPORT void qt_blurImage(QPainter *p, QImage &blurImage, qreal radius, bool quality, bool alphaOnly, int transposed = 0 );
QT_END_NAMESPACE

namespace dsv {
namespace dialogs {

Shadow::Shadow(QObject *parent) :
    QGraphicsEffect(parent),
    _distance(4.0f),
    _blurRadius(10.0f),
    _color(0, 0, 0, 80)
{
}

void Shadow::draw(QPainter* painter)
{
    // if nothing to show outside the item, just draw source
    if ((blurRadius() + distance()) <= 0) {
        drawSource(painter);
        return;
    }

    PixmapPadMode mode = QGraphicsEffect::PadToEffectiveBoundingRect;
    QPoint offset;
    const QPixmap px = sourcePixmap(Qt::DeviceCoordinates, &offset, mode);

    // return if no source
    if (px.isNull())
        return;

    // save world transform
    QTransform restoreTransform = painter->worldTransform();
    painter->setWorldTransform(QTransform());

    // Calculate size for the background image
    QSize szi(px.size().width() + 2 * distance(), px.size().height() + 2 * distance());

    QImage tmp(szi, QImage::Format_ARGB32_Premultiplied);
    QPixmap scaled = px.scaled(szi);
    tmp.fill(0);
    QPainter tmpPainter(&tmp);
    tmpPainter.setCompositionMode(QPainter::CompositionMode_Source);
    tmpPainter.drawPixmap(QPointF(-distance(), -distance()), scaled);
    tmpPainter.end();

    // blur the alpha channel
    QImage blurred(tmp.size(), QImage::Format_ARGB32_Premultiplied);
    blurred.fill(0);
    QPainter blurPainter(&blurred);
    qt_blurImage(&blurPainter, tmp, blurRadius(), false, true);
    blurPainter.end();

    tmp = blurred;

    // blacken the image...
    tmpPainter.begin(&tmp);
    tmpPainter.setCompositionMode(QPainter::CompositionMode_SourceIn);
    tmpPainter.fillRect(tmp.rect(), color());
    tmpPainter.end();

    // draw the blurred shadow...
    painter->drawImage(offset, tmp);

    // draw the actual pixmap...
    painter->drawPixmap(offset, px, QRectF());

    // restore world transform
    painter->setWorldTransform(restoreTransform);
}

QRectF Shadow::boundingRectFor(const QRectF& rect) const
{
    qreal delta = blurRadius() + distance();
    return rect.united(rect.adjusted(-delta, -delta, delta, delta));
}

} // namespace dialogs
} // namespace dsv
/****************************************************************************
** Meta object code from reading C++ file 'regionoptions.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "regionoptions.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'regionoptions.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPERegionOptionsENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPERegionOptionsENDCLASS = QtMocHelpers::stringData(
    "dsv::dialogs::RegionOptions",
    "set_region",
    ""
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPERegionOptionsENDCLASS_t {
    uint offsetsAndSizes[6];
    char stringdata0[28];
    char stringdata1[11];
    char stringdata2[1];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPERegionOptionsENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPERegionOptionsENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPERegionOptionsENDCLASS = {
    {
        QT_MOC_LITERAL(0, 27),  // "dsv::dialogs::RegionOptions"
        QT_MOC_LITERAL(28, 10),  // "set_region"
        QT_MOC_LITERAL(39, 0)   // ""
    },
    "dsv::dialogs::RegionOptions",
    "set_region",
    ""
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdialogsSCOPERegionOptionsENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   20,    2, 0x08,    1 /* Private */,

 // slots: parameters
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dialogs::RegionOptions::staticMetaObject = { {
    QMetaObject::SuperData::link<DSDialog::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPERegionOptionsENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdialogsSCOPERegionOptionsENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPERegionOptionsENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<RegionOptions, std::true_type>,
        // method 'set_region'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::dialogs::RegionOptions::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<RegionOptions *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->set_region(); break;
        default: ;
        }
    }
    (void)_a;
}

const QMetaObject *dsv::dialogs::RegionOptions::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dialogs::RegionOptions::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPERegionOptionsENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return DSDialog::qt_metacast(_clname);
}

int dsv::dialogs::RegionOptions::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = DSDialog::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 1;
    }
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_ABOUT_H
#define DSVIEW_PV_ABOUT_H

#include <QLabel>
#include "dsdialog.h"

  
namespace dsv {
namespace dialogs {

class About : public DSDialog
{
	Q_OBJECT

public:
	explicit About(QWidget *parent = 0);
	~About();
};

} // namespace dialogs
} // namespace dsv

#endif // DSVIEW_PV_ABOUT_H
/****************************************************************************
** Meta object code from reading C++ file 'dsmessagebox.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "dsmessagebox.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'dsmessagebox.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDSMessageBoxENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDSMessageBoxENDCLASS = QtMocHelpers::stringData(
    "dsv::dialogs::DSMessageBox",
    "on_button",
    "",
    "QAbstractButton*",
    "btn"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDSMessageBoxENDCLASS_t {
    uint offsetsAndSizes[10];
    char stringdata0[27];
    char stringdata1[10];
    char stringdata2[1];
    char stringdata3[17];
    char stringdata4[4];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDSMessageBoxENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDSMessageBoxENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDSMessageBoxENDCLASS = {
    {
        QT_MOC_LITERAL(0, 26),  // "dsv::dialogs::DSMessageBox"
        QT_MOC_LITERAL(27, 9),  // "on_button"
        QT_MOC_LITERAL(37, 0),  // ""
        QT_MOC_LITERAL(38, 16),  // "QAbstractButton*"
        QT_MOC_LITERAL(55, 3)   // "btn"
    },
    "dsv::dialogs::DSMessageBox",
    "on_button",
    "",
    "QAbstractButton*",
    "btn"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdialogsSCOPEDSMessageBoxENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   20,    2, 0x08,    1 /* Private */,

 // slots: parameters
    QMetaType::Void, 0x80000000 | 3,    4,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dialogs::DSMessageBox::staticMetaObject = { {
    QMetaObject::SuperData::link<QDialog::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDSMessageBoxENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdialogsSCOPEDSMessageBoxENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDSMessageBoxENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<DSMessageBox, std::true_type>,
        // method 'on_button'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QAbstractButton *, std::false_type>
    >,
    nullptr
} };

void dsv::dialogs::DSMessageBox::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<DSMessageBox *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->on_button((*reinterpret_cast< std::add_pointer_t<QAbstractButton*>>(_a[1]))); break;
        default: ;
        }
    }
}

const QMetaObject *dsv::dialogs::DSMessageBox::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dialogs::DSMessageBox::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDSMessageBoxENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QDialog::qt_metacast(_clname);
}

int dsv::dialogs::DSMessageBox::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QDialog::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 1;
    }
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "deviceoptions.h" 
#include <QListWidget>
#include <QSpinBox>
#include <QDoubleSpinBox> 
#include <QGuiApplication>
#include <QScreen>
#include <QScrollArea>
#include <QLayoutItem>
#include <assert.h>
#include "dsmessagebox.h"
#include "../prop/property.h"
#include "../basedef.h"
#include "../config/appconfig.h"
#include "../appcore/appcontrol.h"
#include "../appcore/sigsession.h"
#include "../ui/langresource.h"
#include "../log.h"
#include "../ui/msgbox.h"

using namespace boost;
using namespace std;
using namespace dsv::config;

//--------------------------ChannelLabel

ChannelLabel::ChannelLabel(IChannelCheck *check, QWidget *parent, int chanIndex)
: QWidget(parent)
{
    _checked = check;
    _index = chanIndex;

    QGridLayout *lay = new QGridLayout();
    lay->setContentsMargins(0,0,0,0);
    lay->setSpacing(0);
    this->setLayout(lay);
    QLabel *lb = new QLabel(QString::number(chanIndex));
    lb->setAlignment(Qt::AlignCenter);
    _box = new QCheckBox();
    _box->setFixedSize(20,20);
    lay->addWidget(lb, 0, 0, Qt::AlignCenter);
    lay->addWidget(_box, 1, 0, Qt::AlignCenter);

    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
    lb->setFont(font);

    int fh = lb->fontMetrics().height();
    int w = lb->fontMetrics().horizontalAdvance(lb->text()) + 5;
    w = w < 30 ? 30 : w;
    int h = fh + _box->height() + 2;
    setFixedSize(w, h);

    connect(_box, SIGNAL(released()), this, SLOT(on_checked()));
}

void ChannelLabel::on_checked()
{
    assert(_checked);
    _checked->ChannelChecked(_index, _box);
}

//--------------------------DeviceOptions
 
namespace dsv{
namespace dialogs {

DeviceOptions::DeviceOptions(QWidget *parent) :
    DSDialog(parent)
{
    _scroll_panel = NULL;
    _container_panel = NULL;   
    _scroll = NULL; 
    _width = 0;
    _groupHeight1 = 0;
    _groupHeight2 = 0;
    _dynamic_panel = NULL;
    _container_lay = NULL;
    _isBuilding = false;
    _cur_analog_tag_index = 0;

    SigSession *session = AppControl::Instance()->GetSession();
    _device_agent = session->get_device();

    this->setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_DEVICE_OPTIONS), "Device Options"));
    this->SetTitleSpace(0);
    this->layout()->setSpacing(0);
    this->layout()->setDirection(QBoxLayout::TopToBottom);
    this->layout()->setAlignment(Qt::AlignTop); 

    // scroll panel
    _scroll_panel  = new QWidget();
    QVBoxLayout *scroll_lay = new QVBoxLayout();
    scroll_lay->setContentsMargins(0, 0, 0, 0);
    scroll_lay->setAlignment(Qt::AlignLeft);
    scroll_lay->setDirection(QBoxLayout::TopToBottom);
    _scroll_panel->setLayout(scroll_lay);
    this->layout()->addWidget(_scroll_panel);

    // container
    _container_panel = new QWidget();      
    _container_lay = new QVBoxLayout();
    _container_lay->setDirection(QBoxLayout::TopToBottom);
    _container_lay->setAlignment(Qt::AlignTop);
    _container_lay->setContentsMargins(0, 0, 0, 0);
    _container_lay->setSpacing(5);
    _container_panel->setLayout(_container_lay);
    scroll_lay->addWidget(_container_panel);

    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
   
    // mode group box
    QGroupBox *props_box = new QGroupBox(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_MODE), "Mode"), this);
    props_box->setFont(font);
    QLayout *props_lay = get_property_form(props_box);
    props_box->setLayout(props_lay);
    _container_lay->addWidget(props_box);

    QWidget *minWid = new QWidget();
    minWid->setFixedHeight(1);
    minWid->setMinimumWidth(230);
    _container_lay->addWidget(minWid);

    // chnnels group box
    this->build_dynamic_panel();

    // space
    QWidget *space = new QWidget();
    space->setMinimumHeight(5);
    this->layout()->addWidget(space);

    //button
    auto button_box = new QDialogButtonBox(QDialogButtonBox::Ok, Qt::Horizontal, this);
	this->layout()->addWidget(button_box); 
   
    _device_agent->get_config_int16(SR_CONF_OPERATION_MODE, _opt_mode);

    if (_device_agent->is_demo())
        _demo_operation_mode = _device_agent->get_demo_operation_mode();

    try_resize_scroll();
  
    connect(&_mode_check_timer, SIGNAL(timeout()), this, SLOT(mode_check_timeout()));
    connect(button_box, SIGNAL(accepted()), this, SLOT(accept()));

    _mode_check_timer.setInterval(100);
    _mode_check_timer.start();  
}

DeviceOptions::~DeviceOptions()
{   
}

void DeviceOptions::ChannelChecked(int index, QObject *object)
{
    (void)index;
    
    QCheckBox* sc = dynamic_cast<QCheckBox*>(object);
    channel_checkbox_clicked(sc);
}

void DeviceOptions::accept()
{
	using namespace Qt;
    bool hasEnabled = false;

	// Commit the properties
    const auto &dev_props = _device_options_binding.properties();

    for(auto p : dev_props) {
		p->commit();
	}

    // Commit the probes
    int mode = _device_agent->get_work_mode();
    if (mode == LOGIC || mode == ANALOG) {
        int index = 0;
        for (const GSList *l = _device_agent->get_channels(); l; l = l->next) {
            sr_channel *const probe = (sr_channel*)l->data;
            assert(probe);
            probe->enabled = _probes_checkBox_list.at(index)->isChecked();
            index++;
            if (probe->enabled)
                hasEnabled = true;
        }
    }
    else {
        hasEnabled = true;
    }

    if (hasEnabled) {
        auto it = _probe_options_binding_list.begin();
        while(it != _probe_options_binding_list.end()) {
            const auto &probe_props = (*it)->properties();

            for(auto p :probe_props) {
                p->commit();
            }
            it++;
        }

        QDialog::accept();
    }
    else {
        QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_ALL_CHANNEL_DISABLE), "All channel disabled! Please enable at least one channel."));
        MsgBox::Show(strMsg);
    }
}

void DeviceOptions::reject()
{
    using namespace Qt;

    QDialog::reject();
}

QLayout * DeviceOptions::get_property_form(QWidget * parent)
{
    QGridLayout *const layout = new QGridLayout(parent);
    layout->setVerticalSpacing(2);
    const auto &properties =_device_options_binding.properties();

    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);

    int i = 0;
    for(auto p : properties)
	{ 
        const QString label = p->labeled_widget() ? QString() : p->label();       
        QString lable_text = "";

        if (label != ""){
            QByteArray bytes = label.toLocal8Bit();
            const char *lang_str = LangResource::Instance()->get_lang_text(STR_PAGE_DSL, bytes.data(), bytes.data());
            lable_text = QString(lang_str);
        }

        QLabel *lb = new QLabel(lable_text, parent);
        lb->setFont(font);
        layout->addWidget(lb, i, 0);
        
        if (label ==  QString("Operation Mode")){
            QWidget *wid = p->get_widget(parent, true);
            wid->setFont(font);
            layout->addWidget(wid, i, 1);
        }
        else{
            QWidget *wid = p->get_widget(parent);
            wid->setFont(font);
            layout->addWidget(wid, i, 1);
        }
        layout->setRowMinimumHeight(i, 22);
        i++;
	}

    _groupHeight1 = parent->sizeHint().height(); 
    parent->setFixedHeight(_groupHeight1); 

    return layout;
}

void DeviceOptions::logic_probes(QVBoxLayout &layout)
{
	using namespace Qt;

    layout.setSpacing(2);

    int row1 = 0;
    int row2 = 0;
    int vld_ch_num = 0;
    int cur_ch_num = 0;
    int contentHeight = 0;
 
    _probes_checkBox_list.clear();

    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
  
    //channel count checked
    if (_device_agent->get_work_mode()== LOGIC) {
        GVariant * gvar_opts = _device_agent->get_config_list(NULL, SR_CONF_CHANNEL_MODE);

        if (gvar_opts != NULL)
        {
            struct sr_list_item *plist = (struct sr_list_item*)g_variant_get_uint64(gvar_opts);
            g_variant_unref(gvar_opts);

            int ch_mode = 0;
            _device_agent->get_config_int16(SR_CONF_CHANNEL_MODE, ch_mode);
            _channel_mode_indexs.clear();

            while (plist != NULL && plist->id >= 0)
            {
                row1++;
                QString mode_bt_text = LangResource::Instance()->get_lang_text(STR_PAGE_DSL, plist->name, plist->name);
                QRadioButton *mode_button = new QRadioButton(mode_bt_text);
                mode_button->setFont(font);
                ChannelModePair mode_index;
                mode_index.key = mode_button;
                mode_index.value = plist->id;
                _channel_mode_indexs.push_back(mode_index);
                
                layout.addWidget(mode_button); 
                contentHeight += mode_button->sizeHint().height();  //radio button height
                
                connect(mode_button, SIGNAL(pressed()), this, SLOT(channel_check()));
 
                if (plist->id == ch_mode)
                    mode_button->setChecked(true); 

                plist++;
            }
        }
    }

    _device_agent->get_config_int16(SR_CONF_VLD_CH_NUM, vld_ch_num);

    // channels
    QWidget *channel_pannel = new QWidget();
    QGridLayout *channel_grid = new QGridLayout();
    channel_grid->setContentsMargins(0,0,0,0);
    channel_grid->setSpacing(0);
    channel_pannel->setLayout(channel_grid);

    int channel_row = 0;
    int channel_column = 0;
    int channel_line_height = 0;
    row2++;

    for (const GSList *l = _device_agent->get_channels(); l; l = l->next) {
		sr_channel *const probe = (sr_channel*)l->data;
		 
        if (probe->enabled)
            cur_ch_num++;

        if (cur_ch_num > vld_ch_num)
            probe->enabled = false;

        ChannelLabel *ch_item = new ChannelLabel(this, NULL, probe->index);
        channel_grid->addWidget(ch_item, channel_row, channel_column++, Qt::AlignCenter);
        _probes_checkBox_list.push_back(ch_item->getCheckBox());
        ch_item->getCheckBox()->setCheckState(probe->enabled ? Qt::Checked : Qt::Unchecked);
        channel_line_height = ch_item->height();

         if (channel_column == 8){
            channel_column = 0;
            channel_row++;
            
            if (l->next != NULL){
                row2++;
            }
         }
	}

    layout.addWidget(channel_pannel);

    // space
    QWidget *space = new QWidget();
    space->setFixedHeight(10);
    layout.addWidget(space);
    contentHeight += 10;
 
    // buttons
    QHBoxLayout *line_lay = new QHBoxLayout();
    layout.addLayout(line_lay);
    line_lay->setSpacing(10);

    QPushButton *enable_all_probes = new QPushButton(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_ENABLE_ALL), "Enable All"));
    QPushButton *disable_all_probes = new QPushButton(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_DISABLE_ALL), "Disable All"));
    enable_all_probes->setMaximumHeight(30);
    disable_all_probes->setMaximumHeight(30);
    enable_all_probes->setFont(font);
    disable_all_probes->setFont(font);

    int bt_width = enable_all_probes->fontMetrics().horizontalAdvance(enable_all_probes->text()) + 20;
    enable_all_probes->setMaximumWidth(bt_width);
    disable_all_probes->setMaximumWidth(bt_width);

    this->update_font(); 

    contentHeight += enable_all_probes->sizeHint().height();
    contentHeight += channel_line_height * row2 + 50;

    connect(enable_all_probes, SIGNAL(clicked()),
            this, SLOT(enable_all_probes()));
    connect(disable_all_probes, SIGNAL(clicked()),
            this, SLOT(disable_all_probes()));

    line_lay->addWidget(enable_all_probes);
    line_lay->addWidget(disable_all_probes);

    _groupHeight2 = contentHeight + (row1 + row2) * 2 + 38;

#ifdef Q_OS_DARWIN
    _groupHeight2 += 5;
#endif

    _dynamic_panel->setFixedHeight(_groupHeight2); 
}

void DeviceOptions::set_all_probes(bool set)
{ 
    for (auto box : _probes_checkBox_list) {
        box->setCheckState(set ? Qt::Checked : Qt::Unchecked);
    }
}

void DeviceOptions::enable_max_probes() {
    int cur_ch_num = 0; 
    for (auto box : _probes_checkBox_list) {
        if (box->isChecked())
            cur_ch_num++;
    }

    int vld_ch_num;

    if (_device_agent->get_config_int16(SR_CONF_VLD_CH_NUM, vld_ch_num) == false)
        return;

    while(cur_ch_num < vld_ch_num  && cur_ch_num < (int)_probes_checkBox_list.size()) {
        auto box = _probes_checkBox_list[cur_ch_num];
        if (box->isChecked() == false) {
            box->setChecked(true);
            cur_ch_num++;
        } 
    }
}

void DeviceOptions::enable_all_probes()
{   
    bool stream_mode; 

    if (_device_agent->get_config_bool(SR_CONF_STREAM, stream_mode)) {
        if (stream_mode) {
            enable_max_probes();
            return;
        }
    }

	set_all_probes(true);
}

void DeviceOptions::disable_all_probes()
{
	set_all_probes(false);
}

void DeviceOptions::zero_adj()
{
    using namespace Qt;
    QDialog::accept();

    QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_AUTO_CALIB_START), 
                                   "Auto Calibration program will be started. Don't connect any probes. \nIt can take a while!"));
    bool bRet = MsgBox::Confirm(strMsg);

    if (bRet) {
        _device_agent->set_config_bool(SR_CONF_ZERO, true);
    } 
    else {
        _device_agent->set_config_bool(SR_CONF_ZERO, false);
    }
}

void DeviceOptions::on_calibration()
{
    using namespace Qt;
    QDialog::accept();
    _device_agent->set_config_bool(SR_CONF_CALI, true);
}

void DeviceOptions::mode_check_timeout()
{
    if (_isBuilding)
        return;

    if (_device_agent->is_hardware())
    {
        bool test;
        int mode;

        if (_device_agent->get_config_int16(SR_CONF_OPERATION_MODE, mode)) {
            if (mode != _opt_mode) { 
                _opt_mode = mode; 
                build_dynamic_panel();
                try_resize_scroll();
            }
        }

        if (_device_agent->get_config_bool(SR_CONF_TEST, test)) {
            if (test) { 
                for (auto box : _probes_checkBox_list) {
                    box->setCheckState(Qt::Checked);
                    box->setDisabled(true);
                }
            }
        } 
    }
    else if (_device_agent->is_demo())
    {
        QString opt_mode = _device_agent->get_demo_operation_mode();
        if (opt_mode != _demo_operation_mode){
            _demo_operation_mode = opt_mode;
            build_dynamic_panel();
            try_resize_scroll();
        }
    }    
}

void DeviceOptions::channel_check()
{
    QRadioButton* bt = dynamic_cast<QRadioButton*>(sender());
    assert(bt);

    int mode_index = -1;

    for( auto p : _channel_mode_indexs){
        if (p.key == bt){
            mode_index = p.value;
            break;
        }
    }
    assert(mode_index >= 0);
    _device_agent->set_config_int16(SR_CONF_CHANNEL_MODE, mode_index);
  
    build_dynamic_panel();
    try_resize_scroll();
}

void DeviceOptions::analog_channel_check()
{
    QCheckBox* sc=dynamic_cast<QCheckBox*>(sender());
    if(sc != NULL) 
    {
        for (const GSList *l = _device_agent->get_channels(); l; l = l->next) {
            sr_channel *const probe = (sr_channel*)l->data;
            
            if (sc->property("index").toInt() == probe->index){
               _device_agent->set_config_bool(SR_CONF_PROBE_MAP_DEFAULT, sc->isChecked(), probe);
            }
        }
    }

    build_dynamic_panel();
    try_resize_scroll();
}

void DeviceOptions::on_analog_channel_enable()
{
    QCheckBox* sc = dynamic_cast<QCheckBox*>(sender());
    channel_checkbox_clicked(sc);
}

void DeviceOptions::channel_checkbox_clicked(QCheckBox *sc)
{
    if (_device_agent->get_work_mode() == LOGIC) {
        if (sc == NULL || !sc->isChecked())
            return;

        bool stream_mode;
        if (_device_agent->get_config_bool(SR_CONF_STREAM, stream_mode) == false)
            return;

        if (!stream_mode)
            return;

        int cur_ch_num = 0; 
        for (auto box : _probes_checkBox_list) {
            if (box->isChecked())
                cur_ch_num++;
        }

        int vld_ch_num;
        if (_device_agent->get_config_int16(SR_CONF_VLD_CH_NUM, vld_ch_num) == false)
            return;

        if (cur_ch_num > vld_ch_num) {
            QString msg_str(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_MAX_CHANNEL_COUNT_WARNING), "max count of channels!"));
            msg_str = msg_str.replace("{0}", QString::number(vld_ch_num) );
            MsgBox::Show(msg_str);

            sc->setChecked(false);
        }
    }
    else if (_device_agent->get_work_mode() == ANALOG) {
        if (sc != NULL) {
            QGridLayout *const layout = (QGridLayout *)sc->property("Layout").value<void *>();
            int i = layout->count();

            int ck_index = -1;
            int i_dex = 0;
            bool map_default = false;
            
            for(auto ck : _probes_checkBox_list){
                if (ck == sc){
                    ck_index = i_dex;
                    break;
                }
                i_dex++;
            }

            if (ck_index != -1)
            {
                _device_agent->get_config_bool(SR_CONF_PROBE_MAP_DEFAULT,
                                map_default, _dso_channel_list[ck_index], NULL);
            }

            while(i--)
            {
                QWidget* w = layout->itemAt(i)->widget();

                if (w->objectName() == "map-enable"){
                    QCheckBox *map_ckbox = dynamic_cast<QCheckBox*>(w);
                    map_ckbox->isChecked();
                }

                if (w->property("Enable").isNull()) {                    

                    if (map_default && w->objectName() == "map-row"){
                        w->setEnabled(false);
                    }
                    else{
                        w->setEnabled(sc->isChecked());
                    }
                }
            }
        }
    }
} 

void DeviceOptions::analog_probes(QGridLayout &layout)
{
    using namespace Qt;
 
    _probes_checkBox_list.clear();
    _probe_options_binding_list.clear();
    _dso_channel_list.clear();

    QTabWidget *tabWidget = new QTabWidget();
    tabWidget->setTabPosition(QTabWidget::North);
    tabWidget->setUsesScrollButtons(false);

    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
    
    for (const GSList *l = _device_agent->get_channels(); l; l = l->next) {
        sr_channel *const probe = (sr_channel*)l->data;
        assert(probe);

        _dso_channel_list.push_back(probe);

        QWidget *probe_widget = new QWidget(tabWidget);
        QGridLayout *probe_layout = new QGridLayout(probe_widget);
        probe_widget->setLayout(probe_layout); 

        QCheckBox *probe_checkBox = new QCheckBox(this);
        QVariant vlayout = QVariant::fromValue((void *)probe_layout);
        probe_checkBox->setProperty("Layout", vlayout);
        probe_checkBox->setProperty("Enable", true);
        probe_checkBox->setCheckState(probe->enabled ? Qt::Checked : Qt::Unchecked);
        _probes_checkBox_list.push_back(probe_checkBox);

        QLabel *en_label = new QLabel(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_ENABLE), "Enable: "), this);
        en_label->setFont(font);
        en_label->setProperty("Enable", true);
        probe_layout->addWidget(en_label, 0, 0, 1, 1);
        probe_layout->addWidget(probe_checkBox, 0, 1, 1, 3);
        
        auto *probe_options_binding = new dsv::prop::binding::ProbeOptions(probe);
        const auto &properties = probe_options_binding->properties();
        int i = 1;
        
        for(auto p : properties)
        {
            const QString label = p->labeled_widget() ? QString() : p->label();
            QLabel *lb = new QLabel(label, probe_widget);
            lb->setFont(font);
            probe_layout->addWidget(lb, i, 0, 1, 1);

            QWidget * pow = p->get_widget(probe_widget);
            pow->setEnabled(probe_checkBox->isChecked());
            pow->setFont(font);

            if (p->name().contains("Map Default")) {
                pow->setProperty("index", probe->index);
                connect(pow, SIGNAL(clicked()), this, SLOT(analog_channel_check()));
            }
            else {
                if (probe_checkBox->isChecked() && p->name().contains("Map")) {
                    bool map_default = true;

                    _device_agent->get_config_bool(SR_CONF_PROBE_MAP_DEFAULT, map_default, probe, NULL);

                    if (map_default)
                        pow->setEnabled(false);

                    pow->setObjectName("map-row");
                }
            }
            probe_layout->addWidget(pow, i, 1, 1, 3);
            i++;
        }
        _probe_options_binding_list.push_back(probe_options_binding);

        connect(probe_checkBox, SIGNAL(released()), this, SLOT(on_analog_channel_enable()));

        QString tabName = QString::fromUtf8(probe->name);
        tabName += " ";

        tabWidget->addTab(probe_widget, tabName);
    }

    layout.addWidget(tabWidget, 0, 0, 1, 1);

    this->update_font();
    _groupHeight2 = tabWidget->sizeHint().height() + 10;
    _dynamic_panel->setFixedHeight(_groupHeight2); 

    connect(tabWidget, SIGNAL(currentChanged(int)), this, SLOT(on_anlog_tab_changed(int)));
    tabWidget->setCurrentIndex(_cur_analog_tag_index);
}

void DeviceOptions::on_anlog_tab_changed(int index)
{
    _cur_analog_tag_index = index;
}

QString DeviceOptions::dynamic_widget(QLayout *lay)
 { 
    int mode = _device_agent->get_work_mode();

    if (mode == LOGIC) {
        QVBoxLayout *grid = dynamic_cast<QVBoxLayout*>(lay);
        assert(grid);
        logic_probes(*grid);
        //tr
        return L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CHANNEL), "Channel");
    } 
    else if (mode == DSO) {
        bool have_zero;
      
        if (_device_agent->get_config_bool(SR_CONF_HAVE_ZERO, have_zero)) {
            QGridLayout *grid = dynamic_cast<QGridLayout*>(lay);
            assert(grid);

            QFont font = this->font();
            font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);

            if (have_zero) {
                auto config_button = new QPushButton(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_AUTO_CALIBRATION), "Auto Calibration"), this);
                config_button->setFont(font);
                grid->addWidget(config_button, 0, 0, 1, 1);
                connect(config_button, SIGNAL(clicked()), this, SLOT(zero_adj()));

                auto cali_button = new QPushButton(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_MANUAL_CALIBRATION), "Manual Calibration"), this);
                cali_button->setFont(font);
                grid->addWidget(cali_button, 1, 0, 1, 1);
                connect(cali_button, SIGNAL(clicked()), this, SLOT(on_calibration()));

                _groupHeight2 = 100;
                _dynamic_panel->setFixedHeight(_groupHeight2); 

                //tr
                return L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CALIBRATION), "Calibration");
            }
        }
    } 
    else if (mode == ANALOG) {
        QGridLayout *grid = dynamic_cast<QGridLayout*>(lay);
        assert(grid);
        analog_probes(*grid);
        //tr
        return L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CHANNEL), "Channel");
    }
    return NULL;
}

void DeviceOptions::build_dynamic_panel()
{
    _isBuilding = true;

    if (_dynamic_panel != NULL){
        _dynamic_panel->deleteLater();
        _dynamic_panel = NULL;
    }

    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);

    if (_dynamic_panel == NULL)
    {  
        _dynamic_panel = new QGroupBox("group", _dynamic_panel);
        _dynamic_panel->setFont(font);
        _container_lay->addWidget(_dynamic_panel);

        if (_device_agent->get_work_mode() == LOGIC)
            _dynamic_panel->setLayout(new QVBoxLayout());
        else
            _dynamic_panel->setLayout(new QGridLayout());
    }
 
    QString title = dynamic_widget(_dynamic_panel->layout());
    QGroupBox *box = dynamic_cast<QGroupBox*>(_dynamic_panel);
    box->setFont(font);
    box->setTitle(title);

    if (title == ""){ 
        box->setVisible(false);
    }

    _isBuilding = false;
}

int bb = 0;
void DeviceOptions::try_resize_scroll()
{
    this->update_font();

    // content area height
    int contentHeight = _groupHeight1 + _groupHeight2 + 20; // +space
    //dialog height
    int dlgHeight = contentHeight + 100; // +bottom buttton

#ifdef Q_OS_DARWIN
    dlgHeight += 20;
#endif

    float sk = QGuiApplication::primaryScreen()->logicalDotsPerInch() / 96;

    int srcHeight = 600;
    int w = _width;

    if (w == 0)
    {
        w = this->sizeHint().width();
        _width = w;
    }

    QScrollArea *scroll = _scroll;
    if (scroll == NULL)
    {
        scroll = new QScrollArea(_scroll_panel);
        scroll->setWidget(_container_panel);
        scroll->setStyleSheet("QScrollArea{border:none;}");
        scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        _scroll = scroll;
    }

    _container_panel->setFixedHeight(contentHeight);
    int sclw = w - 23;

#ifdef Q_OS_DARWIN
    sclw -= 20;
#endif

    if (sk * dlgHeight > srcHeight)
    {
        int exth = 120;
        this->setFixedSize(w + 12, srcHeight);
        _scroll_panel->setFixedSize(w, srcHeight - exth);
        _scroll->setFixedSize(sclw, srcHeight - exth);
    }
    else
    { 
        this->setFixedSize(w + 12, dlgHeight);
        _scroll_panel->setFixedSize(w, contentHeight);
        _scroll->setFixedSize(sclw, contentHeight);
    }
}

} // namespace dialogs
} // namespace dsv
/****************************************************************************
** Meta object code from reading C++ file 'protocolexp.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "protocolexp.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'protocolexp.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEProtocolExpENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEProtocolExpENDCLASS = QtMocHelpers::stringData(
    "dsv::dialogs::ProtocolExp",
    "export_progress",
    "",
    "percent",
    "cancel_export"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEProtocolExpENDCLASS_t {
    uint offsetsAndSizes[10];
    char stringdata0[26];
    char stringdata1[16];
    char stringdata2[1];
    char stringdata3[8];
    char stringdata4[14];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEProtocolExpENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEProtocolExpENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEProtocolExpENDCLASS = {
    {
        QT_MOC_LITERAL(0, 25),  // "dsv::dialogs::ProtocolExp"
        QT_MOC_LITERAL(26, 15),  // "export_progress"
        QT_MOC_LITERAL(42, 0),  // ""
        QT_MOC_LITERAL(43, 7),  // "percent"
        QT_MOC_LITERAL(51, 13)   // "cancel_export"
    },
    "dsv::dialogs::ProtocolExp",
    "export_progress",
    "",
    "percent",
    "cancel_export"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdialogsSCOPEProtocolExpENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       2,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   26,    2, 0x06,    1 /* Public */,

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       4,    0,   29,    2, 0x08,    3 /* Private */,

 // signals: parameters
    QMetaType::Void, QMetaType::Int,    3,

 // slots: parameters
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dialogs::ProtocolExp::staticMetaObject = { {
    QMetaObject::SuperData::link<DSDialog::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEProtocolExpENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdialogsSCOPEProtocolExpENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEProtocolExpENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<ProtocolExp, std::true_type>,
        // method 'export_progress'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'cancel_export'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::dialogs::ProtocolExp::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<ProtocolExp *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->export_progress((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 1: _t->cancel_export(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (ProtocolExp::*)(int );
            if (_t _q_method = &ProtocolExp::export_progress; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
    }
}

const QMetaObject *dsv::dialogs::ProtocolExp::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dialogs::ProtocolExp::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEProtocolExpENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return DSDialog::qt_metacast(_clname);
}

int dsv::dialogs::ProtocolExp::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = DSDialog::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 2)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 2;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 2)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 2;
    }
    return _id;
}

// SIGNAL 0
void dsv::dialogs::ProtocolExp::export_progress(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#pragma once

#include <QObject>
#include <QWidget>
#include <QStringList>

class QComboBox;

namespace dsv{
namespace dialogs
{
    class ApplicationParamDlg
    { 
    public:
        ApplicationParamDlg();
        ~ApplicationParamDlg();

        bool ShowDlg(QWidget *parent);
 
    private:
        void bind_font_name_list(QComboBox *box, QString v);

        void bind_font_size_list(QComboBox *box, float size);

    private:
        QStringList _font_name_list; 
    };

}//
}//
/****************************************************************************
** Meta object code from reading C++ file 'mathoptions.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "mathoptions.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'mathoptions.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEMathOptionsENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEMathOptionsENDCLASS = QtMocHelpers::stringData(
    "dsv::dialogs::MathOptions"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEMathOptionsENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[26];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEMathOptionsENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEMathOptionsENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEMathOptionsENDCLASS = {
    {
        QT_MOC_LITERAL(0, 25)   // "dsv::dialogs::MathOptions"
    },
    "dsv::dialogs::MathOptions"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdialogsSCOPEMathOptionsENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dialogs::MathOptions::staticMetaObject = { {
    QMetaObject::SuperData::link<DSDialog::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEMathOptionsENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdialogsSCOPEMathOptionsENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEMathOptionsENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<MathOptions, std::true_type>
    >,
    nullptr
} };

void dsv::dialogs::MathOptions::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *dsv::dialogs::MathOptions::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dialogs::MathOptions::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEMathOptionsENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return DSDialog::qt_metacast(_clname);
}

int dsv::dialogs::MathOptions::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = DSDialog::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "calibration.h"  
#include <QGridLayout>
#include <QFuture>
#include <QProgressDialog>
#include <QtConcurrent/QtConcurrent>
#include <QTime>
#include <assert.h>
#include "../view/trace.h"
#include "../dialogs/dsmessagebox.h"
#include "../basedef.h"
#include "../appcore/appcontrol.h"
#include "../appcore/sigsession.h"
#include "../ui/langresource.h"
#include "../ui/msgbox.h"

using namespace std;

namespace dsv {
namespace dialogs {

const QString Calibration::VGAIN = QT_TR_NOOP(" VGAIN");
const QString Calibration::VOFF = QT_TR_NOOP(" VOFF");
const QString Calibration::VCOMB = QT_TR_NOOP(" VCOMB");

Calibration::Calibration(QWidget *parent) :
    DSDialog(parent)
{ 
    _save_btn = NULL;
    _abort_btn = NULL;
    _reset_btn = NULL;
    _exit_btn = NULL;
    _flayout = NULL;

#ifdef Q_OS_DARWIN
    Qt::WindowFlags flags = windowFlags();
    this->setWindowFlags(flags | Qt::Tool);
#endif
    this->setFixedSize(400, 250);
    this->setWindowOpacity(0.7);
    this->setModal(false);

    _device_agent = AppControl::Instance()->GetSession()->get_device();

    _save_btn = new QPushButton(this);
    _abort_btn = new QPushButton(this);
    _reset_btn = new QPushButton(this);
    _exit_btn = new QPushButton(this);

    _flayout = new QFormLayout();
    _flayout->setVerticalSpacing(10);
    _flayout->setFormAlignment(Qt::AlignLeft);
    _flayout->setLabelAlignment(Qt::AlignLeft);
    _flayout->setFieldGrowthPolicy(QFormLayout::AllNonFixedFieldsGrow);
    QGridLayout *glayout = new QGridLayout();
    glayout->setVerticalSpacing(5);

    glayout->addLayout(_flayout, 1, 0, 1, 7);
    glayout->addWidget(_save_btn, 2, 0);
    glayout->addWidget(new QWidget(this), 2, 1);
    glayout->setColumnStretch(1, 1);
    glayout->addWidget(_abort_btn, 2, 2);
    glayout->addWidget(new QWidget(this), 2, 3);
    glayout->setColumnStretch(3, 1);
    glayout->addWidget(_reset_btn, 2, 4);
    glayout->addWidget(new QWidget(this), 2, 5);
    glayout->setColumnStretch(5, 1);
    glayout->addWidget(_exit_btn, 2, 6);

    layout()->addLayout(glayout);

    connect(_save_btn, SIGNAL(clicked()), this, SLOT(on_save()));
    connect(_abort_btn, SIGNAL(clicked()), this, SLOT(on_abort()));
    connect(_reset_btn, SIGNAL(clicked()), this, SLOT(on_reset()));
    connect(_exit_btn, SIGNAL(clicked()), this, SLOT(reject()));

    retranslateUi();
}

Calibration::~Calibration(){ 
    DESTROY_QT_OBJECT(_save_btn);
    DESTROY_QT_OBJECT(_abort_btn);
    DESTROY_QT_OBJECT(_reset_btn);
    DESTROY_QT_OBJECT(_exit_btn);
    DESTROY_QT_OBJECT(_flayout);
}

void Calibration::changeEvent(QEvent *event)
{
    if (event->type() == QEvent::LanguageChange)
        retranslateUi();
    DSDialog::changeEvent(event);
}

void Calibration::retranslateUi()
{
    _save_btn->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SAVE), "Save"));
    _abort_btn->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_ABORT), "Abort"));
    _reset_btn->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_RESET), "Reset"));
    _exit_btn->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_EXIT), "Exit"));

    setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_MANUAL_CALIBRATION), "Manual Calibration"));
}

void Calibration::update_device_info()
{ 
    if (_device_agent->have_instance() == false){
        assert(false);
    }

    for(std::list<QSlider *>::const_iterator i = _slider_list.begin();
        i != _slider_list.end(); i++) {
        (*i)->setParent(NULL);
        _flayout->removeWidget((*i));
        delete (*i);
    }

    _slider_list.clear();
    for(std::list<QLabel *>::const_iterator i = _label_list.begin();
        i != _label_list.end(); i++) {
        (*i)->setParent(NULL);
        _flayout->removeWidget((*i));
        delete (*i);
    }
    _label_list.clear();

    for (const GSList *l = _device_agent->get_channels(); l; l = l->next) {
        sr_channel *const probe = (sr_channel*)l->data;
        assert(probe);

        uint64_t vgain = 0, vgain_default = 0;
        int vgain_range = 0;
        
        _device_agent->get_config_uint64(SR_CONF_PROBE_VGAIN, vgain, probe, NULL);
        _device_agent->get_config_uint64(SR_CONF_PROBE_VGAIN_DEFAULT, vgain_default, probe, NULL);   
        _device_agent->get_config_uint16(SR_CONF_PROBE_VGAIN_RANGE, vgain_range, probe, NULL);

        QSlider *gain_slider = new QSlider(Qt::Horizontal, this);
        gain_slider->setRange(-vgain_range/2, vgain_range/2);
        gain_slider->setValue(vgain - vgain_default);
        gain_slider->setObjectName(VGAIN+probe->index);
        QString gain_string = L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CHANNEL), "Channel") + QString::number(probe->index) + VGAIN;
        QLabel *gain_label = new QLabel(gain_string, this);
        _flayout->addRow(gain_label, gain_slider);
        _slider_list.push_back(gain_slider);
        _label_list.push_back(gain_label);

        uint64_t voff = 0;
        uint16_t voff_range = 0;
        int v;
 
        if (_device_agent->get_config_uint16(SR_CONF_PROBE_PREOFF, v, probe, NULL)) {
            voff = (uint64_t)v;
        }
        if (_device_agent->get_config_uint16(SR_CONF_PROBE_PREOFF_MARGIN, v, probe, NULL)) {
            voff_range = (uint16_t)v;
        }

        QSlider *off_slider = new QSlider(Qt::Horizontal, this);
        off_slider->setRange(0, voff_range);
        off_slider->setValue(voff);
        off_slider->setObjectName(VOFF+probe->index);
        QString off_string = L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CHANNEL), "Channel") + QString::number(probe->index) + VOFF;
        QLabel *off_label = new QLabel(off_string, this);
        _flayout->addRow(off_label, off_slider);
        _slider_list.push_back(off_slider);
        _label_list.push_back(off_label);

        bool comb_comp_en = false;
        _device_agent->get_config_bool(SR_CONF_PROBE_COMB_COMP_EN, comb_comp_en);

        if (comb_comp_en) {
            int comb_comp = 0;
           _device_agent->get_config_int16(SR_CONF_PROBE_COMB_COMP, comb_comp, probe, NULL);

            QSlider *comp_slider = new QSlider(Qt::Horizontal, this);
            comp_slider->setRange(-127, 127);
            comp_slider->setValue(comb_comp);
            comp_slider->setObjectName(VCOMB+probe->index);
            QString comp_string = L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CHANNEL), "Channel") + QString::number(probe->index) + VCOMB;
            QLabel *comp_label = new QLabel(comp_string, this);
            _flayout->addRow(comp_label, comp_slider);
            _slider_list.push_back(comp_slider);
            _label_list.push_back(comp_label);
            connect(comp_slider, SIGNAL(valueChanged(int)), this, SLOT(set_value(int)));
        }

        connect(gain_slider, SIGNAL(valueChanged(int)), this, SLOT(set_value(int)));
        connect(off_slider, SIGNAL(valueChanged(int)), this, SLOT(set_value(int)));
    }

    update();
}

void Calibration::accept()
{
    using namespace Qt;
    _device_agent->set_config_bool(SR_CONF_CALI, false);
    QDialog::accept();
}

void Calibration::reject()
{
    using namespace Qt;
    _device_agent->set_config_bool(SR_CONF_CALI, false);
    QDialog::reject();
}

void Calibration::set_value(int value)
{
    QSlider* sc = dynamic_cast<QSlider *>(sender());

    for (const GSList *l = _device_agent->get_channels(); l; l = l->next) {
        sr_channel *const probe = (sr_channel*)l->data;
        assert(probe);
        if (sc->objectName() == VGAIN+probe->index) {
            uint64_t vgain_default;
            if (_device_agent->get_config_uint64(SR_CONF_PROBE_VGAIN_DEFAULT, vgain_default, probe))
            {
                _device_agent->set_config_uint64(SR_CONF_PROBE_VGAIN, value+vgain_default, probe);          
            }
            break;
        }
        else if (sc->objectName() == VOFF+probe->index) {
           _device_agent->set_config_uint16(SR_CONF_PROBE_PREOFF, value, probe); 
            break;
        } else if (sc->objectName() == VCOMB+probe->index) {
            _device_agent->set_config_int16(SR_CONF_PROBE_COMB_COMP, value, probe);
            break;
        }
    }
}

void Calibration::on_save()
{
    this->hide();
    QFuture<void> future;

    future = QtConcurrent::run([&]{
        _device_agent->set_config_bool( SR_CONF_ZERO_SET, true);
    });

    Qt::WindowFlags flags = Qt::CustomizeWindowHint;
    QProgressDialog dlg(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SAVE_CALIBRATION_RESULTS), 
                        "Save calibration results... It can take a while."),
                        L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CANCEL), "Cancel"),
                        0,0,this,flags);
    dlg.setWindowModality(Qt::WindowModal);
    dlg.setWindowFlags(Qt::Dialog | Qt::FramelessWindowHint | Qt::WindowSystemMenuHint |
                       Qt::WindowMinimizeButtonHint | Qt::WindowMaximizeButtonHint);
    dlg.setCancelButton(NULL);

    QFutureWatcher<void> watcher;
    connect(&watcher,SIGNAL(finished()),&dlg,SLOT(cancel()));
    watcher.setFuture(future);

    dlg.exec();
    this->show();
}

void Calibration::on_abort()
{
    this->hide();
    QFuture<void> future;

    future = QtConcurrent::run([&]{ 
        _device_agent->set_config_bool(SR_CONF_ZERO_LOAD, true);
        reload_value();
    });

    Qt::WindowFlags flags = Qt::CustomizeWindowHint;
    QProgressDialog dlg(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_RELOAD_CALIBRATION_RESULTS), 
                        "Reload last calibration results... It can take a while."),
                        L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CANCEL), "Cancel"),0,0,this,flags);
    dlg.setWindowModality(Qt::WindowModal);
    dlg.setWindowFlags(Qt::Dialog | Qt::FramelessWindowHint | Qt::WindowSystemMenuHint |
                       Qt::WindowMinimizeButtonHint | Qt::WindowMaximizeButtonHint);
    dlg.setCancelButton(NULL);

    QFutureWatcher<void> watcher;
    connect(&watcher,SIGNAL(finished()),&dlg,SLOT(cancel()));
    watcher.setFuture(future);

    dlg.exec();
    this->show();
}

void Calibration::reload_value()
{
    for (const GSList *l = _device_agent->get_channels(); l; l = l->next) {
        sr_channel *const probe = (sr_channel*)l->data;
        assert(probe);

        uint64_t vgain = 0, vgain_default = 0;
        int vgain_range = 0;
        _device_agent->get_config_uint64(SR_CONF_PROBE_VGAIN, vgain, probe, NULL);
        _device_agent->get_config_uint64(SR_CONF_PROBE_VGAIN_DEFAULT, vgain_default, probe, NULL);   
        _device_agent->get_config_uint16(SR_CONF_PROBE_VGAIN_RANGE, vgain_range, probe, NULL);

        int voff = 0;
        int voff_range = 0;

        _device_agent->get_config_uint16(SR_CONF_PROBE_PREOFF, voff, probe, NULL);
        _device_agent->get_config_uint16(SR_CONF_PROBE_PREOFF_MARGIN, voff_range, probe, NULL);

        for(std::list<QSlider*>::iterator i = _slider_list.begin();
            i != _slider_list.end(); i++) {
            if ((*i)->objectName() == VGAIN+probe->index) {
                (*i)->setRange(-vgain_range/2, vgain_range/2);
                (*i)->setValue(vgain - vgain_default);
            } else if ((*i)->objectName() == VOFF+probe->index) {
                (*i)->setRange(0, voff_range);
                (*i)->setValue(voff);
            }
        }
    }
}

void Calibration::on_reset()
{
    QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_SET_DEF_CAL_SETTING), 
        "All calibration settings will become the defualt values!"));

    if (MsgBox::Confirm(strMsg)) {
        _device_agent->set_config_bool(SR_CONF_ZERO_DEFAULT, true);
        reload_value();
    }
}

} // namespace dialogs
} // namespace dsv
/****************************************************************************
** Meta object code from reading C++ file 'decoderoptionsdlg.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "decoderoptionsdlg.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'decoderoptionsdlg.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDecoderOptionsDlgENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDecoderOptionsDlgENDCLASS = QtMocHelpers::stringData(
    "dsv::dialogs::DecoderOptionsDlg",
    "on_probe_selected",
    "",
    "on_region_set",
    "index",
    "on_accept",
    "on_trans_pramas"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDecoderOptionsDlgENDCLASS_t {
    uint offsetsAndSizes[14];
    char stringdata0[32];
    char stringdata1[18];
    char stringdata2[1];
    char stringdata3[14];
    char stringdata4[6];
    char stringdata5[10];
    char stringdata6[16];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDecoderOptionsDlgENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDecoderOptionsDlgENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDecoderOptionsDlgENDCLASS = {
    {
        QT_MOC_LITERAL(0, 31),  // "dsv::dialogs::DecoderOptionsDlg"
        QT_MOC_LITERAL(32, 17),  // "on_probe_selected"
        QT_MOC_LITERAL(50, 0),  // ""
        QT_MOC_LITERAL(51, 13),  // "on_region_set"
        QT_MOC_LITERAL(65, 5),  // "index"
        QT_MOC_LITERAL(71, 9),  // "on_accept"
        QT_MOC_LITERAL(81, 15)   // "on_trans_pramas"
    },
    "dsv::dialogs::DecoderOptionsDlg",
    "on_probe_selected",
    "",
    "on_region_set",
    "index",
    "on_accept",
    "on_trans_pramas"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdialogsSCOPEDecoderOptionsDlgENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       4,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   38,    2, 0x08,    1 /* Private */,
       3,    1,   41,    2, 0x08,    3 /* Private */,
       5,    0,   44,    2, 0x08,    5 /* Private */,
       6,    0,   45,    2, 0x08,    6 /* Private */,

 // slots: parameters
    QMetaType::Void, QMetaType::Int,    2,
    QMetaType::Void, QMetaType::Int,    4,
    QMetaType::Void,
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dialogs::DecoderOptionsDlg::staticMetaObject = { {
    QMetaObject::SuperData::link<DSDialog::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDecoderOptionsDlgENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdialogsSCOPEDecoderOptionsDlgENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDecoderOptionsDlgENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<DecoderOptionsDlg, std::true_type>,
        // method 'on_probe_selected'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'on_region_set'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'on_accept'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_trans_pramas'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::dialogs::DecoderOptionsDlg::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<DecoderOptionsDlg *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->on_probe_selected((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 1: _t->on_region_set((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 2: _t->on_accept(); break;
        case 3: _t->on_trans_pramas(); break;
        default: ;
        }
    }
}

const QMetaObject *dsv::dialogs::DecoderOptionsDlg::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dialogs::DecoderOptionsDlg::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDecoderOptionsDlgENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return DSDialog::qt_metacast(_clname);
}

int dsv::dialogs::DecoderOptionsDlg::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = DSDialog::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 4)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 4;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 4)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 4;
    }
    return _id;
}
QT_WARNING_POP
/****************************************************************************
** Meta object code from reading C++ file 'protocollist.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "protocollist.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'protocollist.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEProtocolListENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEProtocolListENDCLASS = QtMocHelpers::stringData(
    "dsv::dialogs::ProtocolList",
    "set_protocol",
    "",
    "index",
    "on_row_check",
    "show",
    "on_set_map_zoom"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEProtocolListENDCLASS_t {
    uint offsetsAndSizes[14];
    char stringdata0[27];
    char stringdata1[13];
    char stringdata2[1];
    char stringdata3[6];
    char stringdata4[13];
    char stringdata5[5];
    char stringdata6[16];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEProtocolListENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEProtocolListENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEProtocolListENDCLASS = {
    {
        QT_MOC_LITERAL(0, 26),  // "dsv::dialogs::ProtocolList"
        QT_MOC_LITERAL(27, 12),  // "set_protocol"
        QT_MOC_LITERAL(40, 0),  // ""
        QT_MOC_LITERAL(41, 5),  // "index"
        QT_MOC_LITERAL(47, 12),  // "on_row_check"
        QT_MOC_LITERAL(60, 4),  // "show"
        QT_MOC_LITERAL(65, 15)   // "on_set_map_zoom"
    },
    "dsv::dialogs::ProtocolList",
    "set_protocol",
    "",
    "index",
    "on_row_check",
    "show",
    "on_set_map_zoom"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdialogsSCOPEProtocolListENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       3,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   32,    2, 0x08,    1 /* Private */,
       4,    1,   35,    2, 0x08,    3 /* Private */,
       6,    1,   38,    2, 0x08,    5 /* Private */,

 // slots: parameters
    QMetaType::Void, QMetaType::Int,    3,
    QMetaType::Void, QMetaType::Bool,    5,
    QMetaType::Void, QMetaType::Int,    3,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dialogs::ProtocolList::staticMetaObject = { {
    QMetaObject::SuperData::link<DSDialog::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEProtocolListENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdialogsSCOPEProtocolListENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEProtocolListENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<ProtocolList, std::true_type>,
        // method 'set_protocol'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'on_row_check'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>,
        // method 'on_set_map_zoom'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>
    >,
    nullptr
} };

void dsv::dialogs::ProtocolList::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<ProtocolList *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->set_protocol((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 1: _t->on_row_check((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        case 2: _t->on_set_map_zoom((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        default: ;
        }
    }
}

const QMetaObject *dsv::dialogs::ProtocolList::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dialogs::ProtocolList::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEProtocolListENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return DSDialog::qt_metacast(_clname);
}

int dsv::dialogs::ProtocolList::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = DSDialog::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 3)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 3;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 3)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 3;
    }
    return _id;
}
QT_WARNING_POP
/****************************************************************************
** Meta object code from reading C++ file 'shadow.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "shadow.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'shadow.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEShadowENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEShadowENDCLASS = QtMocHelpers::stringData(
    "dsv::dialogs::Shadow"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEShadowENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[21];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEShadowENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEShadowENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEShadowENDCLASS = {
    {
        QT_MOC_LITERAL(0, 20)   // "dsv::dialogs::Shadow"
    },
    "dsv::dialogs::Shadow"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdialogsSCOPEShadowENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dialogs::Shadow::staticMetaObject = { {
    QMetaObject::SuperData::link<QGraphicsEffect::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEShadowENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdialogsSCOPEShadowENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEShadowENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<Shadow, std::true_type>
    >,
    nullptr
} };

void dsv::dialogs::Shadow::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *dsv::dialogs::Shadow::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dialogs::Shadow::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEShadowENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QGraphicsEffect::qt_metacast(_clname);
}

int dsv::dialogs::Shadow::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QGraphicsEffect::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2015 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_LISSAJOUSOPTIONS_H
#define DSVIEW_PV_LISSAJOUSOPTIONS_H

#include <QGridLayout>
#include <QToolButton>
#include <QDialogButtonBox>
#include <QTabWidget>
#include <QGroupBox>
#include <QCheckBox>
#include <QRadioButton>
#include <QSlider>
#include "../view/dsosignal.h"
#include "../toolbars/titlebar.h"
#include "dsdialog.h"

namespace dsv {

namespace appcore {
    class SigSession;
}

namespace view {
class View;
}

namespace dialogs {

class LissajousOptions : public DSDialog
{
	Q_OBJECT

private:
    static const int WellLen = SR_Kn(16);

public:
    LissajousOptions(SigSession *session, QWidget *parent);

private:
    void changeEvent(QEvent *event);
    void retranslateUi();

protected:
	void accept();
    void reject();

private:
    SigSession *_session;

    QCheckBox *_enable;
    QGroupBox *_x_group;
    QGroupBox *_y_group;
    QSlider *_percent;
    QGridLayout *_layout;

    QVector<QRadioButton *> _x_radio;
    QVector<QRadioButton *> _y_radio;
    QDialogButtonBox _button_box;  
};

} // namespace dialogs
} // namespace dsv

#endif // DSVIEW_PV_LISSAJOUSOPTIONS_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_CALIBRATION_H
#define DSVIEW_PV_CALIBRATION_H

#include <QDialogButtonBox>
#include <QPushButton>
#include <QLabel>
#include <QFormLayout>
#include <QSlider>

#include <list> 
#include "../toolbars/titlebar.h"
#include "dsdialog.h"

namespace dsv{
	namespace appcore{
    	class SigSession;
        class DeviceAgent;
	}
}
using namespace dsv::appcore;
 
namespace dsv { 
namespace dialogs {

class Calibration : public DSDialog
{
	Q_OBJECT

private:
    static const QString VGAIN;
    static const QString VOFF;
    static const QString VCOMB;

public:
    Calibration(QWidget *parent);
    ~Calibration();

    void update_device_info();
    
protected:
	void accept();
    void reject();

private:
    void changeEvent(QEvent *event);
    void retranslateUi();

private slots:
    void set_value(int value);
    void on_save();
    void on_abort();
    void on_reset();
    void reload_value();

private:  
    QPushButton *_save_btn;
    QPushButton *_abort_btn;
    QPushButton *_reset_btn;
    QPushButton *_exit_btn;
    QFormLayout *_flayout;
    std::list <QSlider *> _slider_list;
    std::list<QLabel *> _label_list;

    DeviceAgent *_device_agent;
};

} // namespace dialogs
} // namespace dsv

#endif // DSVIEW_PV_CALIBRATION_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#include "dsmessagebox.h"
#include <QObject>
#include <QEvent>
#include <QMouseEvent>
#include <QVBoxLayout>
#include <QAbstractButton>
#include "shadow.h"
#include "../basedef.h"
#include "../ui/langresource.h"
#include "../config/appconfig.h"
#include "../ui/fn.h"

using namespace dsv::config;

namespace dsv {
namespace dialogs {

DSMessageBox::DSMessageBox(QWidget *parent,const QString title) :
    QDialog(parent)
{
    (void)parent;
    _layout = NULL;
    _main_widget = NULL;
    _msg = NULL;
    _titlebar = NULL;
    _shadow = NULL;  
    _main_layout = NULL;

    _bClickYes = false;

    setWindowFlags(Qt::Dialog | Qt::FramelessWindowHint | Qt::WindowSystemMenuHint);
    setAttribute(Qt::WA_TranslucentBackground);

    _main_widget = new QWidget(this);
    _main_layout = new QVBoxLayout(_main_widget);
    _main_widget->setLayout(_main_layout);  

    _shadow = new Shadow(this);
    _msg = new QMessageBox(this);
    _titlebar = new toolbars::TitleBar(false, this);
    _layout = new QVBoxLayout(this);
 
    _shadow->setBlurRadius(10.0);
    _shadow->setDistance(3.0);
    _shadow->setColor(QColor(0, 0, 0, 80));

    _main_widget->setAutoFillBackground(true);
    this->setGraphicsEffect(_shadow);  

    _msg->setWindowFlags(Qt::Dialog | Qt::FramelessWindowHint | Qt::WindowSystemMenuHint);   

    if (!title.isEmpty()){
        _titlebar->setTitle(title);
    }
    else{
        _titlebar->setTitle(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_MESSAGE), "Message"));
    }
    
    _main_layout->addWidget(_titlebar);
    _main_layout->addWidget(_msg);   
    _layout->addWidget(_main_widget);

    setLayout(_layout); 

    connect(_msg, SIGNAL(buttonClicked(QAbstractButton*)), this, SLOT(on_button(QAbstractButton*)));
}


DSMessageBox::~DSMessageBox()
{
    DESTROY_QT_OBJECT(_layout);
    DESTROY_QT_OBJECT(_main_widget);
    DESTROY_QT_OBJECT(_msg);
    DESTROY_QT_OBJECT(_titlebar);
    DESTROY_QT_OBJECT(_shadow);
    DESTROY_QT_OBJECT(_main_layout);
}

void DSMessageBox::accept()
{
    using namespace Qt;

    QDialog::accept();
}

void DSMessageBox::reject()
{
    using namespace Qt;

    QDialog::reject();
}
  
QMessageBox* DSMessageBox::mBox()
{
    return _msg;
}
  
void DSMessageBox::on_button(QAbstractButton *btn)
{
    QMessageBox::ButtonRole role = _msg->buttonRole(btn);

    if (role == QMessageBox::AcceptRole || role == QMessageBox::YesRole){
        _bClickYes = true;
         accept();
    } 
    else
        reject();
}

int DSMessageBox::exec()
{
    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
    ui::set_form_font(this, font);

    if (_titlebar != NULL){
        _titlebar->update_font();
    }

    return QDialog::exec();
}

} // namespace dialogs
} // namespace dsv
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2014 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "storeprogress.h" 
#include <QGridLayout>
#include <QDialogButtonBox>
#include <QTimer>
#include <QTextEdit>
#include <QPushButton>
#include <QRadioButton>
#include "../appcore/sigsession.h"
#include "../ui/msgbox.h"
#include "../config/appconfig.h"
#include "../interface/icallbacks.h"
#include "../log.h"
#include "../ui/langresource.h"

using namespace dsv::config;

namespace dsv {
namespace dialogs {

StoreProgress::StoreProgress(SigSession *session, QWidget *parent) :
    DSDialog(parent),
    _store_session(session)
{
    _fileLab = NULL;
    _ckOrigin = NULL;

    this->setMinimumSize(550, 220);
    this->setModal(true);
 
    _progress.setValue(0);
    _progress.setMaximum(100);

    _isExport = false;
    _done = false;
    _isBusy = false;

    QGridLayout *grid = new QGridLayout(); 
    _grid = grid;
    grid->setContentsMargins(10, 20, 10, 10);
    grid->setVerticalSpacing(25);

    grid->setColumnStretch(0, 2);
    grid->setColumnStretch(1, 2);
    grid->setColumnStretch(2, 1);
    grid->setColumnStretch(3, 1);

    _fileLab = new QTextEdit();
    _fileLab->setReadOnly(true);   
    _fileLab->setObjectName("PathLine");
    _fileLab->setMaximumHeight(50); 

    _openButton = new QPushButton(this);
    _openButton->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_PATH_NAME), "path"));

    _space = new QWidget(this);
    _space->setMinimumHeight(80);
    _space->setVisible(false);

    grid->addWidget(&_progress, 0, 0, 1, 4);
    grid->addWidget(_fileLab, 1, 0, 1, 3);
    grid->addWidget(_openButton, 1, 3, 1, 1);    
    grid->addWidget(_space);

    QDialogButtonBox  *_button_box = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel, 
                                        Qt::Horizontal, this);
    grid->addWidget(_button_box, 2, 2, 1, 2, Qt::AlignRight | Qt::AlignBottom);

    layout()->addLayout(grid);

    connect(_button_box, SIGNAL(rejected()), this, SLOT(reject()));
    connect(_button_box, SIGNAL(accepted()), this, SLOT(accept()));

    connect(&_store_session, SIGNAL(progress_updated()),
        this, SLOT(on_progress_updated()), Qt::QueuedConnection);

    connect(_openButton, SIGNAL(clicked()),this, SLOT(on_change_file()));

    _progress.setVisible(false);
}

StoreProgress::~StoreProgress()
{
    _store_session.wait();
}

 void StoreProgress::on_change_file()
 {
    QString file  = "";
    if (_isExport)
        file = _store_session.MakeExportFile(true);
    else
        file = _store_session.MakeSaveFile(true);

    if (file != ""){
        _fileLab->setText(file); 

        if (_ckOrigin != NULL){
            bool bFlag = file.endsWith(".csv");
            _ckOrigin->setVisible(bFlag);
            _ckCompress->setVisible(bFlag);
        }
    }          
 }

void StoreProgress::reject()
{
    using namespace Qt;
    _store_session.cancel();
    _store_session.session()->set_saving(false);
    save_done(); 
    DSDialog::reject();
    _store_session.session()->broadcast_msg(DSV_MSG_SAVE_COMPLETE);
}

void StoreProgress::accept()
{
    if (_store_session.GetFileName() == ""){
        MsgBox::Show(NULL, L_S(STR_PAGE_MSG, S_ID(IDS_MSG_SEL_FILENAME), "You need to select a file name."));
        return;
    }

    if (_isBusy)
        return;
    
     _progress.setVisible(true);
     _fileLab->setVisible(false);     
     _fileLab->setVisible(false);
     _openButton->setVisible(false);

     if (_ckOrigin != NULL){
        _ckOrigin->setVisible(false);
        _ckCompress->setVisible(false);
     }
     _space->setVisible(true);


    if (_isExport && _store_session.IsLogicDataType()){
        bool ck  = _ckOrigin->isChecked();
        AppConfig &app = AppConfig::Instance();
        if (app.appOptions.originalData != ck){
            app.appOptions.originalData = ck;
            app.SaveApp();
        }
    }

    //start done 
    if (_isExport){
        if (_store_session.export_start()){
            _isBusy = true;
            _store_session.session()->set_saving(true);
            QTimer::singleShot(100, this, SLOT(timeout()));
            setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_EXPORTING), "Exporting..."));    
        }
        else{
            save_done();
            close(); 
            show_error();
        }
    }
    else{
         if (_store_session.save_start()){
            _isBusy = true;
            _store_session.session()->set_saving(true);
            QTimer::singleShot(100, this, SLOT(timeout()));
            setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SAVING), "Saving..."));
        }
        else{
            save_done();
            close(); 
            show_error();
        }
    }
    //do not to call base class method, otherwise the window will be closed;
}

void StoreProgress::timeout()
{
    if (_done) {
        _store_session.session()->set_saving(false);
        save_done();
        close(); 
        delete this;
        
    } else {
        QTimer::singleShot(100, this, SLOT(timeout()));
    }
}

void StoreProgress::save_run(ISessionDataGetter *getter)
{
    _isExport = false;
    setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SAVE), "Save"));
    QString file = _store_session.MakeSaveFile(false);
    _fileLab->setText(file); 
    _store_session._sessionDataGetter = getter;
    show();  
}

void StoreProgress::export_run()
{
    if (_store_session.IsLogicDataType())
    { 
        QGridLayout *lay = new QGridLayout();
        lay->setContentsMargins(5, 0, 0, 0); 
        bool isOrg = AppConfig::Instance().appOptions.originalData;

        _ckOrigin  = new QRadioButton();
        _ckOrigin->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_ORIGINAL_DATA), "Original data"));   
        _ckOrigin->setChecked(isOrg);       

        _ckCompress  = new QRadioButton();
        _ckCompress->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_COMPRESSED_DATA), "Compressed data"));
        _ckCompress->setChecked(!isOrg);

        lay->addWidget(_ckOrigin);
        lay->addWidget(_ckCompress);
        _grid->addLayout(lay, 2, 0, 1, 2);

        connect(_ckOrigin, SIGNAL(clicked(bool)), this, SLOT(on_ck_origin(bool)));
        connect(_ckCompress, SIGNAL(clicked(bool)), this, SLOT(on_ck_compress(bool)));
    }

    _isExport = true;
    setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_EXPORT), "Export"));
    QString file = _store_session.MakeExportFile(false);
    _fileLab->setText(file); 

     if (_ckOrigin != NULL){
            bool bFlag = file.endsWith(".csv");
            _ckOrigin->setVisible(bFlag);
            _ckCompress->setVisible(bFlag);
     }

    show();
}

void StoreProgress::show_error()
{
    _done = true;
    if (!_store_session.error().isEmpty()) { 
        MsgBox::Show(NULL, _store_session.error().toStdString().c_str(), NULL);
    }
}

void StoreProgress::closeEvent(QCloseEvent* e)
{ 
    _store_session.cancel();
    _store_session.session()->set_saving(false);
    DSDialog::closeEvent(e);
    _store_session.session()->broadcast_msg(DSV_MSG_SAVE_COMPLETE);
}

void StoreProgress::on_progress_updated()
{
    const std::pair<uint64_t, uint64_t> p = _store_session.progress();
	assert(p.first <= p.second);
    int percent = p.first * 1.0 / p.second * 100;
    _progress.setValue(percent);

    const QString err = _store_session.error();
	if (!err.isEmpty()) {
		show_error();
	}

    if (p.first == p.second) {
        _done = true;
    }
}

void StoreProgress::on_ck_origin(bool ck)
{
    if (ck){
        _ckCompress->setChecked(false);
    }
}

void StoreProgress::on_ck_compress(bool ck)
{
    if (ck){
        _ckOrigin->setChecked(false);
    }
}

} // dialogs
} // pv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "regionoptions.h" 
#include "../appcore/sigsession.h"
#include "../view/cursor.h"
#include "../view/view.h"
#include "../ui/langresource.h"

using namespace boost;
using namespace std;

namespace dsv {
namespace dialogs {

const QString RegionOptions::RegionStart = QT_TR_NOOP("Start");
const QString RegionOptions::RegionEnd = QT_TR_NOOP("End");

RegionOptions::RegionOptions(view::View *view, SigSession *session, QWidget *parent) :
    DSDialog(parent),
    _session(session),
    _view(view),
    _button_box(QDialogButtonBox::Ok,
        Qt::Horizontal, this)
{
    QHBoxLayout *hlayout = new QHBoxLayout();
    hlayout->setContentsMargins(0,0,0,0);
    hlayout->setSpacing(0);
    _start_comboBox = new DsComboBox(this);
    _end_comboBox = new DsComboBox(this);
    _start_comboBox->addItem(RegionStart);
    _end_comboBox->addItem(RegionEnd);

    if (_view) {
        int index = 1;
        auto &cursor_list = _view->get_cursorList();

        for(auto i = cursor_list.begin(); i != cursor_list.end(); i++) {
            QString curCursor = L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CURSOR), "Cursor")+QString::number(index);
            _start_comboBox->addItem(curCursor);
            _end_comboBox->addItem(curCursor);
            index++;
        }
    }

    hlayout->addWidget(new QLabel("Start: ", this));
    hlayout->addWidget(_start_comboBox);
    hlayout->addWidget(new QLabel("    ", this));
    hlayout->addWidget(new QLabel("End: ", this));
    hlayout->addWidget(_end_comboBox);

    QVBoxLayout *vlayout = new QVBoxLayout();
    vlayout->addLayout(hlayout);
    vlayout->addWidget(&_button_box);

    layout()->addLayout(vlayout);
    setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_REGION), "Region"));

    connect(&_button_box, SIGNAL(accepted()), this, SLOT(set_region()));
    connect(_session->device_event_object(), SIGNAL(device_updated()), this, SLOT(reject()));

}

void RegionOptions::set_region()
{
    const uint64_t last_samples = _session->cur_samplelimits() - 1;
    const int index1 = _start_comboBox->currentIndex();
    const int index2 = _end_comboBox->currentIndex();
    uint64_t start, end;

    _session->set_save_start(0);
    _session->set_save_end(last_samples);

    if (index1 == 0) {
        start = 0;
    } else {
        start = _view->get_cursor_samples(index1-1);
    }
    if (index2 == 0) {
        end = last_samples;
    } else {
        end = _view->get_cursor_samples(index2-1);
    }

    if (start > last_samples)
        start = 0;
    if (end > last_samples)
        end = last_samples;

    _session->set_save_start(min(start, end));
    _session->set_save_end(max(start, end));

    QDialog::accept();
}

} // namespace dialogs
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_DEVICEOPTIONS_H
#define DSVIEW_PV_DEVICEOPTIONS_H

#include <libsigrok.h> 
#include <QDialog>
#include <QDialogButtonBox>
#include <QGroupBox>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGridLayout>
#include <QPushButton>
#include <QLabel>
#include <QCheckBox>
#include <QRadioButton>
#include <QTimer> 
#include <QWidget>
#include <vector> 
#include "../prop/binding/deviceoptions.h"
#include "../prop/binding/probeoptions.h"
#include "../toolbars/titlebar.h"
#include "../dialogs/dsdialog.h"
#include "../ui/dscombobox.h"

class QScrollArea;

namespace dsv{
	namespace appcore{
    	class SigSession;
        class DeviceAgent;
	}
}
using namespace dsv::appcore;

class IChannelCheck
{
public:
    virtual void ChannelChecked(int index, QObject *object)=0;
};

class ChannelLabel : public QWidget 
{
Q_OBJECT

public:
    ChannelLabel(IChannelCheck *check, QWidget *parent, int chanIndex);

    inline QCheckBox* getCheckBox(){
        return _box;
    }

private slots:
    void on_checked();

private:
    QCheckBox *_box;
    IChannelCheck *_checked;
    int     _index;
};

struct ChannelModePair
{
    void *key;
    int  value;
};

namespace dsv {
namespace dialogs {

class DeviceOptions : public DSDialog, public IChannelCheck
{
	Q_OBJECT

public:
    DeviceOptions(QWidget *parent);

    ~DeviceOptions();

protected:
	void accept();
    void reject();

private:
    QLayout *get_property_form(QWidget *parent);

    void logic_probes(QVBoxLayout& layout);
    void analog_probes(QGridLayout& layout);
    QString dynamic_widget(QLayout *lay); 

	void set_all_probes(bool set);
    void enable_max_probes(); 
    void build_dynamic_panel();
    void try_resize_scroll();

    void channel_checkbox_clicked(QCheckBox *sc);

private:
    //IChannelCheck
    void ChannelChecked(int index, QObject *object);

private slots:
	void enable_all_probes();
	void disable_all_probes();
    void zero_adj();
    void mode_check_timeout();
    void channel_check();
    void analog_channel_check();
    void on_calibration();
    void on_analog_channel_enable();
    void on_anlog_tab_changed(int index);
    
private: 
    std::vector<QCheckBox *> _probes_checkBox_list;

    QTimer      _mode_check_timer;
    int         _opt_mode;  
    QWidget     *_scroll_panel;
    QScrollArea *_scroll;
    QWidget     *_container_panel;
    QVBoxLayout *_container_lay;   
    QWidget     *_dynamic_panel;
   // QWidget     *_dynamic_panel;
    int     _width;
    int     _groupHeight1;
    int     _groupHeight2;
    volatile    bool _isBuilding;
    DeviceAgent *_device_agent;
    int     _cur_analog_tag_index;
    QString _demo_operation_mode;

	dsv::prop::binding::DeviceOptions _device_options_binding;
    std::vector<dsv::prop::binding::ProbeOptions *> _probe_options_binding_list;
    std::vector<ChannelModePair> _channel_mode_indexs;
    std::vector<struct sr_channel*>     _dso_channel_list;
};

} // namespace dialogs
} // namespace dsv

#endif // DSVIEW_PV_DEVICEOPTIONS_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2015 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "dsomeasure.h"
#include <QCheckBox>
#include <QVariant>
#include <QLabel>
#include <QTabBar>
#include <QBitmap> 
#include "../appcore/sigsession.h"
#include "../view/view.h"
#include "../basedef.h"
#include "../ui/langresource.h"

using namespace std;
using namespace dsv::view;

namespace dsv {
namespace dialogs {

DsoMeasure::DsoMeasure(SigSession *session, View &parent,
                       unsigned int position, int last_sig_index) :
    DSDialog((QWidget *)&parent),
    _session(session),
    _view(parent),
    _position(position),
    _button_box(QDialogButtonBox::Reset | QDialogButtonBox::Cancel,
        Qt::Horizontal, this)
{
    _measure_tab = NULL;

    setMinimumSize(500, 400);

    _measure_tab = new QTabWidget(this);
    _measure_tab->setTabPosition(QTabWidget::West);
    _measure_tab->setUsesScrollButtons(false);

    for(auto s : _session->get_signals()) {
        if (s->signal_type() == SR_CHANNEL_DSO && s->enabled()) {
            view::DsoSignal *dsoSig = (view::DsoSignal*)s;
            QWidget *measure_widget = new QWidget(this);
            this->add_measure(measure_widget, dsoSig);
            _measure_tab->addTab(measure_widget, QString::number(dsoSig->get_index()));
            _measure_tab->tabBar()->setMinimumHeight(30);
            _measure_tab->tabBar()->setPalette(QPalette(Qt::red));
            measure_widget->setProperty("index", dsoSig->get_index());
            if (dsoSig->get_index() == last_sig_index)
                _measure_tab->setCurrentIndex(last_sig_index);
        }
    }

    _layout.addWidget(_measure_tab);
    _layout.addWidget(&_button_box, Qt::AlignHCenter | Qt::AlignBottom);

    layout()->addLayout(&_layout);
    setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_MEASUREMENTS), "Measurements"));

    connect(_button_box.button(QDialogButtonBox::Cancel), SIGNAL(clicked()), this, SLOT(reject()));
    connect(_button_box.button(QDialogButtonBox::Reset), SIGNAL(clicked()), this, SLOT(reset()));
    connect(_session->device_event_object(), SIGNAL(device_updated()), this, SLOT(reject()));
}

DsoMeasure::~DsoMeasure(){
    DESTROY_QT_OBJECT(_measure_tab);
}

void DsoMeasure::add_measure(QWidget *widget, const view::DsoSignal *dsoSig)
{
    const int Column = 5;
    const int IconSizeForText = 5;
    QGridLayout *layout = new QGridLayout(widget);
    layout->setSpacing(0);

    dsv::view::DsoSignal *psig = const_cast<dsv::view::DsoSignal*>(dsoSig);
    
    for (int i=DSO_MS_BEGIN+1; i<DSO_MS_END; i++) {
        QToolButton *button = new QToolButton(this);
        button->setProperty("id", QVariant(i));
        button->setIconSize(QSize(48, 48));
        QPixmap msPix(get_ms_icon(i));
        QBitmap msMask = msPix.createMaskFromColor(QColor("black"), Qt::MaskOutColor);
        msPix.fill(psig->get_colour());
        msPix.setMask(msMask);
        button->setIcon(QIcon(msPix));
        layout->addWidget(button,
                          ((i-1)/Column)*IconSizeForText, (i-1)%Column,
                          IconSizeForText-1, 1,
                          Qt::AlignCenter);
        layout->addWidget(new QLabel(get_ms_text(i), this),
                          ((i-1)/Column)*IconSizeForText+4, (i-1)%Column,
                          1, 1,
                          Qt::AlignCenter);
        layout->setColumnMinimumWidth((i-1)%Column, this->width()/Column);

        connect(button, SIGNAL(clicked()), this, SLOT(accept()));
    }
}

void DsoMeasure::set_measure(bool en)
{
    (void)en;
    QCheckBox* sc=dynamic_cast<QCheckBox*>(sender());
    if(sc != NULL) {
        QVariant id = sc->property("id");
    }
}

QString DsoMeasure::get_ms_icon(int ms_type)
{
    assert(ms_type >= DSO_MS_BEGIN);
    assert(ms_type < DSO_MS_END);
    const QString icon_name[DSO_MS_END-DSO_MS_BEGIN] = {"blank.png",
                                                        "mFreq.png", "mPeriod.png", "mPduty.png", "mNduty.png", "mPcount.png",
                                                        "mRise.png", "mFall.png", "mPwidth.png", "mNwidth.png", "mBurst.png",
                                                        "mAmplitude.png", "mHigh.png", "mLow.png", "mRms.png", "mMean.png",
                                                        "mVpp.png", "mMax.png", "mMin.png", "mPover.png", "mNover.png"};
    return ":/icons/"+icon_name[ms_type];
}

QString DsoMeasure::get_ms_text(int ms_type)
{
    assert(ms_type >= DSO_MS_BEGIN);
    assert(ms_type < DSO_MS_END);
    //tr
    const QString label_name[DSO_MS_END-DSO_MS_BEGIN] = {tr("NULL"),
                                                         tr("Freq"), tr("Period"), tr("+Duty"), tr("-Duty"), tr("+Count"),
                                                         tr("Rise"), tr("Fall"), tr("+Width"), tr("-Width"), tr("BrstW"),
                                                         tr("Ampl"), tr("High"), tr("Low"), tr("RMS"), tr("Mean"),
                                                         tr("PK-PK"), tr("Max"), tr("Min"), tr("+Over"), tr("-Over")};
    return label_name[ms_type];
}

void DsoMeasure::accept()
{
	using namespace Qt;

    QToolButton* sc = dynamic_cast<QToolButton*>(sender());
    if(sc != NULL) {
        QVariant id = sc->property("id");
        enum DSO_MEASURE_TYPE ms_type = DSO_MEASURE_TYPE(id.toInt());
        
        for(auto s : _session->get_signals()) { 
            if (s->signal_type() == SR_CHANNEL_DSO) {
                view::DsoSignal *dsoSig = (view::DsoSignal*)s;
                if (_measure_tab->currentWidget()->property("index").toInt() == dsoSig->get_index()) {
                    _view.get_viewstatus()->set_measure(_position, false, dsoSig->get_index(), ms_type);
                    break;
                }
            }
        }
    }
    QDialog::accept();
}

void DsoMeasure::reject()
{
    using namespace Qt;

    _view.get_viewstatus()->set_measure(_position, true, -1, DSO_MS_BEGIN);
    QDialog::reject();
}

void DsoMeasure::reset()
{
    using namespace Qt;

    _view.get_viewstatus()->set_measure(_position, false, -1, DSO_MS_BEGIN);
    QDialog::reject();
}

} // namespace dialogs
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2022 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DECODER_OPTIONS_DLG_H
#define DECODER_OPTIONS_DLG_H

#include <QObject>
#include <QWidget>
#include <vector>
#include <QString>

class QGridLayout;
class DsComboBox;
class QFormLayout;

struct srd_channel;

#include "dsdialog.h"

namespace dsv{
    namespace data{
        class DecoderStack;       
    }
    namespace decode{
        class Decoder;
    }
    namespace prop{   
        namespace binding{
            class DecoderOptions;
        }
    }
    namespace view{
        class View;
        class Cursor;
        class DecodeTrace;
    }
}
using namespace dsv::data;
using namespace dsv::decode;
using namespace dsv::view;

namespace dsv { 
namespace dialogs {
 
class DecoderOptionsDlg: public DSDialog
{
    Q_OBJECT

private:
	struct ProbeSelector
	{
		const DsComboBox *_combo;
        const Decoder *_decoder;
		const srd_channel *_pdch;
	};

public:
    DecoderOptionsDlg(QWidget *parent);
    ~DecoderOptionsDlg(); 

    inline void set_cursor_range(uint64_t cursor1, uint64_t cursor2)
    {
        _cursor1 = cursor1;
        _cursor2 = cursor2;
    }

    inline void get_cursor_range(uint64_t &cursor1, uint64_t &cursor2)
    {
        cursor1 = _cursor1;
        cursor2 = _cursor2;
    }

    void load_options(DecodeTrace *trace);

    inline bool is_reload_form(){
        return _is_reload_form;
    }

private:
    void load_options_view();

    void load_decoder_forms(QWidget *container);  

    DsComboBox* create_probe_selector(QWidget *parent, const Decoder *dec,
            const srd_channel *const pdch);
 
    void create_decoder_form(Decoder *dec,
            QWidget *parent, QFormLayout *form);

    void commit_probes();    
    void commit_decoder_probes(Decoder *dec);
    void update_decode_range(); 
 
private slots:
    void on_probe_selected(int);
    void on_region_set(int index);
    void on_accept();
    void on_trans_pramas();

private: 
    std::vector<prop::binding::DecoderOptions*> _bindings;
    DsComboBox 		*_start_comboBox;
	DsComboBox 		*_end_comboBox;
    DecodeTrace   *_trace;
    uint64_t     _cursor1; //cursor key
    uint64_t     _cursor2;
    int          _contentHeight;
    
    std::vector<ProbeSelector> _probe_selectors;
    bool        _is_reload_form;
    int         _content_width;
};

}//dialogs
}//pv

#endif
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_FFTOPTIONS_H
#define DSVIEW_PV_FFTOPTIONS_H

#include <QDialogButtonBox>
#include <QFormLayout>
#include <QVBoxLayout>
#include <QLabel>
#include <QCheckBox> 
#include "../toolbars/titlebar.h"
#include "dsdialog.h"
#include "../ui/dscombobox.h"

namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
}
using namespace dsv::appcore;

namespace dsv {
namespace dialogs {

class FftOptions : public DSDialog
{
    Q_OBJECT

private:


public:
    FftOptions(QWidget *parent, SigSession *session);

    ~FftOptions();

protected:
    void accept();
    void reject();

private slots:
    void window_changed(int index);
    void len_changed(int index);

private:
    SigSession *_session;
    uint64_t _sample_limit;
 
    DsComboBox *_len_combobox;
    DsComboBox *_interval_combobox;
    QCheckBox *_en_checkbox;
    DsComboBox *_ch_combobox;
    DsComboBox *_window_combobox;
    QCheckBox *_dc_checkbox;
    DsComboBox *_view_combobox;
    DsComboBox *_dbv_combobox;

    QLabel *_hint_label;
    QGridLayout *_glayout;
    QVBoxLayout *_layout;
    QDialogButtonBox _button_box;

};

} // namespace dialogs
} // namespace dsv

#endif // DSVIEW_PV_FFTOPTIONS_H
/****************************************************************************
** Meta object code from reading C++ file 'deviceoptions.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "deviceoptions.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'deviceoptions.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSChannelLabelENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSChannelLabelENDCLASS = QtMocHelpers::stringData(
    "ChannelLabel",
    "on_checked",
    ""
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSChannelLabelENDCLASS_t {
    uint offsetsAndSizes[6];
    char stringdata0[13];
    char stringdata1[11];
    char stringdata2[1];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSChannelLabelENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSChannelLabelENDCLASS_t qt_meta_stringdata_CLASSChannelLabelENDCLASS = {
    {
        QT_MOC_LITERAL(0, 12),  // "ChannelLabel"
        QT_MOC_LITERAL(13, 10),  // "on_checked"
        QT_MOC_LITERAL(24, 0)   // ""
    },
    "ChannelLabel",
    "on_checked",
    ""
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSChannelLabelENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   20,    2, 0x08,    1 /* Private */,

 // slots: parameters
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject ChannelLabel::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_CLASSChannelLabelENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSChannelLabelENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSChannelLabelENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<ChannelLabel, std::true_type>,
        // method 'on_checked'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void ChannelLabel::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<ChannelLabel *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->on_checked(); break;
        default: ;
        }
    }
    (void)_a;
}

const QMetaObject *ChannelLabel::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *ChannelLabel::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSChannelLabelENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int ChannelLabel::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 1;
    }
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDeviceOptionsENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDeviceOptionsENDCLASS = QtMocHelpers::stringData(
    "dsv::dialogs::DeviceOptions",
    "enable_all_probes",
    "",
    "disable_all_probes",
    "zero_adj",
    "mode_check_timeout",
    "channel_check",
    "analog_channel_check",
    "on_calibration",
    "on_analog_channel_enable",
    "on_anlog_tab_changed",
    "index"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDeviceOptionsENDCLASS_t {
    uint offsetsAndSizes[24];
    char stringdata0[28];
    char stringdata1[18];
    char stringdata2[1];
    char stringdata3[19];
    char stringdata4[9];
    char stringdata5[19];
    char stringdata6[14];
    char stringdata7[21];
    char stringdata8[15];
    char stringdata9[25];
    char stringdata10[21];
    char stringdata11[6];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDeviceOptionsENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDeviceOptionsENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDeviceOptionsENDCLASS = {
    {
        QT_MOC_LITERAL(0, 27),  // "dsv::dialogs::DeviceOptions"
        QT_MOC_LITERAL(28, 17),  // "enable_all_probes"
        QT_MOC_LITERAL(46, 0),  // ""
        QT_MOC_LITERAL(47, 18),  // "disable_all_probes"
        QT_MOC_LITERAL(66, 8),  // "zero_adj"
        QT_MOC_LITERAL(75, 18),  // "mode_check_timeout"
        QT_MOC_LITERAL(94, 13),  // "channel_check"
        QT_MOC_LITERAL(108, 20),  // "analog_channel_check"
        QT_MOC_LITERAL(129, 14),  // "on_calibration"
        QT_MOC_LITERAL(144, 24),  // "on_analog_channel_enable"
        QT_MOC_LITERAL(169, 20),  // "on_anlog_tab_changed"
        QT_MOC_LITERAL(190, 5)   // "index"
    },
    "dsv::dialogs::DeviceOptions",
    "enable_all_probes",
    "",
    "disable_all_probes",
    "zero_adj",
    "mode_check_timeout",
    "channel_check",
    "analog_channel_check",
    "on_calibration",
    "on_analog_channel_enable",
    "on_anlog_tab_changed",
    "index"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdialogsSCOPEDeviceOptionsENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       9,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   68,    2, 0x08,    1 /* Private */,
       3,    0,   69,    2, 0x08,    2 /* Private */,
       4,    0,   70,    2, 0x08,    3 /* Private */,
       5,    0,   71,    2, 0x08,    4 /* Private */,
       6,    0,   72,    2, 0x08,    5 /* Private */,
       7,    0,   73,    2, 0x08,    6 /* Private */,
       8,    0,   74,    2, 0x08,    7 /* Private */,
       9,    0,   75,    2, 0x08,    8 /* Private */,
      10,    1,   76,    2, 0x08,    9 /* Private */,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::Int,   11,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dialogs::DeviceOptions::staticMetaObject = { {
    QMetaObject::SuperData::link<DSDialog::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDeviceOptionsENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdialogsSCOPEDeviceOptionsENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDeviceOptionsENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<DeviceOptions, std::true_type>,
        // method 'enable_all_probes'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'disable_all_probes'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'zero_adj'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'mode_check_timeout'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'channel_check'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'analog_channel_check'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_calibration'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_analog_channel_enable'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_anlog_tab_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>
    >,
    nullptr
} };

void dsv::dialogs::DeviceOptions::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<DeviceOptions *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->enable_all_probes(); break;
        case 1: _t->disable_all_probes(); break;
        case 2: _t->zero_adj(); break;
        case 3: _t->mode_check_timeout(); break;
        case 4: _t->channel_check(); break;
        case 5: _t->analog_channel_check(); break;
        case 6: _t->on_calibration(); break;
        case 7: _t->on_analog_channel_enable(); break;
        case 8: _t->on_anlog_tab_changed((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        default: ;
        }
    }
}

const QMetaObject *dsv::dialogs::DeviceOptions::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dialogs::DeviceOptions::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDeviceOptionsENDCLASS.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "IChannelCheck"))
        return static_cast< IChannelCheck*>(this);
    return DSDialog::qt_metacast(_clname);
}

int dsv::dialogs::DeviceOptions::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = DSDialog::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 9)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 9;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 9)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 9;
    }
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2014 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_DIALOGS_SAVEPROGRESS_H
#define DSVIEW_PV_DIALOGS_SAVEPROGRESS_H
 
#include <QProgressBar>
#include "../com/storesession.h"
#include "../dialogs/dsdialog.h" 
#include "../interface/icallbacks.h"

class QTextEdit;
class QRadioButton;
class QGridLayout;
class QPushButton;
class QWidget;

namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
    namespace com{
        class StoreSession;
    }
}
using namespace dsv::appcore;
using namespace dsv::com;

namespace dsv {
namespace dialogs {

class StoreProgress : public DSDialog
{
	Q_OBJECT

public:
    StoreProgress(SigSession *session,
        QWidget *parent = 0);

	virtual ~StoreProgress();

 
protected:
    void reject();
    void accept();

private:
	void show_error();
    void closeEvent(QCloseEvent* e);

signals:
    void save_done();

public slots:
    void save_run(ISessionDataGetter *getter);
    void export_run();

private slots:
	void on_progress_updated();
    void timeout();
    void on_change_file();
    void on_ck_origin(bool ck);
    void on_ck_compress(bool ck);

private:
    StoreSession    _store_session;
    QProgressBar        _progress;
    bool                _done;
    bool                _isExport;
    QTextEdit           *_fileLab;
    QRadioButton        *_ckOrigin;
    QRadioButton        *_ckCompress;
    QPushButton         *_openButton;
    QGridLayout         *_grid;
    QWidget             *_space;
    bool                 _isBusy;
};

} // dialogs
} // pv

#endif // PULSEVIEW_PV_DIALOGS_SAVEPROGRESS_H
/****************************************************************************
** Meta object code from reading C++ file 'dsomeasure.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "dsomeasure.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'dsomeasure.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDsoMeasureENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDsoMeasureENDCLASS = QtMocHelpers::stringData(
    "dsv::dialogs::DsoMeasure",
    "set_measure",
    "",
    "en",
    "reset"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDsoMeasureENDCLASS_t {
    uint offsetsAndSizes[10];
    char stringdata0[25];
    char stringdata1[12];
    char stringdata2[1];
    char stringdata3[3];
    char stringdata4[6];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDsoMeasureENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDsoMeasureENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDsoMeasureENDCLASS = {
    {
        QT_MOC_LITERAL(0, 24),  // "dsv::dialogs::DsoMeasure"
        QT_MOC_LITERAL(25, 11),  // "set_measure"
        QT_MOC_LITERAL(37, 0),  // ""
        QT_MOC_LITERAL(38, 2),  // "en"
        QT_MOC_LITERAL(41, 5)   // "reset"
    },
    "dsv::dialogs::DsoMeasure",
    "set_measure",
    "",
    "en",
    "reset"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdialogsSCOPEDsoMeasureENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       2,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   26,    2, 0x08,    1 /* Private */,
       4,    0,   29,    2, 0x08,    3 /* Private */,

 // slots: parameters
    QMetaType::Void, QMetaType::Bool,    3,
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dialogs::DsoMeasure::staticMetaObject = { {
    QMetaObject::SuperData::link<DSDialog::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDsoMeasureENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdialogsSCOPEDsoMeasureENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDsoMeasureENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<DsoMeasure, std::true_type>,
        // method 'set_measure'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>,
        // method 'reset'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::dialogs::DsoMeasure::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<DsoMeasure *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->set_measure((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        case 1: _t->reset(); break;
        default: ;
        }
    }
}

const QMetaObject *dsv::dialogs::DsoMeasure::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dialogs::DsoMeasure::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDsoMeasureENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return DSDialog::qt_metacast(_clname);
}

int dsv::dialogs::DsoMeasure::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = DSDialog::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 2)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 2;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 2)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 2;
    }
    return _id;
}
QT_WARNING_POP
/****************************************************************************
** Meta object code from reading C++ file 'storeprogress.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "storeprogress.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'storeprogress.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEStoreProgressENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEStoreProgressENDCLASS = QtMocHelpers::stringData(
    "dsv::dialogs::StoreProgress",
    "save_done",
    "",
    "save_run",
    "ISessionDataGetter*",
    "getter",
    "export_run",
    "on_progress_updated",
    "timeout",
    "on_change_file",
    "on_ck_origin",
    "ck",
    "on_ck_compress"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEStoreProgressENDCLASS_t {
    uint offsetsAndSizes[26];
    char stringdata0[28];
    char stringdata1[10];
    char stringdata2[1];
    char stringdata3[9];
    char stringdata4[20];
    char stringdata5[7];
    char stringdata6[11];
    char stringdata7[20];
    char stringdata8[8];
    char stringdata9[15];
    char stringdata10[13];
    char stringdata11[3];
    char stringdata12[15];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEStoreProgressENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEStoreProgressENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEStoreProgressENDCLASS = {
    {
        QT_MOC_LITERAL(0, 27),  // "dsv::dialogs::StoreProgress"
        QT_MOC_LITERAL(28, 9),  // "save_done"
        QT_MOC_LITERAL(38, 0),  // ""
        QT_MOC_LITERAL(39, 8),  // "save_run"
        QT_MOC_LITERAL(48, 19),  // "ISessionDataGetter*"
        QT_MOC_LITERAL(68, 6),  // "getter"
        QT_MOC_LITERAL(75, 10),  // "export_run"
        QT_MOC_LITERAL(86, 19),  // "on_progress_updated"
        QT_MOC_LITERAL(106, 7),  // "timeout"
        QT_MOC_LITERAL(114, 14),  // "on_change_file"
        QT_MOC_LITERAL(129, 12),  // "on_ck_origin"
        QT_MOC_LITERAL(142, 2),  // "ck"
        QT_MOC_LITERAL(145, 14)   // "on_ck_compress"
    },
    "dsv::dialogs::StoreProgress",
    "save_done",
    "",
    "save_run",
    "ISessionDataGetter*",
    "getter",
    "export_run",
    "on_progress_updated",
    "timeout",
    "on_change_file",
    "on_ck_origin",
    "ck",
    "on_ck_compress"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdialogsSCOPEStoreProgressENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       8,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   62,    2, 0x06,    1 /* Public */,

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       3,    1,   63,    2, 0x0a,    2 /* Public */,
       6,    0,   66,    2, 0x0a,    4 /* Public */,
       7,    0,   67,    2, 0x08,    5 /* Private */,
       8,    0,   68,    2, 0x08,    6 /* Private */,
       9,    0,   69,    2, 0x08,    7 /* Private */,
      10,    1,   70,    2, 0x08,    8 /* Private */,
      12,    1,   73,    2, 0x08,   10 /* Private */,

 // signals: parameters
    QMetaType::Void,

 // slots: parameters
    QMetaType::Void, 0x80000000 | 4,    5,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::Bool,   11,
    QMetaType::Void, QMetaType::Bool,   11,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dialogs::StoreProgress::staticMetaObject = { {
    QMetaObject::SuperData::link<DSDialog::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEStoreProgressENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdialogsSCOPEStoreProgressENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEStoreProgressENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<StoreProgress, std::true_type>,
        // method 'save_done'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'save_run'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<ISessionDataGetter *, std::false_type>,
        // method 'export_run'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_progress_updated'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'timeout'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_change_file'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_ck_origin'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>,
        // method 'on_ck_compress'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>
    >,
    nullptr
} };

void dsv::dialogs::StoreProgress::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<StoreProgress *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->save_done(); break;
        case 1: _t->save_run((*reinterpret_cast< std::add_pointer_t<ISessionDataGetter*>>(_a[1]))); break;
        case 2: _t->export_run(); break;
        case 3: _t->on_progress_updated(); break;
        case 4: _t->timeout(); break;
        case 5: _t->on_change_file(); break;
        case 6: _t->on_ck_origin((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        case 7: _t->on_ck_compress((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (StoreProgress::*)();
            if (_t _q_method = &StoreProgress::save_done; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
    }
}

const QMetaObject *dsv::dialogs::StoreProgress::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dialogs::StoreProgress::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEStoreProgressENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return DSDialog::qt_metacast(_clname);
}

int dsv::dialogs::StoreProgress::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = DSDialog::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 8)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 8;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 8)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 8;
    }
    return _id;
}

// SIGNAL 0
void dsv::dialogs::StoreProgress::save_done()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}
QT_WARNING_POP
/****************************************************************************
** Meta object code from reading C++ file 'about.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "about.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'about.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEAboutENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEAboutENDCLASS = QtMocHelpers::stringData(
    "dsv::dialogs::About"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEAboutENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[20];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEAboutENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEAboutENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEAboutENDCLASS = {
    {
        QT_MOC_LITERAL(0, 19)   // "dsv::dialogs::About"
    },
    "dsv::dialogs::About"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdialogsSCOPEAboutENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dialogs::About::staticMetaObject = { {
    QMetaObject::SuperData::link<DSDialog::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEAboutENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdialogsSCOPEAboutENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEAboutENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<About, std::true_type>
    >,
    nullptr
} };

void dsv::dialogs::About::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *dsv::dialogs::About::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dialogs::About::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEAboutENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return DSDialog::qt_metacast(_clname);
}

int dsv::dialogs::About::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = DSDialog::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_PROTOCOLEXP_H
#define DSVIEW_PV_PROTOCOLEXP_H

#include <QDialogButtonBox>
#include <QFormLayout>
#include <QVBoxLayout>
#include <QLabel>
#include <QCheckBox> 
#include <QString>
 
#include "../prop/binding/deviceoptions.h"
#include "../toolbars/titlebar.h"
#include "dsdialog.h"
#include "../ui/dscombobox.h"

namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
    namespace decode {
        class Row;
        class Annotation;
    }
}
using namespace dsv::appcore;
using namespace dsv::decode;

namespace dsv {
namespace dialogs {
    
class ProtocolExp : public DSDialog
{
    Q_OBJECT

private:
    struct ExportRowInfo
    {
        QString title;
        const decode::Row *row;
        int     row_index;
        uint64_t    read_index;
    };

public:
    ProtocolExp(QWidget *parent, SigSession *session);

protected:
    void accept();
    void reject();
    void save_proc();
    static bool compare_ann_index(const decode::Annotation *a, 
                    const decode::Annotation *b);

signals:
    void export_progress(int percent);

private slots:
    void cancel_export();

private:
    SigSession *_session;

    toolbars::TitleBar *_titlebar;
    DsComboBox *_format_combobox;
    std::list<QCheckBox *> _row_sel_list;
    std::list<QLabel *> _row_label_list;
    QFormLayout *_flayout;
    QVBoxLayout *_layout;
    QDialogButtonBox _button_box;

    bool _export_cancel;
    QString     _fileName; 
};

} // namespace dialogs
} // namespace dsv

#endif // DSVIEW_PV_PROTOCOLEXP_H
/****************************************************************************
** Meta object code from reading C++ file 'interval.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "interval.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'interval.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEIntervalENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEIntervalENDCLASS = QtMocHelpers::stringData(
    "dsv::dialogs::Interval",
    "on_slider_changed",
    "",
    "value",
    "on_inputbox_changed"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEIntervalENDCLASS_t {
    uint offsetsAndSizes[10];
    char stringdata0[23];
    char stringdata1[18];
    char stringdata2[1];
    char stringdata3[6];
    char stringdata4[20];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEIntervalENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEIntervalENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEIntervalENDCLASS = {
    {
        QT_MOC_LITERAL(0, 22),  // "dsv::dialogs::Interval"
        QT_MOC_LITERAL(23, 17),  // "on_slider_changed"
        QT_MOC_LITERAL(41, 0),  // ""
        QT_MOC_LITERAL(42, 5),  // "value"
        QT_MOC_LITERAL(48, 19)   // "on_inputbox_changed"
    },
    "dsv::dialogs::Interval",
    "on_slider_changed",
    "",
    "value",
    "on_inputbox_changed"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdialogsSCOPEIntervalENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       2,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   26,    2, 0x08,    1 /* Private */,
       4,    1,   29,    2, 0x08,    3 /* Private */,

 // slots: parameters
    QMetaType::Void, QMetaType::Int,    3,
    QMetaType::Void, QMetaType::Double,    3,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dialogs::Interval::staticMetaObject = { {
    QMetaObject::SuperData::link<DSDialog::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEIntervalENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdialogsSCOPEIntervalENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEIntervalENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<Interval, std::true_type>,
        // method 'on_slider_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'on_inputbox_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<double, std::false_type>
    >,
    nullptr
} };

void dsv::dialogs::Interval::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<Interval *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->on_slider_changed((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 1: _t->on_inputbox_changed((*reinterpret_cast< std::add_pointer_t<double>>(_a[1]))); break;
        default: ;
        }
    }
}

const QMetaObject *dsv::dialogs::Interval::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dialogs::Interval::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEIntervalENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return DSDialog::qt_metacast(_clname);
}

int dsv::dialogs::Interval::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = DSDialog::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 2)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 2;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 2)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 2;
    }
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "fftoptions.h"
#include <QFormLayout>
#include <QListWidget>
#include "../appcore/sigsession.h"
#include "../data/spectrumstack.h"
#include "../view/trace.h"
#include "../view/dsosignal.h"
#include "../view/spectrumtrace.h"
#include "../basedef.h"
#include "../log.h"
#include "../ui/langresource.h"


using namespace boost;
using namespace std;
 
namespace dsv {
namespace dialogs {

FftOptions::FftOptions(QWidget *parent, SigSession *session) :
    DSDialog(parent),
    _session(session),
    _button_box(QDialogButtonBox::Ok | QDialogButtonBox::Cancel,
        Qt::Horizontal, this)
{
    _len_combobox = NULL;
    _interval_combobox = NULL;
    _en_checkbox = NULL;
    _ch_combobox = NULL;
    _window_combobox = NULL;
    _dc_checkbox = NULL;
    _view_combobox = NULL;
    _dbv_combobox = NULL;
    _hint_label = NULL;
    _glayout = NULL;
    _layout = NULL;

    _en_checkbox = new QCheckBox(this);
    _len_combobox = new DsComboBox(this);
    _interval_combobox = new DsComboBox(this);
    _ch_combobox = new DsComboBox(this);
    _window_combobox = new DsComboBox(this);
    _dc_checkbox = new QCheckBox(this);
    _dc_checkbox->setChecked(true);
    _view_combobox = new DsComboBox(this);
    _dbv_combobox = new DsComboBox(this);
 
    // setup _ch_combobox
    for(auto s : _session->get_signals()) {
        if (s->signal_type() == SR_CHANNEL_DSO) {
            view::DsoSignal *dsoSig = (view::DsoSignal*)s;
            _ch_combobox->addItem(dsoSig->get_name(), QVariant::fromValue(dsoSig->get_index()));
        }
    }

    // setup _window_combobox _len_combobox
    _sample_limit = 0;
    
    if (_session->get_device()->get_config_uint64(SR_CONF_MAX_DSO_SAMPLELIMITS, _sample_limit)) {
        _sample_limit = _sample_limit * 0.5;
    }
    else {
        dsv_err("ERROR: config_get SR_CONF_MAX_DSO_SAMPLELIMITS failed.");
    }

    std::vector<QString> windows;
    std::vector<uint64_t> length;
    std::vector<QString> view_modes;
    std::vector<int> dbv_ranges;

    for(auto t : _session->get_spectrum_traces()) {
        view::SpectrumTrace *spectrumTraces = NULL;
        if ((spectrumTraces = dynamic_cast<view::SpectrumTrace*>(t))) {
            windows = spectrumTraces->get_spectrum_stack()->get_windows_support();
            length = spectrumTraces->get_spectrum_stack()->get_length_support();
            view_modes = spectrumTraces->get_view_modes_support();
            dbv_ranges = spectrumTraces->get_dbv_ranges();
            break;
        }
    }
    assert(windows.size() > 0);
    assert(length.size() > 0);
    assert(view_modes.size() > 0);
    assert(dbv_ranges.size() > 0);
    for (unsigned int i = 0; i < windows.size(); i++)
    {
        _window_combobox->addItem(windows[i],
            QVariant::fromValue(i));
    }
    for (unsigned int i = 0; i < length.size(); i++)
    {
        if (length[i] < _sample_limit)
            _len_combobox->addItem(QString::number(length[i]),
                QVariant::fromValue(length[i]));
        else
            break;
    }
    assert(_len_combobox->count() > 0);
    _len_combobox->setCurrentIndex(_len_combobox->count()-1);

    const int max_interval = _sample_limit/_len_combobox->currentData().toLongLong();
    for (int i = 1; i <= max_interval; i*=2)
    {
        _interval_combobox->addItem(QString::number(i),
            QVariant::fromValue(i));
    }
    for (unsigned int i = 0; i < view_modes.size(); i++)
    {
        _view_combobox->addItem(view_modes[i],
            QVariant::fromValue(i));
    }
    assert(_view_combobox->count() > 0);
    _view_combobox->setCurrentIndex(_view_combobox->count()-1);
    for (unsigned int i = 0; i < dbv_ranges.size(); i++)
    {
        _dbv_combobox->addItem(QString::number(dbv_ranges[i]),
            QVariant::fromValue(dbv_ranges[i]));
    }

    // load current settings
    for(auto t : _session->get_spectrum_traces()) {
         view::SpectrumTrace *spectrumTraces = NULL;
        if ((spectrumTraces = dynamic_cast<view::SpectrumTrace*>(t))) {
            if (spectrumTraces->enabled()) {
                _en_checkbox->setChecked(true);
                for (int i = 0; i < _ch_combobox->count(); i++) {
                    if (spectrumTraces->get_index() == _ch_combobox->itemData(i).toInt()) {
                        _ch_combobox->setCurrentIndex(i);
                        break;
                    }
                }
                for (int i = 0; i < _len_combobox->count(); i++) {
                    if (spectrumTraces->get_spectrum_stack()->get_sample_num() == _len_combobox->itemData(i).toULongLong()) {
                        _len_combobox->setCurrentIndex(i);
                        break;
                    }
                }
                _interval_combobox->clear();
                const int max_interval = _sample_limit/_len_combobox->currentData().toLongLong();
                for (int i = 1; i <= max_interval; i*=2)
                {
                    _interval_combobox->addItem(QString::number(i),
                        QVariant::fromValue(i));
                }
                for (int i = 0; i < _interval_combobox->count(); i++) {
                    if (spectrumTraces->get_spectrum_stack()->get_sample_interval() == _interval_combobox->itemData(i).toInt()) {
                        _interval_combobox->setCurrentIndex(i);
                        break;
                    }
                }
                for (int i = 0; i < _dbv_combobox->count(); i++) {
                    if (spectrumTraces->dbv_range() == _dbv_combobox->itemData(i).toLongLong()) {
                        _dbv_combobox->setCurrentIndex(i);
                        break;
                    }
                }
                _window_combobox->setCurrentIndex(spectrumTraces->get_spectrum_stack()->get_windows_index());
                _dc_checkbox->setChecked(spectrumTraces->get_spectrum_stack()->dc_ignored());
                _view_combobox->setCurrentIndex(spectrumTraces->view_mode());
            }
        }
    }

    _hint_label = new QLabel(this);
    QString hint_pic= ":/icons/" + _window_combobox->currentText()+".png";
    QPixmap pixmap(hint_pic);
    _hint_label->setPixmap(pixmap);

    //*
    _glayout = new QGridLayout();  //QGridLayout
    _glayout->setVerticalSpacing(5);
    _glayout->addWidget(new QLabel(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_FFT_ENABLE), "FFT Enable: "), this), 0, 0);
    _glayout->addWidget(_en_checkbox, 0, 1);
    _glayout->addWidget(new QLabel(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_FFT_LENGTH), "FFT Length: "), this), 1, 0);
    _glayout->addWidget(_len_combobox, 1, 1);
    _glayout->addWidget(new QLabel(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SAMPLE_INTERVAL), "Sample Interval: "), this), 2, 0);
    _glayout->addWidget(_interval_combobox, 2, 1);
    _glayout->addWidget(new QLabel(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_FFT_SOURCE), "FFT Source: "), this), 3, 0);
    _glayout->addWidget(_ch_combobox, 3, 1);
    _glayout->addWidget(new QLabel(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_FFT_WINDOW), "FFT Window: "), this), 4, 0);
    _glayout->addWidget(_window_combobox, 4, 1);
    _glayout->addWidget(new QLabel(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_DC_IGNORED), "DC Ignored: "), this), 5, 0);
    _glayout->addWidget(_dc_checkbox, 5, 1);
    _glayout->addWidget(new QLabel(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_Y-AXIS_MODE), "Y-axis Mode: "), this), 6, 0);
    _glayout->addWidget(_view_combobox, 6, 1);
    _glayout->addWidget(new QLabel(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_DBV_RANGE), "DBV Range: "), this), 7, 0);
    _glayout->addWidget(_dbv_combobox, 7, 1);
    _glayout->addWidget(_hint_label, 0, 2, 8, 1);


    _layout = new QVBoxLayout();
    _layout->addLayout(_glayout);
    _layout->addWidget(&_button_box);

    layout()->addLayout(_layout);
    setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_FFT_OPTIONS), "FFT Options"));

    connect(&_button_box, SIGNAL(accepted()), this, SLOT(accept()));
    connect(&_button_box, SIGNAL(rejected()), this, SLOT(reject()));
    connect(_window_combobox, SIGNAL(currentIndexChanged(int)), this, SLOT(window_changed(int)));
    connect(_len_combobox, SIGNAL(currentIndexChanged(int)), this, SLOT(len_changed(int)));
    connect(_session->device_event_object(), SIGNAL(device_updated()), this, SLOT(reject()));
}

FftOptions::~FftOptions(){

}

void FftOptions::accept()
{
    using namespace Qt;

    QDialog::accept();

   for(auto t : _session->get_spectrum_traces()) {
        view::SpectrumTrace *spectrumTraces = NULL;
        if ((spectrumTraces = dynamic_cast<view::SpectrumTrace*>(t))) {
            spectrumTraces->set_enable(false);
            if (spectrumTraces->get_index() == _ch_combobox->currentData().toInt()) {
                spectrumTraces->get_spectrum_stack()->set_dc_ignore(_dc_checkbox->isChecked());
                spectrumTraces->get_spectrum_stack()->set_sample_num(_len_combobox->currentData().toULongLong());
                spectrumTraces->get_spectrum_stack()->set_sample_interval(_interval_combobox->currentData().toInt());
                spectrumTraces->get_spectrum_stack()->set_windows_index(_window_combobox->currentData().toInt());
                spectrumTraces->set_view_mode(_view_combobox->currentData().toUInt());
                
                spectrumTraces->set_dbv_range(_dbv_combobox->currentData().toInt());
                spectrumTraces->set_enable(_en_checkbox->isChecked());

                if (_session->is_stopped_status() && spectrumTraces->enabled()){
                    spectrumTraces->get_spectrum_stack()->calc_fft();
                }
            }
        }
    }
    _session->spectrum_rebuild();
}

void FftOptions::reject()
{
    using namespace Qt;

    QDialog::reject();
}

void FftOptions::window_changed(int index)
{
    QString str = _window_combobox->itemText(index);
    QString hint_pic= ":/icons/" + str +".png";
    QPixmap pixmap(hint_pic);
    _hint_label->setPixmap(pixmap);
}

void FftOptions::len_changed(int index)
{
    int pre_index = _interval_combobox->currentIndex();
    _interval_combobox->clear();
    const int max_interval = _sample_limit/_len_combobox->itemData(index).toLongLong();
    for (int i = 1; i <= max_interval; i*=2)
    {
        _interval_combobox->addItem(QString::number(i),
            QVariant::fromValue(i));
    }
    _interval_combobox->setCurrentIndex(pre_index);
}

} // namespace dialogs
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#include "dsdialog.h"
#include <QObject>
#include <QEvent>
#include <QMouseEvent>
#include <QVBoxLayout>
#include <QAbstractButton>
#include "shadow.h"
#include "../basedef.h"
#include "../config/appconfig.h"
#include "../ui/fn.h"

using namespace dsv::config;

namespace dsv {
namespace dialogs {

DSDialog::DSDialog() : 
 DSDialog(NULL, false, false)
{
}

DSDialog::DSDialog(QWidget *parent):
 DSDialog(parent, false, false)
{
}

DSDialog::DSDialog(QWidget *parent, bool hasClose):
 DSDialog(parent, hasClose, false)
{
}

DSDialog::DSDialog(QWidget *parent, bool hasClose, bool bBaseButton) :
    QDialog(parent),
    m_bBaseButton(bBaseButton)
{
    (void)parent;

    _base_layout = NULL;
    _main_layout = NULL;
    _main_widget = NULL;
    _titlebar = NULL;
    _shadow = NULL; 
    _base_button = NULL;
    _titleSpaceLine = NULL;

    m_callback = NULL; 
    _clickYes = false;
    
    setWindowFlags(Qt::Dialog | Qt::FramelessWindowHint | Qt::WindowSystemMenuHint);
    setAttribute(Qt::WA_TranslucentBackground);

    build_base(hasClose); 
}

DSDialog::~DSDialog()
{ 
    DESTROY_QT_OBJECT(_base_layout);
    DESTROY_QT_OBJECT(_main_layout);
    DESTROY_QT_OBJECT(_main_widget);
    DESTROY_QT_OBJECT(_titlebar);
    DESTROY_QT_OBJECT(_shadow);
    DESTROY_QT_OBJECT(_base_button);
}

void DSDialog::accept()
{  
    _clickYes = true;
    if (m_callback){
        m_callback->OnDlgResult(true);
    }


    QDialog::accept();
}

void DSDialog::reject()
{ 
    _clickYes = false;

    if (m_callback){
        m_callback->OnDlgResult(false);
    } 

    QDialog::reject();
}
  
void DSDialog::setTitle(QString title)
{
    if (_titlebar){
         _titlebar->setTitle(title);
    } 
}

void DSDialog::reload()
{
    show();
}

int DSDialog::exec()
{ 
      //ok,cancel
    if (m_bBaseButton){
        _base_button = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel,Qt::Horizontal, this);
         _main_layout->addWidget(_base_button);//, 5, 1, 1, 1, Qt::AlignHCenter | Qt::AlignBottom);
        //_main_layout->addWidget(_base_button,0, Qt::AlignHCenter | Qt::AlignBottom);
        connect(_base_button, SIGNAL(rejected()), this, SLOT(reject()));
        connect(_base_button, SIGNAL(accepted()), this, SLOT(accept()));
    }

    update_font();
 
    return QDialog::exec();
}

 void DSDialog::SetTitleSpace(int h)
 {
     if (_titleSpaceLine != NULL){ 
         if (h > 0){
             _titleSpaceLine->setFixedHeight(h);
             _titleSpaceLine->setVisible(true);
         }
         else{
             _titleSpaceLine->setVisible(false);
         }        
     }
 }

void DSDialog::build_base(bool hasClose)
{    
    _main_widget = new QWidget(this);
    _main_layout = new QVBoxLayout(_main_widget);
    _main_widget->setLayout(_main_layout);

    _shadow  = new Shadow(this);
    _shadow->setBlurRadius(10.0);
    _shadow->setDistance(3.0);
    _shadow->setColor(QColor(0, 0, 0, 80));
    _main_widget->setAutoFillBackground(true); 
    this->setGraphicsEffect(_shadow);

    _titlebar = new toolbars::TitleBar(false, this, hasClose);
    _main_layout->addWidget(_titlebar);

    _titleSpaceLine = new QWidget(this);
    _titleSpaceLine->setFixedHeight(15);
    _main_layout->addWidget(_titleSpaceLine);

    _base_layout = new QVBoxLayout(this);   
    _base_layout->addWidget(_main_widget);
    setLayout(_base_layout); 

    _main_layout->setAlignment(Qt::AlignCenter | Qt::AlignTop);
    _main_layout->setContentsMargins(10,5,10,10);   
} 

void DSDialog::update_font()
{
    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
    ui::set_form_font(this, font);

    if (_titlebar != NULL){
        _titlebar->update_font();
    }
}

void DSDialog::show()
{
    update_font();
    
    QWidget::show();
}

} // namespace dialogs
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2015 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "mathoptions.h"
#include <QCheckBox>
#include <QVariant>
#include <QLabel>
#include <QTabBar>
#include <QBitmap>
#include "../appcore/sigsession.h"
#include "../view/view.h"
#include "../view/mathtrace.h"
#include "../data/mathstack.h"
#include "../ui/langresource.h"
  
using namespace boost;
using namespace std;
using namespace dsv::view;

namespace dsv {
namespace dialogs {

MathOptions::MathOptions(SigSession *session, QWidget *parent) :
    DSDialog(parent),
    _session(session),
    _button_box(QDialogButtonBox::Ok | QDialogButtonBox::Cancel,
        Qt::Horizontal, this)
{
    setMinimumSize(300, 300);

    _enable = new QCheckBox(this);

    QLabel *lisa_label = new QLabel(this);
    lisa_label->setPixmap(QPixmap(":/icons/math.svg"));

    _math_group = new QGroupBox(this);
    QHBoxLayout *type_layout = new QHBoxLayout();
    QRadioButton *add_radio = new QRadioButton(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_ADD), "Add"), _math_group);
    add_radio->setProperty("type", data::MathStack::MATH_ADD);
    type_layout->addWidget(add_radio);
    QRadioButton *sub_radio = new QRadioButton(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SUBSTRACT), "Substract"), _math_group);
    sub_radio->setProperty("type", data::MathStack::MATH_SUB);
    type_layout->addWidget(sub_radio);
    QRadioButton *mul_radio = new QRadioButton(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_MULTIPLY), "Multiply"), _math_group);
    mul_radio->setProperty("type", data::MathStack::MATH_MUL);
    type_layout->addWidget(mul_radio);
    QRadioButton *div_radio = new QRadioButton(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_DIVIDE), "Divide"), _math_group);
    div_radio->setProperty("type", data::MathStack::MATH_DIV);
    type_layout->addWidget(div_radio);
    _math_radio.append(add_radio);
    _math_radio.append(sub_radio);
    _math_radio.append(mul_radio);
    _math_radio.append(div_radio);
    _math_group->setLayout(type_layout);

    _src1_group = new QGroupBox(this);
    _src2_group = new QGroupBox(this);
    QHBoxLayout *src1_layout = new QHBoxLayout();
    QHBoxLayout *src2_layout = new QHBoxLayout();

    for(auto s : _session->get_signals()) {
        if (s->signal_type() == SR_CHANNEL_DSO) {
            view::DsoSignal *dsoSig = (view::DsoSignal*)s;
            QString index_str = QString::number(dsoSig->get_index());
            QRadioButton *xradio = new QRadioButton(index_str, _src1_group);
            xradio->setProperty("index", dsoSig->get_index());
            src1_layout->addWidget(xradio);
            QRadioButton *yradio = new QRadioButton(index_str, _src2_group);
            yradio->setProperty("index", dsoSig->get_index());
            src2_layout->addWidget(yradio);
            _src1_radio.append(xradio);
            _src2_radio.append(yradio);
        }
    }
    _src1_group->setLayout(src1_layout);
    _src2_group->setLayout(src2_layout);


    auto math = _session->get_math_trace();
    if (math) {
        _enable->setChecked(math->enabled());
        for (QVector<QRadioButton *>::const_iterator i = _src1_radio.begin();
            i != _src1_radio.end(); i++) {
            if ((*i)->property("index").toInt() == math->src1()) {
               (*i)->setChecked(true);
                break;
            }
        }
        for (QVector<QRadioButton *>::const_iterator i = _src2_radio.begin();
            i != _src2_radio.end(); i++) {
            if ((*i)->property("index").toInt() == math->src2()) {
               (*i)->setChecked(true);
                break;
            }
        }
        for (QVector<QRadioButton *>::const_iterator i = _math_radio.begin();
            i != _math_radio.end(); i++) {
            if ((*i)->property("type").toInt() == math->get_math_stack()->get_type()) {
                (*i)->setChecked(true);
                break;
            }
        }
    } else {
        _enable->setChecked(false);
        for (QVector<QRadioButton *>::const_iterator i = _src1_radio.begin();
            i != _src1_radio.end(); i++) {
           (*i)->setChecked(true);
            break;
        }
        for (QVector<QRadioButton *>::const_iterator i = _src2_radio.begin();
            i != _src2_radio.end(); i++) {
           (*i)->setChecked(true);
            break;
        }
        for (QVector<QRadioButton *>::const_iterator i = _math_radio.begin();
            i != _math_radio.end(); i++) {
            (*i)->setChecked(true);
            break;
        }
    }

    _layout = new QGridLayout(); 
    _layout->setSpacing(0);
    _layout->addWidget(lisa_label, 0, 0, 1, 2, Qt::AlignCenter);
    _layout->addWidget(_enable, 1, 0, 1, 1);
    _layout->addWidget(_math_group, 2, 0, 1, 2);
    _layout->addWidget(_src1_group, 3, 0, 1, 1);
    _layout->addWidget(_src2_group, 3, 1, 1, 1);
    _layout->addWidget(new QLabel(this), 4, 1, 1, 1);
    _layout->addWidget(&_button_box, 5, 1, 1, 1, Qt::AlignHCenter | Qt::AlignBottom);

    layout()->addLayout(_layout);

    connect(&_button_box, SIGNAL(rejected()), this, SLOT(reject()));
    connect(&_button_box, SIGNAL(accepted()), this, SLOT(accept()));

    retranslateUi();
}

void MathOptions::changeEvent(QEvent *event)
{
    if (event->type() == QEvent::LanguageChange)
        retranslateUi();
    DSDialog::changeEvent(event);
}

void MathOptions::retranslateUi()
{
    _enable->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_ENABLE), "Enable"));
    _math_group->setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_MATH_TYPE), "Math Type"));
    _src1_group->setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_1ST_SOURCE), "1st Source"));
    _src2_group->setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_2ST_SOURCE), "2st Source"));
    setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_MATH_OPTIONS), "Math Options"));
}

void MathOptions::accept()
{
	using namespace Qt;
    QDialog::accept();

    int src1 = -1;
    int src2 = -1;
    data::MathStack::MathType type = data::MathStack::MATH_ADD;
    for (QVector<QRadioButton *>::const_iterator i = _src1_radio.begin();
        i != _src1_radio.end(); i++) {
        if ((*i)->isChecked()) {
            src1 = (*i)->property("index").toInt();
            break;
        }
    }
    for (QVector<QRadioButton *>::const_iterator i = _src2_radio.begin();
        i != _src2_radio.end(); i++) {
        if ((*i)->isChecked()) {
            src2 = (*i)->property("index").toInt();
            break;
        }
    }
    for (QVector<QRadioButton *>::const_iterator i = _math_radio.begin();
        i != _math_radio.end(); i++) {
        if ((*i)->isChecked()) {
            type = (data::MathStack::MathType)(*i)->property("type").toInt();
            break;
        }
    }
    bool enable = (src1 != -1 && src2 != -1 && _enable->isChecked());
    view::DsoSignal *dsoSig1 = NULL;
    view::DsoSignal *dsoSig2 = NULL;

    for(auto s : _session->get_signals()) {
        if (s->signal_type() == SR_CHANNEL_DSO) {
            view::DsoSignal *dsoSig = (view::DsoSignal*)s;
            if (dsoSig->get_index() == src1)
                dsoSig1 = dsoSig;
            if (dsoSig->get_index() == src2)
                dsoSig2 = dsoSig;
        }
    }

    if (dsoSig1 != NULL && dsoSig2 != NULL){
        _session->math_rebuild(enable, dsoSig1, dsoSig2, type);
    }    
}

void MathOptions::reject()
{
    using namespace Qt;
    QDialog::reject();
}

} // namespace dialogs
} // namespace dsv
/****************************************************************************
** Meta object code from reading C++ file 'search.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "search.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'search.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPESearchENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPESearchENDCLASS = QtMocHelpers::stringData(
    "dsv::dialogs::Search",
    "format",
    ""
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPESearchENDCLASS_t {
    uint offsetsAndSizes[6];
    char stringdata0[21];
    char stringdata1[7];
    char stringdata2[1];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPESearchENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPESearchENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPESearchENDCLASS = {
    {
        QT_MOC_LITERAL(0, 20),  // "dsv::dialogs::Search"
        QT_MOC_LITERAL(21, 6),  // "format"
        QT_MOC_LITERAL(28, 0)   // ""
    },
    "dsv::dialogs::Search",
    "format",
    ""
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdialogsSCOPESearchENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   20,    2, 0x08,    1 /* Private */,

 // slots: parameters
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dialogs::Search::staticMetaObject = { {
    QMetaObject::SuperData::link<DSDialog::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPESearchENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdialogsSCOPESearchENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPESearchENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<Search, std::true_type>,
        // method 'format'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::dialogs::Search::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<Search *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->format(); break;
        default: ;
        }
    }
    (void)_a;
}

const QMetaObject *dsv::dialogs::Search::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dialogs::Search::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPESearchENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return DSDialog::qt_metacast(_clname);
}

int dsv::dialogs::Search::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = DSDialog::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 1;
    }
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2015 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "lissajousoptions.h"
#include <QCheckBox>
#include <QVariant>
#include <QLabel>
#include <QTabBar>
#include <QBitmap>
#include <math.h>
#include "../appcore/sigsession.h"
#include "../view/view.h"
#include "../view/lissajoustrace.h"
#include "../ui/langresource.h"

  
using namespace boost;
using namespace std;
using namespace dsv::view;

namespace dsv {
namespace dialogs {

LissajousOptions::LissajousOptions(SigSession *session, QWidget *parent) :
    DSDialog(parent),
    _session(session),
    _button_box(QDialogButtonBox::Ok | QDialogButtonBox::Cancel,
        Qt::Horizontal, this)
{
    _enable = NULL;
    _x_group = NULL;
    _y_group = NULL;
    _percent = NULL;
    _layout = NULL;

    setMinimumSize(300, 300);

    _enable = new QCheckBox(this);

    QLabel *lisa_label = new QLabel(this);
    lisa_label->setPixmap(QPixmap(":/icons/lissajous.svg"));

    _percent = new QSlider(Qt::Horizontal, this);
    _percent->setRange(100, 100);
    _percent->setEnabled(false);
    if (_session->cur_samplelimits() > WellLen) {
        int min = ceil(WellLen*100.0/_session->cur_samplelimits());
        _percent->setEnabled(true);
        _percent->setRange(min, 100);
        _percent->setValue(min);
    }

    _x_group = new QGroupBox(this);
    _y_group = new QGroupBox(this);
    QHBoxLayout *xlayout = new QHBoxLayout();
    QHBoxLayout *ylayout = new QHBoxLayout();

    for(auto s : _session->get_signals()) {
        if (s->signal_type() == SR_CHANNEL_DSO) {
            view::DsoSignal *dsoSig = (view::DsoSignal*)s;
            QString index_str = QString::number(dsoSig->get_index());
            QRadioButton *xradio = new QRadioButton(index_str, _x_group);
            xradio->setProperty("index", dsoSig->get_index());
            xlayout->addWidget(xradio);
            QRadioButton *yradio = new QRadioButton(index_str, _y_group);
            yradio->setProperty("index", dsoSig->get_index());
            ylayout->addWidget(yradio);
            _x_radio.append(xradio);
            _y_radio.append(yradio);
        }
    }
    _x_group->setLayout(xlayout);
    _y_group->setLayout(ylayout);


    auto lissajous = _session->get_lissajous_trace();
    if (lissajous) {
        _enable->setChecked(lissajous->enabled());
        _percent->setValue(lissajous->percent());
        for (QVector<QRadioButton *>::const_iterator i = _x_radio.begin();
            i != _x_radio.end(); i++) {
            if ((*i)->property("index").toInt() == lissajous->xIndex()) {
               (*i)->setChecked(true);
                break;
            }
        }
        for (QVector<QRadioButton *>::const_iterator i = _y_radio.begin();
            i != _y_radio.end(); i++) {
            if ((*i)->property("index").toInt() == lissajous->yIndex()) {
               (*i)->setChecked(true);
                break;
            }
        }
    } else {
        _enable->setChecked(false);
        for (QVector<QRadioButton *>::const_iterator i = _x_radio.begin();
            i != _x_radio.end(); i++) {
           (*i)->setChecked(true);
            break;
        }
        for (QVector<QRadioButton *>::const_iterator i = _y_radio.begin();
            i != _y_radio.end(); i++) {
           (*i)->setChecked(true);
            break;
        }
    }

    _layout = new QGridLayout();
    _layout->setSpacing(0);
    _layout->addWidget(lisa_label, 0, 0, 1, 2, Qt::AlignCenter);
    _layout->addWidget(_enable, 1, 0, 1, 1);
    _layout->addWidget(_percent, 2, 0, 1, 2);
    _layout->addWidget(_x_group, 3, 0, 1, 1);
    _layout->addWidget(_y_group, 3, 1, 1, 1);
    _layout->addWidget(new QLabel(this), 4, 1, 1, 1);
    _layout->addWidget(&_button_box, 5, 1, 1, 1, Qt::AlignHCenter | Qt::AlignBottom);

    layout()->addLayout(_layout);

    connect(&_button_box, SIGNAL(rejected()), this, SLOT(reject()));
    connect(&_button_box, SIGNAL(accepted()), this, SLOT(accept()));

    retranslateUi();
}

void LissajousOptions::changeEvent(QEvent *event)
{
    if (event->type() == QEvent::LanguageChange)
        retranslateUi();
    DSDialog::changeEvent(event);
}

void LissajousOptions::retranslateUi()
{
    _enable->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_ENABLE), "Enable"));
    _x_group->setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_X_AXIS), "X-axis"));
    _y_group->setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_Y_AXIS), "Y-axis"));
    setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_LISSAJOUS_OPTIONS), "Lissajous Options"));
}

void LissajousOptions::accept()
{
	using namespace Qt;
    QDialog::accept();

    int xindex = -1;
    int yindex = -1;
    for (QVector<QRadioButton *>::const_iterator i = _x_radio.begin();
        i != _x_radio.end(); i++) {
        if ((*i)->isChecked()) {
            xindex = (*i)->property("index").toInt();
            break;
        }
    }
    for (QVector<QRadioButton *>::const_iterator i = _y_radio.begin();
        i != _y_radio.end(); i++) {
        if ((*i)->isChecked()) {
            yindex = (*i)->property("index").toInt();
            break;
        }
    }
    bool enable = (xindex != -1 && yindex != -1 && _enable->isChecked());
    _session->lissajous_rebuild(enable, xindex, yindex, _percent->value());

    for(auto s : _session->get_signals()) {
        if (s->signal_type() == SR_CHANNEL_DSO) {
            view::DsoSignal *dsoSig = (view::DsoSignal*)s;
            dsoSig->set_show(!enable);
        }
    }
    auto mathTrace = _session->get_math_trace();
    if (mathTrace && mathTrace->enabled()) {
        mathTrace->set_show(!enable);
    }
}

void LissajousOptions::reject()
{
    using namespace Qt;
    QDialog::reject();
}

} // namespace dialogs
} // namespace dsv
/****************************************************************************
** Meta object code from reading C++ file 'waitingdialog.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "waitingdialog.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'waitingdialog.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEWaitingDialogENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEWaitingDialogENDCLASS = QtMocHelpers::stringData(
    "dsv::dialogs::WaitingDialog",
    "changeText",
    "",
    "stop"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEWaitingDialogENDCLASS_t {
    uint offsetsAndSizes[8];
    char stringdata0[28];
    char stringdata1[11];
    char stringdata2[1];
    char stringdata3[5];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEWaitingDialogENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEWaitingDialogENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEWaitingDialogENDCLASS = {
    {
        QT_MOC_LITERAL(0, 27),  // "dsv::dialogs::WaitingDialog"
        QT_MOC_LITERAL(28, 10),  // "changeText"
        QT_MOC_LITERAL(39, 0),  // ""
        QT_MOC_LITERAL(40, 4)   // "stop"
    },
    "dsv::dialogs::WaitingDialog",
    "changeText",
    "",
    "stop"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdialogsSCOPEWaitingDialogENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       2,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   26,    2, 0x08,    1 /* Private */,
       3,    0,   27,    2, 0x08,    2 /* Private */,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dialogs::WaitingDialog::staticMetaObject = { {
    QMetaObject::SuperData::link<DSDialog::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEWaitingDialogENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdialogsSCOPEWaitingDialogENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEWaitingDialogENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<WaitingDialog, std::true_type>,
        // method 'changeText'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'stop'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::dialogs::WaitingDialog::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<WaitingDialog *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->changeText(); break;
        case 1: _t->stop(); break;
        default: ;
        }
    }
    (void)_a;
}

const QMetaObject *dsv::dialogs::WaitingDialog::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dialogs::WaitingDialog::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEWaitingDialogENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return DSDialog::qt_metacast(_clname);
}

int dsv::dialogs::WaitingDialog::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = DSDialog::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 2)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 2;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 2)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 2;
    }
    return _id;
}
QT_WARNING_POP
/****************************************************************************
** Meta object code from reading C++ file 'calibration.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "calibration.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'calibration.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPECalibrationENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPECalibrationENDCLASS = QtMocHelpers::stringData(
    "dsv::dialogs::Calibration",
    "set_value",
    "",
    "value",
    "on_save",
    "on_abort",
    "on_reset",
    "reload_value"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPECalibrationENDCLASS_t {
    uint offsetsAndSizes[16];
    char stringdata0[26];
    char stringdata1[10];
    char stringdata2[1];
    char stringdata3[6];
    char stringdata4[8];
    char stringdata5[9];
    char stringdata6[9];
    char stringdata7[13];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPECalibrationENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPECalibrationENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPECalibrationENDCLASS = {
    {
        QT_MOC_LITERAL(0, 25),  // "dsv::dialogs::Calibration"
        QT_MOC_LITERAL(26, 9),  // "set_value"
        QT_MOC_LITERAL(36, 0),  // ""
        QT_MOC_LITERAL(37, 5),  // "value"
        QT_MOC_LITERAL(43, 7),  // "on_save"
        QT_MOC_LITERAL(51, 8),  // "on_abort"
        QT_MOC_LITERAL(60, 8),  // "on_reset"
        QT_MOC_LITERAL(69, 12)   // "reload_value"
    },
    "dsv::dialogs::Calibration",
    "set_value",
    "",
    "value",
    "on_save",
    "on_abort",
    "on_reset",
    "reload_value"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdialogsSCOPECalibrationENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       5,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   44,    2, 0x08,    1 /* Private */,
       4,    0,   47,    2, 0x08,    3 /* Private */,
       5,    0,   48,    2, 0x08,    4 /* Private */,
       6,    0,   49,    2, 0x08,    5 /* Private */,
       7,    0,   50,    2, 0x08,    6 /* Private */,

 // slots: parameters
    QMetaType::Void, QMetaType::Int,    3,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dialogs::Calibration::staticMetaObject = { {
    QMetaObject::SuperData::link<DSDialog::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPECalibrationENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdialogsSCOPECalibrationENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPECalibrationENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<Calibration, std::true_type>,
        // method 'set_value'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'on_save'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_abort'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_reset'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'reload_value'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::dialogs::Calibration::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<Calibration *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->set_value((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 1: _t->on_save(); break;
        case 2: _t->on_abort(); break;
        case 3: _t->on_reset(); break;
        case 4: _t->reload_value(); break;
        default: ;
        }
    }
}

const QMetaObject *dsv::dialogs::Calibration::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dialogs::Calibration::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPECalibrationENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return DSDialog::qt_metacast(_clname);
}

int dsv::dialogs::Calibration::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = DSDialog::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 5)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 5;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 5)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 5;
    }
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "search.h"
#include <assert.h>
#include <QRegularExpressionValidator>
#include "../ui/langresource.h"
#include "../view/logicsignal.h"
#include "../appcore/sigsession.h"
 
namespace dsv {
namespace dialogs {

Search::Search(QWidget *parent, SigSession *session, std::map<uint16_t, QString> pattern) :
    DSDialog(parent),
    _session(session)
{

    QFont font("Monaco");
    font.setStyleHint(QFont::Monospace);
    font.setFixedPitch(true);
    //this->setMinimumWidth(350);

    QRegularExpression value_rx("[10XRFCxrfc]+");
    QValidator *value_validator = new QRegularExpressionValidator(value_rx, this);

    search_buttonBox.addButton(QDialogButtonBox::Ok);
    search_buttonBox.addButton(QDialogButtonBox::Cancel);

    QGridLayout *search_layout = new QGridLayout();
    search_layout->setVerticalSpacing(0);

    int index = 0;

    for(auto s :  _session->get_signals()) {
        if (s->signal_type() == SR_CHANNEL_LOGIC) {
            view::LogicSignal *logicSig = (view::LogicSignal*)s;
            QLineEdit *search_lineEdit = new QLineEdit(this);
            if (pattern.find(logicSig->get_index()) != pattern.end())
                search_lineEdit->setText(pattern[logicSig->get_index()]);
            else
                search_lineEdit->setText("X");
            search_lineEdit->setValidator(value_validator);
            search_lineEdit->setMaxLength(1);
            search_lineEdit->setInputMask("X");
            search_lineEdit->setFont(font);
            _search_lineEdit_vec.push_back(search_lineEdit);

            search_layout->addWidget(new QLabel(logicSig->get_name()+":"), index, 0, Qt::AlignRight);
            search_layout->addWidget(new QLabel(QString::number(logicSig->get_index())), index, 1, Qt::AlignRight);
            search_layout->addWidget(search_lineEdit, index, 2);

            connect(search_lineEdit, SIGNAL(editingFinished()), this, SLOT(format()));

            index++;
        }
    }

    search_layout->addWidget(new QLabel(" "), index,0);
    //tr
    search_layout->addWidget(new QLabel(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SEARCH_LABEL), 
                            "X: Don't care\n0: Low level\n1: High level\nR: Rising edge\nF: Falling edge\nC: Rising/Falling edge")), 0, 3, index, 1);
    search_layout->addWidget(&search_buttonBox, index+1, 3);
    search_layout->setColumnStretch(3, 100);

    layout()->addLayout(search_layout);
    setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SEARCH_OPTIONS), "Search Options"));

    connect(&search_buttonBox, SIGNAL(accepted()), this, SLOT(accept()));
    connect(&search_buttonBox, SIGNAL(rejected()), this, SLOT(reject()));
}

Search::~Search()
{
}

void Search::accept()
{
    using namespace Qt;

    QDialog::accept();
}

void Search::format()
{
    QLineEdit *sc = qobject_cast<QLineEdit *>(sender());
    sc->setText(sc->text().toUpper());
}

std::map<uint16_t, QString> Search::get_pattern()
{
    std::map<uint16_t, QString> pattern;

    int index = 0;
    for(auto s :_session->get_signals()) {
        if (s->signal_type() == SR_CHANNEL_LOGIC) {
            view::LogicSignal *logicSig = (view::LogicSignal*)s;
            pattern[logicSig->get_index()] = _search_lineEdit_vec[index]->text();
            index++;
        }
    }

    return pattern;
}

} // namespace dialogs
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2015 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_MATHOPTIONS_H
#define DSVIEW_PV_MATHOPTIONS_H

#include <QGridLayout>
#include <QToolButton>
#include <QDialogButtonBox>
#include <QTabWidget>
#include <QGroupBox>
#include <QCheckBox>
#include <QRadioButton>
#include <QSlider>
 

#include "../view/dsosignal.h"
#include "../toolbars/titlebar.h"
#include "dsdialog.h"

namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
    namespace view {
        class View;
    }
}
using namespace dsv::appcore;
using namespace dsv::view;

namespace dsv {
namespace dialogs {

class MathOptions : public DSDialog
{
	Q_OBJECT

private:
    static const int WellLen = SR_Kn(16);

public:
    MathOptions(SigSession *session, QWidget *parent);

private:
    void changeEvent(QEvent *event);
    void retranslateUi();

protected:
	void accept();
    void reject();

private:
    SigSession *_session;

    QCheckBox *_enable;
    QGroupBox *_src1_group;
    QGroupBox *_src2_group;
    QGroupBox *_math_group;
    QVector<QRadioButton *> _src1_radio;
    QVector<QRadioButton *> _src2_radio;
    QVector<QRadioButton *> _math_radio;
    QDialogButtonBox _button_box;
    QGridLayout *_layout;
};

} // namespace dialogs
} // namespace dsv

#endif // DSVIEW_PV_MATHOPTIONS_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "protocolexp.h"
#include <QFormLayout>
#include <QListWidget>
#include <QFile>
#include <QFileDialog>
#include <QTextStream>
#include <QProgressDialog>
#include <QFuture>
#include <QtConcurrent/QtConcurrent>
#include <algorithm>
#include "../appcore/sigsession.h"
#include "../data/decoderstack.h"
#include "../decode/row.h"
#include "../decode/annotation.h"
#include "../view/decodetrace.h"
#include "../data/decodermodel.h"
#include "../config/appconfig.h"
#include "../basedef.h"
#include "../utility/encoding.h"
#include "../utility/path.h"
#include "../log.h"
#include "../ui/langresource.h"

#define EXPORT_DEC_ROW_COUNT_MAX 20

using namespace dsv::config;

namespace dsv {
namespace dialogs {

ProtocolExp::ProtocolExp(QWidget *parent, SigSession *session) :
    DSDialog(parent),
    _session(session),
    _button_box(QDialogButtonBox::Ok | QDialogButtonBox::Cancel,
        Qt::Horizontal, this),
    _export_cancel(false)
{
    _format_combobox = new DsComboBox(this);
    //tr
    _format_combobox->addItem("Comma-Separated Values (*.csv)");
    _format_combobox->addItem("Text files (*.txt)");

    _flayout = new QFormLayout();
    _flayout->setVerticalSpacing(5);
    _flayout->setFormAlignment(Qt::AlignLeft);
    _flayout->setLabelAlignment(Qt::AlignLeft);
    _flayout->setFieldGrowthPolicy(QFormLayout::AllNonFixedFieldsGrow);
    _flayout->addRow(new QLabel(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_EXPORT_FORMAT), "Export Format: "), this), _format_combobox);

    dsv::data::DecoderModel* decoder_model = _session->get_decoder_model();

    const auto decoder_stack = decoder_model->getDecoderStack();
    if (decoder_stack) {
        int row_index = 0;
        auto rows = decoder_stack->get_rows_lshow();

        for (auto i = rows.begin();i != rows.end(); i++) {
            if ((*i).second) {
                QLabel *row_label = new QLabel((*i).first.title(), this);
                QCheckBox *row_sel = new QCheckBox(this);
                if (row_index == 0) {
                    row_sel->setChecked(true);
                }
                _row_label_list.push_back(row_label);
                _row_sel_list.push_back(row_sel);
                _flayout->addRow(row_label, row_sel);
                row_sel->setProperty("index", row_index);
                row_sel->setProperty("title", (*i).first.title());
                row_index++;
            }
        }
    }

    _layout = new QVBoxLayout();
    _layout->addLayout(_flayout);
    _layout->addWidget(&_button_box);

    layout()->addLayout(_layout);
    setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_PROTOCOL_EXPORT), "Protocol Export"));

    connect(&_button_box, SIGNAL(accepted()), this, SLOT(accept()));
    connect(&_button_box, SIGNAL(rejected()), this, SLOT(reject()));
    connect(_session->device_event_object(), SIGNAL(device_updated()), this, SLOT(reject()));

}

void ProtocolExp::accept()
{ 
    QDialog::accept();

    if (_row_sel_list.empty()){
        return;
    }

    QList<QString> supportedFormats;
    for (int i = _format_combobox->count() - 1; i >= 0; i--)
    {
        supportedFormats.push_back(_format_combobox->itemText(i));
    }

    QString filter;
    for (int i = 0; i < supportedFormats.count(); i++)
    {
        filter.append(supportedFormats[i]);
        if (i < supportedFormats.count() - 1)
            filter.append(";;");
    }

    AppConfig &app = AppConfig::Instance();
    QString default_filter = _format_combobox->currentText();
    QString default_name = app.userHistory.protocolExportPath + "/" + "decoder-";
    default_name += _session->get_session_time().toString("-yyMMdd-hhmmss");

    QString file_name = QFileDialog::getSaveFileName(
        this,
        L_S(STR_PAGE_DLG, S_ID(IDS_DLG_EXPORT_DATA), "Export Data"),
        default_name, filter,
        &default_filter);

    if (file_name == ""){
        return;
    }

    QFileInfo f(file_name);
    QStringList list = default_filter.split('.').last().split(')');
    QString ext = list.first();
    if (f.suffix().compare(ext))
        //tr
        file_name += "." + ext;

    QString fname = path::GetDirectoryName(file_name);
    if (fname != app.userHistory.openDir)
    {
        app.userHistory.protocolExportPath = fname;
        app.SaveHistory();
    }
    _fileName = file_name;
 
    QFuture<void> future;
    future = QtConcurrent::run([&]{
                    save_proc();
               });

    Qt::WindowFlags flags = Qt::CustomizeWindowHint;
    QProgressDialog dlg(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_EXPORT_PROTOCOL_LIST_RESULT), 
                        "Export Protocol List Result... It can take a while."),
                        L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CANCEL), "Cancel"), 0, 100, this, flags);
    dlg.setWindowModality(Qt::WindowModal);
    dlg.setWindowFlags(Qt::Dialog | Qt::FramelessWindowHint | Qt::WindowSystemMenuHint |
                       Qt::WindowMinimizeButtonHint | Qt::WindowMaximizeButtonHint);

    QFutureWatcher<void> watcher;

    connect(&watcher, SIGNAL(finished()), &dlg, SLOT(cancel()));
    connect(this, SIGNAL(export_progress(int)), &dlg, SLOT(setValue(int)));
    connect(&dlg, SIGNAL(canceled()), this, SLOT(cancel_export()));

    watcher.setFuture(future);
    dlg.exec();

    future.waitForFinished();   
}

void ProtocolExp::save_proc()
{
    _export_cancel = false;

    QFile file(_fileName);
    file.open(QIODevice::WriteOnly | QIODevice::Text);
    QTextStream out(&file);
    encoding::set_utf8(out);
    // out.setGenerateByteOrderMark(true); // UTF-8 without BOM
    int row_num = 0;
    ExportRowInfo row_inf_arr[EXPORT_DEC_ROW_COUNT_MAX];
    std::vector<Annotation*> annotations_arr[EXPORT_DEC_ROW_COUNT_MAX];

    for (std::list<QCheckBox *>::const_iterator i = _row_sel_list.begin();
         i != _row_sel_list.end(); i++)
    {
        if ((*i)->isChecked())
        {
            row_inf_arr[row_num].title = (*i)->property("title").toString();
            row_inf_arr[row_num].row_index = (*i)->property("index").toULongLong();
            row_num++;

            if (row_num == EXPORT_DEC_ROW_COUNT_MAX)
                break;
        }
    }

    if (row_num == 0){
        dsv_info("ERROR: There have no decode data row to export.");
        return;
    }

    dsv::data::DecoderModel *decoder_model = _session->get_decoder_model();
    const auto decoder_stack = decoder_model->getDecoderStack();
    
    int fd_row_dex = 0;
    const std::map<const Row, bool> rows_lshow = decoder_stack->get_rows_lshow();
    for (auto it = rows_lshow.begin();it != rows_lshow.end(); it++)
    {
        if ((*it).second)
        {
            for (int i=0; i<row_num; i++) {
                if (row_inf_arr[i].row_index == fd_row_dex){
                    row_inf_arr[i].row = &(*it).first;
                    break;
                }
            }      
            fd_row_dex++;
        }
    }

    //get annotation list
    uint64_t total_ann_count = 0;

    for (int i=0; i<row_num; i++)
    {
        decoder_stack->get_annotation_subset(annotations_arr[i], *row_inf_arr[i].row,
                                         0, decoder_stack->sample_count() - 1);
        total_ann_count += (uint64_t)annotations_arr[i].size();
        sort(annotations_arr[i].begin(), annotations_arr[i].end(), compare_ann_index);  
        row_inf_arr[i].read_index = 0;
    }

    //title
    QString title_str;

    for (int i=0; i<row_num; i++) {
        if (i > 0 && i < row_num){
            title_str.append(",");
        }
        title_str.append(row_inf_arr[i].title);
    }

    out << QString("%1,%2,%3\n")
            .arg("Id")
            .arg("Time[ns]")
            .arg(title_str);

    uint64_t write_row_dex = 0;
    uint64_t write_ann_num = 0;
    double ns_per_sample = SR_SEC(1) * 1.0 / decoder_stack->samplerate();
    uint64_t sample_index = 0;
    uint64_t sample_index1 = 0;

    while (write_ann_num < total_ann_count && !_export_cancel)
    {    
        bool bFirtColumn = true;

        for (int i=0; i<row_num; i++)
        {   
            if (row_inf_arr[i].read_index >= annotations_arr[i].size())
                continue;
            
            Annotation *ann = annotations_arr[i].at(row_inf_arr[i].read_index);
            sample_index1 = ann->start_sample();

            if (bFirtColumn || sample_index1 < sample_index){
                sample_index = sample_index1;
                bFirtColumn = false;
            }
        }

        QString ann_row_str;

        for (int i=0; i<row_num; i++)
        {   
            if (i > 0 && i < row_num){
                ann_row_str.append(",");
            }

            if (row_inf_arr[i].read_index >= annotations_arr[i].size())
                continue;
            
            Annotation *ann = annotations_arr[i].at(row_inf_arr[i].read_index);           

            if (ann->start_sample() == sample_index){
                ann_row_str.append(ann->annotations().at(0));
                row_inf_arr[i].read_index++;
                write_ann_num++;
            }
        }

        write_row_dex++;

        out << QString("%1,%2,%3\n")
                       .arg(QString::number(write_row_dex))
                       .arg(QString::number(sample_index * ns_per_sample, 'f', 2))
                       .arg(ann_row_str);

        emit export_progress(write_ann_num * 100 / total_ann_count);
    }

    file.close();
}

bool ProtocolExp::compare_ann_index(const decode::Annotation *a, 
                    const decode::Annotation *b)
{   
    assert(a);
    assert(b);
    return a->start_sample() < b->start_sample();
}

void ProtocolExp::reject()
{
    using namespace Qt;

    QDialog::reject();
}

void ProtocolExp::cancel_export()
{
    _export_cancel = true;
}

} // namespace dialogs
} // namespace dsv
/****************************************************************************
** Meta object code from reading C++ file 'fftoptions.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "fftoptions.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'fftoptions.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEFftOptionsENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEFftOptionsENDCLASS = QtMocHelpers::stringData(
    "dsv::dialogs::FftOptions",
    "window_changed",
    "",
    "index",
    "len_changed"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEFftOptionsENDCLASS_t {
    uint offsetsAndSizes[10];
    char stringdata0[25];
    char stringdata1[15];
    char stringdata2[1];
    char stringdata3[6];
    char stringdata4[12];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEFftOptionsENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEFftOptionsENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEFftOptionsENDCLASS = {
    {
        QT_MOC_LITERAL(0, 24),  // "dsv::dialogs::FftOptions"
        QT_MOC_LITERAL(25, 14),  // "window_changed"
        QT_MOC_LITERAL(40, 0),  // ""
        QT_MOC_LITERAL(41, 5),  // "index"
        QT_MOC_LITERAL(47, 11)   // "len_changed"
    },
    "dsv::dialogs::FftOptions",
    "window_changed",
    "",
    "index",
    "len_changed"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdialogsSCOPEFftOptionsENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       2,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   26,    2, 0x08,    1 /* Private */,
       4,    1,   29,    2, 0x08,    3 /* Private */,

 // slots: parameters
    QMetaType::Void, QMetaType::Int,    3,
    QMetaType::Void, QMetaType::Int,    3,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dialogs::FftOptions::staticMetaObject = { {
    QMetaObject::SuperData::link<DSDialog::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEFftOptionsENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdialogsSCOPEFftOptionsENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEFftOptionsENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<FftOptions, std::true_type>,
        // method 'window_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'len_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>
    >,
    nullptr
} };

void dsv::dialogs::FftOptions::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<FftOptions *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->window_changed((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 1: _t->len_changed((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        default: ;
        }
    }
}

const QMetaObject *dsv::dialogs::FftOptions::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dialogs::FftOptions::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEFftOptionsENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return DSDialog::qt_metacast(_clname);
}

int dsv::dialogs::FftOptions::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = DSDialog::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 2)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 2;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 2)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 2;
    }
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_SHADOW_H
#define DSVIEW_PV_SHADOW_H

#include <QGraphicsDropShadowEffect>
#include <QGraphicsEffect>

namespace dsv {
namespace dialogs {

class Shadow : public QGraphicsEffect
{
    Q_OBJECT
public:
    explicit Shadow(QObject *parent = 0);

    void draw(QPainter* painter);
    QRectF boundingRectFor(const QRectF& rect) const;

    inline void setDistance(qreal distance) { _distance = distance; updateBoundingRect(); }
    inline qreal distance() const { return _distance; }

    inline void setBlurRadius(qreal blurRadius) { _blurRadius = blurRadius; updateBoundingRect(); }
    inline qreal blurRadius() const { return _blurRadius; }

    inline void setColor(const QColor& color) { _color = color; }
    inline QColor color() const { return _color; }

private:
    qreal  _distance;
    qreal  _blurRadius;
    QColor _color;
};

} // namespace dialogs
} // namespace dsv

#endif // DSVIEW_PV_SHADOW_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_REGIONOPTIONS_H
#define DSVIEW_PV_REGIONOPTIONS_H

#include <QDialogButtonBox>
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QLabel> 
#include "../toolbars/titlebar.h"
#include "dsdialog.h"
#include "../ui/dscombobox.h"

namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
}
using namespace dsv::appcore;

namespace dsv{
	namespace view{
    	class View;
	}
}
using namespace dsv::view;

namespace dsv {
namespace dialogs {

class RegionOptions : public DSDialog
{
    Q_OBJECT
private:
    static const QString RegionStart;
    static const QString RegionEnd;

public:
    RegionOptions(view::View *view, SigSession *session, QWidget *parent = 0);

private slots:
    void set_region();

private:
    SigSession *_session;
    view::View *_view;

    DsComboBox *_start_comboBox;
    DsComboBox *_end_comboBox;

    QDialogButtonBox _button_box;

};

} // namespace dialogs
} // namespace dsv

#endif // DSVIEW_PV_REGIONOPTIONS_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_DSMESSAGEBOX_H
#define DSVIEW_PV_DSMESSAGEBOX_H

#include <QDialog>
#include <QWidget>
#include <QMessageBox>
#include <QVBoxLayout>
#include "../toolbars/titlebar.h"

namespace dsv {
namespace dialogs {

    class Shadow;

class DSMessageBox : public QDialog
{
	Q_OBJECT

public:
    DSMessageBox(QWidget *parent, const QString title=0);

    ~DSMessageBox();

    QMessageBox *mBox(); 

    int exec();
    
    inline int IsYes(){return _bClickYes;}

protected:
    void accept();
    void reject();  

private slots:
    void on_button(QAbstractButton* btn);

private:
    QVBoxLayout         *_layout;
    QVBoxLayout         *_main_layout;
    QWidget             *_main_widget;
    QMessageBox         *_msg;
    toolbars::TitleBar  *_titlebar;
    Shadow              *_shadow;
 
    QPoint              _startPos;
    bool                _bClickYes;
};

} // namespace dialogs
} // namespace dsv

#endif // DSVIEW_PV_DSMESSAGEBOX_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2015 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_DSOMEASURE_H
#define DSVIEW_PV_DSOMEASURE_H

#include <QVBoxLayout>
#include <QToolButton>
#include <QDialogButtonBox>
#include <QTabWidget>
 

#include "../view/dsosignal.h"
#include "../toolbars/titlebar.h"
#include "dsdialog.h"

namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
    namespace view {
        class View;
    }
}
using namespace dsv::appcore;
using namespace dsv::view;

namespace dsv {
namespace dialogs {

class DsoMeasure : public DSDialog
{
	Q_OBJECT

public:
    DsoMeasure(SigSession *session, view::View &parent, unsigned int position, int last_sig_index);

    ~DsoMeasure();

    static QString get_ms_icon(int ms_type);
    static QString get_ms_text(int ms_type);

private:
    void add_measure(QWidget *widget, const view::DsoSignal *dsoSig);

private slots:
    void set_measure(bool en);
    void reset();

protected:
	void accept();
    void reject();

private:
    SigSession *_session;
    view::View &_view;
    unsigned int _position;
 
    QDialogButtonBox _button_box;
    QTabWidget *_measure_tab;
    QVBoxLayout _layout; 
};

} // namespace dialogs
} // namespace dsv

#endif // DSVIEW_PV_DSOMEASURE_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "waitingdialog.h"
#include <QMovie>
#include <QAbstractButton>
#include <QFuture>
#include <QProgressDialog>
#include <QtConcurrent/QtConcurrent>
#include <QVBoxLayout>
#include "../view/trace.h"
#include "../view/dsosignal.h"
#include "../config/appconfig.h"
#include "../ui/langresource.h"
#include "../appcore/appcontrol.h"
#include "../appcore/sigsession.h"

using namespace boost;
using namespace std;
using namespace dsv::config;

namespace dsv {
namespace dialogs {

const QString WaitingDialog::TIPS_WAIT = "Waiting";
const QString WaitingDialog::TIPS_FINISHED = "Finished!";

WaitingDialog::WaitingDialog(QWidget *parent, SigSession *session, int key) :
    DSDialog(parent),
    _key(key),
    _session(session),
    _button_box(QDialogButtonBox::Abort,
        Qt::Horizontal, this)
{
    _device_agent = _session->get_device();

    this->setFixedSize((GIF_WIDTH+2*TIP_WIDTH)*1.2, (GIF_HEIGHT+2*TIP_HEIGHT)*4);
    this->setWindowOpacity(0.7);

    QFont font;
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
    font.setBold(true);

    QLabel *warning_tips = new QLabel(this);
    warning_tips->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_DONT_CONNECT_PROBES), "Don't connect any probes!"));
    warning_tips->setFont(font);
    warning_tips->setAlignment(Qt::AlignCenter);

    QString iconPath = AppConfig::GetIconPath();
    label = new QLabel(this);
    movie = new QMovie(iconPath+"/wait.gif");
    label->setMovie(movie);
    label->setAlignment(Qt::AlignCenter);

    tips = new QLabel(this);
    tips->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_WAITING), "Waiting"));
    tips->setFont(font);
    tips->setAlignment(Qt::AlignCenter);

    index = 0;
    timer = new QTimer();
    connect(timer, SIGNAL(timeout()), this, SLOT(changeText()));
    connect(&_button_box, SIGNAL(accepted()), this, SLOT(accept()));
    connect(&_button_box, SIGNAL(rejected()), this, SLOT(reject()));
    connect(_session->device_event_object(), SIGNAL(device_updated()), this, SLOT(stop()));

    QVBoxLayout *mlayout = new QVBoxLayout();
    mlayout->addWidget(warning_tips, Qt::AlignHCenter);
    mlayout->addWidget(label, Qt::AlignHCenter);
    mlayout->addWidget(tips, Qt::AlignHCenter);
    mlayout->addWidget(&_button_box);

    layout()->addLayout(mlayout);
    setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_AUTO_CALIBRATION), "Auto Calibration"));
}

WaitingDialog::~WaitingDialog()
{

}

void WaitingDialog::accept()
{
	using namespace Qt;
    movie->stop();
    timer->stop();
    QDialog::accept();

    QFuture<void> future;
    future = QtConcurrent::run([&]{
        _device_agent->set_config_bool(SR_CONF_ZERO_SET, true);
    });

    Qt::WindowFlags flags = Qt::CustomizeWindowHint;
    QProgressDialog dlg(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SAVE_CALIBRATION_RESULTS), "Save calibration results... It can take a while."),
                        L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CANCEL), "Cancel"),0,0,this,flags);
    dlg.setWindowModality(Qt::WindowModal);
    dlg.setWindowFlags(Qt::Dialog | Qt::FramelessWindowHint | Qt::WindowSystemMenuHint |
                       Qt::WindowMinimizeButtonHint | Qt::WindowMaximizeButtonHint);
    dlg.setCancelButton(NULL);

    QFutureWatcher<void> watcher;
    connect(&watcher,SIGNAL(finished()),&dlg,SLOT(cancel()));
    watcher.setFuture(future);

    dlg.exec();
}

void WaitingDialog::reject()
{
    using namespace Qt;

    movie->stop();
    timer->stop();
    QDialog::reject();

    QFuture<void> future;
    future = QtConcurrent::run([&]{
        _device_agent->set_config_bool(_key, false);
        _device_agent->set_config_bool(SR_CONF_ZERO_LOAD, true);
    });

    Qt::WindowFlags flags = Qt::CustomizeWindowHint;
    QProgressDialog dlg(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_LOAD_CURRENT_SETTING), "Load current setting... It can take a while."),
                        L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CANCEL), "Cancel"),0,0,this,flags);
    dlg.setWindowModality(Qt::WindowModal);
    dlg.setWindowFlags(Qt::Dialog | Qt::FramelessWindowHint | Qt::WindowSystemMenuHint |
                       Qt::WindowMinimizeButtonHint | Qt::WindowMaximizeButtonHint);
    dlg.setCancelButton(NULL);

    QFutureWatcher<void> watcher;
    connect(&watcher,SIGNAL(finished()),&dlg,SLOT(cancel()));
    watcher.setFuture(future);

    dlg.exec();
}

void WaitingDialog::stop()
{
    using namespace Qt;

    movie->stop();
    timer->stop();
    QDialog::reject();
}

int WaitingDialog::start()
{
    movie->start();
    timer->start(300);
    return this->exec();
}

void WaitingDialog::changeText()
{
    index++;
    if(index == WPOINTS_NUM + 1)
    {
        tips->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_WAITING), "Waiting"));
        index = 0;
        bool comb_comp_en = false;
        bool zero_fgain = false;

        if (_device_agent->get_config_bool(SR_CONF_PROBE_COMB_COMP_EN, comb_comp_en) && comb_comp_en) {
            
            if (_device_agent->get_config_bool(SR_CONF_ZERO_COMB_FGAIN, zero_fgain) && zero_fgain) {                 
                                        
                for(auto s : _session->get_signals()){
                    if (s->signal_type() == SR_CHANNEL_DSO){
                        view::DsoSignal *dsoSig = (view::DsoSignal*)s;
                        dsoSig->set_enable(dsoSig->get_index() == 0);
                    }                                
                }

                std::this_thread::sleep_for(std::chrono::milliseconds(100));
                _device_agent->set_config_bool(SR_CONF_ZERO_COMB, true);
            }
        }
        
        bool bzero = false; 
        if (_device_agent->get_config_bool(_key, bzero)) {
            if (!bzero) {
                movie->stop();
                movie->jumpToFrame(0);
                timer->stop();
                tips->setAlignment(Qt::AlignHCenter);
                tips->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_FINISHED), "Finished!"));
                _button_box.addButton(QDialogButtonBox::Save);
            }
        }
    } 
    else {
        tips->setText(tips->text()+".");
    }
}

} // namespace dialogs
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_WAITINGDIALOG_H
#define DSVIEW_PV_WAITINGDIALOG_H

#include <QDialogButtonBox>
#include <QTimer>
#include <QLabel>
#include <QMovie>
#include "../toolbars/titlebar.h"
#include "dsdialog.h"


namespace dsv{
	namespace appcore{
    	class SigSession;
        class DeviceAgent;
	}
}
using namespace dsv::appcore;

namespace dsv {
namespace dialogs {

class WaitingDialog : public DSDialog
{
	Q_OBJECT

private:
    static const int GIF_SIZE = 80;
    static const int GIF_WIDTH = 220;
    static const int GIF_HEIGHT = 20;
    static const int TIP_WIDTH = 100;
    static const int TIP_HEIGHT = 40;
    static const int WPOINTS_NUM = 6;
    static const QString TIPS_WAIT;
    static const QString TIPS_FINISHED;

public:
    WaitingDialog(QWidget *parent, SigSession *session, int key);
    ~WaitingDialog();
    
    int start();

protected:
	void accept();
    void reject();

private slots:
    void changeText();
    void stop();

private:
    int _key;
    SigSession *_session;
    toolbars::TitleBar *_titlebar;
    QDialogButtonBox _button_box;

    int index;
    QLabel *label;
    QMovie *movie;
    QTimer *timer;
    QLabel *tips;
    DeviceAgent *_device_agent;
};

} // namespace dialogs
} // namespace dsv

#endif // DSVIEW_PV_WAITINGDIALOG_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_SEARCH_H
#define DSVIEW_PV_SEARCH_H

#include <QLabel>
#include <QLineEdit>
#include <QVBoxLayout>
#include <QGridLayout>
#include <QDialogButtonBox>
#include "../toolbars/titlebar.h"
#include "dsdialog.h"
 
namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
}
using namespace dsv::appcore;

namespace dsv {
namespace dialogs {

class Search : public DSDialog
{
    Q_OBJECT

public:

    Search(QWidget *parent, SigSession *session, std::map<uint16_t, QString> pattern);
    ~Search();

    std::map<uint16_t, QString> get_pattern();

protected:
    void accept();

signals:
    
private slots:
    void format();
    
private:
    SigSession *_session;

    toolbars::TitleBar *_titlebar;
    QVector<QLineEdit *> _search_lineEdit_vec;
    QDialogButtonBox search_buttonBox;
};

} // namespace dialogs
} // namespace dsv

#endif // DSVIEW_PV_SEARCH_H
/****************************************************************************
** Meta object code from reading C++ file 'dsdialog.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "dsdialog.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'dsdialog.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDSDialogENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDSDialogENDCLASS = QtMocHelpers::stringData(
    "dsv::dialogs::DSDialog"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDSDialogENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[23];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDSDialogENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDSDialogENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDSDialogENDCLASS = {
    {
        QT_MOC_LITERAL(0, 22)   // "dsv::dialogs::DSDialog"
    },
    "dsv::dialogs::DSDialog"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdialogsSCOPEDSDialogENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dialogs::DSDialog::staticMetaObject = { {
    QMetaObject::SuperData::link<QDialog::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDSDialogENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdialogsSCOPEDSDialogENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDSDialogENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<DSDialog, std::true_type>
    >,
    nullptr
} };

void dsv::dialogs::DSDialog::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *dsv::dialogs::DSDialog::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dialogs::DSDialog::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdialogsSCOPEDSDialogENDCLASS.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "IFontForm"))
        return static_cast< IFontForm*>(this);
    return QDialog::qt_metacast(_clname);
}

int dsv::dialogs::DSDialog::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QDialog::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "interval.h"
#include <QGridLayout>
#include "../ui/langresource.h"

namespace dsv {
namespace dialogs {

Interval::Interval(QWidget *parent) :
    DSDialog(parent),
    _button_box(QDialogButtonBox::Ok,
        Qt::Horizontal, this)
{
    _interval_label = NULL;
    _interval_spinBox = NULL;
    _interval_slider = NULL;
    _bSetting = false;
    _bDone = false;

    setMinimumWidth(300);
    _interval_label = new QLabel(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_INTERVAL_S), "Interval(s): "), this);
    _interval_spinBox = new QDoubleSpinBox(this);
    _interval_spinBox->setRange(0.1, 10);
    _interval_spinBox->setDecimals(1);
    _interval_spinBox->setButtonSymbols(QAbstractSpinBox::NoButtons);
    _interval_slider = new QSlider(Qt::Horizontal, this);
    _interval_slider->setRange(0, 10);

    QGridLayout *glayout = new QGridLayout(this);
    glayout->addWidget(_interval_label, 0, 0);
    glayout->addWidget(_interval_spinBox, 0, 1);
    glayout->addWidget(_interval_slider, 1, 0, 1, 3);
    glayout->addWidget(&_button_box, 2, 2);

    layout()->addLayout(glayout);
    setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_REPETITIVE_INTERVAL), "Repetitive Interval"));

    connect(&_button_box, SIGNAL(accepted()), this, SLOT(accept()));
    connect(_interval_slider, SIGNAL(valueChanged(int)), this, SLOT(on_slider_changed(int)));
    connect(_interval_spinBox, SIGNAL(valueChanged(double)), this, SLOT(on_inputbox_changed(double)));
}

void Interval::accept()
{
    using namespace Qt;
    _bDone = true;
    QDialog::accept();
}

void Interval::reject()
{
    using namespace Qt;

    QDialog::reject();
}

void Interval::set_interval(double value)
{
    _interval_slider->setValue((int)value);
    _interval_spinBox->setValue(value);
}

double Interval::get_interval()
{
    return _interval_spinBox->value();
}

void Interval::on_slider_changed(int value)
{
    if (!_bSetting){
        _bSetting = true;
        _interval_spinBox->setValue((double)value);
        _bSetting = false;
    }    
}

void Interval::on_inputbox_changed(double value)
{
    if (!_bSetting){
        _bSetting = true;
        _interval_slider->setValue((int)value);
        _bSetting = false;
    }    
}

} // namespace dialogs
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2022 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "decoderoptionsdlg.h"
#include <libsigrokdecode.h>
#include <QScrollArea> 
#include <QDialogButtonBox>
#include <assert.h>
#include <QVBoxLayout>
#include <QLabel> 
#include <QGridLayout>
#include <QFormLayout>
#include <QScrollArea> 
#include <QVariant>
#include <QGuiApplication>
#include <QScreen>
#include <QCheckBox>
#include "../data/decoderstack.h"
#include "../prop/binding/decoderoptions.h"
#include "../decode/decoder.h"
#include "../ui/dscombobox.h"
#include "../view/logicsignal.h"
#include "../appcore/appcontrol.h"
#include "../appcore/sigsession.h"
#include "../view/view.h"
#include "../view/cursor.h"
#include "../widgets/decodergroupbox.h"
#include "../view/decodetrace.h"
#include "../ui/msgbox.h"
#include "../ui/langresource.h"
#include "../config/appconfig.h"

using namespace dsv::config;

namespace dsv {
namespace dialogs {

DecoderOptionsDlg::DecoderOptionsDlg(QWidget *parent)
:DSDialog(parent)
{
    _cursor1 = 0;
    _cursor2 = 0;
    _contentHeight = 0;
    _is_reload_form = false;
    _content_width = 0;
}

DecoderOptionsDlg::~DecoderOptionsDlg()
{
    for(auto p : _bindings){
        delete p;
    }
    _bindings.clear();
}

void DecoderOptionsDlg::load_options(view::DecodeTrace *trace)
{
    assert(trace);
    _trace = trace;

    const char *dec_id = trace->decoder()->get_root_decoder_id();

    if (LangResource::Instance()->is_new_decoder(dec_id))
        LangResource::Instance()->reload_dynamic();

    load_options_view();

    LangResource::Instance()->release_dynamic();
}

void DecoderOptionsDlg::load_options_view()
{   
    DSDialog *dlg = this;   

    dlg->setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_DECODER_OPTIONS), "Decoder Options"));   

    QFormLayout *form = new QFormLayout();
    form->setContentsMargins(0, 0, 0, 0);
    form->setVerticalSpacing(5);
    form->setFormAlignment(Qt::AlignLeft);
    form->setLabelAlignment(Qt::AlignLeft);
    dlg->layout()->addLayout(form);
    
    //scroll pannel
    QWidget *scroll_pannel  = new QWidget();
    QVBoxLayout *scroll_lay = new QVBoxLayout();
    scroll_lay->setContentsMargins(0, 0, 0, 0);
    scroll_lay->setAlignment(Qt::AlignLeft);
    scroll_pannel->setLayout(scroll_lay);
    form->addRow(scroll_pannel);

    // decoder options 
    QWidget *container_panel = new QWidget();      
    QVBoxLayout *decoder_lay = new QVBoxLayout();
    decoder_lay->setContentsMargins(0, 0, 0, 0);
    decoder_lay->setDirection(QBoxLayout::TopToBottom);
    container_panel->setLayout(decoder_lay);
    scroll_lay->addWidget(container_panel);
  
    load_decoder_forms(container_panel);
 
    //Add region combobox
    _start_comboBox = new DsComboBox(dlg);
    _end_comboBox = new DsComboBox(dlg);
    _start_comboBox->addItem("Start");
    _end_comboBox->addItem("End"); 
    _start_comboBox->setMinimumContentsLength(7);
    _end_comboBox->setMinimumContentsLength(7);
    _start_comboBox->setMinimumWidth(30);
    _end_comboBox->setMinimumWidth(30);
    
    // Add cursor list
    auto view = _trace->get_view();
    int dex1 = 0;
    int dex2 = 0;

    if (view)
    {  
        int num = 1;
        auto &cursor_list = view->get_cursorList();
        
        for (auto c : cursor_list){
            //tr
            QString cursor_name = L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CURSOR), "Cursor") + 
                                QString::number(num);
            _start_comboBox->addItem(cursor_name, QVariant((quint64)c->get_key()));
            _end_comboBox->addItem(cursor_name, QVariant((quint64)c->get_key()));

            if (c->get_key() == _cursor1)
                dex1 = num;
            if (c->get_key() == _cursor2) 
                dex2 = num; 

            num++;
        }
    }

    if (dex1 == 0)
        _cursor1 = 0;
    if (dex2 == 0)
        _cursor2 = 0;

    _start_comboBox->setCurrentIndex(dex1);
    _end_comboBox->setCurrentIndex(dex2);
 
    update_decode_range(); // set default sample range
 
    int h_ex2 = 0;
    bool bLang = AppConfig::Instance().appOptions.transDecoderDlg;

    if (LangResource::Instance()->is_lang_en() == false){
        QWidget *sp1 = new QWidget();
        sp1->setFixedHeight(5);
        form->addRow(sp1);
        QString trans_lable(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_DECODER_IF_TRANS), "Translate param names"));
        QCheckBox *ck_trans = new QCheckBox();
        ck_trans->setFixedSize(20,20);
        ck_trans->setChecked(bLang);
        connect(ck_trans, SIGNAL(released()), this, SLOT(on_trans_pramas()));
        ck_trans->setStyleSheet("margin-top:5px");
        QLabel *trans_lb = new QLabel(trans_lable);
        
        QHBoxLayout *trans_lay = new QHBoxLayout();
        QWidget *trans_wid = new QWidget();
        trans_wid->setLayout(trans_lay);
        trans_lay->setSpacing(0);
        trans_lay->setContentsMargins(10,0,0,0);
        trans_lay->addWidget(ck_trans);
        trans_lay->addWidget(trans_lb);
        form->addRow("", trans_wid);
        h_ex2 = 40;   
    }  

  //tr
    QLabel *lb1 = new QLabel(
                     L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CURSOR_FOR_DECODE_START), "The cursor for decode start time"));
    QLabel *lb2 = new QLabel(
                     L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CURSOR_FOR_DECODE_END), "The cursor for decode end time"));

    form->addRow(_start_comboBox, lb1);
    form->addRow(_end_comboBox, lb2);
 
    // Add ButtonBox (OK/Cancel)
    QDialogButtonBox *button_box = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel,
                                Qt::Horizontal, dlg);

    QHBoxLayout *confirm_button_box = new QHBoxLayout;
    confirm_button_box->addWidget(button_box, 0, Qt::AlignRight);
    form->addRow(confirm_button_box);

    this->update_font();

    int real_content_width = _content_width;
    int content_height = _contentHeight;

     // scroll     
    QSize tsize = dlg->sizeHint();
    int w = tsize.width(); 
    int other_height = 190 + h_ex2; 
    content_height += 20;

    int cursor_line_width = lb1->sizeHint().width() + _start_comboBox->sizeHint().width();

    if (w < real_content_width){
        w = real_content_width;
    }
    if (w < cursor_line_width){
        w = cursor_line_width;
    }

#ifdef Q_OS_DARWIN
    other_height += 40;
#endif

    int dlgHeight = content_height + other_height; 
     
    float sk = QGuiApplication::primaryScreen()->logicalDotsPerInch() / 96;
    int srcHeight = 600;
    container_panel->setFixedHeight(content_height);

    if (dlgHeight * sk > srcHeight)
    { 
        QScrollArea *scroll = new QScrollArea(scroll_pannel);
        scroll->setWidget(container_panel);
        scroll->setStyleSheet("QScrollArea{border:none;}");
        scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        dlg->setFixedSize(w + 20, srcHeight);
        scroll_pannel->setFixedSize(w, srcHeight - other_height);
        int sclw = w - 18;
#ifdef Q_OS_DARWIN
        sclw -= 20;
#endif
        scroll->setFixedSize(sclw, srcHeight - other_height);
    }
    else{
        dlg->setFixedSize(w + 20,dlgHeight);
    }
 
    connect(_start_comboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(on_region_set(int)));
    connect(_end_comboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(on_region_set(int))); 
    connect(button_box, SIGNAL(accepted()), dlg, SLOT(on_accept()));
    connect(button_box, SIGNAL(rejected()), dlg, SLOT(reject()));
}

void DecoderOptionsDlg::load_decoder_forms(QWidget *container)
{ 
	assert(container); 

    int dex = 0;
 
    for(auto dec : _trace->decoder()->stack()) 
    { 
        ++dex;
        QWidget *panel = new QWidget(container);
        QFormLayout *form = new QFormLayout();
        form->setContentsMargins(0,0,0,0);
        panel->setLayout(form);
        container->layout()->addWidget(panel);
       
        create_decoder_form(dec, panel, form); 

        _contentHeight += panel->sizeHint().height();
	} 
}
 

DsComboBox* DecoderOptionsDlg::create_probe_selector(
    QWidget *parent, const Decoder *dec,
	const srd_channel *const pdch)
{
	assert(dec);
    
    const auto &sigs = AppControl::Instance()->GetSession()->get_signals();

    auto _dec = const_cast<Decoder*>(dec);
    auto probe_iter = _dec->channels().find(pdch);
	DsComboBox *selector = new DsComboBox(parent);
    selector->addItem("-", QVariant::fromValue(-1));

	if (probe_iter == _dec->channels().end())
		selector->setCurrentIndex(0);
    
    int dex = 0;

	for(auto s : sigs) 
    {
        if (s->signal_type() == SR_CHANNEL_LOGIC && s->enabled()){
			selector->addItem(s->get_name(),QVariant::fromValue(s->get_index()));
            
            if (probe_iter != _dec->channels().end()) {
                if ((*probe_iter).second == s->get_index())
                    selector->setCurrentIndex(dex + 1);
            }
		}
        ++dex;
	}

	return selector;
}

void DecoderOptionsDlg::on_region_set(int index)
{
    (void)index;
    update_decode_range();
}

void DecoderOptionsDlg::update_decode_range()
{ 
    const uint64_t last_samples = AppControl::Instance()->GetSession()->cur_samplelimits() - 1;
    const int index1 = _start_comboBox->currentIndex();
    const int index2 = _end_comboBox->currentIndex();
    uint64_t decode_start, decode_end;

    auto view = _trace->get_view();

    if (index1 == 0) {
        decode_start = 0;
        _cursor1 = 0;

    } else {
        _cursor1 = _start_comboBox->itemData(index1).toULongLong();
        int cusrsor_index = view->get_cursor_index_by_key(_cursor1);
        if (cusrsor_index != -1){
            decode_start = view->get_cursor_samples(cusrsor_index);
        }
        else{
            decode_start = 0;
            _cursor1 = 0;
        }        
    }

    if (index2 == 0) {
        decode_end = last_samples;
        _cursor2 = 0;

    } else {
        _cursor2 = _end_comboBox->itemData(index2).toULongLong();
        int cusrsor_index = view->get_cursor_index_by_key(_cursor2);
        if (cusrsor_index != -1){
            decode_end = view->get_cursor_samples(cusrsor_index);
        }
        else{
            decode_end = last_samples;
            _cursor2 = 0;
        }       
    }

    if (decode_start > last_samples)
        decode_start = 0;
    if (decode_end > last_samples)
        decode_end = last_samples;

    if (decode_start > decode_end) {
        uint64_t tmp = decode_start;
        decode_start = decode_end;
        decode_end = tmp;
    }
  
    for(auto dec : _trace->decoder()->stack()) {
        dec->set_decode_region(decode_start, decode_end);
    }
}
 

void DecoderOptionsDlg::create_decoder_form(
    Decoder *dec, QWidget *parent,
    QFormLayout *form)
{
	const GSList *l;

    assert(dec);     
	const srd_decoder *const decoder = dec->decoder();
	assert(decoder);

    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);

    QFormLayout *const decoder_form = new QFormLayout();
    decoder_form->setContentsMargins(0,0,0,0);
    decoder_form->setVerticalSpacing(4);
    decoder_form->setFormAlignment(Qt::AlignLeft);
    decoder_form->setLabelAlignment(Qt::AlignLeft);
    decoder_form->setFieldGrowthPolicy(QFormLayout::AllNonFixedFieldsGrow);

    bool bLang = AppConfig::Instance().appOptions.transDecoderDlg;
    if (LangResource::Instance()->is_lang_en()){
        bLang = false;
    }
 
	// Add the mandatory channels
	for(l = decoder->channels; l; l = l->next) {
		const struct srd_channel *const pdch = (struct srd_channel *)l->data;
		DsComboBox *const combo = create_probe_selector(parent, dec, pdch);

        const char *desc_str = NULL;
        const char *lang_str = NULL;

        if (pdch->idn != NULL && LangResource::Instance()->is_lang_en() == false){
            lang_str = LangResource::Instance()->get_lang_text(STR_PAGE_DECODER, pdch->idn, pdch->desc);
        }

        if (lang_str != NULL && bLang){
            desc_str = lang_str;
        }
        else{
            desc_str = pdch->desc;
        }

        //tr
        decoder_form->addRow(QString("<b>%1</b> (%2) *")
			.arg(QString::fromUtf8(pdch->name))
			.arg(QString::fromUtf8(desc_str)), combo);

        const ProbeSelector s = {combo, dec, pdch};
    	_probe_selectors.push_back(s);

        connect(combo, SIGNAL(currentIndexChanged(int)), this, SLOT(on_probe_selected(int)));
	} 

	// Add the optional channels
	for(l = decoder->opt_channels; l; l = l->next) {
		const struct srd_channel *const pdch = (struct srd_channel *)l->data;
		DsComboBox *const combo = create_probe_selector(parent, dec, pdch);
		
        const char *desc_str = NULL;
        const char *lang_str = NULL;
        
        if (pdch->idn != NULL && LangResource::Instance()->is_lang_en() == false){
            lang_str = LangResource::Instance()->get_lang_text(STR_PAGE_DECODER, pdch->idn, pdch->desc);
        }

        if (lang_str != NULL && bLang){
            desc_str = lang_str;
        }
        else{
            desc_str = pdch->desc;
        }

        //tr
        decoder_form->addRow(QString("<b>%1</b> (%2)")
			.arg(QString::fromUtf8(pdch->name))
			.arg(QString::fromUtf8(desc_str)), combo);

        const ProbeSelector s = {combo, dec, pdch};
        _probe_selectors.push_back(s);

        connect(combo, SIGNAL(currentIndexChanged(int)), this, SLOT(on_probe_selected(int)));
	}

	// Add the options
    auto binding = new prop::binding::DecoderOptions(_trace->decoder(), dec);
    binding->add_properties_to_form(decoder_form, true, font);
	_bindings.push_back(binding);
  
    auto group = new dsv::widgets::DecoderGroupBox(_trace->decoder(), 
                            dec, 
                            decoder_form, 
                            parent, font);

    if (group->_content_width > _content_width){
        _content_width = group->_content_width;
    }

	form->addRow(group);
}

void DecoderOptionsDlg::commit_probes()
{ 
    for(auto dec : _trace->decoder()->stack()){
		commit_decoder_probes(dec);
    }
}

void DecoderOptionsDlg::on_probe_selected(int)
{
	commit_probes();
}

void DecoderOptionsDlg::commit_decoder_probes(decode::Decoder *dec)
{
	assert(dec); 

    std::map<const srd_channel*, int> probe_map;
    const auto &sigs = AppControl::Instance()->GetSession()->get_signals();

    std::list<int> index_list;

	for(auto &p : _probe_selectors)
	{
		if(p._decoder != dec)
			break;

        const int selection = p._combo->itemData(p._combo->currentIndex()).value<int>();

        for(auto s : sigs){
            if(s->get_index() == selection) {
                probe_map[p._pdch] = selection;
                index_list.push_back(selection);
				break;
			}
        }
	}

	dec->set_probes(probe_map);

    if (index_list.size())
        _trace->set_index_list(index_list);
}
 
void DecoderOptionsDlg::on_accept()
{ 
    if (_cursor1 > 0 && _cursor1 == _cursor2){
        MsgBox::Show(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_ERROR), "error"), 
        L_S(STR_PAGE_MSG, S_ID(IDS_MSG_DECODE_INVAILD_CURSOR), "Invalid cursor index for sample range!"));
        return;
    }

    this->accept();
}

void DecoderOptionsDlg::on_trans_pramas()
{
    QCheckBox *ck_box = dynamic_cast<QCheckBox*>(sender());
    assert(ck_box);

    AppConfig::Instance().appOptions.transDecoderDlg = ck_box->isChecked();
    AppConfig::Instance().SaveApp();
    _is_reload_form = true;
    this->accept();
}

}//dialogs
}//pv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "applicationpardlg.h"
#include "dsdialog.h"
#include <QFormLayout>
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QCheckBox>
#include <QString>
#include <QFontDatabase>
#include <QGroupBox>
#include <QLabel>
#include <vector>
#include <QGridLayout>
#include "../config/appconfig.h"
#include "../ui/langresource.h"
#include "../appcore/appcontrol.h"
#include "../appcore/sigsession.h"
#include "../ui/dscombobox.h"
#include "../log.h"

using namespace dsv::appcore;
using namespace dsv::config;

namespace dsv{
namespace dialogs
{

ApplicationParamDlg::ApplicationParamDlg()
{
   
}

ApplicationParamDlg::~ApplicationParamDlg()
{
}

void ApplicationParamDlg::bind_font_name_list(QComboBox *box, QString v)
{   
    int selDex = -1;

    QString defName(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_DEFAULT_FONT), "Default"));
    box->addItem(defName);

    if (_font_name_list.size() == 0)
    {
        QFontDatabase fDataBase;
        _font_name_list = fDataBase.families();
    }
   
    for (QString family : _font_name_list) {
        if (family.indexOf("[") == -1)
        {
            box->addItem(family);

            if (selDex == -1 && family == v){
                selDex = box->count() - 1;
            }
        }
    }

    if (selDex == -1)
        selDex = 0;

    box->setCurrentIndex(selDex);
}

void ApplicationParamDlg::bind_font_size_list(QComboBox *box, float size)
{   
    int selDex = -1;

    for(int i=7; i<=12; i++)
    {
        box->addItem(QString::number(i));
        if (i == size){
            selDex = box->count() - 1;
        }
    }
    if (selDex == -1)
        selDex = 2;
    box->setCurrentIndex(selDex);
}

bool ApplicationParamDlg::ShowDlg(QWidget *parent)
{
    DSDialog dlg(parent, true, true);
    dlg.setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_DISPLAY_OPTIONS), "Display options"));
    dlg.setMinimumSize(300, 230);

    QVBoxLayout *lay = new QVBoxLayout();
    lay->setContentsMargins(0,10,0,20);
    lay->setSpacing(8);

    //show config
    AppConfig &app = AppConfig::Instance(); 

    QCheckBox *ck_quickScroll = new QCheckBox();
    ck_quickScroll->setChecked(app.appOptions.quickScroll);

    QCheckBox *ck_trigInMid = new QCheckBox();
    ck_trigInMid->setChecked(app.appOptions.trigPosDisplayInMid);

    QCheckBox *ck_profileBar = new QCheckBox();
    ck_profileBar->setChecked(app.appOptions.displayProfileInBar);

    QCheckBox *ck_abortData = new QCheckBox();
    ck_abortData->setChecked(app.appOptions.swapBackBufferAlways);

    QComboBox *ftCbSize = new DsComboBox();
    ftCbSize->setFixedWidth(50);
    bind_font_size_list(ftCbSize, app.appOptions.fontSize);
   
    // Logic group
    QGroupBox *logicGroup = new QGroupBox(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_GROUP_LOGIC), "Logic"));
    QGridLayout *logicLay = new QGridLayout();
    logicLay->setContentsMargins(10,15,15,10);
    logicGroup->setLayout(logicLay);
    logicLay->addWidget(new QLabel(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_QUICK_SCROLL), "Quick scroll")), 0, 0, Qt::AlignLeft); 
    logicLay->addWidget(ck_quickScroll, 0, 1, Qt::AlignRight);
    logicLay->addWidget(new QLabel(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_USE_ABORT_DATA_REPEAT), "Used abort data")), 1, 0, Qt::AlignLeft); 
    logicLay->addWidget(ck_abortData, 1, 1, Qt::AlignRight);
    lay->addWidget(logicGroup);

    //Scope group
    QGroupBox *dsoGroup = new QGroupBox(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_GROUP_DSO), "Scope"));
    QGridLayout *dsoLay = new QGridLayout();
    dsoLay->setContentsMargins(10,15,15,10);
    dsoGroup->setLayout(dsoLay);
    dsoLay->addWidget(new QLabel(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_TRIG_DISPLAY_MIDDLE), "Tig pos in middle")), 0, 0, Qt::AlignLeft);
    dsoLay->addWidget(ck_trigInMid, 0, 1, Qt::AlignRight);
    lay->addWidget(dsoGroup);

    //UI
    QGroupBox *uiGroup = new QGroupBox(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_GROUP_UI), "UI"));
    QGridLayout *uiLay = new QGridLayout();
    uiLay->setContentsMargins(10,15,15,10);
    uiGroup->setLayout(uiLay);
    uiLay->addWidget(new QLabel(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_DISPLAY_PROFILE_IN_BAR), "Profile in bar")), 0, 0, Qt::AlignLeft);
    uiLay->addWidget(ck_profileBar, 0, 1, Qt::AlignRight);
    uiLay->addWidget(new QLabel(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_FONT_SIZE), "Font size")), 1, 0, Qt::AlignLeft);
    uiLay->addWidget(ftCbSize, 1, 1, Qt::AlignRight);
    lay->addWidget(uiGroup);

    dlg.layout()->addLayout(lay);      
    dlg.exec();
    bool ret = dlg.IsClickYes();

    //save config
    if (ret){

        bool bAppChanged = false;
        bool bFontChanged = false;
        float fSize = ftCbSize->currentText().toFloat();

        if (app.appOptions.quickScroll != ck_quickScroll->isChecked()){
            app.appOptions.quickScroll = ck_quickScroll->isChecked();
            bAppChanged = true;
        }       
        if (app.appOptions.trigPosDisplayInMid != ck_trigInMid->isChecked()){
            app.appOptions.trigPosDisplayInMid = ck_trigInMid->isChecked();
            bAppChanged = true;
        }
        if (app.appOptions.displayProfileInBar != ck_profileBar->isChecked()){
            app.appOptions.displayProfileInBar = ck_profileBar->isChecked();
            bAppChanged = true;
        }
        if (app.appOptions.swapBackBufferAlways != ck_abortData->isChecked()){
            app.appOptions.swapBackBufferAlways = ck_abortData->isChecked();
            bAppChanged = true;
        }        
        if (app.appOptions.fontSize != fSize){
            app.appOptions.fontSize = fSize;
            bFontChanged = true;
        }
 
        if (bAppChanged){
            app.SaveApp();
            AppControl::Instance()->GetSession()->broadcast_msg(DSV_MSG_APP_OPTIONS_CHANGED);
        }
        
        if (bFontChanged){
            if (!bAppChanged){
                app.SaveApp();
            }
            AppControl::Instance()->GetSession()->broadcast_msg(DSV_MSG_FONT_OPTIONS_CHANGED);
        }
    }
   
   return ret;
}
 

} //
}//

/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_INTERVAL_H
#define DSVIEW_PV_INTERVAL_H

#include <QLabel>
#include <QDoubleSpinBox>
#include <QSlider>
#include <QDialogButtonBox>
#include "dsdialog.h"

namespace dsv {
namespace dialogs {

class Interval : public DSDialog
{
	Q_OBJECT

public:
    Interval(QWidget *parent);

    void set_interval(double value);
    double get_interval();

    inline bool is_done(){
        return _bDone;
    }

protected:
	void accept();
    void reject(); 
    
private Q_SLOTS:
        void on_slider_changed(int value);
        void on_inputbox_changed(double value);

private:
    QLabel *_interval_label;
    QDoubleSpinBox *_interval_spinBox;
    QSlider *_interval_slider;

    QDialogButtonBox _button_box;
    bool    _bSetting;
    bool    _bDone;
};

} // namespace dialogs
} // namespace dsv

#endif // DSVIEW_PV_INTERVAL_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_PROTOCOLLIST_H
#define DSVIEW_PV_PROTOCOLLIST_H

#include <QDialogButtonBox>
#include <QFormLayout>
#include <QVBoxLayout>
#include <QLabel>
#include <QCheckBox> 
#include "../prop/binding/deviceoptions.h"
#include "../toolbars/titlebar.h"
#include "dsdialog.h"
#include "../ui/dscombobox.h"

namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
}
using namespace dsv::appcore;

namespace dsv {
namespace dialogs {

class ProtocolList : public DSDialog
{
    Q_OBJECT

public:
    ProtocolList(QWidget *parent, SigSession *session);

protected:
    void accept();
    void reject();

private slots:
    void set_protocol(int index);
    void on_row_check(bool show);
    void on_set_map_zoom(int index);

private:
    SigSession *_session;

    toolbars::TitleBar *_titlebar;
    DsComboBox *_map_zoom_combobox;
    DsComboBox *_protocol_combobox;
    std::list<QCheckBox *> _show_checkbox_list;
    std::list<QLabel *> _show_label_list;
    QFormLayout *_flayout;
    QVBoxLayout *_layout;
    QDialogButtonBox _button_box;

};

} // namespace dialogs
} // namespace dsv

#endif // DSVIEW_PV_PROTOCOLLIST_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_TOOLBARS_SAMPLINGBAR_H
#define DSVIEW_PV_TOOLBARS_SAMPLINGBAR_H

#include <libsigrok.h>
#include <stdint.h>
#include <list>
#include <map>  
#include <QToolBar>
#include <QToolButton>
#include <QAction>
#include <QMenu>
#include <QDialog>
#include "../ui/dscombobox.h"
#include "../interface/icallbacks.h"

struct st_dev_inst;
class QAction;
struct ds_device_info;

namespace dsv{
	namespace appcore{
    	class SigSession;
        class DeviceAgent;
	}
}
using namespace dsv::appcore;

namespace dsv{
	namespace view{
    	class View;
	}
}
using namespace dsv::view;

namespace dsv{
	namespace dialogs{
        class deviceoptions;
        class Calibration;
    }
}
using namespace dsv::dialogs;

namespace dsv{
namespace toolbars{

        class SamplingBar : public QToolBar, public IFontForm
        {
            Q_OBJECT

        private:
            static const int ComboBoxMaxWidth = 200;
            static const int RefreshShort = 500;
            static const uint64_t LogicMaxSWDepth64 = SR_GB(16);
            static const uint64_t LogicMaxSWDepth32 = SR_GB(8);
            
            static const uint64_t AnalogMaxSWDepth = SR_Mn(100);
            static const QString RLEString;
            static const QString DIVString;
            static const uint64_t ZeroTimeBase = SR_US(2);
 

        public:
            SamplingBar(SigSession *session, QWidget *parent);         

            double hori_knob(int dir);           
            double get_hori_res();          
            void update_device_list();          
            void reload(); 
            void update_view_status();
            void config_device();
            ds_device_handle get_next_device_handle();

            inline void set_view(view::View *view){
                _view = view;
            }

            void run_or_stop();

            void run_or_stop_instant();

            inline void update_sample_rate_list()
            {
                update_sample_rate_selector();
            }

            void commit_settings();

        signals:
            void sig_store_session_data();

        private: 
            void changeEvent(QEvent *event);
            void retranslateUi();
            void reStyle();
            void set_sample_rate(uint64_t sample_rate);
            double commit_hori_res();

            void update_sample_rate_selector();
           
            void update_sample_rate_selector_value();
            void update_sample_count_selector();
            void update_sample_count_selector_value();         
            void setting_adj();
            void enable_toggle(bool enable);
            void update_mode_icon();

            bool action_run_stop();
            bool action_instant_stop();
            
            //IFontForm
            void update_font() override;

        private slots:
            void on_collect_mode();
            void on_run_stop();
            void on_instant_stop();
            void on_device_selected();
            void on_samplerate_sel(int index);
            void on_samplecount_sel(int index);
            void on_configure();
            void zero_adj();
            void on_run_stop_action();
            void on_instant_stop_action();    

        private:
            SigSession          *_session;

            QToolButton         _device_type;
            DsComboBox          _device_selector;
            QToolButton         _configure_button;           
            DsComboBox          _sample_count;
            DsComboBox          _sample_rate;          
            QToolButton         _run_stop_button;
            QToolButton         _instant_button;
            QToolButton         _mode_button;

            QAction             *_run_stop_action;
            QAction             *_instant_action;
            QAction             *_mode_action;
         
            QMenu               *_mode_menu;
            QAction             *_action_repeat;
            QAction             *_action_single;
            QAction             *_action_loop;
        
            DeviceAgent         *_device_agent;
            ds_device_handle    _last_device_handle;
            ds_device_handle    _next_switch_device;
            int                 _last_device_index;
            bool                _is_run_as_instant;
            view::View          *_view;

            bool                _updating_sample_rate;
            bool                _updating_sample_count;
            bool                _updating_device_list;
        };

    } // namespace toolbars
} // namespace dsv

#endif // DSVIEW_PV_TOOLBARS_SAMPLINGBAR_H
/****************************************************************************
** Meta object code from reading C++ file 'logobar.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "logobar.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'logobar.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPELogoBarENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPELogoBarENDCLASS = QtMocHelpers::stringData(
    "dsv::toolbars::LogoBar",
    "sig_open_doc",
    "",
    "on_actionEn_triggered",
    "on_actionCn_triggered",
    "on_actionAbout_triggered",
    "on_actionManual_triggered",
    "on_actionIssue_triggered",
    "on_action_update",
    "on_action_setting_log",
    "on_open_log_file",
    "on_clear_log_file"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPELogoBarENDCLASS_t {
    uint offsetsAndSizes[24];
    char stringdata0[23];
    char stringdata1[13];
    char stringdata2[1];
    char stringdata3[22];
    char stringdata4[22];
    char stringdata5[25];
    char stringdata6[26];
    char stringdata7[25];
    char stringdata8[17];
    char stringdata9[22];
    char stringdata10[17];
    char stringdata11[18];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPELogoBarENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPELogoBarENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPELogoBarENDCLASS = {
    {
        QT_MOC_LITERAL(0, 22),  // "dsv::toolbars::LogoBar"
        QT_MOC_LITERAL(23, 12),  // "sig_open_doc"
        QT_MOC_LITERAL(36, 0),  // ""
        QT_MOC_LITERAL(37, 21),  // "on_actionEn_triggered"
        QT_MOC_LITERAL(59, 21),  // "on_actionCn_triggered"
        QT_MOC_LITERAL(81, 24),  // "on_actionAbout_triggered"
        QT_MOC_LITERAL(106, 25),  // "on_actionManual_triggered"
        QT_MOC_LITERAL(132, 24),  // "on_actionIssue_triggered"
        QT_MOC_LITERAL(157, 16),  // "on_action_update"
        QT_MOC_LITERAL(174, 21),  // "on_action_setting_log"
        QT_MOC_LITERAL(196, 16),  // "on_open_log_file"
        QT_MOC_LITERAL(213, 17)   // "on_clear_log_file"
    },
    "dsv::toolbars::LogoBar",
    "sig_open_doc",
    "",
    "on_actionEn_triggered",
    "on_actionCn_triggered",
    "on_actionAbout_triggered",
    "on_actionManual_triggered",
    "on_actionIssue_triggered",
    "on_action_update",
    "on_action_setting_log",
    "on_open_log_file",
    "on_clear_log_file"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEtoolbarsSCOPELogoBarENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
      10,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   74,    2, 0x06,    1 /* Public */,

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       3,    0,   75,    2, 0x08,    2 /* Private */,
       4,    0,   76,    2, 0x08,    3 /* Private */,
       5,    0,   77,    2, 0x08,    4 /* Private */,
       6,    0,   78,    2, 0x08,    5 /* Private */,
       7,    0,   79,    2, 0x08,    6 /* Private */,
       8,    0,   80,    2, 0x08,    7 /* Private */,
       9,    0,   81,    2, 0x08,    8 /* Private */,
      10,    0,   82,    2, 0x08,    9 /* Private */,
      11,    0,   83,    2, 0x08,   10 /* Private */,

 // signals: parameters
    QMetaType::Void,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::toolbars::LogoBar::staticMetaObject = { {
    QMetaObject::SuperData::link<QToolBar::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPELogoBarENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEtoolbarsSCOPELogoBarENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPELogoBarENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<LogoBar, std::true_type>,
        // method 'sig_open_doc'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_actionEn_triggered'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_actionCn_triggered'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_actionAbout_triggered'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_actionManual_triggered'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_actionIssue_triggered'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_action_update'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_action_setting_log'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_open_log_file'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_clear_log_file'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::toolbars::LogoBar::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<LogoBar *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->sig_open_doc(); break;
        case 1: _t->on_actionEn_triggered(); break;
        case 2: _t->on_actionCn_triggered(); break;
        case 3: _t->on_actionAbout_triggered(); break;
        case 4: _t->on_actionManual_triggered(); break;
        case 5: _t->on_actionIssue_triggered(); break;
        case 6: _t->on_action_update(); break;
        case 7: _t->on_action_setting_log(); break;
        case 8: _t->on_open_log_file(); break;
        case 9: _t->on_clear_log_file(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (LogoBar::*)();
            if (_t _q_method = &LogoBar::sig_open_doc; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
    }
    (void)_a;
}

const QMetaObject *dsv::toolbars::LogoBar::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::toolbars::LogoBar::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPELogoBarENDCLASS.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "IFontForm"))
        return static_cast< IFontForm*>(this);
    return QToolBar::qt_metacast(_clname);
}

int dsv::toolbars::LogoBar::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QToolBar::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 10)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 10;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 10)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 10;
    }
    return _id;
}

// SIGNAL 0
void dsv::toolbars::LogoBar::sig_open_doc()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_TOOLBARS_TITLEBAR_H
#define DSVIEW_PV_TOOLBARS_TITLEBAR_H

#include <QWidget>
#include "../interface/icallbacks.h"

class QToolButton;
class QHBoxLayout;
class QLabel;

namespace dsv {
namespace toolbars {

class TitleBar : public QWidget, public IFontForm
{
    Q_OBJECT

public:
    TitleBar(bool top, QWidget *parent, bool hasClose = false);
    ~TitleBar();
    
    void setTitle(QString title); 
    QString title();

    //IFontForm
    void update_font() override;

private:
    void changeEvent(QEvent *event);
    void reStyle();

signals:
    void normalShow();
    void maximizedShow();

public slots:
    void showMaxRestore();
    void setRestoreButton(bool max);
    inline bool IsMoving(){return _moving;}

protected:
    void paintEvent(QPaintEvent *event);
    void mousePressEvent(QMouseEvent *event);
    void mouseMoveEvent(QMouseEvent *event);
    void mouseReleaseEvent(QMouseEvent *event);
    void mouseDoubleClickEvent(QMouseEvent *event);
 
    
    QToolButton *_minimizeButton;
    QToolButton *_maximizeButton;
    QToolButton *_closeButton;
    QLabel      *_title;
  
    bool        _moving;
    bool        _isTop;
    bool        _hasClose;
    QPoint      _clickPos;
    QPoint      _oldPos;
    QWidget     *_parent;
};

} // namespace toolbars
} // namespace dsv

#endif // DSVIEW_PV_TOOLBARS_TITLEBAR_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "filebar.h"
#include <boost/bind.hpp>   
#include <QMetaObject>
#include <QFileDialog> 
#include <deque>
#include <QApplication>
#include "../ui/msgbox.h"
#include "../config/appconfig.h"
#include "../utility/path.h"
#include "../ui/langresource.h"
#include "../log.h" 
#include "../ui/fn.h"
#include "../appcore/sigsession.h" 

using namespace dsv::config;

namespace dsv {
namespace toolbars {

FileBar::FileBar(SigSession *session, QWidget *parent) :
    QToolBar("File Bar", parent),
    _session(session),
    _file_button(this)
{
    setMovable(false);
    setContentsMargins(0,0,0,0);

    _action_load = new QAction(this);
    _action_load->setObjectName(QString::fromUtf8("actionLoad"));
 
    _action_store = new QAction(this);
    _action_store->setObjectName(QString::fromUtf8("actionStore"));
 
    _action_default = new QAction(this);
    _action_default->setObjectName(QString::fromUtf8("actionDefault"));
  
    //second level menu
    _menu_session = new QMenu(this);
    _menu_session->setObjectName(QString::fromUtf8("menuSession"));
    _menu_session->addAction(_action_load);
    _menu_session->addAction(_action_store);
    _menu_session->addAction(_action_default);

    _action_open = new QAction(this);
    _action_open->setObjectName(QString::fromUtf8("actionOpen"));
    
    _action_save = new QAction(this);
    _action_save->setObjectName(QString::fromUtf8("actionSave"));
     
    _action_export = new QAction(this);
    _action_export->setObjectName(QString::fromUtf8("actionExport"));
     
    _action_capture = new QAction(this);
    _action_capture->setObjectName(QString::fromUtf8("actionCapture"));
 
    _file_button.setToolButtonStyle(Qt::ToolButtonTextUnderIcon);
    _file_button.setPopupMode(QToolButton::InstantPopup);

    _menu = new QMenu(this);
    _menu->addMenu(_menu_session);
    _menu->addAction(_action_open);
    _menu->addAction(_action_save);
    _menu->addAction(_action_export);
    _menu->addAction(_action_capture);
    _file_button.setMenu(_menu);
    addWidget(&_file_button);

    retranslateUi();

    connect(_action_load, SIGNAL(triggered()), this, SLOT(on_actionLoad_triggered()));
    connect(_action_store, SIGNAL(triggered()), this, SLOT(on_actionStore_triggered()));
    connect(_action_default, SIGNAL(triggered()), this, SLOT(on_actionDefault_triggered()));
    connect(_action_open, SIGNAL(triggered()), this, SLOT(on_actionOpen_triggered()));
    connect(_action_save, SIGNAL(triggered()), this, SIGNAL(sig_save()));
    connect(_action_export, SIGNAL(triggered()), this, SIGNAL(sig_export()));
    connect(_action_capture, SIGNAL(triggered()), this, SLOT(on_actionCapture_triggered()));

    update_font();
}

void FileBar::changeEvent(QEvent *event)
{
    if (event->type() == QEvent::LanguageChange)
        retranslateUi();
    else if (event->type() == QEvent::StyleChange)
        reStyle();
    QToolBar::changeEvent(event);
}

void FileBar::retranslateUi()
{
    _file_button.setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_FILE), "File"));
    _menu_session->setTitle(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_FILE_CONFIG), "Con&fig...")); //load,save session file
    _action_load->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_FILE_CONFIG_LOAD), "&Load..."));
    _action_store->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_FILE_CONFIG_STORE), "S&tore..."));
    _action_default->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_FILE_CONFIG_DEFAULT), "&Default..."));
    _action_open->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_FILE_OPEN), "&Open..."));
    _action_save->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_FILE_SAVE), "&Save..."));
    _action_export->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_FILE_EXPORT), "&Export..."));
    _action_capture->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_FILE_CAPTURE), "&Capture..."));
}

void FileBar::reStyle()
{
    QString iconPath = AppConfig::GetIconPath();

    _action_load->setIcon(QIcon(iconPath+"/open.svg"));
    _action_store->setIcon(QIcon(iconPath+"/save.svg"));
    _action_default->setIcon(QIcon(iconPath+"/gear.svg"));
    _menu_session->setIcon(QIcon(iconPath+"/gear.svg"));
    _action_open->setIcon(QIcon(iconPath+"/open.svg"));
    _action_save->setIcon(QIcon(iconPath+"/save.svg"));
    _action_export->setIcon(QIcon(iconPath+"/export.svg"));
    _action_capture->setIcon(QIcon(iconPath+"/capture.svg"));
    _file_button.setIcon(QIcon(iconPath+"/file.svg"));
}

void FileBar::on_actionOpen_triggered()
{
    //open data file
    AppConfig &app = AppConfig::Instance(); 

    if (_session->have_hardware_data() && _session->is_first_store_confirm()){
        if (MsgBox::Confirm(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_SAVE_CAPDATE), "Save captured data?"))){
            sig_save();
            return;
        }
    }

    // Show the dialog
    const QString file_name = QFileDialog::getOpenFileName(
        this, 
        L_S(STR_PAGE_DLG, S_ID(IDS_DLG_OPEN_FILE), "Open File"), 
        app.userHistory.openDir,
        "DSView Data (*.dsl)");

    if (!file_name.isEmpty()) { 
        QString fname = path::GetDirectoryName(file_name);
        if (fname != app.userHistory.openDir){
            app.userHistory.openDir = fname;
            app.SaveHistory();
        }

        sig_load_file(file_name);
    }
}

void FileBar::on_actionLoad_triggered()
{ 
    //load session file
    AppConfig &app = AppConfig::Instance();      
    const QString file_name = QFileDialog::getOpenFileName(
        this, 
        L_S(STR_PAGE_DLG, S_ID(IDS_DLG_OPEN_SEESION), "Open Session"), 
        app.userHistory.sessionDir, 
        "DSView Session (*.dsc)");

    if (!file_name.isEmpty()) {
        QString fname = path::GetDirectoryName(file_name);
        if (fname != app.userHistory.sessionDir){
            app.userHistory.sessionDir = fname;
            app.SaveHistory();
        }
         
        sig_load_session(file_name);
    }
}

void FileBar::on_actionDefault_triggered()
{ 
    QDir dir(AppConfig::GetFirmwareDir());
    if (!dir.exists()) { 
          MsgBox::Show(NULL, L_S(STR_PAGE_MSG, S_ID(IDS_MSG_NOT_FOND_DEFAULT_PROFILE),
             "Cannot find default profile for this device!"), this);
          return;
    }
   
    QString file_name = genDefaultSessionFile();
    
    sig_load_session(file_name);
}

QString FileBar::genDefaultSessionFile()
{   
    QDir dir(AppConfig::GetFirmwareDir());

    QString driver_name = _session->get_device()->driver_name();
    QString mode_name = QString::number(_session->get_device()->get_work_mode());
    QString file_name = dir.absolutePath() + "/" + driver_name + mode_name +".def.dsc";

    return file_name;
}

void FileBar::on_actionStore_triggered()
{
    //store session file
  
      AppConfig &app = AppConfig::Instance();  

    QString file_name = QFileDialog::getSaveFileName(
                this, 
                L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SAVE_SEESION), "Save Session"),
                app.userHistory.sessionDir,
                "DSView Session (*.dsc)");

    if (!file_name.isEmpty()) {
        QFileInfo f(file_name);
        if(f.suffix().compare("dsc"))
            file_name.append(".dsc");

        QString fname = path::GetDirectoryName(file_name);
        if (fname != app.userHistory.sessionDir){
            app.userHistory.sessionDir = fname;
            app.SaveHistory();
        }

        _session->broadcast_msg(DSV_MSG_STORE_CONF_PREV);
         
        sig_store_session(file_name);
    }
}

void FileBar::on_actionCapture_triggered()
{
    _file_button.close();
    QCoreApplication::sendPostedEvents();
    QTimer::singleShot(100, this, SIGNAL(sig_screenShot()));
}

void FileBar::update_view_status()
{
    bool bEnable = _session->is_working() == false;
    bool is_hardware = _session->get_device()->is_hardware();
    _file_button.setEnabled(bEnable);
    _menu_session->setEnabled(bEnable && is_hardware); 
}

void FileBar::update_font()
{ 
    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
    ui::set_toolbar_font(this, font);
}

} // namespace toolbars
} // namespace dsv
/****************************************************************************
** Meta object code from reading C++ file 'filebar.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "filebar.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'filebar.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPEFileBarENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPEFileBarENDCLASS = QtMocHelpers::stringData(
    "dsv::toolbars::FileBar",
    "sig_load_file",
    "",
    "sig_save",
    "sig_export",
    "sig_screenShot",
    "sig_load_session",
    "sig_store_session",
    "on_actionLoad_triggered",
    "on_actionStore_triggered",
    "on_actionDefault_triggered",
    "on_actionOpen_triggered",
    "on_actionCapture_triggered"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPEFileBarENDCLASS_t {
    uint offsetsAndSizes[26];
    char stringdata0[23];
    char stringdata1[14];
    char stringdata2[1];
    char stringdata3[9];
    char stringdata4[11];
    char stringdata5[15];
    char stringdata6[17];
    char stringdata7[18];
    char stringdata8[24];
    char stringdata9[25];
    char stringdata10[27];
    char stringdata11[24];
    char stringdata12[27];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPEFileBarENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPEFileBarENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPEFileBarENDCLASS = {
    {
        QT_MOC_LITERAL(0, 22),  // "dsv::toolbars::FileBar"
        QT_MOC_LITERAL(23, 13),  // "sig_load_file"
        QT_MOC_LITERAL(37, 0),  // ""
        QT_MOC_LITERAL(38, 8),  // "sig_save"
        QT_MOC_LITERAL(47, 10),  // "sig_export"
        QT_MOC_LITERAL(58, 14),  // "sig_screenShot"
        QT_MOC_LITERAL(73, 16),  // "sig_load_session"
        QT_MOC_LITERAL(90, 17),  // "sig_store_session"
        QT_MOC_LITERAL(108, 23),  // "on_actionLoad_triggered"
        QT_MOC_LITERAL(132, 24),  // "on_actionStore_triggered"
        QT_MOC_LITERAL(157, 26),  // "on_actionDefault_triggered"
        QT_MOC_LITERAL(184, 23),  // "on_actionOpen_triggered"
        QT_MOC_LITERAL(208, 26)   // "on_actionCapture_triggered"
    },
    "dsv::toolbars::FileBar",
    "sig_load_file",
    "",
    "sig_save",
    "sig_export",
    "sig_screenShot",
    "sig_load_session",
    "sig_store_session",
    "on_actionLoad_triggered",
    "on_actionStore_triggered",
    "on_actionDefault_triggered",
    "on_actionOpen_triggered",
    "on_actionCapture_triggered"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEtoolbarsSCOPEFileBarENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
      11,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       6,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   80,    2, 0x06,    1 /* Public */,
       3,    0,   83,    2, 0x06,    3 /* Public */,
       4,    0,   84,    2, 0x06,    4 /* Public */,
       5,    0,   85,    2, 0x06,    5 /* Public */,
       6,    1,   86,    2, 0x06,    6 /* Public */,
       7,    1,   89,    2, 0x06,    8 /* Public */,

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       8,    0,   92,    2, 0x08,   10 /* Private */,
       9,    0,   93,    2, 0x08,   11 /* Private */,
      10,    0,   94,    2, 0x08,   12 /* Private */,
      11,    0,   95,    2, 0x08,   13 /* Private */,
      12,    0,   96,    2, 0x08,   14 /* Private */,

 // signals: parameters
    QMetaType::Void, QMetaType::QString,    2,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::QString,    2,
    QMetaType::Void, QMetaType::QString,    2,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::toolbars::FileBar::staticMetaObject = { {
    QMetaObject::SuperData::link<QToolBar::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPEFileBarENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEtoolbarsSCOPEFileBarENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPEFileBarENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<FileBar, std::true_type>,
        // method 'sig_load_file'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QString, std::false_type>,
        // method 'sig_save'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'sig_export'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'sig_screenShot'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'sig_load_session'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QString, std::false_type>,
        // method 'sig_store_session'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QString, std::false_type>,
        // method 'on_actionLoad_triggered'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_actionStore_triggered'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_actionDefault_triggered'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_actionOpen_triggered'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_actionCapture_triggered'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::toolbars::FileBar::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<FileBar *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->sig_load_file((*reinterpret_cast< std::add_pointer_t<QString>>(_a[1]))); break;
        case 1: _t->sig_save(); break;
        case 2: _t->sig_export(); break;
        case 3: _t->sig_screenShot(); break;
        case 4: _t->sig_load_session((*reinterpret_cast< std::add_pointer_t<QString>>(_a[1]))); break;
        case 5: _t->sig_store_session((*reinterpret_cast< std::add_pointer_t<QString>>(_a[1]))); break;
        case 6: _t->on_actionLoad_triggered(); break;
        case 7: _t->on_actionStore_triggered(); break;
        case 8: _t->on_actionDefault_triggered(); break;
        case 9: _t->on_actionOpen_triggered(); break;
        case 10: _t->on_actionCapture_triggered(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (FileBar::*)(QString );
            if (_t _q_method = &FileBar::sig_load_file; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (FileBar::*)();
            if (_t _q_method = &FileBar::sig_save; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 1;
                return;
            }
        }
        {
            using _t = void (FileBar::*)();
            if (_t _q_method = &FileBar::sig_export; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 2;
                return;
            }
        }
        {
            using _t = void (FileBar::*)();
            if (_t _q_method = &FileBar::sig_screenShot; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 3;
                return;
            }
        }
        {
            using _t = void (FileBar::*)(QString );
            if (_t _q_method = &FileBar::sig_load_session; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 4;
                return;
            }
        }
        {
            using _t = void (FileBar::*)(QString );
            if (_t _q_method = &FileBar::sig_store_session; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 5;
                return;
            }
        }
    }
}

const QMetaObject *dsv::toolbars::FileBar::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::toolbars::FileBar::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPEFileBarENDCLASS.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "IFontForm"))
        return static_cast< IFontForm*>(this);
    return QToolBar::qt_metacast(_clname);
}

int dsv::toolbars::FileBar::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QToolBar::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 11)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 11;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 11)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 11;
    }
    return _id;
}

// SIGNAL 0
void dsv::toolbars::FileBar::sig_load_file(QString _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}

// SIGNAL 1
void dsv::toolbars::FileBar::sig_save()
{
    QMetaObject::activate(this, &staticMetaObject, 1, nullptr);
}

// SIGNAL 2
void dsv::toolbars::FileBar::sig_export()
{
    QMetaObject::activate(this, &staticMetaObject, 2, nullptr);
}

// SIGNAL 3
void dsv::toolbars::FileBar::sig_screenShot()
{
    QMetaObject::activate(this, &staticMetaObject, 3, nullptr);
}

// SIGNAL 4
void dsv::toolbars::FileBar::sig_load_session(QString _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 4, _a);
}

// SIGNAL 5
void dsv::toolbars::FileBar::sig_store_session(QString _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 5, _a);
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_TOOLBARS_LOGOBAR_H
#define DSVIEW_PV_TOOLBARS_LOGOBAR_H

#include <QToolBar>
#include <QToolButton>
#include <QAction>
#include <QMenu>
#include <libsigrok.h> 
#include <QPushButton>
#include "../interface/icallbacks.h"

namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
}
using namespace dsv::appcore;

namespace dsv {
namespace toolbars {

//The tool button for help,is a ui class,referenced by MainWindow
//TODO: switch language,submit bug descript,
class LogoBar : public QToolBar, public IFontForm
{
    Q_OBJECT

public:
    explicit LogoBar(SigSession *session, QWidget *parent = 0);

    void enable_toggle(bool enable);

   //show the hardware device conneted status with logo picture
    void dsl_connected(bool conn);

    inline void set_mainform_callback(IMainForm *callback){
        _mainForm = callback;
    }

private:
    void changeEvent(QEvent *event);
    void retranslateUi();
    void reStyle();

    //IFontForm
    void update_font() override;

signals: 
    //post event message to open user help document, MainWindow class receive it
    void sig_open_doc(); 

private slots:
    void on_actionEn_triggered();
    void on_actionCn_triggered();
    void on_actionAbout_triggered();
    void on_actionManual_triggered();
    void on_actionIssue_triggered();
    void on_action_update();
    void on_action_setting_log();
    void on_open_log_file();
    void on_clear_log_file();

private:
    bool _enable;
    bool _connected;
    SigSession* _session;

    QToolButton _logo_button;

    QMenu *_menu;

    QMenu *_language;
    QAction *_action_en;
    QAction *_action_cn;

    QAction *_about;
    QAction *_manual;
    QAction *_issue;
    QAction *_update;
    QAction *_log;

    QPushButton *_log_open_bt;
    QPushButton *_log_clear_bt;

    IMainForm *_mainForm;
};

} // namespace toolbars
} // namespace dsv

#endif // DSVIEW_PV_TOOLBARS_LOGOBAR_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "logobar.h"
#include <boost/bind.hpp>
#include <QMetaObject>
#include <QFileDialog> 
#include <QDesktopServices>
#include <QUrl>
#include <QApplication>
#include <assert.h>
#include <QComboBox>
#include <QFormLayout>
#include <QWidget>
#include <QCheckBox>
#include <QLineEdit>
#include <QHBoxLayout>
#include <QFile> 
#include <QLabel>
#include "../dialogs/about.h"
#include "../dialogs/dsmessagebox.h"
#include "../config/appconfig.h"
#include "../dialogs/dsdialog.h"
#include "../appcore/appcontrol.h"
#include "../log.h"
#include "../ui/langresource.h"
#include "../ui/msgbox.h"
#include "../ui/fn.h"
#include "../appcore/sigsession.h"

using namespace dsv::config;

namespace dsv {
namespace toolbars {

LogoBar::LogoBar(SigSession *session, QWidget *parent) :
    QToolBar("File Bar", parent),
    _enable(true),
    _connected(false),
    _session(session),
    _logo_button(this)
{
    _mainForm  = NULL;
    _log_open_bt = NULL;
    _log_clear_bt = NULL;

    setMovable(false);
    setContentsMargins(0,0,0,0);

    _action_en = new QAction(this);
    _action_en->setObjectName(QString::fromUtf8("actionEn"));
   
    _action_cn = new QAction(this);
    _action_cn->setObjectName(QString::fromUtf8("actionCn"));
    
    _language = new QMenu(this);
    _language->setObjectName(QString::fromUtf8("menuLanguage"));
    _language->addAction(_action_cn);
    _language->addAction(_action_en);

    _action_en->setIcon(QIcon(":/icons/English.svg"));
    _action_cn->setIcon(QIcon(":/icons/Chinese.svg"));

    _about = new QAction(this);
    _about->setObjectName(QString::fromUtf8("actionAbout"));
    _logo_button.addAction(_about);
     
    _manual = new QAction(this);
    _manual->setObjectName(QString::fromUtf8("actionManual"));
    _logo_button.addAction(_manual);
   
    _issue = new QAction(this);
    _issue->setObjectName(QString::fromUtf8("actionIssue"));
    _logo_button.addAction(_issue);   

    _update = new QAction(this);
    _log = new QAction(this);

    _menu = new QMenu(this);
    _menu->addMenu(_language);
    _menu->addAction(_about);
    _menu->addAction(_manual);
    _menu->addAction(_issue);
    _menu->addAction(_update);
    _menu->addAction(_log);
    _logo_button.setMenu(_menu);

    _logo_button.setToolButtonStyle(Qt::ToolButtonTextUnderIcon);
    _logo_button.setPopupMode(QToolButton::InstantPopup);

    QWidget *spacer = new QWidget(this);
    spacer->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    addWidget(spacer);
    addWidget(&_logo_button);
    QWidget *margin = new QWidget(this);
    margin->setMinimumWidth(20);
    addWidget(margin);

    retranslateUi();

    connect(_action_en, SIGNAL(triggered()), this, SLOT(on_actionEn_triggered()));
    connect(_action_cn, SIGNAL(triggered()), this, SLOT(on_actionCn_triggered()));
    connect(_about, SIGNAL(triggered()), this, SLOT(on_actionAbout_triggered()));
    connect(_manual, SIGNAL(triggered()), this, SIGNAL(sig_open_doc()));
    connect(_issue, SIGNAL(triggered()), this, SLOT(on_actionIssue_triggered()));
    connect(_update, SIGNAL(triggered()), this, SLOT(on_action_update()));
    connect(_log, SIGNAL(triggered()), this, SLOT(on_action_setting_log()));

    update_font();
}

void LogoBar::changeEvent(QEvent *event)
{
    if (event->type() == QEvent::LanguageChange)
        retranslateUi();
    else if (event->type() == QEvent::StyleChange)
        reStyle();
    QToolBar::changeEvent(event);
}

void LogoBar::retranslateUi()
{

    _logo_button.setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_HELP), "Help"));
     _language->setTitle(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_HELP_LANG), "&Language"));
    _action_en->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_HELP_LANG_EN), "English"));
    _action_cn->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_HELP_LANG_CN), ""));   
    _about->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_HELP_ABOUT), "&About..."));
    _manual->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_HELP_MANUAL), "&Manual..."));
    _issue->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_HELP_BUG), "&Bug Report"));
    _update->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_HELP_UPDATE), "&Update"));
    _log->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_HELP_LOG), "L&og Options"));

    AppConfig &app = AppConfig::Instance(); 
    if (app.frameOptions.language == LAN_CN)
        _language->setIcon(QIcon(":/icons/Chinese.svg"));
    else
        _language->setIcon(QIcon(":/icons/English.svg"));
}

void LogoBar::reStyle()
{
    QString iconPath = AppConfig::GetIconPath();

    _about->setIcon(QIcon(iconPath+"/about.svg"));
    _manual->setIcon(QIcon(iconPath+"/manual.svg"));
    _issue->setIcon(QIcon(iconPath+"/bug.svg"));
    _update->setIcon(QIcon(iconPath+"/update.svg"));
    _log->setIcon(QIcon(iconPath+"/log.svg"));

    if (_connected)
        _logo_button.setIcon(QIcon(iconPath+"/logo_color.svg"));
    else
        _logo_button.setIcon(QIcon(iconPath+"/logo_noColor.svg"));
}

void LogoBar::dsl_connected(bool conn)
{
    _connected = conn;
    QString iconPath =  AppConfig::GetIconPath();
    if (_connected)
        _logo_button.setIcon(QIcon(iconPath+"/logo_color.svg"));
    else
        _logo_button.setIcon(QIcon(iconPath+"/logo_noColor.svg"));
}

void LogoBar::on_actionEn_triggered()
{
    _language->setIcon(QIcon::fromTheme("file",
        QIcon(":/icons/English.svg")));

    assert(_mainForm);
    _mainForm->switchLanguage(LAN_EN);
}

void LogoBar::on_actionCn_triggered()
{
    _language->setIcon(QIcon::fromTheme("file",
        QIcon(":/icons/Chinese.svg")));
    assert(_mainForm);
    _mainForm->switchLanguage(LAN_CN);  
}

void LogoBar::on_actionAbout_triggered()
{
    dialogs::About dlg(this);
    dlg.exec();
}

void LogoBar::on_actionManual_triggered()
{ 
    QDir dir(AppConfig::GetAppDataDir());
    QDesktopServices::openUrl( QUrl("file:///"+dir.absolutePath() + "/ug.pdf"));
}

void LogoBar::on_actionIssue_triggered()
{
    QDesktopServices::openUrl(QUrl(QLatin1String("https://github.com/DreamSourceLab/DSView/issues")));
}

 void LogoBar::on_action_update()
 {
     if (AppConfig::Instance().frameOptions.language == LAN_CN){
         QDesktopServices::openUrl(QUrl(QLatin1String("https://dreamsourcelab.cn/download/")));
     }
     else{
         QDesktopServices::openUrl(QUrl(QLatin1String("https://www.dreamsourcelab.com/download/")));
     }
 }

void LogoBar::enable_toggle(bool enable)
{
    _logo_button.setDisabled(!enable);
}

void LogoBar::on_action_setting_log()
{   
    AppConfig &app = AppConfig::Instance(); 
    auto *topWind = AppControl::Instance()->GetTopWindow();
    dialogs::DSDialog dlg(topWind, false, true);
    dlg.setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_LOG_OPTIONS), "Log Options"));
    dlg.setMinimumSize(460, 300);
    QWidget *panel = new QWidget(&dlg);
    dlg.layout()->addWidget(panel);
    panel->setMinimumSize(250, 110);
    QFormLayout *lay = new QFormLayout();
    panel->setLayout(lay);
    lay->setVerticalSpacing(15);
 
    QComboBox *cbBox = new QComboBox();
    cbBox->setMinimumWidth(40);
    lay->addRow(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_LOG_LEVEL), "Log Level"), cbBox);

    for (int i=0; i<=5; i++){
        cbBox->addItem(QString::number(i));
    }
    cbBox->setCurrentIndex(app.appOptions.logLevel);

    QCheckBox *ckSave = new QCheckBox();
    ckSave->setChecked(app.appOptions.ableSaveLog);
    lay->addRow(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SAVE_FILE), "Save To File"), ckSave);

    QCheckBox *ckRebuild = new QCheckBox();
    ckRebuild->setChecked(app.appOptions.appendLogMode);
    lay->addRow(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_APPEND_MODE), "Append mode"), ckRebuild);

    QPushButton *btOpen = new QPushButton();
    btOpen->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_OPEN), "Open"));
    _log_open_bt = btOpen;
    connect(btOpen, SIGNAL(released()), this, SLOT(on_open_log_file()));   

    QPushButton *btClear = new QPushButton();
    btClear->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CLEARE), "Clear"));
    _log_clear_bt = btClear;
    connect(btClear, SIGNAL(released()), this, SLOT(on_clear_log_file()));

    QWidget *btWid = new QWidget();
    QHBoxLayout *btLay = new QHBoxLayout();
    btWid->setLayout(btLay);
    btLay->setSpacing(10);
    btLay->addWidget(btOpen);
    btLay->addWidget(btClear);

    lay->addRow("", btWid);

    QFile qf(get_dsv_log_path());
    if (qf.exists() == false){
        btOpen->setEnabled(false);
        btClear->setEnabled(false);
    }

    dlg.exec();

    if (dlg.IsClickYes()){
        bool ableSave = ckSave->isChecked();
        int level = cbBox->currentIndex();
        bool appendLogMode = ckRebuild->isChecked();

        if (ableSave != app.appOptions.ableSaveLog 
            || level != app.appOptions.logLevel
            || appendLogMode != app.appOptions.appendLogMode){
            app.appOptions.ableSaveLog = ableSave;
            app.appOptions.logLevel = level;
            app.appOptions.appendLogMode = appendLogMode;            
            app.SaveApp();

            dsv_log_level(level);
            
            if (ableSave){
                dsv_log_enalbe_logfile(false);
            }

            dsv_set_log_file_enable(ableSave);
        }
    }  
}

void LogoBar::on_open_log_file()
{
    QFile qf(get_dsv_log_path());
    if (qf.exists()){
        QDesktopServices::openUrl( QUrl("file:///" + get_dsv_log_path()));
    }
    else{
        QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_FILE_NOT_EXIST), "Not exist!"));
        MsgBox::Show(strMsg);
    }        
}

void LogoBar::on_clear_log_file()
{
    QFile qf(get_dsv_log_path());
    if (qf.exists()){
        QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_TO_CLEAR_LOG), "Confirm!"));
        if (MsgBox::Confirm(strMsg)){
            dsv_clear_log_file();

            if (_log_open_bt != NULL && _log_clear_bt != NULL){
                QFile qf(get_dsv_log_path());
                if (qf.exists() == false){
                    _log_open_bt->setEnabled(false);
                    _log_clear_bt->setEnabled(false);
                }
            }
        }
    }
    else{
        QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_FILE_NOT_EXIST), "Not exist!"));
        MsgBox::Show(strMsg);
    }  
}

void LogoBar::update_font()
{ 
    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
    ui::set_toolbar_font(this, font);
}

} // namespace toolbars
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "trigbar.h"
#include <QBitmap>
#include <QPainter>
#include <QEvent>
#include "../appcore/sigsession.h"
#include "../dialogs/fftoptions.h"
#include "../dialogs/lissajousoptions.h"
#include "../dialogs/mathoptions.h"
#include "../view/trace.h"
#include "../dialogs/applicationpardlg.h"
#include "../ui/langresource.h"
#include "../config/appconfig.h"
#include "../ui/fn.h"

using namespace dsv::config;

namespace dsv {
namespace toolbars {
 
TrigBar::TrigBar(SigSession *session, QWidget *parent) :
    QToolBar("Trig Bar", parent),
    _session(session),
 
    _trig_button(this),
    _protocol_button(this),
    _measure_button(this),
    _search_button(this),
    _function_button(this),
    _setting_button(this)
{
    _enable = true;

    setMovable(false);
    setContentsMargins(0,0,0,0);

    _action_fft = new QAction(this);
    _action_fft->setObjectName(QString::fromUtf8("actionFft"));
   
    _action_math = new QAction(this);
    _action_math->setObjectName(QString::fromUtf8("actionMath"));
     
    _function_menu = new QMenu(this);
    _function_menu->setContentsMargins(0,0,0,0);
    _function_menu->addAction(_action_fft);
    _function_menu->addAction(_action_math);
    _function_button.setPopupMode(QToolButton::InstantPopup);
    _function_button.setMenu(_function_menu);

    _action_lissajous = new QAction(this);
    _action_lissajous->setObjectName(QString::fromUtf8("actionLissajous"));
   
    _dark_style = new QAction(this);
    _dark_style->setObjectName(QString::fromUtf8("actionDark"));
    
    _light_style = new QAction(this);
    _light_style->setObjectName(QString::fromUtf8("actionLight"));
     
    _themes = new QMenu(this);
    _themes->setObjectName(QString::fromUtf8("menuThemes"));
    _themes->addAction(_light_style);
    _themes->addAction(_dark_style);

     _action_dispalyOptions = new QAction(this);

    _display_menu = new QMenu(this);
    _display_menu->setContentsMargins(0,0,0,0);
    
    _display_menu->addAction(_action_lissajous);    
    _display_menu->addMenu(_themes);
	_display_menu->addAction(_action_dispalyOptions);

    _setting_button.setPopupMode(QToolButton::InstantPopup);
    _setting_button.setMenu(_display_menu);

    _trig_button.setToolButtonStyle(Qt::ToolButtonTextUnderIcon);
    _protocol_button.setToolButtonStyle(Qt::ToolButtonTextUnderIcon);
    _measure_button.setToolButtonStyle(Qt::ToolButtonTextUnderIcon);
    _search_button.setToolButtonStyle(Qt::ToolButtonTextUnderIcon);
    _function_button.setToolButtonStyle(Qt::ToolButtonTextUnderIcon);
    _setting_button.setToolButtonStyle(Qt::ToolButtonTextUnderIcon);

    _protocol_button.setContentsMargins(0,0,0,0);

    _trig_action = addWidget(&_trig_button);
    _protocol_action = addWidget(&_protocol_button);
    _measure_action = addWidget(&_measure_button);
    _search_action = addWidget(&_search_button);
    _function_action = addWidget(&_function_button); 
    _display_action = addWidget(&_setting_button); //must be created
 
    retranslateUi();

    connect(&_trig_button, SIGNAL(clicked()),this, SLOT(trigger_clicked()));
    connect(&_protocol_button, SIGNAL(clicked()),this, SLOT(protocol_clicked()));
    connect(&_measure_button, SIGNAL(clicked()),this, SLOT(measure_clicked()));
    connect(&_search_button, SIGNAL(clicked()), this, SLOT(search_clicked()));

    connect(_action_fft, SIGNAL(triggered()), this, SLOT(on_actionFft_triggered()));
    connect(_action_math, SIGNAL(triggered()), this, SLOT(on_actionMath_triggered()));
    connect(_action_lissajous, SIGNAL(triggered()), this, SLOT(on_actionLissajous_triggered()));
    connect(_dark_style, SIGNAL(triggered()), this, SLOT(on_actionDark_triggered()));
    connect(_light_style, SIGNAL(triggered()), this, SLOT(on_actionLight_triggered()));
    connect(_action_dispalyOptions, SIGNAL(triggered()), this, SLOT(on_display_setting()));

    update_font();
}

//
void TrigBar::changeEvent(QEvent *event)
{
    if (event->type() == QEvent::LanguageChange)
        retranslateUi();
    else if (event->type() == QEvent::StyleChange)
        reStyle();
    QToolBar::changeEvent(event);
}

void TrigBar::retranslateUi()
{
    _trig_button.setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_TRIGGER), "Trigger"));
    _protocol_button.setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_DECODE), "Decode"));
    _measure_button.setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_MEASURE), "Measure"));
    _search_button.setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_SEARCH), "Search"));
    _function_button.setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_FUNCTION), "Function"));

    _setting_button.setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_DISPLAY), "Display"));    
    _themes->setTitle(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_DISPLAY_THEMES), "Themes"));
    _action_lissajous->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_DISPLAY_LISSAJOUS), "Lissajous"));

   
    _dark_style->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_DISPLAY_THEMES_DARK), "Dark"));
    _light_style->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_DISPLAY_THEMES_LIGHT), "Light"));

    _action_fft->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_FUNCTION_FFT), "FFT"));
    _action_math->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_FUNCTION_MATH), "Math"));

    _action_dispalyOptions->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_DISPLAY_OPTIONS), "Options"));
}

void TrigBar::reStyle()
{
    QString iconPath = AppConfig::GetIconPath();

    _trig_button.setIcon(QIcon(iconPath+"/trigger.svg"));
    _protocol_button.setIcon(QIcon(iconPath+"/protocol.svg"));
    _measure_button.setIcon(QIcon(iconPath+"/measure.svg"));
    _search_button.setIcon(QIcon(iconPath+"/search-bar.svg"));
    _function_button.setIcon(QIcon(iconPath+"/function.svg"));
    _setting_button.setIcon(QIcon(iconPath+"/display.svg"));

    _action_fft->setIcon(QIcon(iconPath+"/fft.svg"));
    _action_math->setIcon(QIcon(iconPath+"/math.svg"));
    _action_lissajous->setIcon(QIcon(iconPath+"/lissajous.svg"));
    _dark_style->setIcon(QIcon(iconPath+"/dark.svg"));
    _light_style->setIcon(QIcon(iconPath+"/light.svg"));

    _action_dispalyOptions->setIcon(QIcon(iconPath+"/gear.svg"));

     AppConfig &app = AppConfig::Instance();
     QString icon_fname = iconPath +"/"+ app.frameOptions.style +".svg";  
    _themes->setIcon(QIcon(icon_fname));
}

void TrigBar::protocol_clicked()
{  
    if (_protocol_button.isVisible() && _protocol_button.isEnabled())
    {
        DockOptions *opt = getDockOptions();
        opt->decodeDock = !opt->decodeDock;
        sig_protocol(opt->decodeDock);
        AppConfig::Instance().SaveFrame();

        update_checked_status();
    }
}

void TrigBar::trigger_clicked()
{
    if (_trig_button.isVisible() && _trig_button.isEnabled())
    {
        DockOptions *opt = getDockOptions();
        opt->triggerDock = !opt->triggerDock;
        sig_trigger(opt->triggerDock);
        AppConfig::Instance().SaveFrame();

        update_checked_status();
    }
}

void TrigBar::measure_clicked()
{   
    if (_measure_button.isVisible() && _measure_button.isEnabled())
    {
        DockOptions *opt = getDockOptions();
        opt->measureDock = !opt->measureDock;
        sig_measure(opt->measureDock);
        AppConfig::Instance().SaveFrame();

        update_checked_status();
    }
}

void TrigBar::search_clicked()
{
    if (_search_button.isVisible() && _search_button.isEnabled())
    {   
        DockOptions *opt = getDockOptions();
        opt->searchDock = !opt->searchDock;
        sig_search(opt->searchDock);
        AppConfig::Instance().SaveFrame();

        update_checked_status();
    }  
}

void TrigBar::reload()
{ 
    int mode = _session->get_device()->get_work_mode();

    if (mode == LOGIC) {
        _trig_action->setVisible(true);
        _protocol_action->setVisible(true);
        _measure_action->setVisible(true);
        _search_action->setVisible(true);
        _function_action->setVisible(false);
        _action_lissajous->setVisible(false);
        _action_dispalyOptions->setVisible(true);

    } else if (mode == ANALOG) {
        _trig_action->setVisible(false);
        _protocol_action->setVisible(false);
        _measure_action->setVisible(true);
        _search_action->setVisible(false);
        _function_action->setVisible(false);
        _action_lissajous->setVisible(false);
        _action_dispalyOptions->setVisible(true);

    } else if (mode == DSO) {
        _trig_action->setVisible(true);
        _protocol_action->setVisible(false);
        _measure_action->setVisible(true);
        _search_action->setVisible(false);
        _function_action->setVisible(true);
        _action_lissajous->setVisible(true);
        _action_dispalyOptions->setVisible(true);
    }

    DockOptions *opt = getDockOptions();

    bool bDecoder = _protocol_action->isVisible() && opt->decodeDock;
    bool bTrigger = _trig_action->isVisible() && opt->triggerDock;
    bool bMeasure = _measure_action->isVisible() && opt->measureDock;
    bool bSearch = _search_action->isVisible() && opt->searchDock;

    sig_protocol(bDecoder);
    sig_trigger(bTrigger);
    sig_measure(bMeasure);
    sig_search(bSearch);
   
    update_view_status(); 
    update_checked_status();
    update();    
}

void TrigBar::on_actionFft_triggered()
{
    dsv::dialogs::FftOptions fft_dlg(this, _session);
    fft_dlg.exec();
}

void TrigBar::on_actionMath_triggered()
{
    dsv::dialogs::MathOptions math_dlg(_session, this);
    math_dlg.exec();
}

void TrigBar::on_actionDark_triggered()
{
    sig_setTheme(THEME_STYLE_DARK);
    QString icon = AppConfig::GetIconPath() + "/" + THEME_STYLE_DARK + ".svg";
    _themes->setIcon(QIcon(icon));
}

void TrigBar::on_actionLight_triggered()
{
    sig_setTheme(THEME_STYLE_LIGHT);
    QString icon = AppConfig::GetIconPath() + "/" + THEME_STYLE_LIGHT +".svg";
    _themes->setIcon(QIcon(icon));
}

void TrigBar::on_actionLissajous_triggered()
{
    dsv::dialogs::LissajousOptions lissajous_dlg(_session, this);
    lissajous_dlg.exec();
}

 void TrigBar::on_display_setting()
 {    
    dsv::dialogs::ApplicationParamDlg dlg;
    dlg.ShowDlg(this);
 }

 DockOptions* TrigBar::getDockOptions()
 {
    AppConfig &app = AppConfig::Instance(); 
    int mode = _session->get_device()->get_work_mode();

    if (mode == LOGIC)
        return &app.frameOptions._logicDock;
     else if (mode == DSO)
        return &app.frameOptions._dsoDock;
    else
        return &app.frameOptions._analogDock;
 }

 void TrigBar::update_view_status()
 {
    bool bEnable = _session->is_working() == false;

    _trig_button.setEnabled(bEnable);
    _protocol_button.setEnabled(bEnable);
    _measure_button.setEnabled(bEnable);
    _search_button.setEnabled(bEnable);
    _function_button.setEnabled(bEnable);
    _setting_button.setEnabled(bEnable);

    if (_session->is_working() && _session->get_device()->get_work_mode() == DSO){
        if (_session->is_instant() == false){
            _trig_button.setEnabled(true);
            _measure_button.setEnabled(true);
            _function_button.setEnabled(true);
            _setting_button.setEnabled(true);
        }
    }
 }

void TrigBar::update_checked_status()
{
    DockOptions *opt = getDockOptions();
    assert(opt);

    _trig_button.setCheckable(true); 
    _protocol_button.setCheckable(true); 
    _measure_button.setCheckable(true);
    _search_button.setCheckable(true);

    _trig_button.setChecked(opt->triggerDock);
    _protocol_button.setChecked(opt->decodeDock);
    _measure_button.setChecked(opt->measureDock);
    _search_button.setChecked(opt->searchDock);
}

void TrigBar::update_font()
{ 
    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
    ui::set_toolbar_font(this, font);
}

} // namespace toolbars
} // namespace dsv
/****************************************************************************
** Meta object code from reading C++ file 'samplingbar.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "samplingbar.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'samplingbar.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPESamplingBarENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPESamplingBarENDCLASS = QtMocHelpers::stringData(
    "dsv::toolbars::SamplingBar",
    "sig_store_session_data",
    "",
    "on_collect_mode",
    "on_run_stop",
    "on_instant_stop",
    "on_device_selected",
    "on_samplerate_sel",
    "index",
    "on_samplecount_sel",
    "on_configure",
    "zero_adj",
    "on_run_stop_action",
    "on_instant_stop_action"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPESamplingBarENDCLASS_t {
    uint offsetsAndSizes[28];
    char stringdata0[27];
    char stringdata1[23];
    char stringdata2[1];
    char stringdata3[16];
    char stringdata4[12];
    char stringdata5[16];
    char stringdata6[19];
    char stringdata7[18];
    char stringdata8[6];
    char stringdata9[19];
    char stringdata10[13];
    char stringdata11[9];
    char stringdata12[19];
    char stringdata13[23];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPESamplingBarENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPESamplingBarENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPESamplingBarENDCLASS = {
    {
        QT_MOC_LITERAL(0, 26),  // "dsv::toolbars::SamplingBar"
        QT_MOC_LITERAL(27, 22),  // "sig_store_session_data"
        QT_MOC_LITERAL(50, 0),  // ""
        QT_MOC_LITERAL(51, 15),  // "on_collect_mode"
        QT_MOC_LITERAL(67, 11),  // "on_run_stop"
        QT_MOC_LITERAL(79, 15),  // "on_instant_stop"
        QT_MOC_LITERAL(95, 18),  // "on_device_selected"
        QT_MOC_LITERAL(114, 17),  // "on_samplerate_sel"
        QT_MOC_LITERAL(132, 5),  // "index"
        QT_MOC_LITERAL(138, 18),  // "on_samplecount_sel"
        QT_MOC_LITERAL(157, 12),  // "on_configure"
        QT_MOC_LITERAL(170, 8),  // "zero_adj"
        QT_MOC_LITERAL(179, 18),  // "on_run_stop_action"
        QT_MOC_LITERAL(198, 22)   // "on_instant_stop_action"
    },
    "dsv::toolbars::SamplingBar",
    "sig_store_session_data",
    "",
    "on_collect_mode",
    "on_run_stop",
    "on_instant_stop",
    "on_device_selected",
    "on_samplerate_sel",
    "index",
    "on_samplecount_sel",
    "on_configure",
    "zero_adj",
    "on_run_stop_action",
    "on_instant_stop_action"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEtoolbarsSCOPESamplingBarENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
      11,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   80,    2, 0x06,    1 /* Public */,

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       3,    0,   81,    2, 0x08,    2 /* Private */,
       4,    0,   82,    2, 0x08,    3 /* Private */,
       5,    0,   83,    2, 0x08,    4 /* Private */,
       6,    0,   84,    2, 0x08,    5 /* Private */,
       7,    1,   85,    2, 0x08,    6 /* Private */,
       9,    1,   88,    2, 0x08,    8 /* Private */,
      10,    0,   91,    2, 0x08,   10 /* Private */,
      11,    0,   92,    2, 0x08,   11 /* Private */,
      12,    0,   93,    2, 0x08,   12 /* Private */,
      13,    0,   94,    2, 0x08,   13 /* Private */,

 // signals: parameters
    QMetaType::Void,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::Int,    8,
    QMetaType::Void, QMetaType::Int,    8,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::toolbars::SamplingBar::staticMetaObject = { {
    QMetaObject::SuperData::link<QToolBar::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPESamplingBarENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEtoolbarsSCOPESamplingBarENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPESamplingBarENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<SamplingBar, std::true_type>,
        // method 'sig_store_session_data'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_collect_mode'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_run_stop'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_instant_stop'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_device_selected'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_samplerate_sel'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'on_samplecount_sel'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'on_configure'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'zero_adj'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_run_stop_action'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_instant_stop_action'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::toolbars::SamplingBar::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<SamplingBar *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->sig_store_session_data(); break;
        case 1: _t->on_collect_mode(); break;
        case 2: _t->on_run_stop(); break;
        case 3: _t->on_instant_stop(); break;
        case 4: _t->on_device_selected(); break;
        case 5: _t->on_samplerate_sel((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 6: _t->on_samplecount_sel((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 7: _t->on_configure(); break;
        case 8: _t->zero_adj(); break;
        case 9: _t->on_run_stop_action(); break;
        case 10: _t->on_instant_stop_action(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (SamplingBar::*)();
            if (_t _q_method = &SamplingBar::sig_store_session_data; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
    }
}

const QMetaObject *dsv::toolbars::SamplingBar::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::toolbars::SamplingBar::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPESamplingBarENDCLASS.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "IFontForm"))
        return static_cast< IFontForm*>(this);
    return QToolBar::qt_metacast(_clname);
}

int dsv::toolbars::SamplingBar::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QToolBar::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 11)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 11;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 11)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 11;
    }
    return _id;
}

// SIGNAL 0
void dsv::toolbars::SamplingBar::sig_store_session_data()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}
QT_WARNING_POP
/****************************************************************************
** Meta object code from reading C++ file 'trigbar.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "trigbar.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'trigbar.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPETrigBarENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPETrigBarENDCLASS = QtMocHelpers::stringData(
    "dsv::toolbars::TrigBar",
    "sig_setTheme",
    "",
    "style",
    "sig_protocol",
    "visible",
    "sig_trigger",
    "sig_measure",
    "sig_search",
    "sig_show_lissajous",
    "on_actionDark_triggered",
    "on_actionLight_triggered",
    "on_actionLissajous_triggered",
    "on_actionFft_triggered",
    "on_actionMath_triggered",
    "on_display_setting",
    "protocol_clicked",
    "trigger_clicked",
    "measure_clicked",
    "search_clicked"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPETrigBarENDCLASS_t {
    uint offsetsAndSizes[40];
    char stringdata0[23];
    char stringdata1[13];
    char stringdata2[1];
    char stringdata3[6];
    char stringdata4[13];
    char stringdata5[8];
    char stringdata6[12];
    char stringdata7[12];
    char stringdata8[11];
    char stringdata9[19];
    char stringdata10[24];
    char stringdata11[25];
    char stringdata12[29];
    char stringdata13[23];
    char stringdata14[24];
    char stringdata15[19];
    char stringdata16[17];
    char stringdata17[16];
    char stringdata18[16];
    char stringdata19[15];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPETrigBarENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPETrigBarENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPETrigBarENDCLASS = {
    {
        QT_MOC_LITERAL(0, 22),  // "dsv::toolbars::TrigBar"
        QT_MOC_LITERAL(23, 12),  // "sig_setTheme"
        QT_MOC_LITERAL(36, 0),  // ""
        QT_MOC_LITERAL(37, 5),  // "style"
        QT_MOC_LITERAL(43, 12),  // "sig_protocol"
        QT_MOC_LITERAL(56, 7),  // "visible"
        QT_MOC_LITERAL(64, 11),  // "sig_trigger"
        QT_MOC_LITERAL(76, 11),  // "sig_measure"
        QT_MOC_LITERAL(88, 10),  // "sig_search"
        QT_MOC_LITERAL(99, 18),  // "sig_show_lissajous"
        QT_MOC_LITERAL(118, 23),  // "on_actionDark_triggered"
        QT_MOC_LITERAL(142, 24),  // "on_actionLight_triggered"
        QT_MOC_LITERAL(167, 28),  // "on_actionLissajous_triggered"
        QT_MOC_LITERAL(196, 22),  // "on_actionFft_triggered"
        QT_MOC_LITERAL(219, 23),  // "on_actionMath_triggered"
        QT_MOC_LITERAL(243, 18),  // "on_display_setting"
        QT_MOC_LITERAL(262, 16),  // "protocol_clicked"
        QT_MOC_LITERAL(279, 15),  // "trigger_clicked"
        QT_MOC_LITERAL(295, 15),  // "measure_clicked"
        QT_MOC_LITERAL(311, 14)   // "search_clicked"
    },
    "dsv::toolbars::TrigBar",
    "sig_setTheme",
    "",
    "style",
    "sig_protocol",
    "visible",
    "sig_trigger",
    "sig_measure",
    "sig_search",
    "sig_show_lissajous",
    "on_actionDark_triggered",
    "on_actionLight_triggered",
    "on_actionLissajous_triggered",
    "on_actionFft_triggered",
    "on_actionMath_triggered",
    "on_display_setting",
    "protocol_clicked",
    "trigger_clicked",
    "measure_clicked",
    "search_clicked"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEtoolbarsSCOPETrigBarENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
      16,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       6,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,  110,    2, 0x06,    1 /* Public */,
       4,    1,  113,    2, 0x06,    3 /* Public */,
       6,    1,  116,    2, 0x06,    5 /* Public */,
       7,    1,  119,    2, 0x06,    7 /* Public */,
       8,    1,  122,    2, 0x06,    9 /* Public */,
       9,    1,  125,    2, 0x06,   11 /* Public */,

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
      10,    0,  128,    2, 0x08,   13 /* Private */,
      11,    0,  129,    2, 0x08,   14 /* Private */,
      12,    0,  130,    2, 0x08,   15 /* Private */,
      13,    0,  131,    2, 0x08,   16 /* Private */,
      14,    0,  132,    2, 0x08,   17 /* Private */,
      15,    0,  133,    2, 0x08,   18 /* Private */,
      16,    0,  134,    2, 0x0a,   19 /* Public */,
      17,    0,  135,    2, 0x0a,   20 /* Public */,
      18,    0,  136,    2, 0x0a,   21 /* Public */,
      19,    0,  137,    2, 0x0a,   22 /* Public */,

 // signals: parameters
    QMetaType::Void, QMetaType::QString,    3,
    QMetaType::Void, QMetaType::Bool,    5,
    QMetaType::Void, QMetaType::Bool,    5,
    QMetaType::Void, QMetaType::Bool,    5,
    QMetaType::Void, QMetaType::Bool,    5,
    QMetaType::Void, QMetaType::Bool,    5,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::toolbars::TrigBar::staticMetaObject = { {
    QMetaObject::SuperData::link<QToolBar::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPETrigBarENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEtoolbarsSCOPETrigBarENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPETrigBarENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<TrigBar, std::true_type>,
        // method 'sig_setTheme'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QString, std::false_type>,
        // method 'sig_protocol'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>,
        // method 'sig_trigger'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>,
        // method 'sig_measure'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>,
        // method 'sig_search'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>,
        // method 'sig_show_lissajous'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>,
        // method 'on_actionDark_triggered'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_actionLight_triggered'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_actionLissajous_triggered'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_actionFft_triggered'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_actionMath_triggered'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_display_setting'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'protocol_clicked'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'trigger_clicked'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'measure_clicked'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'search_clicked'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::toolbars::TrigBar::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<TrigBar *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->sig_setTheme((*reinterpret_cast< std::add_pointer_t<QString>>(_a[1]))); break;
        case 1: _t->sig_protocol((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        case 2: _t->sig_trigger((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        case 3: _t->sig_measure((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        case 4: _t->sig_search((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        case 5: _t->sig_show_lissajous((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        case 6: _t->on_actionDark_triggered(); break;
        case 7: _t->on_actionLight_triggered(); break;
        case 8: _t->on_actionLissajous_triggered(); break;
        case 9: _t->on_actionFft_triggered(); break;
        case 10: _t->on_actionMath_triggered(); break;
        case 11: _t->on_display_setting(); break;
        case 12: _t->protocol_clicked(); break;
        case 13: _t->trigger_clicked(); break;
        case 14: _t->measure_clicked(); break;
        case 15: _t->search_clicked(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (TrigBar::*)(QString );
            if (_t _q_method = &TrigBar::sig_setTheme; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (TrigBar::*)(bool );
            if (_t _q_method = &TrigBar::sig_protocol; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 1;
                return;
            }
        }
        {
            using _t = void (TrigBar::*)(bool );
            if (_t _q_method = &TrigBar::sig_trigger; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 2;
                return;
            }
        }
        {
            using _t = void (TrigBar::*)(bool );
            if (_t _q_method = &TrigBar::sig_measure; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 3;
                return;
            }
        }
        {
            using _t = void (TrigBar::*)(bool );
            if (_t _q_method = &TrigBar::sig_search; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 4;
                return;
            }
        }
        {
            using _t = void (TrigBar::*)(bool );
            if (_t _q_method = &TrigBar::sig_show_lissajous; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 5;
                return;
            }
        }
    }
}

const QMetaObject *dsv::toolbars::TrigBar::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::toolbars::TrigBar::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPETrigBarENDCLASS.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "IFontForm"))
        return static_cast< IFontForm*>(this);
    return QToolBar::qt_metacast(_clname);
}

int dsv::toolbars::TrigBar::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QToolBar::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 16)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 16;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 16)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 16;
    }
    return _id;
}

// SIGNAL 0
void dsv::toolbars::TrigBar::sig_setTheme(QString _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}

// SIGNAL 1
void dsv::toolbars::TrigBar::sig_protocol(bool _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 1, _a);
}

// SIGNAL 2
void dsv::toolbars::TrigBar::sig_trigger(bool _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 2, _a);
}

// SIGNAL 3
void dsv::toolbars::TrigBar::sig_measure(bool _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 3, _a);
}

// SIGNAL 4
void dsv::toolbars::TrigBar::sig_search(bool _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 4, _a);
}

// SIGNAL 5
void dsv::toolbars::TrigBar::sig_show_lissajous(bool _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 5, _a);
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_TOOLBARS_TRIGBAR_H
#define DSVIEW_PV_TOOLBARS_TRIGBAR_H

#include <QToolBar>
#include <QToolButton>
#include <QAction>
#include <QMenu>
#include "../interface/icallbacks.h"

namespace dsv {
    namespace config{
    	class DockOptions; 
	}

    namespace appcore{
    	class SigSession; 
	}
}

using namespace dsv::appcore;
using namespace dsv::config;

namespace dsv {
namespace toolbars {

//boolbar, referenced by MainWindow
//TODO:show the property panel about protocol\trigger
class TrigBar : public QToolBar, public IFontForm
{
    Q_OBJECT

public:
    explicit TrigBar(SigSession *session, QWidget *parent = 0);
    void reload();
    void update_view_status();

private:
    void changeEvent(QEvent *event);
    void retranslateUi();
    void reStyle();
    DockOptions* getDockOptions();
    void update_checked_status();

    //IFontForm
    void update_font() override;

signals:
    void sig_setTheme(QString style);
    void sig_protocol(bool visible); //post decode button click event,to show or hide protocol property panel
    void sig_trigger(bool visible); //post decode button click event,to show or hide trigger property panel
    void sig_measure(bool visible);//post decode button click event,to show or hide measure property panel
    void sig_search(bool visible);
    void sig_show_lissajous(bool visible);

private slots:
    void on_actionDark_triggered();
    void on_actionLight_triggered();
    void on_actionLissajous_triggered();
    void on_actionFft_triggered();
    void on_actionMath_triggered();
    void on_display_setting();

public slots:
    void protocol_clicked();
    void trigger_clicked();
    void measure_clicked();
    void search_clicked();

private:
    SigSession  *_session;
    bool        _enable;
    QToolButton _trig_button;
    QToolButton _protocol_button;
    QToolButton _measure_button;
    QToolButton _search_button;
    QToolButton _function_button;
    QToolButton _setting_button;
    QAction     *_trig_action;
    QAction     *_protocol_action;
    QAction     *_measure_action;
    QAction     *_search_action;
    QAction     *_function_action; 
    QAction     *_display_action;

    QMenu       *_function_menu;
    QAction     *_action_fft;
    QAction     *_action_math;

    QMenu       *_display_menu;
    QMenu       *_themes;
    QAction     *_action_dispalyOptions;
    QAction     *_dark_style;
    QAction     *_light_style;
    QAction     *_action_lissajous;
};

} // namespace toolbars
} // namespace dsv

#endif // DSVIEW_PV_TOOLBARS_TRIGBAR_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "titlebar.h"
#include <QStyle>
#include <QLabel>
#include <QToolButton>
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QEvent>
#include <QMouseEvent> 
#include <QPainter>
#include <QStyleOption>
#include <assert.h>
#include "../config/appconfig.h"
#include "../appcore/appcontrol.h"
#include "../basedef.h"
#include "../ui/fn.h"

using namespace dsv::appcore;
using namespace dsv::config;

namespace dsv {
namespace toolbars {

TitleBar::TitleBar(bool top, QWidget *parent, bool hasClose) :
    QWidget(parent)
{ 
   _minimizeButton = NULL;
   _maximizeButton = NULL;
   _closeButton = NULL;
   _moving = false;
   _parent = parent;
   _isTop = top;
   _hasClose = hasClose;
   _title = NULL;

   assert(parent);

    setObjectName("TitleBar");
    setContentsMargins(0,0,0,0);
    setFixedHeight(32); 

    QHBoxLayout *lay1 = new QHBoxLayout(this);

    _title = new QLabel(this);
    lay1->addWidget(_title);

    if (_isTop) {
        _minimizeButton = new QToolButton(this);
        _minimizeButton->setObjectName("MinimizeButton");
        _maximizeButton = new QToolButton(this);
        _maximizeButton->setObjectName("MaximizeButton");

        lay1->addWidget(_minimizeButton);
        lay1->addWidget(_maximizeButton);

        connect(this, SIGNAL(normalShow()), parent, SLOT(showNormal()));
        connect(this, SIGNAL( maximizedShow()), parent, SLOT(showMaximized()));
        connect(_minimizeButton, SIGNAL( clicked()), parent, SLOT(showMinimized()));
        connect(_maximizeButton, SIGNAL( clicked()), this, SLOT(showMaxRestore()));
    }

    if (_isTop || _hasClose) {
        _closeButton= new QToolButton(this);
        _closeButton->setObjectName("CloseButton");
        lay1->addWidget(_closeButton);
        connect(_closeButton, SIGNAL( clicked()), parent, SLOT(close()));
    }

    lay1->insertStretch(0, 500);
    lay1->insertStretch(2, 500);
    lay1->setContentsMargins(0,0,0,0);
    lay1->setSpacing(0);

    setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed); 

    update_font();
}

TitleBar::~TitleBar(){ 
    DESTROY_QT_OBJECT(_minimizeButton);
    DESTROY_QT_OBJECT(_maximizeButton);
    DESTROY_QT_OBJECT(_closeButton);
}

void TitleBar::changeEvent(QEvent *event)
{
    if (event->type() == QEvent::StyleChange)
        reStyle();
    QWidget::changeEvent(event);
}

void TitleBar::reStyle()
{ 
    QString iconPath =  AppConfig::GetIconPath();

    if (_isTop) {
        _minimizeButton->setIcon(QIcon(iconPath+"/minimize.svg"));
        if (parentWidget()->isMaximized())
            _maximizeButton->setIcon(QIcon(iconPath+"/restore.svg"));
        else
            _maximizeButton->setIcon(QIcon(iconPath+"/maximize.svg"));
    }
    if (_isTop || _hasClose)
        _closeButton->setIcon(QIcon(iconPath+"/close.svg"));
}

void TitleBar::paintEvent(QPaintEvent *event)
{ 
    //draw logo icon
    QStyleOption o;
    o.initFrom(this);
    QPainter p(this);
    style()->drawPrimitive(QStyle::PE_Widget, &o, &p, this);

    p.setRenderHint(QPainter::Antialiasing, true);

    const int xgap = 2;
    const int xstart = 10;
    p.setPen(QPen(QColor(213, 15, 37, 255), 2, Qt::SolidLine));
    p.drawLine(xstart + xgap*0,  height()*0.50, xstart + xgap*0,  height()*0.66);
    p.drawLine(xstart + xgap*18, height()*0.34, xstart + xgap*18, height()*0.50);

    p.setPen(QPen(QColor(238, 178, 17, 255), 2, Qt::SolidLine));
    p.drawLine(xstart + xgap*2,  height()*0.50, xstart + xgap*2,  height()*0.83);
    p.drawLine(xstart + xgap*16, height()*0.17, xstart + xgap*16, height()*0.50);

    p.setPen(QPen(QColor(17, 133, 209,  255), 2, Qt::SolidLine));
    p.drawLine(xstart + xgap*4,  height()*0.50, xstart + xgap*4,  height()*1.00);
    p.drawLine(xstart + xgap*14, height()*0.00, xstart + xgap*14, height()*0.50);

    p.setPen(QPen(QColor(0, 153, 37, 200), 2, Qt::SolidLine));
    p.drawLine(xstart + xgap*6,  height()*0.50, xstart + xgap*6,  height()*0.83);
    p.drawLine(xstart + xgap*12, height()*0.17, xstart + xgap*12, height()*0.50);

    p.setPen(QPen(QColor(109, 50, 156, 255), 2, Qt::SolidLine));
    p.drawLine(xstart + xgap*8,  height()*0.50, xstart + xgap*8,  height()*0.66);
    p.drawLine(xstart + xgap*10, height()*0.34, xstart + xgap*10, height()*0.50);

    QWidget::paintEvent(event);
}

void TitleBar::setTitle(QString title)
{
    _title->setText(title);
}
  
QString TitleBar::title()
{
    return _title->text();
}

void TitleBar::showMaxRestore()
{
    QString iconPath = AppConfig::GetIconPath();
    if (parentWidget()->isMaximized()) {
        _maximizeButton->setIcon(QIcon(iconPath+"/maximize.svg"));
        normalShow();
    } else {
        _maximizeButton->setIcon(QIcon(iconPath+"/restore.svg"));
        maximizedShow();
    }   
}

void TitleBar::setRestoreButton(bool max)
{
    QString iconPath = AppConfig::GetIconPath();
    if (!max) {
        _maximizeButton->setIcon(QIcon(iconPath+"/maximize.svg"));
    } else {
        _maximizeButton->setIcon(QIcon(iconPath+"/restore.svg"));
    }
}
  
void TitleBar::mousePressEvent(QMouseEvent* event)
{ 
    if(event->button() == Qt::LeftButton && !parentWidget()->isMaximized()) 
    {
        int x = event->pos().x();
        int y = event->pos().y(); 
        
        bool bTopWidow = AppControl::Instance()->GetTopWindow() == _parent;
        bool bClick = (x >= 6 && y >= 5 && x <= width() - 6);  //top window need resize hit check
 
        if (!bTopWidow || bClick ){
            _moving = true; 
            _clickPos = event->globalPos(); 
            _oldPos = _parent->pos();     
            event->accept();
            return;
        } 
    }  
    QWidget::mousePressEvent(event);
}

void TitleBar::mouseMoveEvent(QMouseEvent *event)
{  
    if(_moving){  
       int x = _oldPos.x() + (event->globalPos().x() - _clickPos.x());
       int y = _oldPos.y() + (event->globalPos().y() - _clickPos.y());
       _parent->move(x, y);  
       event->accept();
       return;
    } 
    QWidget::mouseMoveEvent(event);
}

void TitleBar::mouseReleaseEvent(QMouseEvent* event)
{
    _moving = false;
    QWidget::mouseReleaseEvent(event);
}

void TitleBar::mouseDoubleClickEvent(QMouseEvent *event)
{
    if (_isTop){
         showMaxRestore();
    }       
    QWidget::mouseDoubleClickEvent(event);
}

void TitleBar::update_font()
{  
    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
    _title->setFont(font);
}
 
} // namespace toolbars
} // namespace dsv
/****************************************************************************
** Meta object code from reading C++ file 'titlebar.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "titlebar.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'titlebar.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPETitleBarENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPETitleBarENDCLASS = QtMocHelpers::stringData(
    "dsv::toolbars::TitleBar",
    "normalShow",
    "",
    "maximizedShow",
    "showMaxRestore",
    "setRestoreButton",
    "max",
    "IsMoving"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPETitleBarENDCLASS_t {
    uint offsetsAndSizes[16];
    char stringdata0[24];
    char stringdata1[11];
    char stringdata2[1];
    char stringdata3[14];
    char stringdata4[15];
    char stringdata5[17];
    char stringdata6[4];
    char stringdata7[9];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPETitleBarENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPETitleBarENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPETitleBarENDCLASS = {
    {
        QT_MOC_LITERAL(0, 23),  // "dsv::toolbars::TitleBar"
        QT_MOC_LITERAL(24, 10),  // "normalShow"
        QT_MOC_LITERAL(35, 0),  // ""
        QT_MOC_LITERAL(36, 13),  // "maximizedShow"
        QT_MOC_LITERAL(50, 14),  // "showMaxRestore"
        QT_MOC_LITERAL(65, 16),  // "setRestoreButton"
        QT_MOC_LITERAL(82, 3),  // "max"
        QT_MOC_LITERAL(86, 8)   // "IsMoving"
    },
    "dsv::toolbars::TitleBar",
    "normalShow",
    "",
    "maximizedShow",
    "showMaxRestore",
    "setRestoreButton",
    "max",
    "IsMoving"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEtoolbarsSCOPETitleBarENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       5,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       2,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   44,    2, 0x06,    1 /* Public */,
       3,    0,   45,    2, 0x06,    2 /* Public */,

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       4,    0,   46,    2, 0x0a,    3 /* Public */,
       5,    1,   47,    2, 0x0a,    4 /* Public */,
       7,    0,   50,    2, 0x0a,    6 /* Public */,

 // signals: parameters
    QMetaType::Void,
    QMetaType::Void,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void, QMetaType::Bool,    6,
    QMetaType::Bool,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::toolbars::TitleBar::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPETitleBarENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEtoolbarsSCOPETitleBarENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPETitleBarENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<TitleBar, std::true_type>,
        // method 'normalShow'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'maximizedShow'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'showMaxRestore'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'setRestoreButton'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>,
        // method 'IsMoving'
        QtPrivate::TypeAndForceComplete<bool, std::false_type>
    >,
    nullptr
} };

void dsv::toolbars::TitleBar::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<TitleBar *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->normalShow(); break;
        case 1: _t->maximizedShow(); break;
        case 2: _t->showMaxRestore(); break;
        case 3: _t->setRestoreButton((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        case 4: { bool _r = _t->IsMoving();
            if (_a[0]) *reinterpret_cast< bool*>(_a[0]) = std::move(_r); }  break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (TitleBar::*)();
            if (_t _q_method = &TitleBar::normalShow; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (TitleBar::*)();
            if (_t _q_method = &TitleBar::maximizedShow; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 1;
                return;
            }
        }
    }
}

const QMetaObject *dsv::toolbars::TitleBar::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::toolbars::TitleBar::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEtoolbarsSCOPETitleBarENDCLASS.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "IFontForm"))
        return static_cast< IFontForm*>(this);
    return QWidget::qt_metacast(_clname);
}

int dsv::toolbars::TitleBar::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 5)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 5;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 5)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 5;
    }
    return _id;
}

// SIGNAL 0
void dsv::toolbars::TitleBar::normalShow()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}

// SIGNAL 1
void dsv::toolbars::TitleBar::maximizedShow()
{
    QMetaObject::activate(this, &staticMetaObject, 1, nullptr);
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "samplingbar.h"
#include <assert.h>
#include <QAction>
#include <QLabel>
#include <QAbstractItemView>
#include <math.h>
#include <libusb-1.0/libusb.h>
#include "../dialogs/deviceoptions.h"
#include "../dialogs/waitingdialog.h"
#include "../dialogs/dsmessagebox.h"
#include "../view/dsosignal.h"
#include "../dialogs/interval.h"
#include "../config/appconfig.h"
#include "../basedef.h"
#include "../log.h"
#include "../appcore/deviceagent.h"
#include "../ui/msgbox.h"
#include "../ui/langresource.h"
#include "../view/view.h"
#include "../ui/fn.h"
#include "../appcore/sigsession.h"

#define SINGLE_ACTION_ICON  "/once.svg"
#define REPEAT_ACTION_ICON  "/repeat.svg"
#define LOOP_ACTION_ICON  "/loop.svg"

using std::map;
using std::max;
using std::min;
using std::string;
using namespace dsv::config;

namespace dsv
{
    namespace toolbars
    {

        const QString SamplingBar::RLEString = "(RLE)";
        const QString SamplingBar::DIVString = " / div";

        SamplingBar::SamplingBar(SigSession* session, QWidget* parent) : QToolBar("Sampling Bar", parent),
            _device_type(this),
            _device_selector(this),
            _configure_button(this),
            _sample_count(this),
            _sample_rate(this),
            _run_stop_button(this),
            _instant_button(this),
            _mode_button(this)
        {
            _updating_device_list = false;
            _updating_sample_rate = false;
            _updating_sample_count = false;
            _is_run_as_instant = false;

            _last_device_handle = NULL_HANDLE;
            _last_device_index = -1;
            _next_switch_device = NULL_HANDLE;
            _view = NULL;

            _session = session;
            _device_agent = _session->get_device();

            setMovable(false);
            setContentsMargins(0, 0, 0, 0);
            layout()->setSpacing(0);

            _mode_button.setPopupMode(QToolButton::InstantPopup);

            _device_selector.setSizeAdjustPolicy(DsComboBox::AdjustToContents);
            _sample_rate.setSizeAdjustPolicy(DsComboBox::AdjustToContents);
            _sample_count.setSizeAdjustPolicy(DsComboBox::AdjustToContents);
            _device_selector.setMaximumWidth(ComboBoxMaxWidth);

            //tr
            _run_stop_button.setObjectName("run_stop_button");

            QWidget* leftMargin = new QWidget(this);
            leftMargin->setFixedWidth(4);
            addWidget(leftMargin);

            _device_type.setToolButtonStyle(Qt::ToolButtonTextUnderIcon);
            addWidget(&_device_type);
            addWidget(&_device_selector);
            _configure_button.setToolButtonStyle(Qt::ToolButtonTextUnderIcon);
            addWidget(&_configure_button);

            addWidget(&_sample_count);
            //tr
            addWidget(new QLabel(" @ "));
            addWidget(&_sample_rate);

            _action_single = new QAction(this);
            _action_repeat = new QAction(this);
            _action_loop = new QAction(this);

            _mode_menu = new QMenu(this);
            _mode_menu->addAction(_action_single);
            _mode_menu->addAction(_action_repeat);
            _mode_menu->addAction(_action_loop);
            _mode_button.setMenu(_mode_menu);

            _mode_button.setToolButtonStyle(Qt::ToolButtonTextUnderIcon);
            _mode_action = addWidget(&_mode_button);

            _run_stop_button.setToolButtonStyle(Qt::ToolButtonTextUnderIcon);
            _run_stop_action = addWidget(&_run_stop_button);
            _instant_button.setToolButtonStyle(Qt::ToolButtonTextUnderIcon);
            _instant_action = addWidget(&_instant_button);

            update_view_status();
            update_font();

            connect(&_device_selector, SIGNAL(currentIndexChanged(int)), this, SLOT(on_device_selected()));
            connect(&_configure_button, SIGNAL(clicked()), this, SLOT(on_configure()));
            connect(&_run_stop_button, SIGNAL(clicked()), this, SLOT(on_run_stop()));
            connect(&_instant_button, SIGNAL(clicked()), this, SLOT(on_instant_stop()));
            connect(&_sample_count, SIGNAL(currentIndexChanged(int)), this, SLOT(on_samplecount_sel(int)));
            connect(_action_single, SIGNAL(triggered()), this, SLOT(on_collect_mode()));
            connect(_action_repeat, SIGNAL(triggered()), this, SLOT(on_collect_mode()));
            connect(_action_loop, SIGNAL(triggered()), this, SLOT(on_collect_mode()));
            connect(&_sample_rate, SIGNAL(currentIndexChanged(int)), this, SLOT(on_samplerate_sel(int)));
        }

        void SamplingBar::changeEvent(QEvent* event)
        {
            if (event->type() == QEvent::LanguageChange)
                retranslateUi();
            else if (event->type() == QEvent::StyleChange)
                reStyle();
            QToolBar::changeEvent(event);
        }

        void SamplingBar::retranslateUi()
        {
            bool bDev = _device_agent->have_instance();

            if (bDev)
            {
                if (_device_agent->is_demo())
                {
                    _device_type.setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_DEVICE_TYPE_DEMO), "Demo"));
                }
                else if (_device_agent->is_file())
                {
                    _device_type.setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_DEVICE_TYPE_FILE), "File"));
                }
                else
                {
                    int usb_speed = LIBUSB_SPEED_HIGH;
                    _device_agent->get_config_int32(SR_CONF_USB_SPEED, usb_speed);

                    if (usb_speed == LIBUSB_SPEED_HIGH)
                        _device_type.setText("USB 2.0");
                    else if (usb_speed == LIBUSB_SPEED_SUPER)
                        _device_type.setText("USB 3.0");
                    else
                        _device_type.setText("USB UNKNOWN");
                }
            }
            _configure_button.setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_DEVICE_OPTION), "Options"));
            _mode_button.setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_CAPTURE_MODE), "Mode"));

            int mode = _device_agent->get_work_mode();
            bool is_working = _session->is_working();

            auto str_start = L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_RUN_START), "Start");
            auto str_stop = L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_RUN_STOP), "Stop");
            auto str_single = L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_ONE_SINGLE), "Single");
            auto str_instant = L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_ONE_INSTANT), "Instant");
            auto str_one_stop = L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_ONE_STOP), "Stop");

            if (_is_run_as_instant)
            {
                if (bDev && mode == DSO)
                    _instant_button.setText(is_working ? str_one_stop : str_single);
                else
                    _instant_button.setText(is_working ? str_one_stop : str_instant);

                _run_stop_button.setText(str_start);
            }
            else
            {
                _run_stop_button.setText(is_working ? str_stop : str_start);

                if (bDev && mode == DSO)
                    _instant_button.setText(str_single);
                else
                    _instant_button.setText(str_instant);
            }

            _action_single->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_CAPTURE_MODE_SINGLE), "&Single"));
            _action_repeat->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_CAPTURE_MODE_REPEAT), "&Repetitive"));
            _action_loop->setText(L_S(STR_PAGE_TOOLBAR, S_ID(IDS_TOOLBAR_CAPTURE_MODE_LOOP), "&Loop"));
        }

        void SamplingBar::reStyle()
        {
            bool bDev = _device_agent->have_instance();

            if (bDev)
            {
                if (_device_agent->is_demo())
                    _device_type.setIcon(QIcon(":/icons/demo.svg"));
                else if (_device_agent->is_file())
                    _device_type.setIcon(QIcon(":/icons/data.svg"));
                else
                {
                    int usb_speed = LIBUSB_SPEED_HIGH;
                    _device_agent->get_config_int32(SR_CONF_USB_SPEED, usb_speed);

                    if (usb_speed == LIBUSB_SPEED_SUPER)
                        _device_type.setIcon(QIcon(":/icons/usb3.svg"));
                    else
                        _device_type.setIcon(QIcon(":/icons/usb2.svg"));
                }
            }

            if (true)
            {
                QString iconPath = AppConfig::GetIconPath();
                _configure_button.setIcon(QIcon(iconPath + "/params.svg"));

                QString icon2 = _session->is_working() ? "stop.svg" : "start.svg";
                _run_stop_button.setIcon(QIcon(iconPath + "/" + icon2));
                _instant_button.setIcon(QIcon(iconPath + "/single.svg"));

                _action_single->setIcon(QIcon(iconPath + SINGLE_ACTION_ICON));
                _action_repeat->setIcon(QIcon(iconPath + REPEAT_ACTION_ICON));
                _action_loop->setIcon(QIcon(iconPath + LOOP_ACTION_ICON));

                update_mode_icon();
            }
        }

        void SamplingBar::on_configure()
        {
            int ret;

            if (_device_agent->have_instance() == false)
            {
                dsv_info("Have no device, can't to set device config.");
                return;
            }

            _session->broadcast_msg(DSV_MSG_BEGIN_DEVICE_OPTIONS);

            dsv::dialogs::DeviceOptions dlg(this);
            connect(_session->device_event_object(), SIGNAL(device_updated()), &dlg, SLOT(reject()));

            ret = dlg.exec();

            if (ret == QDialog::Accepted)
            {
                if (_session->have_view_data() == false)
                    this->commit_settings();

                _session->broadcast_msg(DSV_MSG_DEVICE_OPTIONS_UPDATED);

                update_sample_rate_list();

                int mode = _device_agent->get_work_mode();
                bool zero = false;
                bool test;
                bool ret;

                if (mode == DSO)
                {

                    _device_agent->get_config_bool(SR_CONF_ZERO, zero);

                    if (zero)
                    {
                        zero_adj();
                        return;
                    }
                }

                ret = _device_agent->get_config_bool(SR_CONF_TEST, test);
                if (ret)
                {
                    if (test)
                    {
                        update_sample_rate_selector_value();
                        _sample_count.setDisabled(true);
                        _sample_rate.setDisabled(true);
                    }
                    else
                    {
                        _sample_count.setDisabled(false);
                        if (mode != DSO)
                            _sample_rate.setDisabled(false);
                    }
                }

                this->reload();
            }

            _session->broadcast_msg(DSV_MSG_END_DEVICE_OPTIONS);
        }

        void SamplingBar::zero_adj()
        {
            for (auto s : _session->get_signals())
            {
                if (s->signal_type() == SR_CHANNEL_DSO) {
                    view::DsoSignal* dsoSig = (view::DsoSignal*)s;
                    dsoSig->set_enable(true);
                }
            }

            const int index_back = _sample_count.currentIndex();
            int i = 0;

            for (i = 0; i < _sample_count.count(); i++) {
                if (_sample_count.itemData(i).value<uint64_t>() == ZeroTimeBase)
                    break;
            }

            _sample_count.setCurrentIndex(i);
            commit_hori_res();

            if (_session->is_working() == false)
                _session->start_capture(false);

            dsv::dialogs::WaitingDialog wait(this, _session, SR_CONF_ZERO);
            if (wait.start() == QDialog::Rejected)
            {
                for (auto s : _session->get_signals())
                {
                    if (s->signal_type() == SR_CHANNEL_DSO) {
                        view::DsoSignal* dsoSig = (view::DsoSignal*)s;
                        dsoSig->commit_settings();
                    }
                }
            }

            if (_session->is_working())
                _session->stop_capture();

            _sample_count.setCurrentIndex(index_back);
            commit_hori_res();
        }

        void SamplingBar::set_sample_rate(uint64_t sample_rate)
        {
            for (int i = _sample_rate.count() - 1; i >= 0; i--)
            {
                uint64_t cur_index_sample_rate = _sample_rate.itemData(
                    i)
                    .value<uint64_t>();
                if (sample_rate >= cur_index_sample_rate)
                {
                    _sample_rate.setCurrentIndex(i);
                    break;
                }
            }
            commit_settings();
        }

        void SamplingBar::update_sample_rate_selector()
        {
            GVariant* gvar_dict, * gvar_list;
            const uint64_t* elements = NULL;
            gsize num_elements;

            dsv_info("Update rate list.");

            if (_updating_sample_rate)
            {
                dsv_err("Error! The rate list is updating.");
                return;
            }

            disconnect(&_sample_rate, SIGNAL(currentIndexChanged(int)),
                this, SLOT(on_samplerate_sel(int)));

            if (_device_agent->have_instance() == false)
            {
                dsv_info("SamplingBar::update_sample_rate_selector, have no device.");
                return;
            }

            _updating_sample_rate = true;

            gvar_dict = _device_agent->get_config_list(NULL, SR_CONF_SAMPLERATE);
            if (gvar_dict == NULL)
            {
                _sample_rate.clear();
                _sample_rate.show();
                _updating_sample_rate = false;
                return;
            }

            if ((gvar_list = g_variant_lookup_value(gvar_dict,
                "samplerates", G_VARIANT_TYPE("at"))))
            {
                elements = (const uint64_t*)g_variant_get_fixed_array(
                    gvar_list, &num_elements, sizeof(uint64_t));
                _sample_rate.clear();

                for (unsigned int i = 0; i < num_elements; i++)
                {
                    char* const s = sr_samplerate_string(elements[i]);
                    _sample_rate.addItem(QString(s),
                        QVariant::fromValue(elements[i]));
                    g_free(s);
                }

                _sample_rate.show();
                g_variant_unref(gvar_list);
            }

            _sample_rate.setMinimumWidth(_sample_rate.sizeHint().width() + 15);
            _sample_rate.view()->setMinimumWidth(_sample_rate.sizeHint().width() + 30);

            _updating_sample_rate = false;
            g_variant_unref(gvar_dict);

            update_sample_rate_selector_value();

            connect(&_sample_rate, SIGNAL(currentIndexChanged(int)),
                this, SLOT(on_samplerate_sel(int)));

            update_sample_count_selector();
        }

        void SamplingBar::update_sample_rate_selector_value()
        {
            if (_updating_sample_rate)
                return;
            _updating_sample_rate = true;

            const uint64_t samplerate = _device_agent->get_sample_rate();
            uint64_t cur_value = _sample_rate.itemData(_sample_rate.currentIndex()).value<uint64_t>();

            if (samplerate != cur_value)
            {
                for (int i = _sample_rate.count() - 1; i >= 0; i--)
                {
                    if (samplerate >= _sample_rate.itemData(i).value<uint64_t>())
                    {
                        _sample_rate.setCurrentIndex(i);
                        break;
                    }
                }
            }

            _updating_sample_rate = false;
        }

        void SamplingBar::on_samplerate_sel(int index)
        {
            (void)index;
            if (_device_agent->get_work_mode() != DSO)
                update_sample_count_selector();
        }

        void SamplingBar::update_sample_count_selector()
        {
            bool stream_mode = false;
            uint64_t hw_depth = 0;
            uint64_t sw_depth;
            uint64_t rle_depth = 0;
            uint64_t max_timebase = 0;
            uint64_t min_timebase = SR_NS(10);
            double pre_duration = SR_SEC(1);
            double duration;
            bool rle_support = false;

            dsv_info("Update sample count list.");

            if (_updating_sample_count)
            {
                dsv_err("Error! The sample count is updating.");
                return;
            }

            disconnect(&_sample_count, SIGNAL(currentIndexChanged(int)),
                this, SLOT(on_samplecount_sel(int)));

            assert(!_updating_sample_count);
            _updating_sample_count = true;

            _device_agent->get_config_bool(SR_CONF_STREAM, stream_mode);
            _device_agent->get_config_uint64(SR_CONF_HW_DEPTH, hw_depth);
            int mode = _device_agent->get_work_mode();

            if (mode == LOGIC)
            {
#if defined(__x86_64__) || defined(_M_X64)
                sw_depth = LogicMaxSWDepth64;
#elif defined(__i386) || defined(_M_IX86)
                int ch_num = _session->get_ch_num(SR_CHANNEL_LOGIC);
                if (ch_num <= 0)
                    sw_depth = LogicMaxSWDepth32;
                else
                    sw_depth = LogicMaxSWDepth32 / ch_num;
#endif
            }
            else
            {
                sw_depth = AnalogMaxSWDepth;
            }

            if (mode == LOGIC)
            {
                _device_agent->get_config_bool(SR_CONF_RLE_SUPPORT, rle_support);
                if (rle_support)
                    rle_depth = min(hw_depth * SR_KB(1), sw_depth);
            }
            else if (mode == DSO)
            {
                _device_agent->get_config_uint64(SR_CONF_MAX_TIMEBASE, max_timebase);
                _device_agent->get_config_uint64(SR_CONF_MIN_TIMEBASE, min_timebase);
            }

            if (0 != _sample_count.count())
                pre_duration = _sample_count.itemData(
                    _sample_count.currentIndex())
                .value<double>();
            _sample_count.clear();
            const uint64_t samplerate = _sample_rate.itemData(
                _sample_rate.currentIndex())
                .value<uint64_t>();
            const double hw_duration = hw_depth / (samplerate * (1.0 / SR_SEC(1)));

            if (mode == DSO)
                duration = max_timebase;
            else if (stream_mode)
                duration = sw_depth / (samplerate * (1.0 / SR_SEC(1)));
            else if (rle_support)
                duration = rle_depth / (samplerate * (1.0 / SR_SEC(1)));
            else
                duration = hw_duration;

            assert(duration > 0);
            bool not_last = true;

            do
            {
                QString suffix = (mode == DSO) ? DIVString : (!stream_mode && duration > hw_duration) ? RLEString
                    : "";
                char* const s = sr_time_string(duration);
                _sample_count.addItem(QString(s) + suffix, QVariant::fromValue(duration));
                g_free(s);

                double unit;
                if (duration >= SR_DAY(1))
                    unit = SR_DAY(1);
                else if (duration >= SR_HOUR(1))
                    unit = SR_HOUR(1);
                else if (duration >= SR_MIN(1))
                    unit = SR_MIN(1);
                else
                    unit = 1;

                const double log10_duration = pow(10, floor(log10(duration / unit)));

                if (duration > 5 * log10_duration * unit)
                    duration = 5 * log10_duration * unit;
                else if (duration > 2 * log10_duration * unit)
                    duration = 2 * log10_duration * unit;
                else if (duration > log10_duration * unit)
                    duration = log10_duration * unit;
                else
                    duration = log10_duration > 1 ? duration * 0.5 : (unit == SR_DAY(1) ? SR_HOUR(20) : unit == SR_HOUR(1) ? SR_MIN(50)
                        : unit == SR_MIN(1) ? SR_SEC(50)
                        : duration * 0.5);

                if (mode == DSO)
                    not_last = duration >= min_timebase;
                else if (mode == ANALOG)
                    not_last = (duration >= SR_MS(100)) &&
                    (duration / SR_SEC(1) * samplerate >= SR_KB(1));
                else
                    not_last = (duration / SR_SEC(1) * samplerate >= SR_KB(1));

            } while (not_last);

            _updating_sample_count = true;

            if (pre_duration > _sample_count.itemData(0).value<double>())
            {
                _sample_count.setCurrentIndex(0);
            }
            else if (pre_duration < _sample_count.itemData(_sample_count.count() - 1).value<double>())
            {
                _sample_count.setCurrentIndex(_sample_count.count() - 1);
            }
            else
            {
                for (int i = 0; i < _sample_count.count(); i++)
                {
                    double sel_val = _sample_count.itemData(i).value<double>();
                    if (pre_duration >= sel_val)
                    {
                        _sample_count.setCurrentIndex(i);
                        break;
                    }
                }
            }
            _updating_sample_count = false;

            update_sample_count_selector_value();
            on_samplecount_sel(_sample_count.currentIndex());

            connect(&_sample_count, SIGNAL(currentIndexChanged(int)), this, SLOT(on_samplecount_sel(int)));
        }

        void SamplingBar::update_sample_count_selector_value()
        {
            if (_updating_sample_count)
                return;

            double duration;
            uint64_t v;

            if (_device_agent->get_work_mode() == DSO)
            {
                if (_device_agent->get_config_uint64(SR_CONF_TIMEBASE, v))
                {
                    duration = (double)v;
                }
                else
                {
                    dsv_err("ERROR: config_get SR_CONF_TIMEBASE failed.");
                    return;
                }
            }
            else
            {
                if (_device_agent->get_config_uint64(SR_CONF_LIMIT_SAMPLES, v))
                {
                    duration = (double)v;
                }
                else
                {
                    dsv_err("ERROR: config_get SR_CONF_TIMEBASE failed.");
                    return;
                }
                const uint64_t samplerate = _device_agent->get_sample_rate();
                duration = duration / samplerate * SR_SEC(1);
            }
            assert(!_updating_sample_count);
            _updating_sample_count = true;

            double cur_duration = _sample_count.itemData(_sample_count.currentIndex()).value<double>();
            if (duration != cur_duration)
            {
                for (int i = 0; i < _sample_count.count(); i++)
                {
                    double sel_val = _sample_count.itemData(i).value<double>();
                    if (duration >= sel_val)
                    {
                        _sample_count.setCurrentIndex(i);
                        break;
                    }
                }
            }

            _updating_sample_count = false;
        }

        void SamplingBar::on_samplecount_sel(int index)
        {
            (void)index;

            if (_device_agent->get_work_mode() == DSO)
                commit_hori_res();
            _session->broadcast_msg(DSV_MSG_DEVICE_DURATION_UPDATED);
        }

        double SamplingBar::get_hori_res()
        {
            return _sample_count.itemData(_sample_count.currentIndex()).value<double>();
        }

        double SamplingBar::hori_knob(int dir)
        {
            double hori_res = -1;

            disconnect(&_sample_count, SIGNAL(currentIndexChanged(int)), this, SLOT(on_samplecount_sel(int)));

            if (0 == dir)
            {
                hori_res = commit_hori_res();
            }
            else if ((dir > 0) && (_sample_count.currentIndex() > 0))
            {
                _sample_count.setCurrentIndex(_sample_count.currentIndex() - 1);
                hori_res = commit_hori_res();
            }
            else if ((dir < 0) && (_sample_count.currentIndex() < _sample_count.count() - 1))
            {
                _sample_count.setCurrentIndex(_sample_count.currentIndex() + 1);
                hori_res = commit_hori_res();
            }

            connect(&_sample_count, SIGNAL(currentIndexChanged(int)),
                this, SLOT(on_samplecount_sel(int)));

            return hori_res;
        }

        double SamplingBar::commit_hori_res()
        {
            const double hori_res = _sample_count.itemData(
                _sample_count.currentIndex())
                .value<double>();

            const uint64_t sample_limit = _device_agent->get_sample_limit();
            uint64_t max_sample_rate;

            if (_device_agent->get_config_uint64(SR_CONF_MAX_DSO_SAMPLERATE, max_sample_rate) == false)
            {
                dsv_err("ERROR: config_get SR_CONF_MAX_DSO_SAMPLERATE failed.");
                return -1;
            }

            const uint64_t sample_rate = min((uint64_t)(sample_limit * SR_SEC(1) /
                (hori_res * DS_CONF_DSO_HDIVS)),
                (uint64_t)(max_sample_rate /
                    (_session->get_ch_num(SR_CHANNEL_DSO) ? _session->get_ch_num(SR_CHANNEL_DSO) : 1)));
            set_sample_rate(sample_rate);

            _device_agent->set_config_uint64(SR_CONF_TIMEBASE, hori_res);

            return hori_res;
        }

        void SamplingBar::commit_settings()
        {
            bool test = false;
            if (_device_agent->have_instance())
            {
                _device_agent->get_config_bool(SR_CONF_TEST, test);
            }

            if (test)
            {
                update_sample_rate_selector_value();
                update_sample_count_selector_value();
            }
            else
            {
                const double sample_duration = _sample_count.itemData(
                    _sample_count.currentIndex())
                    .value<double>();
                const uint64_t sample_rate = _sample_rate.itemData(
                    _sample_rate.currentIndex())
                    .value<uint64_t>();

                if (_device_agent->have_instance())
                {
                    if (sample_rate != _device_agent->get_sample_rate())
                        _device_agent->set_config_uint64(
                            SR_CONF_SAMPLERATE,
                            sample_rate);

                    if (_device_agent->get_work_mode() != DSO)
                    {
                        const uint64_t sample_count = ((uint64_t)ceil(sample_duration / SR_SEC(1) *
                            sample_rate) +
                            SAMPLES_ALIGN) &
                            ~SAMPLES_ALIGN;
                        if (sample_count != _device_agent->get_sample_limit())
                            _device_agent->set_config_uint64(
                                SR_CONF_LIMIT_SAMPLES,
                                sample_count);

                        bool rle_mode = _sample_count.currentText().contains(RLEString);
                        _device_agent->set_config_bool(
                            SR_CONF_RLE,
                            rle_mode);
                    }
                }
            }
        }

        void SamplingBar::on_run_stop()
        {
            _run_stop_button.setEnabled(false);
            QTimer::singleShot(10, this, &SamplingBar::on_run_stop_action);
        }

        void SamplingBar::on_run_stop_action()
        {
            action_run_stop();
            _run_stop_button.setEnabled(true);
        }

        // start or stop capture
        bool SamplingBar::action_run_stop()
        {
            if (_session->is_doing_action()) {
                dsv_info("Task is busy.");
                return false;
            }

            if (_session->is_working()) {
                return _session->stop_capture();
            }

            if (_device_agent->have_instance() == false)
            {
                dsv_info("Have no device, can't to collect data.");
                return false;
            }

            commit_settings();

            if (_device_agent->get_work_mode() == DSO)
            {
                bool zero;

                bool ret = _device_agent->get_config_bool(SR_CONF_ZERO, zero);
                if (ret && zero)
                {
                    QString str1(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_AUTO_CALIB), "Auto Calibration"));
                    QString str2(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_ADJUST_SAVE), "Please adjust zero skew and save the result"));
                    bool bRet = MsgBox::Confirm(str1, str2);

                    if (bRet)
                    {
                        zero_adj();
                    }
                    else
                    {
                        _device_agent->set_config_bool(SR_CONF_ZERO, false);
                        update_view_status();
                    }
                    return false;
                }
            }

            if (_device_agent->get_work_mode() == LOGIC && _view != NULL) {
                if (_session->is_realtime_refresh())
                    _view->auto_set_max_scale();
            }

            _is_run_as_instant = false;
            bool ret = _session->start_capture(false);

            return ret;
        }

        void SamplingBar::on_instant_stop()
        {
            if (_instant_action->isVisible() == false) {
                return;
            }
            _instant_button.setEnabled(false);
            QTimer::singleShot(10, this, &SamplingBar::on_instant_stop_action);
        }

        void SamplingBar::on_instant_stop_action()
        {
            action_instant_stop();
            _instant_button.setEnabled(true);
        }

        bool SamplingBar::action_instant_stop()
        {
            if (_session->is_doing_action()) {
                dsv_info("Task is busy.");
                return false;
            }

            if (_session->is_working()) {
                return _session->stop_capture();
            }

            if (_device_agent->have_instance() == false)
            {
                dsv_info("Error! Have no device, can't to collect data.");
                return false;
            }

            commit_settings();

            if (_device_agent->get_work_mode() == DSO)
            {
                bool zero;

                bool ret = _device_agent->get_config_bool(SR_CONF_ZERO, zero);
                if (ret && zero)
                {
                    QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_AUTO_CALIB_START), "Auto Calibration program will be started. Don't connect any probes. \nIt can take a while!"));

                    if (MsgBox::Confirm(strMsg))
                    {
                        zero_adj();
                    }
                    else
                    {
                        _device_agent->set_config_bool(SR_CONF_ZERO, false);
                        update_view_status();
                    }
                    return false;
                }
            }

            if (_device_agent->get_work_mode() == LOGIC && _session->is_realtime_refresh()) {
                if (_view != NULL)
                    _view->auto_set_max_scale();
            }

            _is_run_as_instant = true;
            bool ret = _session->start_capture(true);

            return ret;
        }

        void SamplingBar::on_device_selected()
        {
            if (_updating_device_list)
            {
                return;
            }
            if (_device_selector.currentIndex() == -1)
            {
                dsv_err("Have no selected device.");
                return;
            }
            _session->stop_capture();
            _session->session_save();

            ds_device_handle devHandle = (ds_device_handle)_device_selector.currentData().toULongLong();
            if (_session->have_hardware_data() && _session->is_first_store_confirm()) {
                if (MsgBox::Confirm(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_SAVE_CAPDATE), "Save captured data?")))
                {
                    _updating_device_list = true;
                    _device_selector.setCurrentIndex(_last_device_index);
                    _updating_device_list = false;
                    _next_switch_device = devHandle; // Save end, auto switch to this device.
                    sig_store_session_data();
                    return;
                }
            }

            if (_session->set_device(devHandle)) {
                _last_device_index = _device_selector.currentIndex();
            }
            else {
                update_device_list(); // Reload the list.
            }
        }

        void SamplingBar::enable_toggle(bool enable)
        {
            bool test = false;

            if (_device_agent->have_instance())
            {
                _device_agent->get_config_bool(SR_CONF_TEST, test);
            }
            if (!test)
            {
                _sample_count.setDisabled(!enable);

                if (_device_agent->get_work_mode() == DSO)
                    _sample_rate.setDisabled(true);
                else
                    _sample_rate.setDisabled(!enable);
            }
            else
            {
                _sample_count.setDisabled(true);
                _sample_rate.setDisabled(true);
            }
        }

        void SamplingBar::reload()
        {
            QString iconPath = AppConfig::GetIconPath();

            _action_loop->setVisible(false);

            int mode = _device_agent->get_work_mode();
            if (mode == LOGIC)
            {
                if (_device_agent->is_file()) {
                    _mode_action->setVisible(false);
                }
                else
                {
                    update_mode_icon();
                    _mode_action->setVisible(true);
                    _action_repeat->setVisible(true);

                    if (_session->is_loop_mode() && _device_agent->is_stream_mode() == false
                        && _device_agent->is_hardware()) {
                        _session->set_collect_mode(COLLECT_SINGLE);
                    }

                    if (_device_agent->is_stream_mode() || _device_agent->is_demo())
                        _action_loop->setVisible(true);
                }
                _run_stop_action->setVisible(true);
                _instant_action->setVisible(true);
            }
            else if (mode == ANALOG)
            {
                _mode_action->setVisible(false);
                _run_stop_action->setVisible(true);
                _instant_action->setVisible(false);
            }
            else if (mode == DSO)
            {
                _mode_action->setVisible(false);
                _run_stop_action->setVisible(true);
                _instant_action->setVisible(true);
            }

            retranslateUi();
            reStyle();
            update();
        }

        void SamplingBar::on_collect_mode()
        {
            QString iconPath = AppConfig::GetIconPath();
            QAction* act = qobject_cast<QAction*>(sender());

            if (act == _action_single)
            {
                _session->set_collect_mode(COLLECT_SINGLE);

                if (_device_agent->is_demo()) {
                    _device_agent->set_config_string(SR_CONF_PATTERN_MODE, "protocol");
                    _session->broadcast_msg(DSV_MSG_DEMO_OPERATION_MODE_CHNAGED);
                }
            }
            else if (act == _action_repeat)
            {
                if (_device_agent->is_stream_mode() || _device_agent->is_demo())
                {
                    _session->set_repeat_intvl(0.1);
                    _session->set_collect_mode(COLLECT_REPEAT);
                }
                else {
                    dsv::dialogs::Interval interval_dlg(this);

                    interval_dlg.set_interval(_session->get_repeat_intvl());
                    interval_dlg.exec();

                    if (interval_dlg.is_done())
                    {
                        _session->set_repeat_intvl(interval_dlg.get_interval());
                        _session->set_collect_mode(COLLECT_REPEAT);

                    }
                }

                if (_device_agent->is_demo()) {
                    _device_agent->set_config_string(SR_CONF_PATTERN_MODE, "random");
                    _session->broadcast_msg(DSV_MSG_DEMO_OPERATION_MODE_CHNAGED);
                }
            }
            else if (act == _action_loop)
            {
                _session->set_collect_mode(COLLECT_LOOP);

                if (_device_agent->is_demo()) {
                    _device_agent->set_config_string(SR_CONF_PATTERN_MODE, "random");
                    _session->broadcast_msg(DSV_MSG_DEMO_OPERATION_MODE_CHNAGED);
                }
            }

            update_mode_icon();
        }

        void SamplingBar::update_device_list()
        {
            struct ds_device_base_info* array = NULL;
            int dev_count = 0;
            int select_index = 0;

            dsv_info("Update device list.");

            array = _session->get_device_list(dev_count, select_index);

            if (array == NULL)
            {
                dsv_err("Get deivce list error!");
                return;
            }

            _updating_device_list = true;
            struct ds_device_base_info* p = NULL;
            ds_device_handle    cur_dev_handle = NULL_HANDLE;

            _device_selector.clear();

            for (int i = 0; i < dev_count; i++)
            {
                p = (array + i);
                _device_selector.addItem(QString(p->name), QVariant::fromValue((unsigned long long)p->handle));

                if (i == select_index)
                    cur_dev_handle = p->handle;
            }
            free(array);

            _device_selector.setCurrentIndex(select_index);

            if (cur_dev_handle != _last_device_handle) {
                update_sample_rate_list();
                _last_device_handle = cur_dev_handle;
            }

            _last_device_index = select_index;
            int width = _device_selector.sizeHint().width();
            _device_selector.setFixedWidth(min(width + 15, _device_selector.maximumWidth()));
            _device_selector.view()->setMinimumWidth(width + 30);

            _updating_device_list = false;
        }

        void SamplingBar::config_device()
        {
            if (_configure_button.isVisible() && _configure_button.isEnabled()) {
                on_configure();
            }
        }

        void SamplingBar::update_view_status()
        {
            int bEnable = _session->is_working() == false;
            int mode = _session->get_device()->get_work_mode();

            _device_type.setEnabled(bEnable);
            _mode_button.setEnabled(bEnable);
            _configure_button.setEnabled(bEnable);
            _device_selector.setEnabled(bEnable);
            _action_loop->setVisible(false);

            if (_session->get_device()->is_file()) {
                _sample_rate.setEnabled(true);
                _sample_count.setEnabled(false);
            }
            else if (mode == DSO) {
                _sample_rate.setEnabled(true);
                _sample_count.setEnabled(bEnable);

                if (_session->is_working() && _session->is_instant() == false)
                {
                    _sample_count.setEnabled(true);
                }
            }
            else {
                _sample_rate.setEnabled(bEnable);
                _sample_count.setEnabled(bEnable);

                if (mode == LOGIC && _session->get_device()->is_hardware())
                {
                    int mode_val = 0;
                    if (_session->get_device()->get_config_int16(SR_CONF_OPERATION_MODE, mode_val)) {
                        if (mode_val == LO_OP_INTEST) {
                            _sample_rate.setEnabled(true);
                            _sample_count.setEnabled(false);
                        }
                    }
                }

                if (mode == LOGIC && _device_agent->is_file() == false) {
                    if (_device_agent->is_stream_mode() || _device_agent->is_demo())
                        _action_loop->setVisible(true);
                }
            }

            if (_session->is_working()) {
                if (_is_run_as_instant)
                    _run_stop_button.setEnabled(false);
                else
                    _instant_button.setEnabled(false);
            }
            else {
                _run_stop_button.setEnabled(true);
                _instant_button.setEnabled(true);
            }

            QString iconPath = AppConfig::GetIconPath();

            if (_is_run_as_instant)
                _instant_button.setIcon(!bEnable ? QIcon(iconPath + "/stop.svg") : QIcon(iconPath + "/single.svg"));
            else
                _run_stop_button.setIcon(!bEnable ? QIcon(iconPath + "/stop.svg") : QIcon(iconPath + "/start.svg"));

            retranslateUi();

            if (bEnable) {
                _is_run_as_instant = false;
            }

            update_mode_icon();

            if (_session->get_device()->is_demo() && bEnable)
            {
                QString opt_mode = _device_agent->get_demo_operation_mode();

                if (opt_mode != "random" && mode == LOGIC) {
                    _sample_rate.setEnabled(true);
                    _sample_count.setEnabled(false);
                }
            }
        }

        ds_device_handle SamplingBar::get_next_device_handle()
        {
            ds_device_handle h = _next_switch_device;
            _next_switch_device = NULL_HANDLE;
            return h;
        }

        void SamplingBar::update_mode_icon()
        {
            QString iconPath = AppConfig::GetIconPath();

            if (_session->is_repeat_mode())
                _mode_button.setIcon(QIcon(iconPath + REPEAT_ACTION_ICON));
            else if (_session->is_loop_mode())
                _mode_button.setIcon(QIcon(iconPath + LOOP_ACTION_ICON));
            else
                _mode_button.setIcon(QIcon(iconPath + SINGLE_ACTION_ICON));
        }


        void SamplingBar::run_or_stop()
        {
            on_run_stop();
        }

        void SamplingBar::run_or_stop_instant()
        {
            on_instant_stop();
        }

        void SamplingBar::update_font()
        {
            QFont font = this->font();
            font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
            ui::set_toolbar_font(this, font);
        }

    } // namespace toolbars
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_TOOLBARS_FILEBAR_H
#define DSVIEW_PV_TOOLBARS_FILEBAR_H

#include <QToolBar>
#include <QToolButton>
#include <QAction>
#include <QMenu>
#include "../interface/icallbacks.h"

namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
}
using namespace dsv::appcore;

namespace dsv {
namespace toolbars {

//toolbar button,referenced by MainWindow
//TODO: load session file, sorte session, load log data file, sorte data, export data
class FileBar : public QToolBar, public IFontForm
{
    Q_OBJECT

public:
    explicit FileBar(SigSession *session, QWidget *parent = 0);

    void update_view_status();

    QString genDefaultSessionFile();

private:
    void changeEvent(QEvent *event);
    void retranslateUi();
    void reStyle(); 

    //IFontForm
    void update_font() override;

signals:
    void sig_load_file(QString); 
    void sig_save();
    void sig_export();
    void sig_screenShot(); //post screen capture event message
    void sig_load_session(QString); //post load session event message
    void sig_store_session(QString); //post store session event message

private slots:
    void on_actionLoad_triggered();
    void on_actionStore_triggered();
    void on_actionDefault_triggered();
    void on_actionOpen_triggered();
    void on_actionCapture_triggered();

private:
    SigSession* _session;

    QToolButton _file_button;
    QMenu   *_menu;
    QMenu   *_menu_session; //when the hardware device is connected,it will be enable
    QAction *_action_load;
    QAction *_action_store;
    QAction *_action_default;
    QAction *_action_open;
    QAction *_action_save;
    QAction *_action_export;
    QAction *_action_capture;
};

} // namespace toolbars
} // namespace dsv

#endif // DSVIEW_PV_TOOLBARS_FILEBAR_H
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2014 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_DATA_DECODERSTACK_H
#define DSVIEW_PV_DATA_DECODERSTACK_H

#include <libsigrokdecode.h>
#include <list>
#include <boost/optional.hpp>
#include <QObject>
#include <QString>
#include <mutex> 
#include "../decode/row.h" 
#include "signaldata.h"
#include "../decode/decoderstatus.h"

namespace dsv{
    namespace decode {
        class Annotation;
        class Decoder;
        class RowData;
    }
    namespace appcore {
        class SigSession;
    }
    namespace view {
        class LogicSignal;
    }
}
using namespace dsv::appcore;
using namespace dsv::view;
using namespace dsv::decode;
 
namespace dsv {
namespace data {

class LogicSnapshot;
class DecoderStack;

struct decode_task_status
{  
    volatile bool _bStop;
    DecoderStack *_decoder;
};

 //a torotocol have a DecoderStack, destroy by DecodeTrace
class DecoderStack : public QObject, public SignalData
{
	Q_OBJECT

private:
	static const double DecodeMargin;
	static const double DecodeThreshold;
	static const int64_t DecodeChunkLength;
	static const unsigned int DecodeNotifyPeriod;
    static const uint64_t MaxChunkSize = 1024 * 16;

public:
    enum decode_state {
        Stopped,
        Running
    };

public:
   	DecoderStack(SigSession *_session,
		const srd_decoder *const decoder, DecoderStatus *decoder_status);

public:

	virtual ~DecoderStack();

    inline std::list<decode::Decoder*>& stack(){
        return _stack;
    }

    const char* get_root_decoder_id();

	void add_sub_decoder(decode::Decoder *decoder);
    void remove_sub_decoder(decode::Decoder *decoder);
    void remove_decoder_by_handel(const srd_decoder *dec);
    
    void build_row();

	int64_t samples_decoded();

	/**
	 * Extracts sorted annotations between two period into a vector.
	 */
	void get_annotation_subset(
		std::vector<dsv::decode::Annotation*> &dest,
		const decode::Row &row, uint64_t start_sample,
		uint64_t end_sample);

    uint64_t get_annotation_index(
        const decode::Row &row, uint64_t start_sample);
    uint64_t get_max_annotation(const decode::Row &row);
    uint64_t get_min_annotation(const decode::Row &row); // except instant(end=start) annotation

    std::map<const decode::Row, bool> get_rows_gshow();
    std::map<const decode::Row, bool> get_rows_lshow();
    void set_rows_gshow(const decode::Row row, bool show);
    void set_rows_lshow(const decode::Row row, bool show);
    bool has_annotations(const decode::Row &row);
    uint64_t list_annotation_size();
    uint64_t list_annotation_size(uint16_t row_index);


    bool list_annotation(decode::Annotation &ann,
                        uint16_t row_index, uint64_t col_index);


    bool list_row_title(int row, QString &title);
	 
	void clear();
    void init();
	uint64_t get_max_sample_count();

    inline bool IsRunning(){
        return _decode_state == Running;
    }
 
	void begin_decode_work();
    
    void stop_decode_work();  
    int list_rows_size();
    bool options_changed();
    void set_options_changed(bool changed);

    uint64_t sample_count();
    uint64_t sample_rate();
    bool out_of_memory();
    void set_mark_index(int64_t index);
    int64_t get_mark_index();
    void frame_ended();

    inline QString error_message(){ 
	    return _error_message;
    }

    inline void *get_key_handel(){
        return _decoder_status;
    }

    inline bool is_capture_end(){
        return _is_capture_end;
    }

    inline void set_capture_end_flag(bool isEnd){
        _is_capture_end = isEnd;
        if (!isEnd){
            _progress = 0;
            _is_decoding = false;
        }
    }

    inline int get_progress(){
        //if (!_is_decoding && _progress == 0)
          //  return -1;
        return _progress;
    }

private:
    void decode_data(const uint64_t decode_start, const uint64_t decode_end, srd_session *const session);
	void execute_decode_stack();
	static void annotation_callback(srd_proto_data *pdata, void *self);
    void do_decode_work();
  
signals:
	void new_decode_data();
    void decode_done();
  
private: 
	std::list<decode::Decoder*> _stack;
	dsv::data::LogicSnapshot *_snapshot;
  
    std::map<const decode::Row, decode::RowData*>   _rows;
    std::map<const decode::Row, bool>       _rows_gshow;
    std::map<const decode::Row, bool>       _rows_lshow;
    std::map<std::pair<const srd_decoder*, int>, decode::Row> _class_rows;
  
    SigSession      *_session;
    decode_state    _decode_state;
    volatile bool   _options_changed;
    volatile bool   _no_memory;
    int64_t         _mark_index;

    DecoderStatus   *_decoder_status;
    QString         _error_message;
    int64_t	        _samples_decoded;
    uint64_t        _sample_count; 
 
    decode_task_status  *_stask_stauts;    
    mutable std::mutex _output_mutex; 
    bool            _is_capture_end;
    int             _progress;
    bool            _is_decoding;
};

} // namespace data
} // namespace dsv

#endif // DSVIEW_PV_DATA_DECODERSTACK_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_DATA_DECODERMODEL_H
#define DSVIEW_PV_DATA_DECODERMODEL_H

#include <QAbstractTableModel>
  
#include "../decode/rowdata.h"

namespace dsv {

namespace decode {
    class Annotation;
    class Decoder;
    class Row;
}

namespace data {

class DecoderStack;

class DecoderModel : public QAbstractTableModel
{
public:
    DecoderModel(QObject *parent = 0);

    int rowCount(const QModelIndex & /*parent*/) const;
    int columnCount(const QModelIndex & /*parent*/) const;
    QVariant data(const QModelIndex &index, int role) const;
    QVariant headerData(int section, Qt::Orientation orientation,int role) const;

    void setDecoderStack(DecoderStack *decoder_stack);

    inline  DecoderStack* getDecoderStack(){
        return _decoder_stack;
    }

private:
    DecoderStack   *_decoder_stack;
};

} // namespace data
} // namespace dsv

#endif // DSVIEW_PV_DATA_DECODERMODEL_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_DATA_ANALOGSNAPSHOT_H
#define DSVIEW_PV_DATA_ANALOGSNAPSHOT_H

#include <libsigrok.h>
#include <utility>
#include <vector>
#include "snapshot.h"

namespace dsv {
namespace data {

class AnalogSnapshot : public Snapshot
{
public:
	struct EnvelopeSample
	{
        uint8_t min;
        uint8_t max;
	};

	struct EnvelopeSection
	{
		uint64_t start;
		unsigned int scale;
		uint64_t length;
        uint64_t samples_num;
		EnvelopeSample *samples;
	};

private:
	struct Envelope
	{
		uint64_t length;
        uint64_t ring_length;
        uint64_t count;
		uint64_t data_length;
		EnvelopeSample *samples;
        uint8_t *max;
        uint8_t *min;
	};

private:
	static const unsigned int ScaleStepCount = 10;
	static const int EnvelopeScalePower;
	static const int EnvelopeScaleFactor;
	static const float LogEnvelopeScaleFactor;
	static const uint64_t EnvelopeDataUnit;

    static const uint64_t LeafBlockPower = 21;
    static const uint64_t LeafBlockSamples = 1 << LeafBlockPower;
    static const uint64_t LeafMask = ~(~0ULL << LeafBlockPower);

private:
    void init_all();

public:
    AnalogSnapshot();

	virtual ~AnalogSnapshot();

    void clear();
    void init();

    void first_payload(const sr_datafeed_analog &analog,
                       uint64_t total_sample_count, GSList *channels);

	void append_payload(const sr_datafeed_analog &analog);

    const uint8_t *get_samples(int64_t start_sample);

    void get_envelope_section(EnvelopeSection &s,
        uint64_t start, int64_t count, float min_length, int probe_index);

    int get_ch_order(int sig_index);

    int get_scale_factor();

    bool has_data(int index);
    int get_block_num();
    uint64_t get_block_size(int block_index);

    void* get_data();

private:
    void append_data(void *data, uint64_t samples, uint16_t pitch);
    void free_envelop();
	void reallocate_envelope(Envelope &l);
	void append_payload_to_envelope_levels();
    void free_data();

private:
    void *_data;
    struct Envelope _envelope_levels[DS_MAX_ANALOG_PROBES_NUM][ScaleStepCount];  
};

} // namespace data
} // namespace dsv

#endif // DSVIEW_PV_DATA_ANALOGSNAPSHOT_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "dsosnapshot.h"
#include <assert.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <algorithm>
#include "../basedef.h"
#include "../log.h"

using namespace std;

namespace dsv {
namespace data {

const int DsoSnapshot::EnvelopeScalePower = 8;
const int DsoSnapshot::EnvelopeScaleFactor = 1 << EnvelopeScalePower;
const float DsoSnapshot::LogEnvelopeScaleFactor =
	logf(EnvelopeScaleFactor);
const uint64_t DsoSnapshot::EnvelopeDataUnit = 4*1024;	// bytes

const int DsoSnapshot::VrmsScaleFactor = 1 << 8;

DsoSnapshot::DsoSnapshot() :
    Snapshot(sizeof(uint16_t), 1, 1)
{   
    _envelope_en = false;
    _envelope_done = false;
    _instant = false;
    _threshold = 0;
    _measure_voltage_factor1 = 0;
    _measure_voltage_factor2 = 0;
    _is_file = false;

	memset(_envelope_levels, 0, sizeof(_envelope_levels));
}

DsoSnapshot::~DsoSnapshot()
{
    free_envelop();
}

void DsoSnapshot::free_envelop()
{
    for (unsigned int i = 0; i < _channel_num; i++) {
        for(auto &e : _envelope_levels[i]) {
            if (e.samples)
                free(e.samples);
        }
    }
    memset(_envelope_levels, 0, sizeof(_envelope_levels));
}

void DsoSnapshot::init()
{
    std::lock_guard<std::mutex> lock(_mutex);
    init_all();    
}

void DsoSnapshot::init_all()
{
    _sample_count = 0;
    _ring_sample_count = 0;
    _memory_failed = false;
    _last_ended = true;
    _envelope_done = false;   
    _is_file = false; 

    for (unsigned int i = 0; i < _channel_num; i++) {
        for (unsigned int level = 0; level < ScaleStepCount; level++) {
            _envelope_levels[i][level].length = 0;
            _envelope_levels[i][level].data_length = 0;
        }
    }
}

void DsoSnapshot::clear()
{
    std::lock_guard<std::mutex> lock(_mutex);
    free_data();
    free_envelop();
    init_all();
    _envelope_en = false;
}

void DsoSnapshot::free_data()
{
    Snapshot::free_data();

    for (int i=0; i<(int)_ch_data.size(); i++)
    {
        void *p = _ch_data[i];
        free(p);
    }

    _ch_data.clear();
}

void DsoSnapshot::first_payload(const sr_datafeed_dso &dso, uint64_t total_sample_count,
                                GSList *channels, bool instant, bool isFile)
{
    assert(channels);  

    bool channel_changed = false;
    uint16_t channel_num = 0;
    _is_file = isFile;

    for (const GSList *l = channels; l; l = l->next) {
        sr_channel *const probe = (sr_channel*)l->data;

        if (probe->type == SR_CHANNEL_DSO) {
            if (probe->enabled || isFile){
                channel_num++;
                if (!channel_changed){
                    channel_changed = !has_data(probe->index);
                }
            } 
        }
    }

    assert(channel_num != 0);

    _instant = instant;
    bool isOk = true;

    if (total_sample_count != _total_sample_count
        || channel_num != _channel_num
        || channel_changed
        || isFile){
        
        std::lock_guard<std::mutex> lock(_mutex);

        free_data();

        _ch_index.clear();
        _total_sample_count = total_sample_count;
        _channel_num = channel_num; 

         for (const GSList *l = channels; l; l = l->next) {
            sr_channel *const probe = (sr_channel*)l->data;

            if (probe->type == SR_CHANNEL_DSO && (probe->enabled || isFile)) {
                
                uint8_t *chan_buffer = (uint8_t*)malloc(total_sample_count + 1);
                if (chan_buffer == NULL){
                    isOk = false;
                    dsv_err("DsoSnapshot::first_payload, Malloc memory failed!");
                    break;
                }
                _ch_data.push_back(chan_buffer);
                _ch_index.push_back(probe->index);
            }
        }
        
        if (isOk) {
            free_envelop();

            for (unsigned int i = 0; i < _channel_num; i++) {
                uint64_t envelop_count = _total_sample_count / EnvelopeScaleFactor;

                for (unsigned int level = 0; level < ScaleStepCount; level++) {
                    
                    envelop_count = ((envelop_count + EnvelopeDataUnit - 1) / EnvelopeDataUnit) 
                                        * EnvelopeDataUnit;

                    uint64_t buffer_len = envelop_count * sizeof(EnvelopeSample);
                    _envelope_levels[i][level].samples = (EnvelopeSample*)malloc(buffer_len);
                    
                    if (_envelope_levels[i][level].samples == NULL) {
                        dsv_err("DsoSnapshot::first_payload, malloc failed!");
                        isOk = false;
                        break;
                    }
                    
                    envelop_count = envelop_count / EnvelopeScaleFactor;
                }
                if (!isOk)
                    break;
            }
        }
    }

    if (isOk) {
        _memory_failed = false;
        append_payload(dso);
        _last_ended = false;
    }
    else {
        std::lock_guard<std::mutex> lock(_mutex);
        free_data();
        free_envelop();
        _memory_failed = true;
    }
}

void DsoSnapshot::append_payload(const sr_datafeed_dso &dso)
{
    std::lock_guard<std::mutex> lock(_mutex);

    if (_channel_num > 0 && dso.num_samples > 0) {       
        append_data(dso.data, dso.num_samples, _instant);

        // Generate the first mip-map from the data
        if (_envelope_en)
            append_payload_to_envelope_levels(dso.samplerate_tog);
    }
}

void DsoSnapshot::append_data(void *data, uint64_t samples, bool instant)
{
    uint64_t old_sample_count = _sample_count;

    if (instant) { 
        if(_sample_count + samples > _total_sample_count)
            samples = _total_sample_count - _sample_count;
        _sample_count += samples;
    }
    else {
        _sample_count = samples;
    }

    assert(_sample_count <= _total_sample_count);
     
    for (unsigned int ch = 0; ch < _channel_num; ch++)
    {
        uint8_t *src = (uint8_t*)data + ch;
        uint8_t *dest = _ch_data[ch];

        if (instant){
            dest += old_sample_count;
        }

        for (uint64_t i = 0; i < samples; i++)
        {
            *dest++ = *src;
            src += _channel_num;
        }  
    }
}

void DsoSnapshot::enable_envelope(bool enable)
{
    std::lock_guard<std::mutex> lock(_mutex);
    if (!_envelope_done && enable)
        append_payload_to_envelope_levels(true);
    _envelope_en = enable;
}

const uint8_t *DsoSnapshot::get_samples(int64_t start_sample, int64_t end_sample, uint16_t ch_index)
{
    std::lock_guard<std::mutex> lock(_mutex);

	assert(start_sample >= 0);
    assert(start_sample < (int64_t)_sample_count);
	assert(end_sample >= 0);
    assert(end_sample < (int64_t)_sample_count);
	assert(start_sample <= end_sample);

    int order = get_ch_order(ch_index);

    if (order == -1){
        dsv_err("The channel index is not exist:%d", ch_index);
        assert(false);
    } 

    return (uint8_t*)_ch_data[order] + start_sample;
}

void DsoSnapshot::get_envelope_section(EnvelopeSection &s,
    uint64_t start, uint64_t end, float min_length, int probe_index)
{
	assert(end <= get_sample_count());
	assert(start <= end);
	assert(min_length > 0);

    if (!_envelope_done) {
        s.length = 0;
        return;
    }

	const unsigned int min_level = max((int)floorf(logf(min_length) /
		LogEnvelopeScaleFactor) - 1, 0);
	const unsigned int scale_power = (min_level + 1) *
		EnvelopeScalePower;
	start >>= scale_power;
	end >>= scale_power;

	s.start = start << scale_power;
	s.scale = 1 << scale_power;
    if (_envelope_levels[probe_index][min_level].length == 0)
        s.length = 0;
    else
        s.length = end - start;

    s.samples = _envelope_levels[probe_index][min_level].samples + start;
}

void DsoSnapshot::reallocate_envelope(Envelope &e)
{
	const uint64_t new_data_length = ((e.length + EnvelopeDataUnit - 1) /
		EnvelopeDataUnit) * EnvelopeDataUnit;
    if (new_data_length > e.data_length)
	{
		e.data_length = new_data_length;
	}
}

void DsoSnapshot::append_payload_to_envelope_levels(bool header)
{
    for (unsigned int i = 0; i < _channel_num; i++) {
        Envelope &e0 = _envelope_levels[i][0];
        uint64_t prev_length;
        EnvelopeSample *dest_ptr;

        if (header)
            prev_length = 0;
        else
            prev_length = e0.length;
        e0.length = _sample_count / EnvelopeScaleFactor;

        if (e0.length == 0)
            return;
        if (e0.length == prev_length)
            prev_length = 0;

        // Expand the data buffer to fit the new samples
        reallocate_envelope(e0);

        assert(e0.samples);

        dest_ptr = e0.samples + prev_length;

        // Iterate through the samples to populate the first level mipmap
        const uint8_t *const stop_src_ptr = (uint8_t*)_ch_data[i] + e0.length * EnvelopeScaleFactor;
        const uint8_t *src_ptr = (uint8_t*)_ch_data[i] + prev_length * EnvelopeScaleFactor;

        for (; src_ptr < stop_src_ptr; src_ptr += EnvelopeScaleFactor)
        {
            const uint8_t *begin_src_ptr = src_ptr;
            const uint8_t *const end_src_ptr = src_ptr + EnvelopeScaleFactor;

            EnvelopeSample sub_sample;
            sub_sample.min = *begin_src_ptr;
            sub_sample.max = *begin_src_ptr;

            while (begin_src_ptr < end_src_ptr)
            {
                sub_sample.min = ds_min(sub_sample.min, *begin_src_ptr);
                sub_sample.max = ds_max(sub_sample.max, *begin_src_ptr);
                begin_src_ptr++;
            }
            
            *dest_ptr++ = sub_sample;
        }

        // Compute higher level mipmaps
        for (unsigned int level = 1; level < ScaleStepCount; level++)
        {
            Envelope &e = _envelope_levels[i][level];
            const Envelope &el = _envelope_levels[i][level-1];

            // Expand the data buffer to fit the new samples
            if (header)
                prev_length = 0;
            else
                prev_length = e.length;
            e.length = el.length / EnvelopeScaleFactor;

            // Break off if there are no more samples to computed
            if (e.length == 0)
                break;
            if (e.length == prev_length)
                prev_length = 0;

            reallocate_envelope(e);

            // Subsample the level lower level
            const EnvelopeSample *src_ptr =
                el.samples + prev_length * EnvelopeScaleFactor;
            const EnvelopeSample *const end_dest_ptr = e.samples + e.length;

            for (dest_ptr = e.samples + prev_length;
                dest_ptr < end_dest_ptr; dest_ptr++)
            {
                const EnvelopeSample *const end_src_ptr =
                    src_ptr + EnvelopeScaleFactor;

                EnvelopeSample sub_sample = *src_ptr++;
                while (src_ptr < end_src_ptr)
                {
                    sub_sample.min = min(sub_sample.min, src_ptr->min);
                    sub_sample.max = max(sub_sample.max, src_ptr->max);
                    src_ptr++;
                }

                *dest_ptr = sub_sample;
            }
        }
    }
    _envelope_done = true;
}

double DsoSnapshot::cal_vrms(double zero_off, int index)
{
    assert(index >= 0);

    // root-meam-squart value
    double vrms_pre = 0;
    double vrms = 0;
    double tmp;

    // Iterate through the samples to populate the first level mipmap
    const uint8_t *const stop_src_ptr = (uint8_t*)_ch_data[index] + _sample_count;
    const uint8_t *src_ptr = (uint8_t*)_ch_data[index];

    for (;src_ptr < stop_src_ptr; src_ptr += VrmsScaleFactor)
    {
        const uint8_t * begin_src_ptr = src_ptr;
        const uint8_t *const end_src_ptr = src_ptr + VrmsScaleFactor;

        while (begin_src_ptr < end_src_ptr)
        {
            tmp = (zero_off - *begin_src_ptr);
            vrms += tmp * tmp;
            begin_src_ptr++;
        }
        vrms = vrms_pre + vrms / _sample_count;
        vrms_pre = vrms;
    }
    vrms = pow(vrms, 0.5);

    return vrms;
}

double DsoSnapshot::cal_vmean(int index)
{
    assert(index >= 0);

    // mean value
    double vmean_pre = 0;
    double vmean = 0;

    // Iterate through the samples to populate the first level mipmap
    const uint8_t *const stop_src_ptr = (uint8_t*)_ch_data[index] + _sample_count;
    const uint8_t *src_ptr = (uint8_t*)_ch_data[index];

    for (; src_ptr < stop_src_ptr; src_ptr += VrmsScaleFactor)
    {
        const uint8_t * begin_src_ptr = src_ptr;
        const uint8_t *const end_src_ptr = src_ptr + VrmsScaleFactor;

        while (begin_src_ptr < end_src_ptr)
        {
            vmean += *begin_src_ptr;
            begin_src_ptr += _channel_num;
        }
        vmean = vmean_pre + vmean / _sample_count;
        vmean_pre = vmean;
    }

    return vmean;
}

int DsoSnapshot::get_block_num()
{
    const uint64_t size = _sample_count * get_unit_bytes() * get_channel_num();
    return (size >> LeafBlockPower) +
           ((size & LeafMask) != 0);
}

uint64_t DsoSnapshot::get_block_size(int block_index)
{
    assert(block_index < get_block_num());

    if (block_index < get_block_num() - 1) {
        return LeafBlockSamples;
    } else {
        const uint64_t size = _sample_count * get_unit_bytes() * get_channel_num();
        if (size % LeafBlockSamples == 0)
            return LeafBlockSamples;
        else
            return size % LeafBlockSamples;
    }
}

bool DsoSnapshot::get_max_min_value(uint8_t &maxv, uint8_t &minv, int chan_index)
{
    std::lock_guard<std::mutex> lock(_mutex);

    if (_sample_count == 0){
        return false;
    }

    if (chan_index < 0 || chan_index >= (int)_ch_data.size()){
        assert(false);
    }

    uint8_t *p = _ch_data[chan_index];
    maxv = *p;
    minv = *p;

    for (uint64_t i=1; i<_sample_count; i++){
        p++;
        if (*p > maxv)
            maxv = *p;
        if (*p < minv)
            minv = *p;
    }
    
    return true;
}

bool DsoSnapshot::has_data(int sig_index)
{
    return get_ch_order(sig_index) != -1;
}

int DsoSnapshot::get_ch_order(int sig_index)
{
    uint16_t order = 0;

    for (uint16_t i : _ch_index) {
        if (i == sig_index)
            return order;
        else
            order++;
    }

    return -1;
}

} // namespace data
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "analogsnapshot.h"
#include <assert.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <algorithm>
#include "../basedef.h"

using namespace std;

namespace dsv {
namespace data {

const int AnalogSnapshot::EnvelopeScalePower = 4;
const int AnalogSnapshot::EnvelopeScaleFactor = 1 << EnvelopeScalePower;
const float AnalogSnapshot::LogEnvelopeScaleFactor =
	logf(EnvelopeScaleFactor);
const uint64_t AnalogSnapshot::EnvelopeDataUnit = 64*1024;	// bytes

AnalogSnapshot::AnalogSnapshot() :
    Snapshot(sizeof(uint16_t), 1, 1)
{
	memset(_envelope_levels, 0, sizeof(_envelope_levels));
    _unit_pitch = 0;
    _data  = NULL;
}

AnalogSnapshot::~AnalogSnapshot()
{
    free_envelop();
}

void AnalogSnapshot::free_envelop()
{
    for (unsigned int i = 0; i < _channel_num; i++) {
        for(auto &e : _envelope_levels[i]) {
            if (e.samples)
                free(e.samples);
        }
    }
    memset(_envelope_levels, 0, sizeof(_envelope_levels));
}

void AnalogSnapshot::init()
{
    std::lock_guard<std::mutex> lock(_mutex);
    init_all();
}

void AnalogSnapshot::init_all()
{
    _sample_count = 0;
    _ring_sample_count = 0;
    _memory_failed = false;
    _last_ended = true;

    for (unsigned int i = 0; i < _channel_num; i++) {
        for (unsigned int level = 0; level < ScaleStepCount; level++) {
            _envelope_levels[i][level].length = 0;
            _envelope_levels[i][level].ring_length = 0;
            // fix hang issue, count should not be clear
            //_envelope_levels[i][level].count = 0;
            _envelope_levels[i][level].data_length = 0;
        }
    }
}

void AnalogSnapshot::free_data()
{
    Snapshot::free_data();

    if (_data != NULL){
        free(_data);
        _data = NULL;
    }
}

void AnalogSnapshot::clear()
{
    std::lock_guard<std::mutex> lock(_mutex);
    free_data();
    free_envelop();
    init_all();
}

void AnalogSnapshot::first_payload(const sr_datafeed_analog &analog, uint64_t total_sample_count, GSList *channels)
{
    _total_sample_count = total_sample_count;
    _unit_bytes = (analog.unit_bits + 7) / 8;
    assert(_unit_bytes > 0);
    assert(_unit_bytes <= sizeof(uint64_t));
    _channel_num = 0;
    for (const GSList *l = channels; l; l = l->next) {
        sr_channel *const probe = (sr_channel*)l->data;
        assert(probe);
        // TODO: data of disabled channels should not be captured.
        if (probe->type == SR_CHANNEL_ANALOG) {
            _channel_num ++;
        }
    }

    bool isOk = true;
    uint64_t size = _total_sample_count * _channel_num * _unit_bytes + sizeof(uint64_t);
    if (size != _capacity) {
        free_data();
        _data = malloc(size);
        if (_data) {
            free_envelop();
            for (unsigned int i = 0; i < _channel_num; i++) {
                uint64_t envelop_count = _total_sample_count / EnvelopeScaleFactor;
                for (unsigned int level = 0; level < ScaleStepCount; level++) {
                    _envelope_levels[i][level].count = envelop_count;
                    if (envelop_count == 0)
                        break;
                    _envelope_levels[i][level].samples = (EnvelopeSample*)malloc(envelop_count * sizeof(EnvelopeSample));
                    if (!_envelope_levels[i][level].samples) {
                        isOk = false;
                        break;
                    }
                    envelop_count = envelop_count / EnvelopeScaleFactor;
                }
                if (!isOk)
                    break;
            }
        } else {
            isOk = true;
        }
    }

    if (isOk) {
        for (const GSList *l = channels; l; l = l->next) {
            sr_channel *const probe = (sr_channel*)l->data;
            assert(probe);
            // TODO: data of disabled channels should not be captured.
            if (probe->type == SR_CHANNEL_ANALOG) {
                _ch_index.push_back(probe->index);
            }
        }
        _capacity = size;
        _memory_failed = false;
        append_payload(analog);
        _last_ended = false;
    } else {
        free_data();
        free_envelop();
        _memory_failed = true;
    }
}

void AnalogSnapshot::append_payload(
	const sr_datafeed_analog &analog)
{
    std::lock_guard<std::mutex> lock(_mutex);
    append_data(analog.data, analog.num_samples, analog.unit_pitch);

	// Generate the first mip-map from the data
    if (analog.num_samples != 0) // guarantee new samples to compute
        append_payload_to_envelope_levels();
}

void AnalogSnapshot::append_data(void *data, uint64_t samples, uint16_t pitch)
{
    int bytes_per_sample = _unit_bytes * _channel_num;
    if (pitch <= 1) {
        if (_sample_count + samples < _total_sample_count)
            _sample_count += samples;
        else
            _sample_count = _total_sample_count;

        if (_ring_sample_count + samples >= _total_sample_count) {
            memcpy((uint8_t*)_data + _ring_sample_count * bytes_per_sample,
                data, (_total_sample_count - _ring_sample_count) * bytes_per_sample);
            data = (uint8_t*)data + (_total_sample_count - _ring_sample_count) * bytes_per_sample;
            _ring_sample_count = (samples + _ring_sample_count - _total_sample_count) % _total_sample_count;
            memcpy((uint8_t*)_data,
                data, _ring_sample_count * bytes_per_sample);
        } else {
            memcpy((uint8_t*)_data + _ring_sample_count * bytes_per_sample,
                data, samples * bytes_per_sample);
            _ring_sample_count += samples;
        }
    } else {
        while(samples--) {
            if (_unit_pitch == 0) {
                if (_sample_count < _total_sample_count)
                    _sample_count++;
                memcpy((uint8_t*)_data + _ring_sample_count * bytes_per_sample,
                    data, bytes_per_sample);
                data = (uint8_t*)data + bytes_per_sample*pitch;
                _ring_sample_count = (_ring_sample_count + 1) % _total_sample_count;
                _unit_pitch = pitch;
            }
            _unit_pitch--;
        }
    }
}

const uint8_t* AnalogSnapshot::get_samples(int64_t start_sample)
{
	assert(start_sample >= 0);
    assert(start_sample < (int64_t)get_sample_count());

    return (uint8_t*)_data + start_sample * _unit_bytes * _channel_num;
}

void AnalogSnapshot::get_envelope_section(EnvelopeSection &s,
    uint64_t start, int64_t count, float min_length, int probe_index)
{
    assert(count >= 0);
	assert(min_length > 0);

    const unsigned int min_level = max((int)floorf(logf(min_length) /
            LogEnvelopeScaleFactor) - 1, 0);
    const unsigned int scale_power = (min_level + 1) * EnvelopeScalePower;
	start >>= scale_power;

    s.start = start;
    s.scale = (1 << scale_power);
    s.length = (count >> scale_power);
    s.samples_num = _envelope_levels[probe_index][min_level].length;
    s.samples = _envelope_levels[probe_index][min_level].samples;
}

void AnalogSnapshot::reallocate_envelope(Envelope &e)
{
	const uint64_t new_data_length = ((e.length + EnvelopeDataUnit - 1) /
		EnvelopeDataUnit) * EnvelopeDataUnit;
    if (new_data_length > e.data_length)
	{
		e.data_length = new_data_length;
	}
}

void AnalogSnapshot::append_payload_to_envelope_levels()
{
    int i;
    for (i = 0; i < (int)_channel_num; i++) {
        Envelope &e0 = _envelope_levels[i][0];
        uint64_t prev_length;
        EnvelopeSample *dest_ptr;

        // Expand the data buffer to fit the new samples
        e0.length = _sample_count / EnvelopeScaleFactor;
        prev_length = e0.ring_length;
        e0.ring_length = _ring_sample_count / EnvelopeScaleFactor;

        if (e0.length == 0)
            continue;

        //reallocate_envelope(e0);

        dest_ptr = e0.samples + prev_length;

        // Iterate through the samples to populate the first level mipmap
        const uint64_t src_size = _total_sample_count * _unit_bytes * _channel_num;
        uint64_t e0_sample_num = (e0.ring_length > prev_length) ? e0.ring_length - prev_length :
                                                                  e0.ring_length + (_total_sample_count / EnvelopeScaleFactor) - prev_length;
        uint8_t *src_ptr = (uint8_t*)_data +
                    (prev_length * EnvelopeScaleFactor * _channel_num + i) * _unit_bytes;
        for (uint64_t j = 0; j < e0_sample_num; j++) {
            const uint8_t *end_src_ptr =
                src_ptr + EnvelopeScaleFactor * _unit_bytes * _channel_num;
            if (end_src_ptr >= (uint8_t*)_data + src_size)
                end_src_ptr -= src_size;
            EnvelopeSample sub_sample;
            sub_sample.min = *src_ptr;
            sub_sample.max = *src_ptr;
            src_ptr += _channel_num * _unit_bytes;
            while(src_ptr != end_src_ptr) {
                sub_sample.min = min(sub_sample.min, *src_ptr);
                sub_sample.max = max(sub_sample.max, *src_ptr);
                src_ptr += _channel_num * _unit_bytes;
                if (src_ptr >= (uint8_t*)_data + src_size)
                    src_ptr -= src_size;
            }

            *dest_ptr++ = sub_sample;
            if (dest_ptr >= e0.samples + e0.count)
                dest_ptr = e0.samples;
        }

        // Compute higher level mipmaps
        for (unsigned int level = 1; level < ScaleStepCount; level++)
        {
            Envelope &e = _envelope_levels[i][level];
            const Envelope &el = _envelope_levels[i][level-1];

            // Expand the data buffer to fit the new samples
            e.length = el.length / EnvelopeScaleFactor;
            prev_length = e.ring_length;
            e.ring_length = el.ring_length / EnvelopeScaleFactor;

            // Break off if there are no more samples to computed
            if (e.ring_length == prev_length)
                break;

            //reallocate_envelope(e);

            // Subsample the level lower level
            const EnvelopeSample *src_ptr =
                el.samples + prev_length * EnvelopeScaleFactor;
            const EnvelopeSample *const end_dest_ptr = (e.ring_length == e.count) ? e.samples : e.samples + e.ring_length;
            dest_ptr = (prev_length == e.count) ? e.samples : e.samples + prev_length;
            while(dest_ptr != end_dest_ptr) {
                const EnvelopeSample * end_src_ptr =
                    src_ptr + EnvelopeScaleFactor;
                if (end_src_ptr >= el.samples + el.count)
                    end_src_ptr -= el.count;

                EnvelopeSample sub_sample = *src_ptr++;
                while (src_ptr != end_src_ptr)
                {
                    sub_sample.min = min(sub_sample.min, src_ptr->min);
                    sub_sample.max = max(sub_sample.max, src_ptr->max);
                    src_ptr++;
                    if (src_ptr >= el.samples + el.count)
                        src_ptr = el.samples;
                }

                *dest_ptr++ = sub_sample;
                if (dest_ptr >= e.samples + e.count)
                    dest_ptr = e.samples;
            }
        }
    }
}

int AnalogSnapshot::get_ch_order(int sig_index)
{
    uint16_t order = 0;
    for (auto& iter:_ch_index) {
        if (iter == sig_index)
            break;
        order++;
    }

    if (order >= _ch_index.size())
        return -1;
    else
        return order;
}

int AnalogSnapshot::get_scale_factor()
{
    return EnvelopeScaleFactor;
}

bool AnalogSnapshot::has_data(int index)
{
    for (auto& iter:_ch_index) {
        if (iter == index)
            return true;
    }
    return false;
}

int AnalogSnapshot::get_block_num()
{
    const uint64_t size = _sample_count * get_unit_bytes() * get_channel_num();
    return (size >> LeafBlockPower) +
           ((size & LeafMask) != 0);
}

uint64_t AnalogSnapshot::get_block_size(int block_index)
{
    assert(block_index < get_block_num());

    if (block_index < get_block_num() - 1) {
        return LeafBlockSamples;
    } else {
        const uint64_t size = _sample_count * get_unit_bytes() * get_channel_num();
        if (size % LeafBlockSamples == 0)
            return LeafBlockSamples;
        else
            return size % LeafBlockSamples;
    }
}

void* AnalogSnapshot::get_data(){
    return _data;
}

} // namespace data
} // namespace dsv
/****************************************************************************
** Meta object code from reading C++ file 'decoderstack.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "decoderstack.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'decoderstack.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdataSCOPEDecoderStackENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdataSCOPEDecoderStackENDCLASS = QtMocHelpers::stringData(
    "dsv::data::DecoderStack",
    "new_decode_data",
    "",
    "decode_done"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdataSCOPEDecoderStackENDCLASS_t {
    uint offsetsAndSizes[8];
    char stringdata0[24];
    char stringdata1[16];
    char stringdata2[1];
    char stringdata3[12];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdataSCOPEDecoderStackENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdataSCOPEDecoderStackENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdataSCOPEDecoderStackENDCLASS = {
    {
        QT_MOC_LITERAL(0, 23),  // "dsv::data::DecoderStack"
        QT_MOC_LITERAL(24, 15),  // "new_decode_data"
        QT_MOC_LITERAL(40, 0),  // ""
        QT_MOC_LITERAL(41, 11)   // "decode_done"
    },
    "dsv::data::DecoderStack",
    "new_decode_data",
    "",
    "decode_done"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdataSCOPEDecoderStackENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       2,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       2,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   26,    2, 0x06,    1 /* Public */,
       3,    0,   27,    2, 0x06,    2 /* Public */,

 // signals: parameters
    QMetaType::Void,
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::data::DecoderStack::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdataSCOPEDecoderStackENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdataSCOPEDecoderStackENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdataSCOPEDecoderStackENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<DecoderStack, std::true_type>,
        // method 'new_decode_data'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'decode_done'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::data::DecoderStack::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<DecoderStack *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->new_decode_data(); break;
        case 1: _t->decode_done(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (DecoderStack::*)();
            if (_t _q_method = &DecoderStack::new_decode_data; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (DecoderStack::*)();
            if (_t _q_method = &DecoderStack::decode_done; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 1;
                return;
            }
        }
    }
    (void)_a;
}

const QMetaObject *dsv::data::DecoderStack::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::data::DecoderStack::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdataSCOPEDecoderStackENDCLASS.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "SignalData"))
        return static_cast< SignalData*>(this);
    return QObject::qt_metacast(_clname);
}

int dsv::data::DecoderStack::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 2)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 2;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 2)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 2;
    }
    return _id;
}

// SIGNAL 0
void dsv::data::DecoderStack::new_decode_data()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}

// SIGNAL 1
void dsv::data::DecoderStack::decode_done()
{
    QMetaObject::activate(this, &staticMetaObject, 1, nullptr);
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "logicsnapshot.h"
#include <assert.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include "../basedef.h"
#include "../log.h"
#include "../utility/array.h"

using namespace std;

namespace dsv {
namespace data {

const uint64_t LogicSnapshot::LevelMask[LogicSnapshot::ScaleLevel] = {
    ~(~0ULL << ScalePower) << 0 * ScalePower,
    ~(~0ULL << ScalePower) << 1 * ScalePower,
    ~(~0ULL << ScalePower) << 2 * ScalePower,
    ~(~0ULL << ScalePower) << 3 * ScalePower,
};
const uint64_t LogicSnapshot::LevelOffset[LogicSnapshot::ScaleLevel] = {
    0,
    (uint64_t)pow(Scale, 3),
    (uint64_t)pow(Scale, 3) + (uint64_t)pow(Scale, 2),
    (uint64_t)pow(Scale, 3) + (uint64_t)pow(Scale, 2) + (uint64_t)pow(Scale, 1),
};

LogicSnapshot::LogicSnapshot() :
    Snapshot(1, 0, 0)
{
    _channel_num = 0;
    _total_sample_count = 0;
    _is_loop = false;
    _loop_offset = 0;
    _able_free = true;
}

LogicSnapshot::~LogicSnapshot()
{
}

void LogicSnapshot::free_data()
{
    Snapshot::free_data();

    for(auto& iter : _ch_data) {
        for(auto& iter_rn : iter) {
            for (unsigned int k = 0; k < Scale; k++){
                if (iter_rn.lbp[k] != NULL)
                    free(iter_rn.lbp[k]);
            }
        }
        std::vector<struct RootNode> void_vector;
        iter.swap(void_vector);
    }
    _ch_data.clear();
    _sample_count = 0;

    for(void *p : _free_block_list){
        free(p);
    }
    _free_block_list.clear();
}

void LogicSnapshot::init()
{
    std::lock_guard<std::mutex> lock(_mutex);
    init_all(); 
}

void LogicSnapshot::init_all()
{
    _sample_count = 0;
    _ring_sample_count = 0;
    _byte_fraction = 0;
    _ch_fraction = 0;
    _dest_ptr = NULL;
    _memory_failed = false;
    _last_ended = true;
    _loop_offset = 0;
    _able_free = true;
}

void LogicSnapshot::clear()
{
    std::lock_guard<std::mutex> lock(_mutex);
    free_data();
    init_all();
}

void LogicSnapshot::first_payload(const sr_datafeed_logic &logic, uint64_t total_sample_count, GSList *channels, bool able_free)
{
    bool channel_changed = false;
    uint16_t channel_num = 0;
    _able_free = able_free;
    _lst_free_block_index = 0;

    for(void *p : _free_block_list){
        free(p);
    }
    _free_block_list.clear();

    for (const GSList *l = channels; l; l = l->next) {
        sr_channel *const probe = (sr_channel*)l->data;
        if (probe->type == SR_CHANNEL_LOGIC && probe->enabled) {
            channel_num++;
            if (!channel_changed){
                channel_changed = !has_data(probe->index);
            }
        }
    }

    if (total_sample_count != _total_sample_count
        || channel_num != _channel_num
        || channel_changed
        || _is_loop) {

        free_data();
        _ch_index.clear();

        _total_sample_count = total_sample_count;
        _channel_num = channel_num;
        uint64_t rootnode_size = (_total_sample_count + RootNodeSamples - 1) / RootNodeSamples;

        if (_is_loop)
            rootnode_size++;

        for (const GSList *l = channels; l; l = l->next) {
            sr_channel *const probe = (sr_channel*)l->data;

            if (probe->type == SR_CHANNEL_LOGIC && probe->enabled) {
                std::vector<struct RootNode> root_vector;
                for (uint64_t j = 0; j < rootnode_size; j++) {
                    struct RootNode rn;
                    rn.tog = 0;
                    rn.first = 0;
                    rn.last = 0;
                    memset(rn.lbp, 0, sizeof(rn.lbp));
                    root_vector.push_back(rn);
                }
               
                _ch_data.push_back(root_vector);
                _ch_index.push_back(probe->index);
            }
        }
    }
    else {
        for(auto& iter : _ch_data) {
            for(auto& iter_rn : iter) {
                iter_rn.tog = 0;
                iter_rn.first = 0;
                iter_rn.last = 0;

                for (int j=0; j<64; j++){
                    if (iter_rn.lbp[j] != NULL)
                        memset(iter_rn.lbp[j], 0, LeafBlockSpace);
                }
            }
        }
    }

    assert(_channel_num < CHANNEL_MAX_COUNT);

    _sample_count = 0;
    _ring_sample_count = 0;

    for (unsigned int i = 0; i < _channel_num; i++) {
        _last_sample[i] = 0;
        _last_calc_count[i] = 0;
        _cur_ref_block_indexs[i].root_index = 0;
        _cur_ref_block_indexs[i].lbp_index = 0;
    }

    append_payload(logic);
    _last_ended = false;
}

void LogicSnapshot::append_payload(const sr_datafeed_logic &logic)
{
    std::lock_guard<std::mutex> lock(_mutex);

    append_cross_payload(logic);
}

void LogicSnapshot::append_cross_payload(const sr_datafeed_logic &logic)
{
    assert(logic.format == LA_CROSS_DATA);
    assert(logic.length >= ScaleSize * _channel_num);
    assert(logic.data);

    uint8_t *data_src_ptr = (uint8_t*)logic.data;
    uint64_t len = logic.length;
    uint64_t index0 = 0;
    uint64_t index1 = 0;
    uint64_t offset = 0;
    void *lbp = NULL;

    // samples not accurate, lead to a larger _sampole_count
    // _sample_count should be fixed in the last packet
    // so _total_sample_count must be align to LeafBlock
    uint64_t samples = ceil(logic.length * 8.0 / _channel_num);

    if (_sample_count + samples < _total_sample_count){
        _sample_count += samples;
    }
    else{
        if (_sample_count == _total_sample_count && !_is_loop)
            return;
        _sample_count = _total_sample_count;
    }

    if (_is_loop)
    {
        if (_loop_offset + samples >= LeafBlockSamples * Scale){        
            move_first_node_to_last();
            _loop_offset -= LeafBlockSamples * Scale;
            _lst_free_block_index = 0;
        }
        else{
            int free_count = _loop_offset / LeafBlockSamples;
            if (free_count > _lst_free_block_index){
                free_head_blocks(free_count);
            }
        }
    }
 
    _ring_sample_count += _loop_offset;
 
    // bit align
    while ((_ch_fraction != 0 || _byte_fraction != 0) && len > 0) 
    {
        if (_dest_ptr == NULL)
            assert(false);

        do{
            *_dest_ptr++ = *data_src_ptr++;
            _byte_fraction = (_byte_fraction + 1) % 8;
            len--; 
        }
        while (_byte_fraction != 0 && len > 0);

        if (_byte_fraction == 0) {
            index0 = _ring_sample_count / LeafBlockSamples / RootScale;
            index1 = (_ring_sample_count / LeafBlockSamples) % RootScale;
            offset = (_ring_sample_count % LeafBlockSamples) / 8;

            _ch_fraction = (_ch_fraction + 1) % _channel_num;

            lbp = _ch_data[_ch_fraction][index0].lbp[index1];
            if (lbp == NULL){
                lbp = malloc(LeafBlockSpace);
                if (lbp == NULL){
                    dsv_err("LogicSnapshot::append_cross_payload, Malloc memory failed!");
                    return;
                }
                _ch_data[_ch_fraction][index0].lbp[index1] = lbp;
                memset(lbp, 0, LeafBlockSpace);
            }

            _dest_ptr = (uint8_t*)lbp + offset;

            // To the last channel.
            if (_ch_fraction == 0){
                _ring_sample_count += Scale;

                if (_ring_sample_count % LeafBlockSamples == 0){
                    calc_mipmap(_channel_num - 1, index0, index1, LeafBlockSamples, true);
                }                                
                break;
            }                
        }
    } 

    // append data 
    assert(_ch_fraction == 0);
    assert(_byte_fraction == 0);
    assert(_ring_sample_count % Scale == 0);

    uint64_t align_sample_count = _ring_sample_count;
    uint64_t *read_ptr = (uint64_t*)data_src_ptr;
    void *end_read_ptr = (uint8_t*)data_src_ptr + len;
  
    uint64_t filled_sample = align_sample_count % LeafBlockSamples;
    uint64_t old_filled_sample = filled_sample;     
    uint64_t* chans_read_addr[CHANNEL_MAX_COUNT];
 
    for (unsigned int i = 0; i < _channel_num; i++){
        chans_read_addr[i] = (uint64_t*)data_src_ptr + i; 
    }
    
    uint16_t fill_chan = _ch_fraction;
    uint16_t last_chan = _ch_fraction;
    index0 =  align_sample_count / LeafBlockSamples / RootScale;
    index1 = (align_sample_count / LeafBlockSamples) % RootScale;
    offset =  align_sample_count % LeafBlockSamples;
    
    lbp = _ch_data[fill_chan][index0].lbp[index1];
    if (lbp == NULL){
        lbp = malloc(LeafBlockSpace);
        if (lbp == NULL){
            dsv_err("LogicSnapshot::append_cross_payload, Malloc memory failed!");
            return;
        }
        _ch_data[fill_chan][index0].lbp[index1] = lbp;
        memset(lbp, 0, LeafBlockSpace);
    }

    uint64_t *write_ptr = (uint64_t*)lbp + offset / Scale;

    while (len >= 8)
    {     
        *write_ptr++ = *read_ptr;
        read_ptr += _channel_num;
        len -= 8;
        filled_sample += Scale;

        last_chan++;
        if (last_chan == _channel_num){
            last_chan = 0;
        }
  
        if (filled_sample == LeafBlockSamples)
        {
            calc_mipmap(fill_chan, index0, index1, LeafBlockSamples, true);

            chans_read_addr[fill_chan] = read_ptr;
            fill_chan = (fill_chan + 1) % _channel_num;

            if (fill_chan == 0)
                align_sample_count += (filled_sample - old_filled_sample);

            index0 =  align_sample_count / LeafBlockSamples / RootScale;
            index1 = (align_sample_count / LeafBlockSamples) % RootScale;
            offset =  align_sample_count % LeafBlockSamples;
            filled_sample = align_sample_count % LeafBlockSamples;
            old_filled_sample = filled_sample;

            lbp = _ch_data[fill_chan][index0].lbp[index1];
            if (lbp == NULL){
                lbp = malloc(LeafBlockSpace);
                if (lbp == NULL){
                    dsv_err("LogicSnapshot::append_cross_payload, Malloc memory failed!");
                    return;
                }
                _ch_data[fill_chan][index0].lbp[index1] = lbp;
                memset(lbp, 0, LeafBlockSpace);
            }

            write_ptr = (uint64_t*)lbp + offset / Scale;
            read_ptr = chans_read_addr[fill_chan];
        } 
        else if (read_ptr >= end_read_ptr) 
        {  
            calc_mipmap(fill_chan, index0, index1, filled_sample, false);

            fill_chan = (fill_chan + 1) % _channel_num;    

            if (fill_chan == 0)
                align_sample_count += (filled_sample - old_filled_sample);

            index0 =  align_sample_count / LeafBlockSamples / RootScale;
            index1 = (align_sample_count / LeafBlockSamples) % RootScale;
            offset =  align_sample_count % LeafBlockSamples;
            filled_sample = align_sample_count % LeafBlockSamples;
            old_filled_sample = filled_sample;

            lbp = _ch_data[fill_chan][index0].lbp[index1];
            if (lbp == NULL){
                lbp = malloc(LeafBlockSpace);
                if (lbp == NULL){
                    dsv_err("LogicSnapshot::append_cross_payload, Malloc memory failed!");
                    return;
                }
                _ch_data[fill_chan][index0].lbp[index1] = lbp;
                memset(lbp, 0, LeafBlockSpace);
            }

            write_ptr = (uint64_t*)lbp + offset / Scale;   
            read_ptr = chans_read_addr[fill_chan];
        }
    }

    _ring_sample_count = align_sample_count;
    _ring_sample_count -= _loop_offset;

    if (align_sample_count > _total_sample_count){
        _loop_offset = align_sample_count - _total_sample_count;
        _ring_sample_count = _total_sample_count; 
    }

    _ch_fraction = last_chan;

    lbp = _ch_data[_ch_fraction][index0].lbp[index1];
    if (lbp == NULL){
        lbp = malloc(LeafBlockSpace);
        if (lbp == NULL){
            dsv_err("LogicSnapshot::append_cross_payload, Malloc memory failed!");
            return;
        }
        _ch_data[_ch_fraction][index0].lbp[index1] = lbp;
        memset(lbp, 0, LeafBlockSpace);
    }

    _dest_ptr = (uint8_t*)lbp + offset / 8;  
 
    if (len > 0){
        uint8_t *src_ptr = (uint8_t*)end_read_ptr - len;
        _byte_fraction += len;

        while (len > 0){
            *_dest_ptr++ = *src_ptr++;
            len--;
        }
    }   
}

void LogicSnapshot::capture_ended()
{
    std::lock_guard<std::mutex> lock(_mutex);

    Snapshot::capture_ended();  

    _sample_count = _ring_sample_count;
    _ring_sample_count += _loop_offset;
    
    uint64_t index0 = _ring_sample_count / LeafBlockSamples / RootScale;
    uint64_t index1 = (_ring_sample_count / LeafBlockSamples) % RootScale;
    uint64_t offset = (_ring_sample_count % LeafBlockSamples) / 8;

    _ring_sample_count -= _loop_offset;

    if (offset > 0)
    {
        for (unsigned int chan=0; chan<_channel_num; chan++)
        { 
            if (_ch_data[chan][index0].lbp[index1] == NULL){
                dsv_err("ERROR:LogicSnapshot::capture_ended(),buffer is null.");
                assert(false);
            }
            const uint64_t *end_ptr = (uint64_t*)_ch_data[chan][index0].lbp[index1] + (LeafBlockSamples / Scale);
            uint64_t *ptr = (uint64_t*)((uint8_t*)_ch_data[chan][index0].lbp[index1] + offset);

            while (ptr < end_ptr){
                *ptr++ = 0;
            }

            calc_mipmap(chan, index0, index1, offset * 8, true);
        }  
    }
}

void LogicSnapshot::calc_mipmap(unsigned int order, uint8_t index0, uint8_t index1, uint64_t samples, bool isEnd)
{
    void *lbp = _ch_data[order][index0].lbp[index1];
    void *level1_ptr = (uint8_t*)lbp + LeafBlockSamples / 8;
    void *level2_ptr = (uint8_t*)level1_ptr + LeafBlockSamples / Scale / 8;
    void *level3_ptr = (uint8_t*)level2_ptr + LeafBlockSamples / Scale / Scale / 8;

    // level 1
    uint64_t *src_ptr  = (uint64_t*)lbp;
    uint64_t *dest_ptr = (uint64_t*)level1_ptr;
    uint8_t offset = 0;
    uint64_t i = 0;
    uint64_t last_count  = _last_calc_count[order];

    if (last_count > 0){
        i        =  last_count / Scale;
        offset   =  i % Scale;
        src_ptr  += i;
        dest_ptr += i / Scale;
    }

    if (i == 0) {
        _last_sample[order] = (*src_ptr & LSB) ? ~0ULL : 0ULL;
    }

    for(; i < samples / Scale; i++)
    {
        if (_last_sample[order] ^ *src_ptr)
            *dest_ptr |= (1ULL << offset);

        _last_sample[order] = *src_ptr & MSB ? ~0ULL : 0ULL;
        src_ptr++;
        offset++;

        if (offset == Scale){
            offset = 0;
            dest_ptr++; 
        }
    }

    // level 2
    src_ptr  = (uint64_t*)level1_ptr;
    dest_ptr = (uint64_t*)level2_ptr;  
    offset = 0;
    i = 0;

    if (last_count > 0){
        i        =  last_count / Scale / Scale;
        offset   =  i % Scale;
        src_ptr  += i;
        dest_ptr += i / Scale;
    }

    for(; i < LeafBlockSamples / Scale / Scale; i++) 
    {
        if (*src_ptr)
            *dest_ptr |= (1ULL << offset);

        src_ptr++;
        offset++;

        if (offset == Scale){
            offset = 0;
            dest_ptr++; 
        }
    }

    // level 3
    src_ptr = (uint64_t*)level2_ptr;
    dest_ptr = (uint64_t*)level3_ptr; 

    for (i=0; i < Scale; i++)
    {
        if (*src_ptr)
            *dest_ptr |= (1ULL << i);
        src_ptr++;
    }  

    if ((*((uint64_t*)lbp) & LSB) != 0)
        _ch_data[order][index0].first |= 1ULL << index1;

    if ((*((uint64_t*)lbp + LeafBlockSamples / Scale - 1) & MSB) != 0)
        _ch_data[order][index0].last |= 1ULL << index1;

    if (*((uint64_t*)level3_ptr) != 0){
        _ch_data[order][index0].tog |= 1ULL << index1;
    }
    else if (isEnd){
        uint64_t ref_root = _cur_ref_block_indexs[order].root_index;
        uint64_t ref_lbp  = _cur_ref_block_indexs[order].lbp_index;

        if (_able_free || index0 > ref_root || (index0 == ref_root && index1 > ref_lbp))
            free(_ch_data[order][index0].lbp[index1]);
        else
            _free_block_list.push_back(_ch_data[order][index0].lbp[index1]);

        _ch_data[order][index0].lbp[index1] = NULL;
    }

    if (isEnd)
        _last_calc_count[order] = 0;
    else
        _last_calc_count[order] = samples;
} 

const uint8_t *LogicSnapshot::get_samples(uint64_t start_sample, uint64_t &end_sample, int sig_index, void **lbp)
{ 
    std::lock_guard<std::mutex> lock(_mutex);

    uint64_t sample_count = _ring_sample_count;

    assert(start_sample < sample_count);

    if (end_sample >= sample_count)
        end_sample = sample_count - 1;

    assert(end_sample <= sample_count);
    assert(start_sample <= end_sample);

    start_sample += _loop_offset;
    _ring_sample_count += _loop_offset;

    int order = get_ch_order(sig_index);
    uint64_t index0 = start_sample >> (LeafBlockPower + RootScalePower);
    uint64_t index1 = (start_sample & RootMask) >> LeafBlockPower;
    uint64_t offset = (start_sample & LeafMask) / 8;

    end_sample = (index0 << (LeafBlockPower + RootScalePower)) +
                 (index1 << LeafBlockPower) +
                 ~(~0ULL << LeafBlockPower);

    end_sample = min(end_sample + 1, sample_count);

    _ring_sample_count -= _loop_offset;

    if (order == -1 || _ch_data[order][index0].lbp[index1] == NULL)
        return NULL;
    else{
        if (lbp != NULL)
            *lbp = _ch_data[order][index0].lbp[index1];

        _cur_ref_block_indexs[order].root_index = index0;
        _cur_ref_block_indexs[order].lbp_index  = index1;
        
        return (uint8_t*)_ch_data[order][index0].lbp[index1] + offset;
    }
}

bool LogicSnapshot::get_sample(uint64_t index, int sig_index)
{
    std::lock_guard<std::mutex> lock(_mutex);
    return get_sample_unlock(index, sig_index);
}

bool LogicSnapshot::get_sample_unlock(uint64_t index, int sig_index)
{
    index += _loop_offset;
    _ring_sample_count += _loop_offset;

    bool flag = get_sample_self(index, sig_index);

    _ring_sample_count -= _loop_offset;
    return flag;
}

bool LogicSnapshot::get_sample_self(uint64_t index, int sig_index)
{
    int order = get_ch_order(sig_index);
    assert(order != -1);
    assert(_ch_data[order].size() != 0);

    if (index < _ring_sample_count) {
        uint64_t index_mask = 1ULL << (index & LevelMask[0]);
        uint64_t index0 = index >> (LeafBlockPower + RootScalePower);
        uint64_t index1 = (index & RootMask) >> LeafBlockPower;
        uint64_t root_pos_mask = 1ULL << index1;

        if ((_ch_data[order][index0].tog & root_pos_mask) == 0) {
            return (_ch_data[order][index0].first & root_pos_mask) != 0;
        }
        else {
            uint64_t *lbp = (uint64_t*)_ch_data[order][index0].lbp[index1];
            return *(lbp + ((index & LeafMask) >> ScalePower)) & index_mask;
        }
    }
    
    return false;
}

bool LogicSnapshot::get_display_edges(std::vector<std::pair<bool, bool> > &edges,
    std::vector<std::pair<uint16_t, bool> > &togs,
    uint64_t start, uint64_t end, uint16_t width, uint16_t max_togs,
    double pixels_offset, double min_length, uint16_t sig_index)
{
    if (!edges.empty())
        edges.clear();
    if (!togs.empty())
        togs.clear();

    std::lock_guard<std::mutex> lock(_mutex);

    if (_ring_sample_count == 0)
        return false;

    assert(end < _ring_sample_count);
    assert(start <= end);
    assert(min_length > 0);

    uint64_t index = start;
    bool last_sample;
    bool start_sample;

    // Get the initial state
    start_sample = last_sample = get_sample_unlock(index++, sig_index);
    togs.push_back(pair<uint16_t, bool>(0, last_sample));

    while(edges.size() < width) {
        // search next edge
        bool has_edge = get_nxt_edge_unlock(index, last_sample, end, 0, sig_index);

        // calc the edge position
        int64_t gap = (index / min_length) - pixels_offset;
        index = max((uint64_t)ceil((floor(index/min_length) + 1) * min_length), index + 1);

        while(gap > (int64_t)edges.size() && edges.size() < width){
            edges.push_back(pair<bool, bool>(false, last_sample));
        }

        if (index > end)
            last_sample = get_sample_unlock(end, sig_index);
        else
            last_sample = get_sample_unlock(index - 1, sig_index);

        if (has_edge) {
            edges.push_back(pair<bool, bool>(true, last_sample));
            if (togs.size() < max_togs)
                togs.push_back(pair<uint16_t, bool>(edges.size() - 1, last_sample));
        }

        while(index > end && edges.size() < width)
            edges.push_back(pair<bool, bool>(false, last_sample));
    }

    if (togs.size() < max_togs) {
        last_sample = get_sample_unlock(end, sig_index);
        togs.push_back(pair<uint16_t, bool>(edges.size() - 1, last_sample));
    }

    return start_sample;
}

bool LogicSnapshot::get_nxt_edge(uint64_t &index, bool last_sample, uint64_t end,
                      double min_length, int sig_index)
{
    std::lock_guard<std::mutex> lock(_mutex);
    return get_nxt_edge_unlock(index, last_sample, end, min_length, sig_index);
}

bool LogicSnapshot::get_nxt_edge_unlock(uint64_t &index, bool last_sample, uint64_t end,
                      double min_length, int sig_index)
{
    index += _loop_offset;
    end += _loop_offset;
    _ring_sample_count += _loop_offset;

    bool flag = get_nxt_edge_self(index, last_sample, end, min_length, sig_index);

    index -= _loop_offset;
    _ring_sample_count -= _loop_offset;

    return flag;
}

bool LogicSnapshot::get_nxt_edge_self(uint64_t &index, bool last_sample, uint64_t end, double min_length, int sig_index)
{
    if (index > end)
        return false;

    int order = get_ch_order(sig_index);
    if (order == -1)
        return false;

    //const unsigned int min_level = max((int)floorf(logf(min_length) / logf(Scale)) - 1, 0);
    const unsigned int min_level = max((int)(log2f(min_length) - 1) / (int)ScalePower, 0);
    uint64_t root_index = index >> (LeafBlockPower + RootScalePower);
    uint8_t root_pos = (index & RootMask) >> LeafBlockPower;
    bool root_last = (root_index != 0) ? _ch_data[order][root_index-1].last & MSB :
                                         _ch_data[order][0].first & LSB;
    bool edge_hit = false;

    // linear search for the next transition on the root level
    for (uint64_t i = root_index; !edge_hit && (index <= end) && i < (uint64_t)_ch_data[order].size(); i++) 
    {
        uint64_t cur_mask = (~0ULL << root_pos);

        do {
            uint64_t inner_tog = _ch_data[order][i].tog & cur_mask;
            uint64_t lbp_tog = (((_ch_data[order][i].last << 1) + root_last) & cur_mask) ^ (_ch_data[order][i].first & cur_mask);
            uint8_t inner_tog_pos = bsf_folded(inner_tog);
            uint8_t lbp_tog_pos = bsf_folded(lbp_tog);

            if (inner_tog != 0)
            {
                if (lbp_tog != 0) {
                    // lbp tog before inner tog
                    edge_hit = lbp_nxt_edge(index, i, lbp_tog, lbp_tog_pos, true, inner_tog_pos, last_sample, sig_index);
                }

                if (!edge_hit) {
                    uint64_t *lbp = (uint64_t*)_ch_data[order][i].lbp[inner_tog_pos];
                    uint64_t blk_start = (i << (LeafBlockPower + RootScalePower)) + (inner_tog_pos << LeafBlockPower);
                    index = max(blk_start, index);

                    if (min_level < ScaleLevel) {
                        uint64_t block_end = min(index | LeafMask, end);
                        edge_hit = block_nxt_edge(lbp, index, block_end, last_sample, min_level);
                    }
                    else {
                        edge_hit = true;
                    }

                    if (inner_tog_pos == RootScale - 1)
                        break;
                    cur_mask = (~0ULL << (inner_tog_pos + 1));
                }
            }
            else if (lbp_tog != 0) {
                // lbp tog
                edge_hit = lbp_nxt_edge(index, i, lbp_tog, lbp_tog_pos, false, Scale - 1, last_sample, sig_index);
            }
            else {
                //index = (index + (1 << (LeafBlockPower + RootScalePower))) &
                //        (~0ULL << (LeafBlockPower + RootScalePower));
                index = (((i + 1) << (LeafBlockPower + RootScalePower)) - 1);
                break;
            }
        }
        //while (!edge_hit && index < end);
        while (!edge_hit && index < (((i + 1) << (LeafBlockPower + RootScalePower)) - 1));

        root_pos = 0;
        root_last = _ch_data[order][i].last & MSB;
    }

    if (index > end) {
        // skip edges over right
        edge_hit = false;
    }

    return edge_hit;
}

bool LogicSnapshot::get_pre_edge(uint64_t &index, bool last_sample,
                      double min_length, int sig_index)
{
    std::lock_guard<std::mutex> lock(_mutex);

    index += _loop_offset;
    _ring_sample_count += _loop_offset;

    bool flag = get_pre_edge_self(index, last_sample, min_length, sig_index);

    index = (index < _loop_offset) ? 0 : index - _loop_offset;
    _ring_sample_count -= _loop_offset;
    return flag;
}

bool LogicSnapshot::get_pre_edge_self(uint64_t &index, bool last_sample,
    double min_length, int sig_index)
{
    assert(index < _ring_sample_count);

    int order = get_ch_order(sig_index);
    if (order == -1)
        return false;

    //const unsigned int min_level = max((int)floorf(logf(min_length) / logf(Scale)) - 1, 1);
    const unsigned int min_level = max((int)(log2f(min_length) - 1) / (int)ScalePower, 0);
    int root_index = index >> (LeafBlockPower + RootScalePower);
    uint8_t root_pos = (index & RootMask) >> LeafBlockPower;
    bool root_first = _ch_data[order][root_index].last & MSB;
    bool edge_hit = false;

    // linear search for the previous transition on the root level
    for (int64_t i = root_index; !edge_hit && i >= 0; i--)
    {
        uint64_t cur_mask = (~0ULL >> (RootScale - root_pos - 1));

        do {
            uint64_t inner_tog = _ch_data[order][i].tog & cur_mask;
            uint64_t lbp_tog = (_ch_data[order][i].last & cur_mask) ^ ((((uint64_t)root_first << (RootScale - 1)) + (_ch_data[order][i].first >> 1)) & cur_mask);
            uint8_t inner_tog_pos = bsr64(inner_tog);
            uint8_t lbp_tog_pos = bsr64(lbp_tog);

            if (inner_tog != 0)
            {
                if (lbp_tog != 0) {
                    // lbp tog before inner tog
                    edge_hit = lbp_pre_edge(index, i, lbp_tog, lbp_tog_pos, true, inner_tog_pos, last_sample, sig_index);
                }

                if (!edge_hit) {
                    uint64_t *lbp = (uint64_t*)_ch_data[order][i].lbp[inner_tog_pos];
                    uint64_t blk_end = ((i << (LeafBlockPower + RootScalePower)) +
                                    (inner_tog_pos << LeafBlockPower)) | LeafMask;
                    index = min(blk_end, index);
                    if (min_level < ScaleLevel) {
                        edge_hit = block_pre_edge(lbp, index, last_sample, min_level, sig_index);
                    } else {
                        edge_hit = true;
                    }
                    if (inner_tog_pos == 0)
                        break;
                    cur_mask = (~0ULL >> (RootScale - inner_tog_pos));
                }
            }
            else if (lbp_tog != 0) {
                // lbp tog
                edge_hit = lbp_pre_edge(index, i, lbp_tog, lbp_tog_pos, false, 0, last_sample, sig_index);
                if (lbp_tog_pos == 0)
                    break;
            }
            else {
                break;
            }
        }
        while (!edge_hit);

        root_pos = RootScale - 1;
        root_first = _ch_data[order][i].first & LSB;
    }

    return edge_hit;
}

bool LogicSnapshot::lbp_nxt_edge(uint64_t &index, uint64_t root_index, uint64_t lbp_tog, uint8_t lbp_tog_pos,
                  bool aft_tog, uint8_t aft_pos, bool last_sample, int sig_index)
{
    assert(lbp_tog != 0);

    // check last_sample with current index
    bool sample = get_sample_self(index, sig_index);
    if (sample ^ last_sample)
    {
        return true;
    }

    // find edge between lbp
    bool edge_hit = false;
    uint64_t aft_lbp_start = (root_index << (LeafBlockPower + RootScalePower)) + (aft_pos << LeafBlockPower);

    while(lbp_tog_pos <= aft_pos)
    {
        uint64_t lbp_tog_index = (root_index << (LeafBlockPower + RootScalePower)) + (lbp_tog_pos << LeafBlockPower);
        if (lbp_tog_index > aft_lbp_start)
        {
            edge_hit = false;
            break;
        }
        else if (lbp_tog_index > index)
        {
            index = lbp_tog_index;
            edge_hit = true;
            break;
        }

        lbp_tog_pos++;
        lbp_tog &= (~0ULL << lbp_tog_pos);
        if ((lbp_tog_pos < Scale) && (lbp_tog != 0))
        {
            lbp_tog_pos = bsf_folded(lbp_tog);
        }
        else
        {
            break;
        }
    }

    uint64_t lbp_edge_index = aft_tog ? aft_lbp_start : aft_lbp_start + (1ULL << LeafBlockPower) - 1;
    if (!edge_hit && lbp_edge_index > index)
    {
        index = lbp_edge_index;
    }

    return edge_hit;
}

bool LogicSnapshot::block_nxt_edge(uint64_t *lbp, uint64_t &index, uint64_t block_end, bool last_sample,
                                   unsigned int min_level)
{
    unsigned int level = min_level;
    bool fast_forward = true;
    const uint64_t last = last_sample ? ~0ULL : 0ULL;

    //----- Search Next Edge Within Current LeafBlock -----//
    if (level == 0)
    {
        // Search individual samples up to the beginning of
        // the next first level mip map block
        const uint64_t offset = (index & ~(~0ULL << LeafBlockPower)) >> ScalePower;
        const uint64_t mask = last_sample ? ~(~0ULL << (index & LevelMask[0])) : ~0ULL << (index & LevelMask[0]);
        uint64_t sample = last_sample ? *(lbp + offset) | mask : *(lbp + offset) & mask;
        if (sample ^ last) {
            index = (index & ~LevelMask[0]) + bsf_folded(last_sample ? ~sample : sample);
            fast_forward = false;
        } else {
            index = ((index >> ScalePower) + 1) << ScalePower;
        }
    } else {
        index = ((index >> level*ScalePower) + 1) << level*ScalePower;
    }

    if (fast_forward) {

        // Fast forward: This involves zooming out to higher
        // levels of the mip map searching for changes, then
        // zooming in on them to find the point where the edge
        // begins.

        // Zoom out at the beginnings of mip-map
        // blocks until we encounter a change
        while (index <= block_end) {
            // continue only within current block
            if (level == 0)
                level++;
            const int level_scale_power =
                (level + 1) * ScalePower;
            const uint64_t offset =
                (index & ~(~0ULL << LeafBlockPower)) >> level_scale_power;
            const uint64_t mask = ~0ULL << ((index & LevelMask[level]) >> (level*ScalePower));
            uint64_t sample = *(lbp + LevelOffset[level] + offset) & mask;

            // Check if there was a change in this block
            if (sample) {
                index = (index & (~0ULL << (level + 1)*ScalePower)) + (bsf_folded(sample) << level*ScalePower);
                break;
            } else {
                index = ((index >> (level + 1)*ScalePower) + 1) << (level + 1)*ScalePower;
                ++level;
            }
        }

        // Zoom in until we encounter a change,
        // and repeat until we reach min_level
        while ((index <= block_end) && (level > min_level)) {
            // continue only within current block
            level--;
            const int level_scale_power =
                (level + 1) * ScalePower;
            const uint64_t offset =
                (index & ~(~0ULL << LeafBlockPower)) >> level_scale_power;
            const uint64_t mask = (level == 0 && last_sample) ?
                        ~(~0ULL << ((index & LevelMask[level]) >> (level*ScalePower))) :
                        ~0ULL << ((index & LevelMask[level]) >> (level*ScalePower));
            uint64_t sample = (level == 0 && last_sample) ?
                        *(lbp + LevelOffset[level] + offset) | mask :
                        *(lbp + LevelOffset[level] + offset) & mask;

            // Update the low level position of the change in this block
            if (level == 0 ? sample ^ last : sample) {
                index = (index & (~0ULL << (level + 1)*ScalePower)) + (bsf_folded(level == 0 ? sample ^ last : sample) << level*ScalePower);
                if (level == min_level)
                    break;
            }
        }
    }

    return (index <= block_end);
}

bool LogicSnapshot::lbp_pre_edge(uint64_t &index, uint64_t root_index, uint64_t lbp_tog, uint8_t &lbp_tog_pos,
                  bool pre_tog, uint8_t pre_pos, bool last_sample, int sig_index)
{
    assert(lbp_tog != 0);

    // check last_sample with current index
    bool sample = get_sample_self(index, sig_index);
    if (sample ^ last_sample)
    {
        index++;
        return true;
    }

    // find edge between lbp
    bool edge_hit = false;
    uint64_t pre_lbp_end = (root_index << (LeafBlockPower + RootScalePower)) + (pre_pos << LeafBlockPower) + (1ULL << LeafBlockPower) - 1;

    do
    {
        uint64_t lbp_tog_index = (root_index << (LeafBlockPower + RootScalePower)) + (lbp_tog_pos << LeafBlockPower)  + (1ULL << LeafBlockPower) - 1;
        if (lbp_tog_index < pre_lbp_end)
        {
            edge_hit = false;
            break;
        }
        else if (lbp_tog_index < index)
        {
            index = lbp_tog_index + 1;
            edge_hit = true;
            break;
        }

        if (lbp_tog_pos > 0)
        {
            lbp_tog_pos--;
            lbp_tog &= (~0ULL >> (Scale - lbp_tog_pos - 1));
            lbp_tog_pos = (lbp_tog != 0) ? bsr64(lbp_tog) : 0;
        }
        else
        {
            lbp_tog = 0;
        }
    }
    while (lbp_tog != 0 && lbp_tog_pos >= pre_pos);

    uint64_t lbp_edge_index = pre_tog ? pre_lbp_end : pre_lbp_end + 1 - (1ULL << LeafBlockPower);
    if (!edge_hit && lbp_edge_index < index)
    {
        index = lbp_edge_index;
    }

    return edge_hit;
}

bool LogicSnapshot::block_pre_edge(uint64_t *lbp, uint64_t &index, bool last_sample,
                                   unsigned int min_level, int sig_index)
{
    assert(min_level == 0);

    unsigned int level = min_level;
    bool fast_forward = true;
    const uint64_t last = last_sample ? ~0ULL : 0ULL;
    uint64_t block_start = index & ~LeafMask;

    assert(lbp);

    //----- Search Next Edge Within Current LeafBlock -----//
    if (level == 0)
    {
        // Search individual samples down to the beginning of
        // the previous first level mip map block
        const uint64_t offset = (index & ~(~0ULL << LeafBlockPower)) >> ScalePower;
        const uint64_t mask = last_sample ? ~(~0ULL >> (Scale - (index & LevelMask[0]) - 1)) : ~0ULL >> (Scale - (index & LevelMask[0]) - 1);
        uint64_t sample = last_sample ? *(lbp + offset) | mask : *(lbp + offset) & mask;
        if (sample ^ last) {
            index = (index & ~LevelMask[0]) + bsr64(last_sample ? ~sample : sample) + 1;
            return true;
        } else {
            index &= ~LevelMask[0];
            if (index == 0)
                return false;
            else
                index--;

            // using get_sample_self() to avoid out of block case
            bool sample = get_sample_self(index, sig_index);
            if (sample ^ last_sample) {
                index++;
                return true;
            } else if (index < block_start) {
                return false;
            }
        }
    }

    if (fast_forward) {

        // Fast forward: This involves zooming out to higher
        // levels of the mip map searching for changes, then
        // zooming in on them to find the point where the edge
        // begins.

        // Zoom out at the beginnings of mip-map
        // blocks until we encounter a change
        while (index > block_start) {
            // continue only within current block
            if (level == 0)
                level++;
            const int level_scale_power =
                (level + 1) * ScalePower;
            const uint64_t offset =
                (index & ~(~0ULL << LeafBlockPower)) >> level_scale_power;
            const uint64_t mask = ~0ULL >> (Scale - ((index & LevelMask[level]) >> (level*ScalePower)) - 1);
            uint64_t sample = *(lbp + LevelOffset[level] + offset) & mask;

            // Check if there was a change in this block
            if (sample) {
                index = (index & (~0ULL << (level + 1)*ScalePower)) +
                        (bsr64(sample) << level*ScalePower) +
                        ~(~0ULL << level*ScalePower);
                break;
            } else {
                index = (index >> (level + 1)*ScalePower) << (level + 1)*ScalePower;
                if (index == 0)
                    return false;
                else
                    index--;
            }
        }

        // Zoom in until we encounter a change,
        // and repeat until we reach min_level
        while ((index >= block_start) && (level > min_level)) {
            // continue only within current block
            level--;
            const int level_scale_power =
                (level + 1) * ScalePower;
            const uint64_t offset =
                (index & ~(~0ULL << LeafBlockPower)) >> level_scale_power;
            const uint64_t mask = (level == 0 && last_sample) ?
                        ~(~0ULL >> (Scale - ((index & LevelMask[level]) >> (level*ScalePower)) - 1)) :
                        ~0ULL >> (Scale - ((index & LevelMask[level]) >> (level*ScalePower)) - 1);
            uint64_t sample = (level == 0 && last_sample) ?
                        *(lbp + LevelOffset[level] + offset) | mask :
                        *(lbp + LevelOffset[level] + offset) & mask;

            // Update the low level position of the change in this block
            if (level == 0 ? sample ^ last : sample) {
                index = (index & (~0ULL << (level + 1)*ScalePower)) +
                        (bsr64(level == 0 ? sample ^ last : sample) << level*ScalePower) +
                        ~(~0ULL << level*ScalePower);
                if (level == min_level) {
                    index++;
                    break;
                }
            } else {
                index = (index & (~0ULL << (level + 1)*ScalePower));
            }
        }
    }

    return (index >= block_start) && (index != 0);
}

bool LogicSnapshot::pattern_search(int64_t start, int64_t end, int64_t& index,
                        std::map<uint16_t, QString> &pattern, bool isNext)
{
    std::lock_guard<std::mutex> lock(_mutex);
    
    start += _loop_offset;
    end += _loop_offset;
    index += _loop_offset;
    _ring_sample_count += _loop_offset;

    bool flag = pattern_search_self(start, end, index, pattern, isNext);

    index -= _loop_offset;
    _ring_sample_count -= _loop_offset;
    return flag;
}

bool LogicSnapshot::pattern_search_self(int64_t start, int64_t end, int64_t &index,
                    std::map<uint16_t, QString> &pattern, bool isNext)
{
    if (pattern.empty()) {
        return true;
    }
  
    char flagList[CHANNEL_MAX_COUNT];
    char lstValues[CHANNEL_MAX_COUNT];
    int  chanIndexs[CHANNEL_MAX_COUNT];
    int  count = 0;  
    bool bEdgeFlag = false;

    const int64_t to = isNext ? end + 1 : start - 1;
    const int64_t step = isNext ? 1 : -1;

    for (auto it = pattern.begin(); it != pattern.end(); it++){
         char flag = *(it->second.toStdString().c_str());
         int channel = it->first;

         if (flag != 'X' && has_data(channel)){
             flagList[count]  = flag;
             chanIndexs[count] = channel;
             count++;

             if (flag == 'R' || flag == 'F' || flag == 'C'){
                 bEdgeFlag = true;
             }
         }
    }
    if (count == 0){
        return true;
    }  

    //find
    bool ret = false;
    char val = 0;
    int macthed = 0;  

    //get first edge values
    if (bEdgeFlag){
        for (int i=0; i < count; i++){
            lstValues[i] =  (char)get_sample_self(index, chanIndexs[i]);
        }
        index += step;
    }

    if (index < start){
        index = start;
    }
    if (index > end){
        index = end;
    }

    while (index != to)
    {
        macthed = 0;

        for (int i = 0; i < count; i++)
        {
            val = (char)get_sample_self(index, chanIndexs[i]);

            if (flagList[i] == '0')
            {
                macthed += !val;
            }
            else if (flagList[i] == '1')
            {
                macthed += val;
            } 
            else if (flagList[i] == 'R')
            {
                if (isNext)
                    macthed += (lstValues[i] == 0 && val == 1);
                else
                    macthed += (lstValues[i] == 1 && val == 0);
            }
            else if (flagList[i] == 'F')
            {
                if (isNext)
                    macthed += (lstValues[i] == 1 && val == 0);
                else
                    macthed += (lstValues[i] == 0 && val == 1);
            }
            else if (flagList[i] == 'C')
            {   
                if (isNext)
                    macthed += (lstValues[i] == 0 && val == 1) || (lstValues[i] == 1 && val == 0);
                else
                    macthed += (lstValues[i] == 1 && val == 0) || (lstValues[i] == 0 && val == 1);
            }
            lstValues[i] = val;
        }

        // matched all
        if (macthed == count)
        {
            ret = true;
            if (!isNext){
                index++; //move to prev position
            }
            break;
        }

        index += step;
    }

    return ret;
}

bool LogicSnapshot::has_data(int sig_index)
{
    return get_ch_order(sig_index) != -1;
}

int LogicSnapshot::get_block_num()
{
   int block = ceil((_ring_sample_count+_loop_offset) * 1.0 / LeafBlockSamples) 
            - floor(_loop_offset * 1.0 / LeafBlockSamples);
   return block;
}

uint64_t LogicSnapshot::get_block_size(int block_index)
{
    int block_num = get_block_num();
    uint64_t samples = 0;

    assert(block_index < block_num);

    if (_loop_offset > 0)
    {
        if (block_index > 0 && block_index < block_num - 1) {
            return LeafBlockSamples / 8;
        }
        else if (block_index == 0){
            samples = min(_ring_sample_count + (_loop_offset % (uint64_t)LeafBlockSamples),
                        (uint64_t)LeafBlockSamples) - (_loop_offset % (uint64_t)LeafBlockSamples);
            return samples/8;
        }
        else{
            samples = (_ring_sample_count + _loop_offset) - (_ring_sample_count + _loop_offset - 1)
                    / LeafBlockSamples * LeafBlockSamples;
            return samples/8;
        }
    }
    else{
        if (block_index < block_num - 1) {
            return LeafBlockSamples / 8;
        }
        else {
            if (_ring_sample_count % LeafBlockSamples == 0)
                return LeafBlockSamples / 8;
            else
                return (_ring_sample_count % LeafBlockSamples) / 8;
        }
    }    
}

uint8_t *LogicSnapshot::get_block_buf(int block_index, int sig_index, bool &sample)
{
    assert(block_index < get_block_num());

    int order = get_ch_order(sig_index);
    if (order == -1) {
        sample = 0;
        return NULL;
    }

    int block_index0 = block_index;
    block_index += _loop_offset / LeafBlockSamples;

    uint64_t index = block_index / RootScale;
    uint8_t pos = block_index % RootScale;
    uint8_t *lbp = (uint8_t*)_ch_data[order][index].lbp[pos];

    if (lbp == NULL)
        sample = (_ch_data[order][index].first & 1ULL << pos) != 0;

    if (lbp != NULL && _loop_offset > 0 && block_index0 == 0)
    {
        lbp += (_loop_offset % LeafBlockSamples) / 8;
    }

    return lbp;
}

int LogicSnapshot::get_ch_order(int sig_index)
{
    uint16_t order = 0;

    for (uint16_t i : _ch_index) {
        if (i == sig_index)
            return order;
        else
            order++;
    }

    return -1;
}

void LogicSnapshot::move_first_node_to_last()
{
    for (unsigned int i=0; i<_channel_num; i++)
    {
        struct RootNode rn = _ch_data[i][0];
        _ch_data[i].erase(_ch_data[i].begin());

        for (int x=0; x<(int)Scale; x++)
        {
            if (rn.lbp[x] != NULL){
                free(rn.lbp[x]);
                rn.lbp[x] = NULL;
            }
        }

        rn.tog = 0;
        rn.first = 0;
        rn.last = 0;

        _ch_data[i].push_back(rn);                        
    }
}

void LogicSnapshot::decode_end()
{
   std::lock_guard<std::mutex> lock(_mutex);

   for(void *p : _free_block_list){
        free(p);
    }
    _free_block_list.clear();
}

void LogicSnapshot::free_decode_lpb(void *lbp)
{
    assert(lbp);

    std::lock_guard<std::mutex> lock(_mutex);

    for (auto it = _free_block_list.begin(); it != _free_block_list.end(); it++)
    {
        if ((*it) == lbp){
            _free_block_list.erase(it);
            free(lbp);
            break;
        }
    }
}

void LogicSnapshot::free_head_blocks(int count)
{
    assert(count < (int)Scale);
    assert(count > 0);

    for (int i = 0; i < (int)_channel_num; i++)
    {
        for (int j=_lst_free_block_index; j<count; j++){
            if (_ch_data[i][0].lbp[j] != NULL){
                free(_ch_data[i][0].lbp[j]);
                _ch_data[i][0].lbp[j] = NULL;
            }

            _ch_data[i][0].tog = (_ch_data[i][0].tog >> count) << count;
            _ch_data[i][0].first = (_ch_data[i][0].first >> count) << count;
            _ch_data[i][0].last = (_ch_data[i][0].last >> count) << count;
        }
    }
    _lst_free_block_index = count;
}

} // namespace data
} // namespace dsv
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_DATA_MATHSTACK_H
#define DSVIEW_PV_DATA_MATHSTACK_H

#include <list>
#include <QObject>
#include <QString>
#include <boost/optional.hpp> 
#include "signaldata.h"

namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
}
using namespace dsv::appcore;

namespace dsv{
	namespace view{
    	class DsoSignal;
        class dslDial;
	}
}
using namespace dsv::view;

namespace dsv {
namespace data {

class DsoSnapshot;

class MathStack : public QObject, public SignalData
{
    Q_OBJECT

public:
    enum math_state {
        Init,
        Stopped,
        Running
    };

    enum MathType {
        MATH_ADD,
        MATH_SUB,
        MATH_MUL,
        MATH_DIV,
    };

    struct EnvelopeSample
    {
        double min;
        double max;
    };

    struct EnvelopeSection
    {
        uint64_t start;
        unsigned int scale;
        uint64_t length;
        EnvelopeSample *samples;
    };

private:
    struct Envelope
    {
        uint64_t length;
        uint64_t data_length;
        EnvelopeSample *samples;
    };

private:
    static const unsigned int ScaleStepCount = 10;
    static const int EnvelopeScalePower;
    static const int EnvelopeScaleFactor;
    static const float LogEnvelopeScaleFactor;
    static const uint64_t EnvelopeDataUnit;

    static const uint64_t vDialValueStep = 1000;
    static const int vDialValueCount = 19;
    static const uint64_t vDialValue[vDialValueCount];
    static const int vDialUnitCount = 2;
    static const QString vDialAddUnit[vDialUnitCount];
    static const QString vDialMulUnit[vDialUnitCount];
    static const QString vDialDivUnit[vDialUnitCount];

public:
    MathStack(SigSession *_session,
              view::DsoSignal *dsoSig1,
              view::DsoSignal *dsoSig2, MathType type);
    virtual ~MathStack();
    void clear();
    void init();
    void free_envelop();
    void realloc(uint64_t num);

    MathType get_type();
    uint64_t get_sample_num();

    void enable_envelope(bool enable);

    uint64_t default_vDialValue();
    view::dslDial *get_vDial();
    QString get_unit(int level);
    double get_math_scale();

    const double *get_math(uint64_t start);
    void get_math_envelope_section(EnvelopeSection &s,
        uint64_t start, uint64_t end, float min_length);

    void calc_math();
    void reallocate_envelope(Envelope &e);
    void append_to_envelope_level(bool header);

signals:

private:
    SigSession  *_session;
    view::DsoSignal *_dsoSig1;
    view::DsoSignal *_dsoSig2;

    MathType _type;
    uint64_t _sample_num;
    uint64_t _total_sample_num;
    math_state _math_state;

    struct Envelope _envelope_level[ScaleStepCount];
    std::vector<double> _math;

    bool _envelope_en;
    bool _envelope_done;
};

} // namespace data
} // namespace dsv

#endif // DSVIEW_PV_DATA_MATHSTACK_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_DATA_DSOSNAPSHOT_H
#define DSVIEW_PV_DATA_DSOSNAPSHOT_H

#include <utility>
#include <vector>
#include <libsigrok.h> 
#include "snapshot.h"

namespace dsv {
namespace data {

class DsoSnapshot : public Snapshot
{
public:
	struct EnvelopeSample
	{
        uint8_t min;
        uint8_t max;
	};

	struct EnvelopeSection
	{
		uint64_t start;
		unsigned int scale;
		uint64_t length;
		EnvelopeSample *samples;
	};

private:
	struct Envelope
	{
		uint64_t length;
		uint64_t data_length;
		EnvelopeSample *samples;
	};

private:
	static const unsigned int ScaleStepCount = 10;
	static const int EnvelopeScalePower;
	static const int EnvelopeScaleFactor;
	static const float LogEnvelopeScaleFactor;
	static const uint64_t EnvelopeDataUnit;

    static const uint64_t LeafBlockPower = 21;
    static const uint64_t LeafBlockSamples = 1 << LeafBlockPower;
    static const uint64_t LeafMask = ~(~0ULL << LeafBlockPower);

    static const int VrmsScaleFactor;

private:
    void init_all();

public:
    DsoSnapshot();

    virtual ~DsoSnapshot();

    void clear();
    void init();

    void first_payload(const sr_datafeed_dso &dso, uint64_t total_sample_count,
                       GSList *channels, bool instant, bool isFile);

    void append_payload(const sr_datafeed_dso &dso);
    const uint8_t* get_samples(int64_t start_sample, int64_t end_sample, uint16_t ch_index);

	void get_envelope_section(EnvelopeSection &s,
        uint64_t start, uint64_t end, float min_length, int probe_index);

    void enable_envelope(bool enable);
    double cal_vrms(double zero_off, int index);
    double cal_vmean(int index);
    bool has_data(int sig_index);
    int get_block_num();
    uint64_t get_block_size(int block_index);

    bool get_max_min_value(uint8_t &maxv, uint8_t &minv, int chan_index);

    inline void set_threshold(float threshold){
        _threshold = threshold;
    }

    inline float get_threshold(){
        return _threshold;
    }

    inline void set_measure_voltage_factor(uint64_t v, int index){   
        index == 0 ? _measure_voltage_factor1 = v : _measure_voltage_factor2 = v;
    }

    inline uint64_t get_measure_voltage_factor(int index){
        return index == 0 ? _measure_voltage_factor1 : _measure_voltage_factor2;
    }

    inline void set_data_scale(float scale, int index){
        index == 0 ? _data_scale1 = scale : _data_scale2 = scale;
    }

    inline float get_data_scale(int index){
        return index == 0 ? _data_scale1 : _data_scale2;
    }

    inline bool is_file(){
        return _is_file;
    }

private:
    void append_data(void *data, uint64_t samples, bool instant);
    void free_envelop();
	void reallocate_envelope(Envelope &l);
    void append_payload_to_envelope_levels(bool header);
    void free_data();   
    int  get_ch_order(int sig_index);

private:
    struct Envelope _envelope_levels[2*DS_MAX_DSO_PROBES_NUM][ScaleStepCount];
    bool    _envelope_en;
    bool    _envelope_done;
    bool    _instant; 
    std::vector<uint8_t*>   _ch_data;
    float   _threshold;
    uint64_t _measure_voltage_factor1;
    uint64_t _measure_voltage_factor2;
    float _data_scale1 = 0;
    float _data_scale2 = 0;
    bool    _is_file;
};

} // namespace data
} // namespace dsv

#endif // DSVIEW_PV_DATA_DSOSNAPSHOT_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include <assert.h>

#include "signaldata.h"

namespace dsv {
namespace data {

SignalData::SignalData() :
    _samplerate(0)
{
}

SignalData::~SignalData() {}
 

void SignalData::set_samplerate(double samplerate)
{
    assert(samplerate > 0);
    _samplerate = samplerate;
}

} // namespace data
} // namespace dsv
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2014 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */
  
#include "decoderstack.h"
#include <stdexcept>
#include <algorithm>
#include <assert.h>
#include <ds_types.h>
#include "logicsnapshot.h"
#include "../decode/decoder.h"
#include "../decode/annotation.h"
#include "../decode/rowdata.h"
#include "../appcore/sigsession.h"
#include "../view/logicsignal.h"
#include "../basedef.h"
#include "../log.h"
#include "../ui/langresource.h"

using namespace std;
using namespace boost;

namespace dsv {
namespace data {
    
const double DecoderStack::DecodeMargin = 1.0;
const double DecoderStack::DecodeThreshold = 0.2;
const int64_t DecoderStack::DecodeChunkLength = 4 * 1024; 
const unsigned int DecoderStack::DecodeNotifyPeriod = 1024;
 
DecoderStack::DecoderStack(SigSession *session,
	const srd_decoder *const dec, DecoderStatus *decoder_status) :
	_session(session)
{
    assert(session);
    assert(dec);
    assert(decoder_status); 
    
    _samples_decoded = 0;
    _sample_count = 0; 
    _decode_state = Stopped;
    _options_changed = false;
    _no_memory = false;
    _mark_index = -1;
    _decoder_status = decoder_status;
    _stask_stauts = NULL; 
    _is_capture_end = true;
    _snapshot = NULL;
    _progress = 0;
    _is_decoding = false;
    
    _stack.push_back(new decode::Decoder(dec));
 
    build_row();
}

DecoderStack::~DecoderStack()
{   
    //release resource talbe
    DESTROY_OBJECT(_decoder_status);

    //release source
    for (auto &kv : _rows)
    {
        kv.second->clear(); //destory all annotations
        delete kv.second;
    }
    _rows.clear();

    //Decoder
    for (auto *p : _stack){
        delete p;
    }
    _stack.clear();
    
    _rows_gshow.clear();
    _rows_lshow.clear();
    _class_rows.clear();
}
 
void DecoderStack::add_sub_decoder(decode::Decoder *decoder)
{
	assert(decoder);
	_stack.push_back(decoder);
    build_row();
    _options_changed = true;
}

void DecoderStack::remove_sub_decoder(Decoder *decoder)
{
	// Find the decoder in the stack
    auto  iter = _stack.begin();
    for(unsigned int i = 0; i < _stack.size(); i++, iter++)
        if ((*iter) == decoder)
            break;

	// Delete the element
    if (iter != _stack.end())
    {
        _stack.erase(iter);
        delete decoder;
    }        

    build_row();
    _options_changed = true;
}

void DecoderStack::remove_decoder_by_handel(const srd_decoder *dec)
{
    Decoder *decoder = NULL;

    for (auto d : _stack){
        if (d->get_dec_handel() == dec){
            decoder = d;
            break;
        }
    }

    if (decoder){
        remove_sub_decoder(decoder);
    }
}

void DecoderStack::build_row()
{
    //release source
    for (auto &kv : _rows)
    {   
        kv.second->clear(); //destory all annotations
        delete kv.second;
    }
    _rows.clear();

    // Add classes
    for (auto dec : _stack)
    { 
        const srd_decoder *const decc = dec->decoder();
        assert(dec->decoder());

        dec->reset_start();

        // Add a row for the decoder if it doesn't have a row list
        if (!decc->annotation_rows) {
            const Row row(decc);
            _rows[row] = new decode::RowData();
            std::map<const decode::Row, bool>::const_iterator iter = _rows_gshow.find(row);
            if (iter == _rows_gshow.end()) {
                _rows_gshow[row] = true;
                if (row.title().contains("bit", Qt::CaseInsensitive) ||
                    row.title().contains("warning", Qt::CaseInsensitive)) {
                    _rows_lshow[row] = false;
                } else {
                    _rows_lshow[row] = true;
                }
            }
        }

        // Add the decoder rows
        int order = 0;
        for (const GSList *l = decc->annotation_rows; l; l = l->next)
        {
            const srd_decoder_annotation_row *const ann_row =
                (srd_decoder_annotation_row *)l->data;
            assert(ann_row);

            const Row row(decc, ann_row, order);

            // Add a new empty row data object
            _rows[row] = new decode::RowData();
            std::map<const decode::Row, bool>::const_iterator iter = _rows_gshow.find(row);
            if (iter == _rows_gshow.end()) {
                _rows_gshow[row] = true;
                if (row.title().contains("bit", Qt::CaseInsensitive) ||
                    row.title().contains("warning", Qt::CaseInsensitive)) {
                    _rows_lshow[row] = false;
                } else {
                    _rows_lshow[row] = true;
                }
            }

            // Map out all the classes
            for (const GSList *ll = ann_row->ann_classes; ll; ll = ll->next){
                _class_rows[make_pair(decc, GPOINTER_TO_INT(ll->data))] = Row(row);
            }

            order++;
        }
    }
}

int64_t DecoderStack::samples_decoded()
{
    std::lock_guard<std::mutex> decode_lock(_output_mutex);
	return _samples_decoded;
}

void DecoderStack::get_annotation_subset(
	std::vector<dsv::decode::Annotation*> &dest,
	const Row &row, uint64_t start_sample,
	uint64_t end_sample)
{  
    auto iter = _rows.find(row);
    if (iter != _rows.end())
        (*iter).second->get_annotation_subset(dest,
			start_sample, end_sample);
}


uint64_t DecoderStack::get_annotation_index(
    const Row &row, uint64_t start_sample)
{  
    uint64_t index = 0;
    auto iter = _rows.find(row);
    if (iter != _rows.end())
        index = (*iter).second->get_annotation_index(start_sample);

    return index;
}

uint64_t DecoderStack::get_max_annotation(const Row &row)
{ 
    auto iter =  _rows.find(row);
    if (iter != _rows.end())
        return (*iter).second->get_max_annotation();

    return 0;
}

uint64_t DecoderStack::get_min_annotation(const Row &row)
{  
    auto iter = _rows.find(row);
    if (iter != _rows.end())
        return (*iter).second->get_min_annotation();

    return 0;
}

std::map<const decode::Row, bool> DecoderStack::get_rows_gshow()
{
    std::map<const decode::Row, bool> rows_gshow;
    for (std::map<const decode::Row, bool>::const_iterator i = _rows_gshow.begin();
        i != _rows_gshow.end(); i++) {
        rows_gshow[(*i).first] = (*i).second;
    }
    return rows_gshow;
}

std::map<const decode::Row, bool> DecoderStack::get_rows_lshow()
{
    std::map<const decode::Row, bool> rows_lshow;
    for (std::map<const decode::Row, bool>::const_iterator i = _rows_lshow.begin();
        i != _rows_lshow.end(); i++) {
        rows_lshow[(*i).first] = (*i).second;
    }
    return rows_lshow;
}

void DecoderStack::set_rows_gshow(const decode::Row row, bool show)
{
    std::map<const decode::Row, bool>::const_iterator iter = _rows_gshow.find(row);
    if (iter != _rows_gshow.end()) {
        _rows_gshow[row] = show;
    }
}

void DecoderStack::set_rows_lshow(const decode::Row row, bool show)
{
    std::map<const decode::Row, bool>::const_iterator iter = _rows_lshow.find(row);
    if (iter != _rows_lshow.end()) {
        _rows_lshow[row] = show;
    }
}

bool DecoderStack::has_annotations(const Row &row)
{  
    auto iter =
        _rows.find(row);
    if (iter != _rows.end())
        if(0 == (*iter).second->get_max_sample())
            return false;
        else
            return true;
    else
        return false;
}

uint64_t DecoderStack::list_annotation_size()
{
    std::lock_guard<std::mutex> lock(_output_mutex);
    uint64_t max_annotation_size = 0;

    for (auto it = _rows.begin(); it != _rows.end(); it++) {
        auto iter = _rows_lshow.find((*it).first);
        if (iter != _rows_lshow.end() && (*iter).second){
            max_annotation_size = max(max_annotation_size,
                (*it).second->get_annotation_size());
        }
    }

    return max_annotation_size;
}

uint64_t DecoderStack::list_annotation_size(uint16_t row_index)
{ 
    for (auto i = _rows.begin(); i != _rows.end(); i++) {
        auto iter = _rows_lshow.find((*i).first);
        if (iter != _rows_lshow.end() && (*iter).second)
            if (row_index-- == 0) {
                return (*i).second->get_annotation_size();
            }
    }
    return 0;
}

bool DecoderStack::list_annotation(dsv::decode::Annotation &ann,
                                  uint16_t row_index, uint64_t col_index)
{ 
    for (auto i = _rows.begin(); i != _rows.end(); i++) {
        auto iter = _rows_lshow.find((*i).first);
        if (iter != _rows_lshow.end() && (*iter).second) {
            if (row_index-- == 0) {
                return (*i).second->get_annotation(ann, col_index);
            }
        }
    }

    return false;
}


bool DecoderStack::list_row_title(int row, QString &title)
{ 
    for (auto i = _rows.begin();i != _rows.end(); i++) {
        auto iter = _rows_lshow.find((*i).first);
        if (iter != _rows_lshow.end() && (*iter).second) {
            if (row-- == 0) {
                title = (*i).first.title();
                return 1;
            }
        }
    }
    return 0;
}

void DecoderStack::clear()
{
    init();
}

void DecoderStack::init()
{
    _sample_count = 0; 
    _samples_decoded = 0;
    _error_message = QString();
    _no_memory = false;
    _snapshot = NULL;

    for (auto i = _rows.begin();i != _rows.end(); i++) { 
        (*i).second->clear();
    }

    set_mark_index(-1);
}
 
void DecoderStack::stop_decode_work()
{  
    //set the flag to exit from task thread 
     if (_stask_stauts){
         _stask_stauts->_bStop = true;
     }
    _decode_state = Stopped; 
}

void DecoderStack::begin_decode_work()
{
     assert(_decode_state == Stopped);

     _error_message = "";
     _decode_state = Running;
      do_decode_work();
     _decode_state = Stopped;
}

void DecoderStack::do_decode_work()
{
    //set the flag to exit from task thread 
     if (_stask_stauts){
         _stask_stauts->_bStop = true;
     }
     _stask_stauts = new decode_task_status();
     _stask_stauts->_bStop = false;
     _stask_stauts->_decoder = this;
     _decoder_status->clear(); //clear old items

    if (!_options_changed)
    {  
        dsv_err("ERROR:Decoder options have not changed.");
        return;
    } 
    _options_changed = false;

    init();

    _snapshot = NULL;

	// Check that all decoders have the required channels
    for(auto dec : _stack){
		if (!dec->have_required_probes()) {
			_error_message = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_DECODERSTACK_DECODE_WORK_ERROR),
                             "One or more required channels have not been specified");
            dsv_err("ERROR:%s", _error_message.toStdString().c_str());
			return;
		}
    }

	// We get the logic data of the first channel in the list.
	// This works because we are currently assuming all
	// LogicSignals have the same data/snapshot
    for (auto dec : _stack) {
        if (!dec->channels().empty()) {
            for(auto s :  _session->get_signals()) {
                if(s->get_index() == (*dec->channels().begin()).second && s->signal_type() == SR_CHANNEL_LOGIC)
                { 
                    _snapshot = ((dsv::view::LogicSignal*)s)->data();
                    if (_snapshot != NULL)
                        break;
                }
            }
            if (_snapshot != NULL)
                break;
        }
    }

	if (_snapshot == NULL)
    {   
        _error_message = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_DECODERSTACK_DECODE_WORK_ERROR),
                             "One or more required channels have not been specified");
        dsv_err("ERROR:%s", _error_message.toStdString().c_str());
        return;
    }		

    if (_session->is_realtime_refresh() == false && _snapshot->empty())
    { 
        dsv_err("ERROR:Decode data is empty.");
        return;
    }

    // Get the samplerate
	_samplerate = _snapshot->samplerate();
    if (_samplerate == 0.0)
    {
        dsv_err("ERROR:Decode data got an invalid sample rate.");
        return;
    }
     
    execute_decode_stack();   
}

uint64_t DecoderStack::get_max_sample_count()
{
	uint64_t max_sample_count = 0;

    for (auto i = _rows.begin(); i != _rows.end(); i++){
        max_sample_count = max(max_sample_count, (*i).second->get_max_sample());
    } 	

	return max_sample_count;
}

void DecoderStack::decode_data(const uint64_t decode_start, const uint64_t decode_end, srd_session *const session)
{
    decode_task_status *status = _stask_stauts;

    //uint8_t *chunk = NULL;
    uint64_t last_cnt = 0;
    uint64_t notify_cnt = (decode_end - decode_start + 1)/100;
    srd_decoder_inst *logic_di = NULL;

    // find the first level decoder instant
    for (GSList *d = session->di_list; d; d = d->next) {
        srd_decoder_inst *di = (srd_decoder_inst *)d->data;
        srd_decoder *decoder = di->decoder;
        const bool have_probes = (decoder->channels || decoder->opt_channels) != 0;
        if (have_probes) {
            logic_di = di;
            break;
        }
    }

    assert(logic_di);

    uint64_t entry_cnt = 0;
    uint64_t i = decode_start;
    char *error = NULL; 
    bool bError = false;
    bool bEndTime = false;
    //struct srd_push_param push_param;

    if( i >= decode_end){
        dsv_info("decode data index have been to end");
    }

    std::vector<const uint8_t *> chunk;
    std::vector<uint8_t> chunk_const;

    bool bCheckEnd = false;
    uint64_t end_index = decode_end;

    _progress = 0;
    uint64_t sended_len  = 0;
    _is_decoding = true;

    void* lbp_array[35];

    for (int j =0 ; j < logic_di->dec_num_channels; j++){
        lbp_array[j] = NULL;
    }
  
    while(i < end_index && !_no_memory && !status->_bStop)
    {
        chunk.clear();
        chunk_const.clear();

        if (_is_capture_end)
        {
            if (!bCheckEnd){
                bCheckEnd = true;

                uint64_t align_sample_count = _snapshot->get_ring_sample_count();

                if (end_index >= align_sample_count){
                    end_index = align_sample_count - 1;
                    dsv_info("Reset the decode end sample, new:%llu, old:%llu", 
                        (u64_t)end_index, (u64_t)decode_end);
                }
            }
        }
        else if (i >= _snapshot->get_ring_sample_count())
        {   
            // Wait the data is ready.
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            continue;
        }

        if (_is_capture_end && i == _snapshot->get_ring_sample_count()){
            break;
        }

        uint64_t chunk_end = end_index;

        for (int j =0 ; j < logic_di->dec_num_channels; j++) {
            int sig_index = logic_di->dec_channelmap[j];
            void *lbp = NULL;

            if (sig_index == -1) {
                chunk.push_back(NULL);
                chunk_const.push_back(0);
            }
            else {
                if (_snapshot->has_data(sig_index)) {
                    const uint8_t *data_ptr = _snapshot->get_samples(i, chunk_end, sig_index, &lbp);
                    chunk.push_back(data_ptr);
                    chunk_const.push_back(_snapshot->get_sample(i, sig_index));

                    if (_snapshot->is_able_free() == false)
                    {
                        if (lbp_array[j] != lbp){
                            if (lbp_array[j] != NULL)
                                _snapshot->free_decode_lpb(lbp_array[j]);
                            lbp_array[j] = lbp;
                        }
                    }
                }
                else {
                    _error_message = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_DECODERSTACK_DECODE_DATA_ERROR),
                                     "At least one of selected channels are not enabled.");
                    return;
                }
            }
        }

        if (chunk_end > end_index)
            chunk_end = end_index;
        if (chunk_end - i > MaxChunkSize)
            chunk_end = i + MaxChunkSize;

        bEndTime = (chunk_end == end_index);

        if (srd_session_send(
                session,
                i,
                chunk_end,
                chunk.data(),
                chunk_const.data(),
                chunk_end - i,
                &error) != SRD_OK){

            if (error){
                _error_message = QString::fromLocal8Bit(error);
                dsv_err("Failed to call srd_session_send:%s", error);
                g_free(error);
                error = NULL;
            }

            bError = true;
            break;
        }

        sended_len += chunk_end - i; 
        _progress = (int)(sended_len * 100 / end_index);

        i = chunk_end;       

        //use mutex
        {
            std::lock_guard<std::mutex> lock(_output_mutex);
            _samples_decoded = i - decode_start + 1;
        }

        if ((i - last_cnt) > notify_cnt) {
            last_cnt = i;
            new_decode_data();
        }

        entry_cnt++;
    }

    _progress = 100;
    _is_decoding = false;
    
    new_decode_data();

    // the task is normal ends,so all samples was processed;
    if (!bError && bEndTime){
       srd_session_end(session, &error);

        if (error != NULL){
            _error_message = QString::fromLocal8Bit(error);
            dsv_err("Failed to call srd_session_end:%s", error);
        }
    }
 
    dsv_info("%s%llu", "send to decoder times: ", (u64_t)entry_cnt);

    if (error != NULL)
        g_free(error);
  
    if (!_session->is_closed())
        decode_done();
}

void DecoderStack::execute_decode_stack()
{  
	srd_session *session = NULL;
	srd_decoder_inst *prev_di = NULL;
    uint64_t decode_start = 0;
    uint64_t decode_end = 0;

	assert(_snapshot);

	// Create the session
    // one decoderstatck onwer one session
    // all decoderstatck execute in sequence
	srd_session_new(&session);

    if (session == NULL){
        dsv_err("Failed to call srd_session_new()");
        assert(false);
    }
    
    // Get the intial sample count
    _sample_count = _snapshot->get_ring_sample_count();
 
    // Create the decoders
    for(auto dec : _stack)
	{
        srd_decoder_inst *const di = dec->create_decoder_inst(session);

		if (!di)
		{
			_error_message =L_S(STR_PAGE_MSG, S_ID(IDS_MSG_DECODERSTACK_DECODE_STACK_ERROR), 
                            "Failed to create decoder instance");
			srd_session_destroy(session);
			return;
		}

		if (prev_di)
			srd_inst_stack (session, prev_di, di);

		prev_di = di;
        decode_start = dec->decode_start();

        if (_session->is_realtime_refresh() == false)
            decode_end = min(dec->decode_end(), _sample_count-1);
        else
            decode_end = max(dec->decode_end(), decode_end);
	}

    dsv_info("decoder start sample:%llu, end sample:%llu, count:%llu", 
            (u64_t)decode_start, (u64_t)decode_end, (u64_t)(decode_end - decode_start + 1));

	// Start the session
	srd_session_metadata_set(session, SRD_CONF_SAMPLERATE,
		g_variant_new_uint64((uint64_t)_samplerate));

	srd_pd_output_callback_add(
                    session, 
                    SRD_OUTPUT_ANN,
		            DecoderStack::annotation_callback,
                    _stask_stauts);

    char *error = NULL;
    if (srd_session_start(session, &error) == SRD_OK){
       //need a lot time
        decode_data(decode_start, decode_end, session);
    }
    else if (error != NULL){
        _error_message = QString::fromLocal8Bit(error);
    }

	// Destroy the session
    if (error != NULL) {
        g_free(error);
    }

	srd_session_destroy(session); 
}

uint64_t DecoderStack::sample_count()
{
    if (_snapshot)
        return _snapshot->get_sample_count();
    else
        return 0;
}

uint64_t DecoderStack::sample_rate()
{
    return _samplerate;
}

//the decode callback, annotation object will be create
void DecoderStack::annotation_callback(srd_proto_data *pdata, void *self)
{
	assert(pdata);
	assert(self);

    struct decode_task_status *st = (decode_task_status*)self;

	DecoderStack *const d = st->_decoder;
	assert(d);

    if (st->_bStop){ 
        return;
    }
    if (d->_decoder_status == NULL){ 
        dsv_err("decode task was deleted.");
        assert(false);
    }
  
    if (d->_no_memory) {
        return;
    }

    Annotation *a = new Annotation(pdata, d->_decoder_status);
    if (a == NULL){
        d->_no_memory = true;
        return;     
    }

	// Find the row
	assert(pdata->pdo);
	assert(pdata->pdo->di);
	const srd_decoder *const decc = pdata->pdo->di->decoder;
	assert(decc);

    auto row_iter = d->_rows.end();
	
	// Try looking up the sub-row of this class
	const map<pair<const srd_decoder*, int>, Row>::const_iterator r =
        d->_class_rows.find(make_pair(decc, a->format()));
	if (r != d->_class_rows.end())
        row_iter = d->_rows.find((*r).second);
	else
	{
		// Failing that, use the decoder as a key
        row_iter = d->_rows.find(Row(decc));
	}

    assert(row_iter != d->_rows.end());
    if (row_iter == d->_rows.end()) {
        dsv_err("Unexpected annotation: decoder = 0x%x, format = %d", (void*)decc, a->format());
        assert(0);
        return;
    }

	// Add the annotation 
    if (!(*row_iter).second->push_annotation(a))
        d->_no_memory = true; 
}
 
void DecoderStack::frame_ended()
{ 
    _options_changed = true; 
}

int DecoderStack::list_rows_size()
{ 
    int rows_size = 0;
    for (auto i = _rows.begin(); i != _rows.end(); i++) {
        auto iter = _rows_lshow.find((*i).first);
        if (iter != _rows_lshow.end() && (*iter).second)
            rows_size++;
    }
    return rows_size;
}

bool DecoderStack::options_changed()
{
    return _options_changed;
}

void DecoderStack::set_options_changed(bool changed)
{
    _options_changed = changed;
}

bool DecoderStack::out_of_memory()
{
    return _no_memory;
}

void DecoderStack::set_mark_index(int64_t index)
{
    _mark_index = index;
}

int64_t DecoderStack::get_mark_index()
{
    return _mark_index;
}

const char* DecoderStack::get_root_decoder_id()
{
    if (_stack.size() > 0){
        decode::Decoder *dec = _stack.front();
        return dec->decoder()->id;
    }
    return NULL;
}

} // namespace data
} // namespace dsv
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_DATA_SPECTRUMSTACK_H
#define DSVIEW_PV_DATA_SPECTRUMSTACK_H

#include <list>
#include <boost/optional.hpp>   
#include <fftw3.h>
#include <QObject>
#include <QString>
#include "signaldata.h"

namespace dsv{
    namespace appcore {
        class SigSession;
    }
    namespace view {
        class DsoSignal;
    }
}
using namespace dsv::appcore;
using namespace dsv::view;

namespace dsv {
namespace data {

class DsoSnapshot;

class SpectrumStack : public QObject, public SignalData
{
    Q_OBJECT

private:
    static const QString windows_support[5];
    static const uint64_t length_support[5];

public:
    enum spectrum_state {
        Init,
        Stopped,
        Running
    };

public:
    SpectrumStack(SigSession *_session, int index);
    virtual ~SpectrumStack();
    void clear();
    void init();

    int get_index();

    uint64_t get_sample_num();
    void set_sample_num(uint64_t num);

    int get_windows_index();
    void set_windows_index(int index);

    const std::vector<QString> get_windows_support();
    const std::vector<uint64_t> get_length_support();

    bool dc_ignored();
    void set_dc_ignore(bool ignore);

    int get_sample_interval();
    void set_sample_interval(int interval);

    const std::vector<double> get_fft_spectrum();
    double get_fft_spectrum(uint64_t index);

    void calc_fft();

    double window(uint64_t i, int type);

signals:

private:
    SigSession *_session;

    int _index;
    uint64_t _sample_num;
    int _windows_index;
    bool _dc_ignore;
    int _sample_interval;
    spectrum_state _spectrum_state;

    fftw_plan _fft_plan;
    std::vector<double> _xn;
    std::vector<double> _xk;
    std::vector<double> _power_spectrum;
};

} // namespace data
} // namespace dsv

#endif // DSVIEW_PV_DATA_SPECTRUMSTACK_H
/****************************************************************************
** Meta object code from reading C++ file 'mathstack.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "mathstack.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'mathstack.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdataSCOPEMathStackENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdataSCOPEMathStackENDCLASS = QtMocHelpers::stringData(
    "dsv::data::MathStack"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdataSCOPEMathStackENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[21];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdataSCOPEMathStackENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdataSCOPEMathStackENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdataSCOPEMathStackENDCLASS = {
    {
        QT_MOC_LITERAL(0, 20)   // "dsv::data::MathStack"
    },
    "dsv::data::MathStack"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdataSCOPEMathStackENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::data::MathStack::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdataSCOPEMathStackENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdataSCOPEMathStackENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdataSCOPEMathStackENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<MathStack, std::true_type>
    >,
    nullptr
} };

void dsv::data::MathStack::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *dsv::data::MathStack::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::data::MathStack::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdataSCOPEMathStackENDCLASS.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "SignalData"))
        return static_cast< SignalData*>(this);
    return QObject::qt_metacast(_clname);
}

int dsv::data::MathStack::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#include "snapshot.h"
#include <assert.h>
#include <stdlib.h>
#include <string.h>
 
namespace dsv {
namespace data {

Snapshot::Snapshot(int unit_size, uint64_t total_sample_count, unsigned int channel_num)
{
    assert(unit_size > 0);

    _capacity = 0;
    _channel_num = channel_num;
    _sample_count = 0;
    _total_sample_count = total_sample_count;
    _ring_sample_count = 0;
    _unit_size = unit_size;
    _memory_failed = false;
    _last_ended = true;
    _unit_bytes = 1;
    _unit_pitch = 0;
}

Snapshot::~Snapshot()
{
    free_data();
}

void Snapshot::free_data()
{
    _capacity = 0;
    _sample_count = 0;
    _ch_index.clear();
}

bool Snapshot::empty()
{
    if (get_sample_count() == 0)
        return true;
    else
        return false;
}

uint64_t Snapshot::get_sample_count()
{
    std::lock_guard<std::mutex> lock(_mutex);
    return _sample_count;
}

uint64_t Snapshot::get_ring_sample_count()
{
    std::lock_guard<std::mutex> lock(_mutex);
    return _ring_sample_count;
}
 
uint64_t Snapshot::get_ring_start()
{
    std::lock_guard<std::mutex> lock(_mutex);
    return ring_start();    
}

uint64_t Snapshot::get_ring_end()
{
    std::lock_guard<std::mutex> lock(_mutex);
    return ring_end();     
}
 
uint64_t Snapshot::ring_start()
{ 
    if (_sample_count < _total_sample_count)
        return 0;
    else
        return _ring_sample_count;
}
 
uint64_t Snapshot::ring_end()
{ 
    if (_sample_count == 0)
        return 0;
    else if (_ring_sample_count == 0)
        return _total_sample_count - 1;
    else
        return _ring_sample_count - 1;
}

void Snapshot::capture_ended()
{
    _last_ended = true;
}

void Snapshot::set_samplerate(double samplerate)
{
    assert(samplerate > 0);
    _samplerate = samplerate;
}

} // namespace data
} // namespace dsv
/****************************************************************************
** Meta object code from reading C++ file 'spectrumstack.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "spectrumstack.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'spectrumstack.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdataSCOPESpectrumStackENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdataSCOPESpectrumStackENDCLASS = QtMocHelpers::stringData(
    "dsv::data::SpectrumStack"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdataSCOPESpectrumStackENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[25];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdataSCOPESpectrumStackENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdataSCOPESpectrumStackENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdataSCOPESpectrumStackENDCLASS = {
    {
        QT_MOC_LITERAL(0, 24)   // "dsv::data::SpectrumStack"
    },
    "dsv::data::SpectrumStack"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdataSCOPESpectrumStackENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::data::SpectrumStack::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdataSCOPESpectrumStackENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdataSCOPESpectrumStackENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdataSCOPESpectrumStackENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<SpectrumStack, std::true_type>
    >,
    nullptr
} };

void dsv::data::SpectrumStack::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *dsv::data::SpectrumStack::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::data::SpectrumStack::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdataSCOPESpectrumStackENDCLASS.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "SignalData"))
        return static_cast< SignalData*>(this);
    return QObject::qt_metacast(_clname);
}

int dsv::data::SpectrumStack::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "decodermodel.h"
#include <libsigrokdecode.h>
#include "decoderstack.h"
#include "../decode/annotation.h"
#include "../decode/rowdata.h"


using namespace boost;
using namespace std;

namespace dsv {
namespace data {

DecoderModel::DecoderModel(QObject *parent)
    : QAbstractTableModel(parent),
      _decoder_stack(NULL)
{
}

void DecoderModel::setDecoderStack(DecoderStack *decoder_stack)
{
    beginResetModel();
    _decoder_stack = decoder_stack;
    endResetModel();
}
 
int DecoderModel::rowCount(const QModelIndex & /* parent */) const
{
    if (_decoder_stack)
        return _decoder_stack->list_annotation_size();
    else
        return 100;
}
int DecoderModel::columnCount(const QModelIndex & /* parent */) const
{
    if (_decoder_stack)
        return _decoder_stack->list_rows_size();
    else
        return 1;
}

QVariant DecoderModel::data(const QModelIndex &index, int role) const
{
    if (!index.isValid())
        return QVariant();

    if (role == Qt::TextAlignmentRole) {
        return int(Qt::AlignLeft | Qt::AlignVCenter);
    } else if (role == Qt::DisplayRole) {
        if (_decoder_stack) {
            dsv::decode::Annotation ann;
            if (_decoder_stack->list_annotation(ann, index.column(), index.row())) {
                return ann.annotations().at(0);
            }
        }
    }
    return QVariant();
}

QVariant DecoderModel::headerData(int section,
                                   Qt::Orientation  orientation,
                                   int role) const
{
    if (role != Qt::DisplayRole)
        return QVariant();

    if (orientation == Qt::Vertical)
        return section;

    if (_decoder_stack) {
        QString title;
        if (_decoder_stack->list_row_title(section, title))
            return title;
    }
    return QVariant();
}

} // namespace data
} // namespace dsv
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "mathstack.h"
#include <math.h>
#include  "dsosnapshot.h"
#include  "../appcore/sigsession.h"
#include  "../view/dsosignal.h"


#define PI 3.1415

using namespace boost;
using namespace std;

namespace dsv {
namespace data {

const int MathStack::EnvelopeScalePower = 8;
const int MathStack::EnvelopeScaleFactor = 1 << EnvelopeScalePower;
const float MathStack::LogEnvelopeScaleFactor = logf(EnvelopeScaleFactor);
const uint64_t MathStack::EnvelopeDataUnit = 4*1024;	// bytes

const uint64_t MathStack::vDialValue[MathStack::vDialValueCount] = {
    1,
    2,
    5,
    10,
    20,
    50,
    100,
    200,
    500,
    1000,
    2000,
    5000,
    10000,
    20000,
    50000,
    100000,
    200000,
    500000,
    1000000,
};
const QString MathStack::vDialAddUnit[MathStack::vDialUnitCount] = {
    "mV",
    "V",
};
const QString MathStack::vDialMulUnit[MathStack::vDialUnitCount] = {
    "mV*V",
    "V*V",
};
const QString MathStack::vDialDivUnit[MathStack::vDialUnitCount] = {
    "mV/V",
    "V/V",
};

MathStack::MathStack(SigSession *session,
                     view::DsoSignal* dsoSig1,
                     view::DsoSignal* dsoSig2,
                     MathType type) :
    _session(session),
    _dsoSig1(dsoSig1),
    _dsoSig2(dsoSig2),
    _type(type),
    _sample_num(0),
    _total_sample_num(0),
    _math_state(Init),
    _envelope_en(false),
    _envelope_done(false)
{
    memset(_envelope_level, 0, sizeof(_envelope_level));
}

MathStack::~MathStack()
{
    _math.clear();
    free_envelop();
}

void MathStack::free_envelop()
{
    for(auto &e : _envelope_level) {
        if (e.samples)
            free(e.samples);
    }
    memset(_envelope_level, 0, sizeof(_envelope_level));
}

void MathStack::clear()
{
    std::lock_guard<std::mutex> lock(_mutex);
}

void MathStack::init()
{
    std::lock_guard<std::mutex> lock(_mutex);

    _sample_num = 0;
    _envelope_done = false;
}

MathStack::MathType MathStack::get_type()
{
    return _type;
}

uint64_t MathStack::get_sample_num()
{
    return _sample_num;
}

void MathStack::realloc(uint64_t num)
{
    if (num != _total_sample_num) {
        free_envelop();
        _total_sample_num = num;

        _math.resize(_total_sample_num);
        uint64_t envelop_count = _total_sample_num / EnvelopeScaleFactor;
        for (unsigned int level = 0; level < ScaleStepCount; level++) {
            envelop_count = ((envelop_count + EnvelopeDataUnit - 1) /
                    EnvelopeDataUnit) * EnvelopeDataUnit;
            _envelope_level[level].samples = (EnvelopeSample*)malloc(envelop_count * sizeof(EnvelopeSample));
            envelop_count = envelop_count / EnvelopeScaleFactor;
        }
    }
}

void MathStack::enable_envelope(bool enable)
{
    if (!_envelope_done && enable)
        append_to_envelope_level(true);
    _envelope_en = enable;
}

uint64_t MathStack::default_vDialValue()
{
    uint64_t value = 0;
    view::dslDial *dial1 = _dsoSig1->get_vDial();
    view::dslDial *dial2 = _dsoSig1->get_vDial();
    const uint64_t dial1_value = dial1->get_value() * dial1->get_factor();
    const uint64_t dial2_value = dial2->get_value() * dial2->get_factor();

    switch(_type) {
    case MATH_ADD:
    case MATH_SUB:
        value = max(dial1_value, dial2_value);
        break;
    case MATH_MUL:
        value = dial1_value * dial2_value / 1000.0;
        break;
    case MATH_DIV:
        value = dial1_value * 1000.0 / dial2_value;
        break;
    }

    for (int i = 0; i < vDialValueCount; i++) {
        if (vDialValue[i] >= value) {
            value = vDialValue[i];
            break;
        }
    }

    return value;
}

view::dslDial * MathStack::get_vDial()
{
    QVector<uint64_t> vValue;
    QVector<QString> vUnit;
    view::dslDial *dial1 = _dsoSig1->get_vDial();
    view::dslDial *dial2 = _dsoSig2->get_vDial();
    const uint64_t dial1_min = dial1->get_value(0) * dial1->get_factor();
    const uint64_t dial1_max = dial1->get_value(dial1->get_count() - 1) * dial1->get_factor();
    const uint64_t dial2_min = dial2->get_value(0) * dial2->get_factor();
    const uint64_t dial2_max = dial2->get_value(dial2->get_count() - 1) * dial2->get_factor();

    switch(_type) {
    case MATH_ADD:
    case MATH_SUB:
        for (int i = 0; i < vDialValueCount; i++) {
            if (vDialValue[i] < min(dial1_min, dial2_min))
                continue;
            vValue.append(vDialValue[i]);
            if (vDialValue[i] > max(dial1_max, dial2_max))
                break;
        }
        for(int i = 0; i < vDialUnitCount; i++)
            vUnit.append(vDialAddUnit[i]);
        break;
    case MATH_MUL:
        for (int i = 0; i < vDialValueCount; i++) {
            if (vDialValue[i] < dial1_min * dial2_min / 1000.0)
                continue;
            vValue.append(vDialValue[i]);
            if (vDialValue[i] > dial1_max * dial2_max / 1000.0)
                break;
        }
        for(int i = 0; i < vDialUnitCount; i++)
            vUnit.append(vDialMulUnit[i]);
        break;
    case MATH_DIV:
        for (int i = 0; i < vDialValueCount; i++) {
            if (vDialValue[i] < min(dial1_min * 1000.0 / dial2_max, dial2_min * 1000.0  / dial1_max))
                continue;
            vValue.append(vDialValue[i]);
            if (vDialValue[i] > max(dial1_max * 1000.0 / dial2_min, dial2_max * 1000.0 / dial1_min))
                break;
        }
        for(int i = 0; i < vDialUnitCount; i++)
            vUnit.append(vDialDivUnit[i]);
        break;
    }

    view::dslDial *vDial = new view::dslDial(vValue.count(), vDialValueStep, vValue, vUnit);
    return vDial;
}

QString MathStack::get_unit(int level)
{
    if (level >= vDialUnitCount)
    //tr
        return " ";

    QString unit;
    switch(_type) {
    case MATH_ADD:
    case MATH_SUB:
        unit = vDialAddUnit[level];
        break;
    case MATH_MUL:
        unit = vDialMulUnit[level];
        break;
    case MATH_DIV:
        unit = vDialDivUnit[level];
        break;
    }

    return unit;
}

double MathStack::get_math_scale()
{
    double scale = 0;
    switch(_type) {
    case MATH_ADD:
    case MATH_SUB:
        scale = 1.0 / DS_CONF_DSO_VDIVS;
        break;
    case MATH_MUL:
        //scale = 1.0 / (DS_CONF_DSO_VDIVS * DS_CONF_DSO_VDIVS);
        scale = 1.0 / DS_CONF_DSO_VDIVS;
        break;
    case MATH_DIV:
        scale = 1.0 / DS_CONF_DSO_VDIVS;
        break;
    }

    return scale;
}

const double* MathStack::get_math(uint64_t start)
{
    return _math.data() + start;
}

void MathStack::get_math_envelope_section(EnvelopeSection &s,
    uint64_t start, uint64_t end, float min_length)
{
    assert(end <= get_sample_num());
    assert(start <= end);
    assert(min_length > 0);

    if (!_envelope_done) {
        s.length = 0;
        return;
    }

    const unsigned int min_level = max((int)floorf(logf(min_length) /
        LogEnvelopeScaleFactor) - 1, 0);
    const unsigned int scale_power = (min_level + 1) *
        EnvelopeScalePower;
    start >>= scale_power;
    end >>= scale_power;

    s.start = start << scale_power;
    s.scale = 1 << scale_power;
    if (_envelope_level[min_level].length == 0)
        s.length = 0;
    else
        s.length = end - start;

    s.samples = _envelope_level[min_level].samples + start;
}

void MathStack::calc_math()
{
    std::lock_guard<std::mutex> lock(_mutex);

    _math_state = Running;

    const auto data = _dsoSig1->data();

    if (data->empty() || _math.size() < _total_sample_num)
        return;

    if (!_dsoSig1->enabled() || !_dsoSig2->enabled())
        return;

    if (data->get_channel_num() < 2)
        return;

    const double scale1 = _dsoSig1->get_vDialValue() / 1000.0 * _dsoSig1->get_factor() * DS_CONF_DSO_VDIVS *
                          _dsoSig1->get_scale() / _dsoSig1->get_view_rect().height();
    const double delta1 = _dsoSig1->get_hw_offset() * scale1;

    const double scale2 = _dsoSig2->get_vDialValue() / 1000.0 * _dsoSig2->get_factor() * DS_CONF_DSO_VDIVS *
                          _dsoSig2->get_scale() / _dsoSig2->get_view_rect().height();
    const double delta2 = _dsoSig2->get_hw_offset() * scale2;

    _sample_num = data->get_sample_count();
    assert(_sample_num <= _total_sample_num);

    const int index1 = _dsoSig1->get_index();
    const int index2 = _dsoSig2->get_index();
    const uint8_t* value_buffer1 = data->get_samples(0, 0, index1);
    const uint8_t* value_buffer2 = data->get_samples(0, 0, index2);
    double value1, value2;

    for (uint64_t sample = 0; sample < _sample_num; sample++) {
        value1 = *(value_buffer1 + sample);
        value2 = *(value_buffer2 + sample);

        switch(_type) {
        case MATH_ADD:
            _math[sample] = (delta1 - scale1 * value1) + (delta2 - scale2 * value2);
            break;
        case MATH_SUB:
            _math[sample] = (delta1 - scale1 * value1) - (delta2 - scale2 * value2);
            break;
        case MATH_MUL:
            _math[sample] = (delta1 - scale1 * value1) * (delta2 - scale2 * value2);
            break;
        case MATH_DIV:
            _math[sample] = (delta1 - scale1 * value1) / (delta2 - scale2 * value2);
            break;
        }
    }

    if (_envelope_en)
        append_to_envelope_level(true);

    // stop
    _math_state = Stopped;
}

void MathStack::reallocate_envelope(Envelope &e)
{
    const uint64_t new_data_length = ((e.length + EnvelopeDataUnit - 1) /
        EnvelopeDataUnit) * EnvelopeDataUnit;
    if (new_data_length > e.data_length)
    {
        e.data_length = new_data_length;
    }
}

void MathStack::append_to_envelope_level(bool header)
{
    Envelope &e0 = _envelope_level[0];
    uint64_t prev_length;
    EnvelopeSample *dest_ptr;

    if (header)
        prev_length = 0;
    else
        prev_length = e0.length;
    e0.length = _sample_num / EnvelopeScaleFactor;

    if (e0.length == 0)
        return;
    if (e0.length == prev_length)
        prev_length = 0;

    // Expand the data buffer to fit the new samples
    reallocate_envelope(e0);

    dest_ptr = e0.samples + prev_length;

    // Iterate through the samples to populate the first level mipmap
    const double *const stop_src_ptr = (double*)_math.data() +
        e0.length * EnvelopeScaleFactor;
    for (const double *src_ptr = (double*)_math.data() +
        prev_length * EnvelopeScaleFactor;
        src_ptr < stop_src_ptr; src_ptr += EnvelopeScaleFactor)
    {
        const double * begin_src_ptr =
            src_ptr;
        const double *const end_src_ptr =
            src_ptr + EnvelopeScaleFactor;

        EnvelopeSample sub_sample;
        sub_sample.min = *begin_src_ptr;
        sub_sample.max = *begin_src_ptr;
        //begin_src_ptr += _channel_num;
        while (begin_src_ptr < end_src_ptr)
        {
            sub_sample.min = min(sub_sample.min, *begin_src_ptr);
            sub_sample.max = max(sub_sample.max, *begin_src_ptr);
            begin_src_ptr ++;
        }
        *dest_ptr++ = sub_sample;
    }

    // Compute higher level mipmaps
    for (unsigned int level = 1; level < ScaleStepCount; level++)
    {
        Envelope &e = _envelope_level[level];
        const Envelope &el = _envelope_level[level-1];

        // Expand the data buffer to fit the new samples
        prev_length = e.length;
        e.length = el.length / EnvelopeScaleFactor;

        // Break off if there are no more samples to computed
//		if (e.length == prev_length)
//			break;
        if (e.length == prev_length)
            prev_length = 0;

        reallocate_envelope(e);

        // Subsample the level lower level
        const EnvelopeSample *src_ptr =
            el.samples + prev_length * EnvelopeScaleFactor;
        const EnvelopeSample *const end_dest_ptr = e.samples + e.length;
        for (dest_ptr = e.samples + prev_length;
            dest_ptr < end_dest_ptr; dest_ptr++)
        {
            const EnvelopeSample *const end_src_ptr =
                src_ptr + EnvelopeScaleFactor;

            EnvelopeSample sub_sample = *src_ptr++;
            while (src_ptr < end_src_ptr)
            {
                sub_sample.min = min(sub_sample.min, src_ptr->min);
                sub_sample.max = max(sub_sample.max, src_ptr->max);
                src_ptr++;
            }

            *dest_ptr = sub_sample;
        }
    }

    _envelope_done = true;
}

} // namespace data
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_DATA_LOGICSNAPSHOT_H
#define DSVIEW_PV_DATA_LOGICSNAPSHOT_H

#include <libsigrok.h> 
#include <QString>
#include <utility>
#include <vector>
#include <map>
#include "snapshot.h"

#define CHANNEL_MAX_COUNT 64

namespace dsv {
namespace data {

class LogicSnapshot : public Snapshot
{
private:
    static const uint64_t ScaleLevel = 4;
    static const uint64_t ScalePower = 6;
    static const uint64_t Scale = 1 << ScalePower;
    static const uint64_t ScaleSize = Scale / 8;
    static const uint64_t RootScalePower = ScalePower;
    static const uint64_t RootScale = 1 << RootScalePower;
    static const uint64_t LeafBlockSpace = (Scale + Scale*Scale +
            Scale*Scale*Scale + Scale*Scale*Scale*Scale) / 8;

    static const uint64_t LeafBlockPower = ScaleLevel*ScalePower;
    static const uint64_t LeafBlockSamples = 1 << LeafBlockPower;
    static const uint64_t RootNodeSamples = LeafBlockSamples*RootScale;

    static const uint64_t RootMask = ~(~0ULL << RootScalePower) << LeafBlockPower;
    static const uint64_t LeafMask = ~(~0ULL << LeafBlockPower);
    static const uint64_t LevelMask[ScaleLevel];
    static const uint64_t LevelOffset[ScaleLevel];

    static const uint64_t MSB =  (1ULL << (Scale - 1));
    static const uint64_t LSB =  (1ULL);

private:
    struct RootNode
    {
        uint64_t tog;
        uint64_t first;
        uint64_t last;
        void *lbp[Scale];
    };

    struct BlockIndex
    {
        uint64_t    root_index;
        uint64_t    lbp_index;
    };

public:
    typedef std::pair<uint64_t, bool> EdgePair;

private:
    void init_all();

public:
    LogicSnapshot();

	virtual ~LogicSnapshot();

    void free_data();

    void clear();

    void init();   

    void first_payload(const sr_datafeed_logic &logic, uint64_t total_sample_count, GSList *channels, bool able_free);

	void append_payload(const sr_datafeed_logic &logic);

    const uint8_t * get_samples(uint64_t start_sample, uint64_t& end_sample, int sig_index, void **lbp=NULL);

    bool get_sample(uint64_t index, int sig_index);

    void capture_ended();

    bool get_display_edges(std::vector<std::pair<bool, bool>> &edges,
                           std::vector<std::pair<uint16_t, bool>> &togs,
                           uint64_t start, uint64_t end, uint16_t width,
                           uint16_t max_togs, double pixels_offset,
                           double min_length, uint16_t sig_index);

    bool get_nxt_edge(uint64_t &index, bool last_sample, uint64_t end,
                      double min_length, int sig_index);

    bool get_pre_edge(uint64_t &index, bool last_sample,
                      double min_length, int sig_index);

    bool has_data(int sig_index);
    int get_block_num();
    uint64_t get_block_size(int block_index);
    uint8_t *get_block_buf(int block_index, int sig_index, bool &sample);
 
    bool pattern_search(int64_t start, int64_t end, int64_t& index,
                        std::map<uint16_t, QString> &pattern, bool isNext);

    inline void set_loop(bool bLoop){
        _is_loop = bLoop;
    }

    inline bool is_loop(){
        return _is_loop;
    }

    void decode_end();

    void free_decode_lpb(void *lbp);

    inline bool is_able_free(){
        return _able_free;
    } 

    inline uint64_t get_loop_offset(){
        return _loop_offset;
    }

private:
    bool get_sample_unlock(uint64_t index, int sig_index);
    bool get_sample_self(uint64_t index, int sig_index);

    bool get_nxt_edge_unlock(uint64_t &index, bool last_sample, uint64_t end,
                      double min_length, int sig_index);
    bool get_nxt_edge_self(uint64_t &index, bool last_sample, uint64_t end,
                      double min_length, int sig_index);

    bool get_pre_edge_self(uint64_t &index, bool last_sample,
                      double min_length, int sig_index);

    bool pattern_search_self(int64_t start, int64_t end, int64_t& index,
                        std::map<uint16_t, QString> &pattern, bool isNext);

    int get_ch_order(int sig_index);

    void calc_mipmap(unsigned int order, uint8_t index0, uint8_t index1, uint64_t samples, bool isEnd);

    void append_cross_payload(const sr_datafeed_logic &logic);

    bool lbp_nxt_edge(uint64_t &index, uint64_t root_index, uint64_t lbp_tog, uint8_t lbp_tog_pos,
                      bool aft_tog, uint8_t aft_pos, bool last_sample, int sig_index);

    bool block_nxt_edge(uint64_t *lbp, uint64_t &index, uint64_t block_end, bool last_sample,
                        unsigned int min_level);

    bool lbp_pre_edge(uint64_t &index, uint64_t root_index, uint64_t lbp_tog, uint8_t &lbp_tog_pos,
                      bool pre_tog, uint8_t pre_pos, bool last_sample, int sig_index);

    bool block_pre_edge(uint64_t *lbp, uint64_t &index, bool last_sample,
                        unsigned int min_level, int sig_index);

    inline uint8_t bsf_folded (uint64_t bb)
    {
        static const uint8_t lsb_64_table[64] = {
            63, 30,  3, 32, 59, 14, 11, 33,
            60, 24, 50,  9, 55, 19, 21, 34,
            61, 29,  2, 53, 51, 23, 41, 18,
            56, 28,  1, 43, 46, 27,  0, 35,
            62, 31, 58,  4,  5, 49, 54,  6,
            15, 52, 12, 40,  7, 42, 45, 16,
            25, 57, 48, 13, 10, 39,  8, 44,
            20, 47, 38, 22, 17, 37, 36, 26
        };
        unsigned int folded;
        bb ^= bb - 1;
        folded = (int) bb ^ (bb >> 32);
        return lsb_64_table[folded * 0x78291ACF >> 26];
    }

    inline uint8_t bsr32(uint32_t bb)
    {
        static const uint8_t msb_256_table[256] = {
            0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
            4, 4, 4, 4, 4, 4, 4, 4,4, 4, 4, 4,4, 4, 4, 4,
            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
            6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
            6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
            7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
            7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
            7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
            7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
       };
       uint8_t result = 0;

       if (bb > 0xFFFF) {
          bb >>= 16;
          result += 16;
       }
       if (bb > 0xFF) {
          bb >>= 8;
          result += 8;
       }

       return (result + msb_256_table[bb]);
    }

    inline uint8_t bsr64(uint64_t bb)
    {
        const uint32_t hb = bb >> 32;
        return hb ? 32 + bsr32((uint32_t)hb) : bsr32((uint32_t)bb);
    }

    void move_first_node_to_last();

    void free_head_blocks(int count);

private:
    std::vector<std::vector<struct RootNode>> _ch_data;
    uint8_t     _byte_fraction;
    uint16_t    _ch_fraction;
    uint8_t    *_dest_ptr;

    uint64_t    _last_sample[CHANNEL_MAX_COUNT];
    uint64_t    _last_calc_count[CHANNEL_MAX_COUNT];
    bool        _is_loop;
    uint64_t    _loop_offset;
    bool        _able_free;
    std::vector<void*> _free_block_list;
    struct BlockIndex _cur_ref_block_indexs[CHANNEL_MAX_COUNT];
    int         _lst_free_block_index;
};

} // namespace data
} // namespace dsv

#endif // DSVIEW_PV_DATA_LOGICSNAPSHOT_H
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "spectrumstack.h" 
#include <math.h>
#include "dsosnapshot.h"
#include "../appcore/sigsession.h"
#include "../view/dsosignal.h"

#define PI 3.1415

using namespace boost;
using namespace std;

namespace dsv {
namespace data {

const QString SpectrumStack::windows_support[5] = {
    QT_TR_NOOP("Rectangle"),
    QT_TR_NOOP("Hann"),
    QT_TR_NOOP("Hamming"),
    QT_TR_NOOP("Blackman"),
    QT_TR_NOOP("Flat_top")
};

const uint64_t SpectrumStack::length_support[5] = {
    1024,
    2048,
    4096,
    8192,
    16384,
};

SpectrumStack::SpectrumStack(SigSession *session, int index) :
    _session(session),
    _index(index),
    _dc_ignore(true),
    _sample_interval(1),
    _spectrum_state(Init),
    _fft_plan(NULL)
{
}

SpectrumStack::~SpectrumStack()
{
    _xn.clear();
    _xk.clear();
    _power_spectrum.clear();
    if (_fft_plan)
        fftw_destroy_plan(_fft_plan);
}

void SpectrumStack::clear()
{
}

void SpectrumStack::init()
{
}

int SpectrumStack::get_index()
{
    return _index;
}

uint64_t SpectrumStack::get_sample_num()
{
    return _sample_num;
}

void SpectrumStack::set_sample_num(uint64_t num)
{
    _sample_num = num;
    _xn.resize(_sample_num);
    _xk.resize(_sample_num);
    _power_spectrum.resize(_sample_num/2+1);
    _fft_plan = fftw_plan_r2r_1d(_sample_num, _xn.data(), _xk.data(),
                                 FFTW_R2HC, FFTW_ESTIMATE);
}

int SpectrumStack::get_windows_index()
{
    return _windows_index;
}

void SpectrumStack::set_windows_index(int index)
{
    _windows_index = index;
}

bool SpectrumStack::dc_ignored()
{
    return _dc_ignore;
}

void SpectrumStack::set_dc_ignore(bool ignore)
{
    _dc_ignore = ignore;
}

int SpectrumStack::get_sample_interval()
{
    return _sample_interval;
}

void SpectrumStack::set_sample_interval(int interval)
{
    _sample_interval = interval;
}

const std::vector<QString> SpectrumStack::get_windows_support()
{
    std::vector<QString> windows;
    for (size_t i = 0; i < sizeof(windows_support)/sizeof(windows_support[0]); i++)
    {
        windows.push_back(windows_support[i]);
    }
    return windows;
}

const std::vector<uint64_t> SpectrumStack::get_length_support()
{
    std::vector<uint64_t> length;
    for (size_t i = 0; i < sizeof(length_support)/sizeof(length_support[0]); i++)
    {
        length.push_back(length_support[i]);
    }
    return length;
}

const std::vector<double> SpectrumStack::get_fft_spectrum()
{
    std::vector<double> empty;
    if (_spectrum_state == Stopped)
        return _power_spectrum;
    else
        return empty;
}

double SpectrumStack::get_fft_spectrum(uint64_t index)
{
    double ret = -1;
    if (_spectrum_state == Stopped && index < _power_spectrum.size())
        ret = _power_spectrum[index];

    return ret;
}

void SpectrumStack::calc_fft()
{
    _spectrum_state = Running;
    // Get the dso data
    dsv::data::DsoSnapshot *data = NULL;
    dsv::view::DsoSignal *dsoSig = NULL;

    for(auto s : _session->get_signals()) {
        if (s->signal_type() == SR_CHANNEL_DSO) {
            dsoSig = (view::DsoSignal*)s;
            if (dsoSig->get_index() == _index && dsoSig->enabled()) {
                data = dsoSig->data();
                break;
            }
        }
    }

    if (data == NULL || data->empty())
        return;

    if (data->get_sample_count() < _sample_num * _sample_interval)
        return;

    // Get the samplerate
    _samplerate = data->samplerate();
    if (_samplerate == 0.0)
        _samplerate = 1.0;

    // prepare _xn data
    const int offset = dsoSig->get_hw_offset();
    const double vscale = dsoSig->get_vDialValue() * dsoSig->get_factor() * DS_CONF_DSO_VDIVS / (1000*255.0);
    const uint16_t step = _sample_interval;
    const uint8_t *const samples = data->get_samples(0, _sample_num*_sample_interval-1, _index);
    double wsum = 0;
    
    for (unsigned int i = 0; i < _sample_num; i++) {
        double w = window(i, _windows_index);
        _xn[i] = (samples[i*step] - offset) * vscale * w;
        wsum += w;
    }

    // fft
    fftw_execute(_fft_plan);

    // calculate power spectrum
    _power_spectrum[0] = abs(_xk[0])/wsum;  /* DC component */
    for (unsigned int k = 1; k < (_sample_num + 1) / 2; ++k)  /* (k < N/2 rounded up) */
         _power_spectrum[k] = sqrt((_xk[k]*_xk[k] + _xk[_sample_num-k]*_xk[_sample_num-k]) * 2) / wsum;
    if (_sample_num % 2 == 0) /* N is even */
         _power_spectrum[_sample_num/2] = abs(_xk[_sample_num/2])/wsum;  /* Nyquist freq. */

    _spectrum_state = Stopped;
}

double SpectrumStack::window(uint64_t i, int type)
{
    const double n_m_1 = _sample_num-1;
    switch(type) {
    case 1: // Hann window
        return 0.5*(1-cos(2*PI*i/n_m_1));
    case 2: // Hamming window
        return 0.54-0.46*cos(2*PI*i/n_m_1);
    case 3: // Blackman window
        return 0.42659-0.49656*cos(2*PI*i/n_m_1) + 0.076849*cos(4*PI*i/n_m_1);
    case 4: // Flat_top window
        return 1-1.93*cos(2*PI*i/n_m_1)+1.29*cos(4*PI*i/n_m_1)-
                 0.388*cos(6*PI*i/n_m_1)+0.028*cos(8*PI*i/n_m_1);
    default:
        return 1;
    }
}

} // namespace data
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_DATA_SNAPSHOT_H
#define DSVIEW_PV_DATA_SNAPSHOT_H

#include <mutex>
#include <vector>

namespace dsv {
namespace data {

class Snapshot
{
public:
    Snapshot(int unit_size, uint64_t total_sample_count, unsigned int channel_num);

	virtual ~Snapshot();

    virtual void clear() = 0;
    virtual void init() = 0;

	uint64_t get_sample_count();
    uint64_t get_ring_sample_count();
    uint64_t get_ring_start();
    uint64_t get_ring_end();

    inline int unit_size(){
        return _unit_size;
    }

    inline uint8_t get_unit_bytes(){
        return _unit_bytes;
    }

    inline bool memory_failed(){
        return _memory_failed;
    }

    bool empty();

    inline bool last_ended(){
        return _last_ended;
    }

    inline unsigned int get_channel_num(){
        return _channel_num;
    }

    inline bool have_data(){
        return !empty();
    }

    inline double samplerate(){
        return _samplerate; 
    }

    void set_samplerate(double samplerate);

    virtual void capture_ended();
    virtual bool has_data(int index) = 0;
    virtual int get_block_num() = 0;
    virtual uint64_t get_block_size(int block_index) = 0;
     

protected:
    virtual void free_data();

    inline uint64_t sample_count(){
        return _sample_count;
    }

    uint64_t ring_start();
    uint64_t ring_end();

protected:
    mutable std::mutex  _mutex;  
    mutable std::vector<uint16_t> _ch_index;

    uint64_t    _capacity;
    unsigned int _channel_num;
	uint64_t    _sample_count;
    uint64_t    _total_sample_count;
    uint64_t    _ring_sample_count;
	int         _unit_size;
    uint8_t     _unit_bytes;
    uint16_t    _unit_pitch;
    bool        _memory_failed;
    bool        _last_ended;
    double      _samplerate;
};

} // namespace data
} // namespace dsv

#endif // DSVIEW_PV_DATA_SNAPSHOT_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_DATA_SIGNALDATA_H
#define DSVIEW_PV_DATA_SIGNALDATA_H

#include <stdint.h>
#include <mutex>

namespace dsv {
namespace data {

class SignalData
{
public:
    SignalData();
    virtual ~SignalData() = 0;

public:
    inline double samplerate()const 
        {return _samplerate; }

    void set_samplerate(double samplerate);
    virtual void clear() = 0;
    virtual void init() = 0;

protected:
    mutable std::mutex _mutex;
    double _samplerate;
};

} // namespace data
} // namespace dsv

#endif // DSVIEW_PV_DATA_SIGNALDATA_H

/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2023 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSV_BASE_DEF_H
#define DSV_BASE_DEF_H

#ifdef _WIN32
    #define DSV_EXPORT     __declspec(dllexport)
    #define DSV_IMPORT     __declspec(dllimport)
    #define DSV_HIDDEN
#else
    #define DSV_EXPORT     __attribute__((visibility("default")))
    #define DSV_IMPORT     __attribute__((visibility("default")))
    #define DSV_HIDDEN     __attribute__((visibility("hidden")))
#endif


#define countof(x) (sizeof(x)/sizeof(x[0]))

#define begin_element(x) (&x[0])
#define end_element(x) (&x[countof(x)])

enum View_type {
    TIME_VIEW,
    FFT_VIEW,
    ALL_VIEW
};

#define DESTROY_OBJECT(p) if((p)){delete (p); p = NULL;} 
#define DESTROY_QT_OBJECT(p) if((p)){((p))->deleteLater(); p = NULL;}
#define DESTROY_QT_LATER(p) ((p))->deleteLater();

#define RELEASE_ARRAY(a)   for (auto ptr : (a)){delete ptr;} (a).clear();

#define ABS_VAL(x) ((x) > 0 ? (x) : -(x))

#define ds_max(a,b) ((a) > (b) ? (a) : (b))
#define ds_min(a,b) ((a) < (b) ? (a) : (b))

#define SESSION_FORMAT_VERSION      3
#define HEADER_FORMAT_VERSION       3

#endif/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2012 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2013 DreamSourceLab <dreamsourcelab@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */
 
#include <stdint.h>
#include <getopt.h>
#include <QApplication>
#include <QDir>
#include <QStyle> 
#include <QGuiApplication>
#include <QScreen>
#include "mystyle.h" 
#include "appcore/mainframe.h"
#include "config/appconfig.h"
#include "config.h"
#include "appcore/appcontrol.h"
#include "log.h" 
#include "ui/langresource.h"
#include <QDateTime>
#include <string>
#include <ds_types.h>

#ifdef _WIN32
#include <windows.h>
#endif 

void usage()
{
	printf(
		"Usage:\n"
		"  %s [OPTION...] [FILE] - %s\n"
		"\n"
		"Help Options:\n"
		"  -l, --loglevel                  Set log level, value between 0 to 5\n"
		"  -v, -V, --version               Show release version\n"
		"  -s, --storelog                  Save log to locale file\n"
		"  -h, -?, --help                  Show help option\n"
		"\n", DS_BIN_NAME, DS_DESCRIPTION);
}

int main(int argc, char *argv[])
{   
	//return main2();
	int ret = 0; 
	const char *open_file = NULL;
	int logLevel = -1;
	bool bStoreLog = false;

	//----------------------rebuild command param
#ifdef _WIN32
        // Under Windows, we need to manually retrieve the command-line arguments and convert them from UTF-16 to UTF-8.
        // This prevents data loss if there are any characters that wouldn't fit in the local ANSI code page.
        int argcUTF16 = 0;		
        LPWSTR* argvUTF16 = CommandLineToArgvW(GetCommandLineW(), &argcUTF16);

		std::vector<QByteArray> argvUTF8Q;
        std::for_each(argvUTF16, argvUTF16 + argcUTF16, [&argvUTF8Q](const LPWSTR& arg) {
            argvUTF8Q.emplace_back(QString::fromUtf16(reinterpret_cast<const char16_t*>(arg), -1).toUtf8());
        });

        LocalFree(argvUTF16);

        // Ms::runApplication() wants an argv-style array of raw pointers to the arguments, so let's create a vector of them.
        std::vector<char*> argvUTF8;
        for (auto& arg : argvUTF8Q){
            argvUTF8.push_back(arg.data());
		}

        // Don't use the arguments passed to main(), because they're in the local ANSI code page.
        (void*)(argc);
        (void*)(argv);

        int argcFinal = argcUTF16;
        char** argvFinal = argvUTF8.data();
    #else
        int argcFinal = argc;
        char** argvFinal = argv;
    #endif 
 
	//----------------------command param parse
	while (1) {
		static const struct option long_options[] = {
			{"loglevel", required_argument, 0, 'l'},
			{"version", no_argument, 0, 'v'},
			{"storelog", no_argument, 0, 's'},
			{"help", no_argument, 0, 'h'},
			{0, 0, 0, 0}
		};

        const char *shortopts = "l:Vvhs?";
        const int c = getopt_long(argcFinal, argvFinal, shortopts, long_options, NULL);
		if (c == -1)
			break;

		switch (c)
		{
		case 'l': // log level
			logLevel = atoi(optarg);
			break;

		case 's': // the store log flag
			bStoreLog = true;
			break;

		case 'V': // version
		case 'v':
			printf("%s %s\n", DS_TITLE, DS_VERSION_STRING);
			return 0;
 
		case 'h': // get help
		case '?':
			usage();
			return 0;
		}
	}

	if (argcFinal - optind > 1) {
		printf("Only one file can be openened.\n");
		return 1;
    } 
	else if (argcFinal - optind == 1){
        open_file = argvFinal[argcFinal - 1];		
	}

	//----------------------HightDpiScaling
#if QT_VERSION >= QT_VERSION_CHECK(5,6,0)
bool bHighScale = true;

#ifdef _WIN32
	int argc1 = 0;
 	QApplication *a1 = new QApplication(argc1, NULL);
	float sk = QGuiApplication::primaryScreen()->logicalDotsPerInch() / 96;
	int sy = QGuiApplication::primaryScreen()->size().height(); //screen rect height
    delete a1;
	a1 = NULL;

	if (sk >= 1.5 && sy <= 1080){
		QApplication::setAttribute(Qt::AA_DisableHighDpiScaling);
        QApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);
		bHighScale = false;
	} 
#endif
	if (bHighScale){
		QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
      	QApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);
	}
#endif 

	//----------------------init app
    QApplication a(argcFinal, argvFinal);
    a.setStyle(new MyStyle);

    // Set some application metadata
    QApplication::setApplicationVersion(DS_VERSION_STRING);
    QApplication::setApplicationName("DSView");
    QApplication::setOrganizationName("DreamSourceLab");
    QApplication::setOrganizationDomain("www.DreamSourceLab.com");

	//----------------------init log
	dsv::dsv_log_init(); // Don't call before QApplication be inited

	if (bStoreLog && logLevel < XLOG_LEVEL_DBG){
		logLevel = XLOG_LEVEL_DBG;
	}
	if (logLevel != -1){
		dsv::dsv_log_level(logLevel);
	}

	#ifdef DEBUG_INFO
		if (XLOG_LEVEL_INFO > logLevel){
            dsv::dsv_log_level(XLOG_LEVEL_INFO); // on develop mode, set the default log level
			logLevel = XLOG_LEVEL_INFO;
		}
	#endif

	if (bStoreLog){
		dsv::dsv_log_enalbe_logfile(true);
	} 

	auto control = dsv::appcore::AppControl::Instance();	
	dsv::config::AppConfig &app = dsv::config::AppConfig::Instance(); 
	app.LoadAll(); //load app config
	LangResource::Instance()->Load(app.frameOptions.language);

	if (app.appOptions.ableSaveLog){
		dsv::dsv_log_enalbe_logfile(app.appOptions.appendLogMode);

		if (app.appOptions.logLevel >= logLevel){
			dsv::dsv_log_level(app.appOptions.logLevel);
		}
	}

	//----------------------run
	dsv_info("----------------- version: %s-----------------", DS_VERSION_STRING);
	dsv_info("Qt:%s", QT_VERSION_STR);

	QDateTime dateTime = QDateTime::currentDateTime();
	std::string strTime = dateTime .toString("yyyy-MM-dd hh:mm:ss").toStdString();
	dsv_info("%s", strTime.c_str());

	int bit_width = sizeof(u64_t);
	if (bit_width != 8){
		dsv_err("Can only run on 64 bit systems");
		return 0;
	}
 
	//init core
	if (!control->Init()){ 
		dsv_err("init error!"); 
		return 1;
	}
	
	if (open_file != NULL){
		control->_open_file_name = open_file;
	}	

	try
	{   
		dsv::appcore::MainFrame w;
		control->Start();
		w.show(); 
		w.readSettings();
		w.show_doc();  //to show the dailog for open help document
		ret = a.exec(); //Run the application
		control->Stop();

		dsv_info("Main window closed.");
	}
	catch (const std::exception &e)
	{
        dsv_err("main() catch a except!");
		const char *exstr = e.what();
		dsv_err("%s", exstr);
	}

	control->UnInit();  //uninit
	control->Destroy();

	dsv_info("Uninit log.");

	dsv::dsv_log_uninit();
 
	return ret;
}
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef COM_DS_TIMER_H
#define COM_DS_TIMER_H

#include <QObject>
#include <functional>
#include <QTimer>
#include <chrono>

namespace dsv {
namespace com {

typedef std::function<void()> CALLBACL_FUNC;

using std::chrono::high_resolution_clock;
using std::chrono::milliseconds;

class DsTimer : protected QObject
{
     Q_OBJECT

public:
    DsTimer();

    void TimeOut(int millsec, CALLBACL_FUNC f);

    void TimeOut(int millsec);

    void SetCallback(CALLBACL_FUNC f);

    void Start(int millsec, CALLBACL_FUNC f);

    void Start(int millsec);

    void Stop(); 

    inline bool IsActived(){
        return _isActived;
    }

    long long GetActiveTimeLong();

    void ResetActiveTime();

private slots:
    void on_timeout();

private:    
    QTimer          _timer;
    bool            _binded;
    bool            _isActived;
    high_resolution_clock::time_point _beginTime;
    CALLBACL_FUNC   _call;
};

} //namespace com
} //namespace dsv

#endif
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2014 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_STORESESSION_H
#define DSVIEW_PV_STORESESSION_H

#include <stdint.h>
#include <string>
#include <thread>  
#include <QObject>
#include <libsigrok.h>
#include "../interface/icallbacks.h"
#include "zipmaker.h"

namespace dsv
{
  namespace data {
    class Snapshot;
    class LogicSnapshot;
    class AnalogSnapshot;
    class DsoSnapshot;
}
namespace appcore{
    class SigSession;
}
namespace dock {
    class ProtocolDock;
}
}

using namespace dsv::appcore;
using namespace dsv::data;
using namespace dsv::dock;

namespace dsv {
namespace com { 

class StoreSession : public QObject
{
	Q_OBJECT
  
public:
    StoreSession(SigSession *session);

	~StoreSession();

    SigSession* session();

	std::pair<uint64_t, uint64_t> progress();

	const QString& error();

    bool save_start();

    bool export_start();

	void wait();

	void cancel();

private:
    void save_proc(dsv::data::Snapshot *snapshot);
    void save_logic(dsv::data::LogicSnapshot *logic_snapshot);
    void save_analog(dsv::data::AnalogSnapshot *analog_snapshot);
    void save_dso(dsv::data::DsoSnapshot *dso_snapshot);
    bool meta_gen(data::Snapshot *snapshot, std::string &str);
    void export_proc(dsv::data::Snapshot *snapshot);   
    bool decoders_gen(std::string &str);
 

public:    
    bool gen_decoders_json(QJsonArray &array);
    bool load_decoders(dock::ProtocolDock *widget, QJsonArray &dec_array);
    QString MakeSaveFile(bool bDlg);
    QString MakeExportFile(bool bDlg);

    inline QString GetFileName()
        { return _file_name;}

    bool IsLogicDataType();
 

private:
    QList<QString> getSuportedExportFormats();
    double get_integer(GVariant * var);
    void MakeChunkName(char *chunk_name, int chunk_num, int index, int type, int version);

signals:
	void progress_updated();

public:
   ISessionDataGetter   *_sessionDataGetter;

private:
    QString         _file_name;
    QString         _suffix;
    SigSession      *_session;

	std::thread   _thread;

    const struct sr_output_module* _outModule;
 
	uint64_t        _units_stored;
	uint64_t        _unit_count;
    bool            _has_error;
	QString         _error;
    volatile bool   _canceled;
    ZipMaker        m_zipDoc;  
};

} //namespace com
} //namespace dsv

#endif // DSVIEW_PV_STORESESSION_H
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2014 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

/* __STDC_FORMAT_MACROS is required for PRIu64 and friends (in C++). */
#define __STDC_FORMAT_MACROS

#include "storesession.h"
#include <QFileDialog>
#include <QDir>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonArray>
#include <QStandardPaths>
#include <math.h>
#include <QTextStream>
#include <list>
#include <libsigrokdecode.h>

#include "../appcore/sigsession.h"
#include "../data/logicsnapshot.h"
#include "../data/dsosnapshot.h"
#include "../data/analogsnapshot.h"
#include "../data/decoderstack.h"
#include "../decode/decoder.h"
#include "../decode/row.h"
#include "../view/trace.h"
#include "../view/signal.h"
#include "../view/logicsignal.h"
#include "../view/dsosignal.h"
#include "../view/decodetrace.h"
#include "../dock/protocoldock.h" 

#ifdef _WIN32
#include <QTextCodec>
#endif
 
#include "../config/appconfig.h"
#include "../basedef.h"
#include "../utility/encoding.h"
#include "../utility/path.h"
#include "../log.h"
#include "../ui/langresource.h"

#define DEOCDER_CONFIG_VERSION  2

using namespace dsv::config;

namespace dsv {
namespace com {

StoreSession::StoreSession(SigSession *session) :
	_session(session),
    _outModule(NULL),
	_units_stored(0),
    _unit_count(0),
    _has_error(false),
    _canceled(false)
{ 
    _sessionDataGetter = NULL;
}

StoreSession::~StoreSession()
{
	wait();
}

SigSession* StoreSession::session()
{
    return _session;
}

std::pair<uint64_t, uint64_t> StoreSession::progress()
{ 
    return std::make_pair(_units_stored, _unit_count);
}

const QString& StoreSession::error()
{ 
	return _error;
}

void StoreSession::wait()
{
    if (_thread.joinable())
        _thread.join();
}

void StoreSession::cancel()
{ 
    _canceled = true; 
}

QList<QString> StoreSession::getSuportedExportFormats(){
    const struct sr_output_module** supportedModules = sr_output_list();
    QList<QString> list;
    while(*supportedModules){
        if(*supportedModules == NULL)
            break;
        if (_session->get_device()->get_work_mode() != LOGIC &&
            strcmp((*supportedModules)->id, "csv"))
            break;
        QString format((*supportedModules)->desc);
        format.append(" (*.");
        format.append((*supportedModules)->id);
        format.append(")");
        list.append(format);
        supportedModules++;
    }
    return list;
}

bool StoreSession::save_start()
{ 
    assert(_sessionDataGetter);

    std::set<int> type_set;
    for(auto s : _session->get_signals()) {
        type_set.insert(s->get_type());
    }

    if (type_set.size() > 1) {
        _error = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_STORESESS_SAVESTART_ERROR1),
                "DSView does not currently support\nfile saving for multiple data types.");
        return false;

    } else if (type_set.size() == 0) {
        _error = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_STORESESS_SAVESTART_ERROR2), "No data to save.");
        return false;
    }

    if (_file_name == ""){
        _error = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_STORESESS_SAVESTART_ERROR3), "No file name.");
        return false;
    }

    const auto snapshot = _session->get_snapshot(*type_set.begin());
	assert(snapshot);
    // Check we have data
    if (snapshot->empty()) {
        _error = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_STORESESS_SAVESTART_ERROR2), "No data to save.");
        return false;
    }

    std::string meta_data;
    std::string decoder_data;
    std::string session_data;
    
    meta_gen(snapshot, meta_data);
    decoders_gen(decoder_data);
    _sessionDataGetter->genSessionData(session_data);

    if (meta_data.empty()) {
        _error = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_STORESESS_SAVESTART_ERROR4), "Generate temp file data failed.");
        QFile::remove(_file_name);
        return false;
    }
    if (decoder_data.empty()){
        _error = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_STORESESS_SAVESTART_ERROR5), "Generate decoder file data failed.");
        QFile::remove(_file_name);
        return false;
    }
    if (session_data.empty()){
        _error = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_STORESESS_SAVESTART_ERROR6), "Generate session file data failed.");
        QFile::remove(_file_name);
        return false;
    }
   
    auto _filename = path::ConvertPath(_file_name);
    
    if (m_zipDoc.CreateNew(_filename.c_str(), false))
    {    
        if ( !m_zipDoc.AddFromBuffer("header", meta_data.c_str(), meta_data.size())
            || !m_zipDoc.AddFromBuffer("decoders", decoder_data.c_str(), decoder_data.size())
            || !m_zipDoc.AddFromBuffer("session", session_data.c_str(), session_data.size())
        )
        {
            _has_error = true;
            _error = m_zipDoc.GetError();
        }
        else
        {
            if (_thread.joinable()) _thread.join();
            _thread = std::thread(&StoreSession::save_proc, this, snapshot);
            return !_has_error;
        }
    }
    else{
         _error = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_STORESESS_SAVESTART_ERROR7), "Generate zip file failed.");
    }

    QFile::remove(_file_name);
    return false;
}

void StoreSession::save_logic(dsv::data::LogicSnapshot *logic_snapshot)
{
    char chunk_name[20] = {0};
    uint16_t to_save_probes = 0;
    bool sample;
    int ret = SR_ERR;
    int num;

    for(auto s : _session->get_signals()) {
        if (s->enabled() && logic_snapshot->has_data(s->get_index()))
            to_save_probes++;
    }

    _unit_count = logic_snapshot->get_ring_sample_count() / 8 * to_save_probes;
    num = logic_snapshot->get_block_num();

    for(auto s : _session->get_signals()) 
    {
        int ch_type = s->get_type();
        if (ch_type == SR_CHANNEL_LOGIC) {
            int ch_index = s->get_index();
            if (!s->enabled() || !logic_snapshot->has_data(ch_index))
                continue;

            for (int i = 0; !_canceled && i < num; i++) {
                uint8_t *buf = logic_snapshot->get_block_buf(i, ch_index, sample);
                uint64_t size = logic_snapshot->get_block_size(i);
                bool need_malloc = (buf == NULL);
                
                if (need_malloc) {
                    buf = (uint8_t *)malloc(size);
                    if (buf == NULL) {
                        _has_error = true;
                        _error = L_S(STR_PAGE_DLG, S_ID(IDS_MSG_STORESESS_SAVEPROC_ERROR1), 
                                    "Failed to create zip file. Malloc error.");
                    } else {
                        memset(buf, sample ? 0xff : 0x0, size);
                    }
                }
                
                MakeChunkName(chunk_name, i, ch_index, ch_type, HEADER_FORMAT_VERSION);
                ret = m_zipDoc.AddFromBuffer(chunk_name, (const char*)buf, size) ? SR_OK : -1;

                if (ret != SR_OK) {
                    if (!_has_error) {
                        _has_error = true;
                        _error = L_S(STR_PAGE_DLG, S_ID(IDS_MSG_STORESESS_SAVEPROC_ERROR2), 
                                    "Failed to create zip file. Please check write permission of this path.");
                    }
                    progress_updated();
                    if (_has_error)
                        QFile::remove(_file_name);
                    return;
                }
                _units_stored += size;

                if (_units_stored > _unit_count){
                    dsv_err("Read block data error!");
                    assert(false);
                }

                if (need_malloc)
                    free(buf);
                progress_updated();
            }
        }
    }

    progress_updated();

    if (_canceled || num == 0){
        QFile::remove(_file_name);
    }
    else {
        bool bret = m_zipDoc.Close();
        m_zipDoc.Release();

        if (!bret){
            _has_error = true;
            _error = m_zipDoc.GetError();
        }
    } 
}

void StoreSession::save_analog(dsv::data::AnalogSnapshot *analog_snapshot)
{
    char chunk_name[20] = {0};
    int num = 0;
    int ret = SR_ERR;

    int ch_type = -1;
    for(auto s : _session->get_signals()) {
        ch_type = s->get_type();
        break;
    }

    if (ch_type != -1) {
        num = analog_snapshot->get_block_num();
        _unit_count = analog_snapshot->get_sample_count() *
                        analog_snapshot->get_unit_bytes() *
                        analog_snapshot->get_channel_num();
        uint8_t *buf = NULL;
        uint8_t *buf_start = NULL;

        buf = (uint8_t *)analog_snapshot->get_data() +
                        (analog_snapshot->get_ring_start() * analog_snapshot->get_unit_bytes()
                                         * analog_snapshot->get_channel_num());

        buf_start = (uint8_t *)analog_snapshot->get_data();

        const uint8_t *buf_end = buf_start + _unit_count;

        for (int i = 0; !_canceled && i < num; i++) {
            const uint64_t size = analog_snapshot->get_block_size(i);
            if ((buf + size) > buf_end) {
                uint8_t *tmp = (uint8_t *)malloc(size);
                if (tmp == NULL) {
                    _has_error = true;
                    _error = L_S(STR_PAGE_DLG, S_ID(IDS_MSG_STORESESS_SAVEPROC_ERROR1), 
                                "Failed to create zip file. Malloc error.");
                } else {
                    memcpy(tmp, buf, buf_end-buf);
                    memcpy(tmp+(buf_end-buf), buf_start, buf+size-buf_end);
                } 

                MakeChunkName(chunk_name, i, 0, ch_type, HEADER_FORMAT_VERSION);
                ret = m_zipDoc.AddFromBuffer(chunk_name, (const char*)tmp, size) ? SR_OK : -1;

                buf += (size - _unit_count);
                if (tmp)
                    free(tmp);
            } 
            else { 
                MakeChunkName(chunk_name, i, 0, ch_type, HEADER_FORMAT_VERSION);
                ret = m_zipDoc.AddFromBuffer(chunk_name, (const char*)buf, size) ? SR_OK : -1;

                buf += size;
            }

            if (ret != SR_OK) {
                if (!_has_error) {
                    _has_error = true;
                    _error = L_S(STR_PAGE_DLG, S_ID(IDS_MSG_STORESESS_SAVEPROC_ERROR2), 
                            "Failed to create zip file. Please check write permission of this path.");
                }
                progress_updated();
                if (_has_error)
                    QFile::remove(_file_name);
                return;
            }
            _units_stored += size;
            progress_updated();
        }
    }

    progress_updated();

    if (_canceled || num == 0){
        QFile::remove(_file_name);
    }
    else {
        bool bret = m_zipDoc.Close();
        m_zipDoc.Release();

        if (!bret){
            _has_error = true;
            _error = m_zipDoc.GetError();
        }
    } 
}

void StoreSession::save_dso(dsv::data::DsoSnapshot *dso_snapshot)
{
    char chunk_name[20] = {0};
    int ret = SR_ERR; 
 
    uint64_t size = dso_snapshot->get_sample_count();
    int ch_num = dso_snapshot->get_channel_num();
    _unit_count = size * ch_num;

    for(auto s : _session->get_signals()) 
    {
        if (s->get_type() == SR_CHANNEL_DSO) {
            int ch_index = s->get_index();
 
            if (!dso_snapshot->has_data(ch_index))
                continue;

            if (_canceled)
                break;

            const uint8_t *data_buffer = dso_snapshot->get_samples(0, 0, ch_index);
        
            snprintf(chunk_name, 19, "O-%d/0", ch_index);
            ret = m_zipDoc.AddFromBuffer(chunk_name, (const char*)data_buffer, size) ? SR_OK : -1;

            if (ret != SR_OK) {
                if (!_has_error) {
                    _has_error = true;
                    _error = L_S(STR_PAGE_DLG, S_ID(IDS_MSG_STORESESS_SAVEPROC_ERROR2), 
                            "Failed to create zip file. Please check write permission of this path.");
                }
                progress_updated();
                if (_has_error)
                    QFile::remove(_file_name);
                return;
            }

            _units_stored += size;
            progress_updated();
        }
    }

    progress_updated();

    if (_canceled || size == 0 || ch_num == 0){
        QFile::remove(_file_name);
    }
    else {
        bool bret = m_zipDoc.Close();
        m_zipDoc.Release();

        if (!bret){
            _has_error = true;
            _error = m_zipDoc.GetError();
        }
    }
}

void StoreSession::save_proc(data::Snapshot *snapshot)
{
	assert(snapshot);

    data::LogicSnapshot *logic_snapshot = NULL;
    data::AnalogSnapshot *analog_snapshot = NULL;
    data::DsoSnapshot *dso_snapshot = NULL;

    if ((logic_snapshot = dynamic_cast<data::LogicSnapshot*>(snapshot))) {
        save_logic(logic_snapshot);
    }
    else if ((analog_snapshot = dynamic_cast<data::AnalogSnapshot*>(snapshot))) {
        save_analog(analog_snapshot);
    }
    else if ((dso_snapshot = dynamic_cast<data::DsoSnapshot*>(snapshot))) {
        save_dso(dso_snapshot);
    }
}

bool StoreSession::meta_gen(data::Snapshot *snapshot, std::string &str)
{
    GSList *l;
    struct sr_channel *probe;
    int probecnt;
    char *s;
    struct sr_status status;
    char meta[300] = {0};
  
    sprintf(meta, "%s", "[version]\n"); str += meta;
    sprintf(meta, "version = %d\n", HEADER_FORMAT_VERSION); str += meta;
    sprintf(meta, "%s", "[header]\n"); str += meta;

    int mode = _session->get_device()->get_work_mode();

    if (true) {
        sprintf(meta, "driver = %s\n", _session->get_device()->driver_name().toLocal8Bit().data()); str += meta;
        sprintf(meta, "device mode = %d\n", mode); str += meta;
    }
 
    sprintf(meta, "capturefile = data\n"); str += meta;
    sprintf(meta, "total samples = %" PRIu64 "\n", snapshot->get_sample_count()); str += meta;

    if (mode != LOGIC) {
        sprintf(meta, "total probes = %d\n", snapshot->get_channel_num()); str += meta;
        sprintf(meta, "total blocks = %d\n", snapshot->get_block_num()); str += meta;
    }

    data::LogicSnapshot *logic_snapshot = NULL;
    if ((logic_snapshot = dynamic_cast<data::LogicSnapshot*>(snapshot))) {
        uint16_t to_save_probes = 0;
        for (l = _session->get_device()->get_channels(); l; l = l->next) {
            probe = (struct sr_channel *)l->data;
            if (probe->enabled && logic_snapshot->has_data(probe->index))
                to_save_probes++;
        }
        sprintf(meta, "total probes = %d\n", to_save_probes); str += meta;
        sprintf(meta, "total blocks = %d\n", logic_snapshot->get_block_num()); str += meta;
    }

    s = sr_samplerate_string(_session->cur_snap_samplerate());

    sprintf(meta, "samplerate = %s\n", s); str += meta;

    uint64_t tmp_u64;
    int tmp_u8;
    uint32_t tmp_u32;

    if (mode == DSO) {
        if (_session->get_device()->get_config_uint64(SR_CONF_TIMEBASE, tmp_u64)) {
            sprintf(meta, "hDiv = %" PRIu64 "\n", tmp_u64); str += meta;
        }

        if (_session->get_device()->get_config_uint64(SR_CONF_MAX_TIMEBASE, tmp_u64)) {
            sprintf(meta, "hDiv max = %" PRIu64 "\n", tmp_u64); str += meta;
        }

        if (_session->get_device()->get_config_uint64(SR_CONF_MIN_TIMEBASE, tmp_u64)) {
            sprintf(meta, "hDiv min = %" PRIu64 "\n", tmp_u64); str += meta;
        }
 
        if (_session->get_device()->get_config_byte(SR_CONF_UNIT_BITS, tmp_u8)) {
            sprintf(meta, "bits = %d\n", tmp_u8); str += meta;
        }
 
        if (_session->get_device()->get_config_uint32(SR_CONF_REF_MIN, tmp_u32)) {
            sprintf(meta, "ref min = %d\n", tmp_u32); str += meta;
        }

        if (_session->get_device()->get_config_uint32(SR_CONF_REF_MAX, tmp_u32)) {
            sprintf(meta, "ref max = %d\n", tmp_u32); str += meta;
        }
    }
    else if (mode == LOGIC) {
        sprintf(meta, "trigger time = %lld\n", _session->get_session_time().toMSecsSinceEpoch()); str += meta;
    }
    else if (mode == ANALOG) {
        data::AnalogSnapshot *analog_snapshot = NULL;
        if ((analog_snapshot = dynamic_cast<data::AnalogSnapshot*>(snapshot))) {
            uint8_t tmp_u8 = analog_snapshot->get_unit_bytes();
            sprintf(meta, "bits = %d\n", tmp_u8*8); str += meta;
        }

        if (_session->get_device()->get_config_uint32(SR_CONF_REF_MIN, tmp_u32)) {
            sprintf(meta, "ref min = %d\n", tmp_u32); str += meta;
        }

        if (_session->get_device()->get_config_uint32(SR_CONF_REF_MAX, tmp_u32)) {
            sprintf(meta, "ref max = %d\n", tmp_u32); str += meta;
        }
    }
    sprintf(meta, "trigger pos = %" PRIu64 "\n", _session->get_trigger_pos()); str += meta;

    probecnt = 0; 

    for (l = _session->get_device()->get_channels(); l; l = l->next) {
        
        probe = (struct sr_channel *)l->data;
        
        if (!snapshot->has_data(probe->index))
            continue;

        if (mode == LOGIC && !probe->enabled)
            continue;

        if (probe->name)
        {
            int sigdex = (mode == LOGIC) ? probe->index : probecnt;
            sprintf(meta, "probe%d = %s\n", sigdex, probe->name);
            str += meta;
        }

        if (probe->trigger){
            sprintf(meta, " trigger%d = %s\n", probecnt, probe->trigger); 
            str += meta;
        }

        if (mode == DSO)
        {
            sprintf(meta, " enable%d = %d\n", probecnt, probe->enabled);
            str += meta;
            sprintf(meta, " coupling%d = %d\n", probecnt, probe->coupling);
            str += meta;
            sprintf(meta, " vDiv%d = %" PRIu64 "\n", probecnt, probe->vdiv);
            str += meta;
            sprintf(meta, " vFactor%d = %" PRIu64 "\n", probecnt, probe->vfactor);
            str += meta;
            sprintf(meta, " vOffset%d = %d\n", probecnt, probe->hw_offset);
            str += meta;
            sprintf(meta, " vTrig%d = %d\n", probecnt, probe->trig_value);
            str += meta;

            if (_session->get_device()->get_device_status(status, false))
            {
                if (probe->index == 0)
                {
                    sprintf(meta, " period%d = %" PRIu32 "\n", probecnt, status.ch0_cyc_tlen);
                    str += meta;
                    sprintf(meta, " pcnt%d = %" PRIu32 "\n", probecnt, status.ch0_cyc_cnt);
                    str += meta;
                    sprintf(meta, " max%d = %d\n", probecnt, status.ch0_max);
                    str += meta;
                    sprintf(meta, " min%d = %d\n", probecnt, status.ch0_min);
                    str += meta;
                    sprintf(meta, " plen%d = %" PRIu32 "\n", probecnt, status.ch0_cyc_plen);
                    str += meta;
                    sprintf(meta, " llen%d = %" PRIu32 "\n", probecnt, status.ch0_cyc_llen);
                    str += meta;
                    sprintf(meta, " level%d = %d\n", probecnt, status.ch0_level_valid);
                    str += meta;
                    sprintf(meta, " plevel%d = %d\n", probecnt, status.ch0_plevel);
                    str += meta;
                    sprintf(meta, " low%d = %" PRIu32 "\n", probecnt, status.ch0_low_level);
                    str += meta;
                    sprintf(meta, " high%d = %" PRIu32 "\n", probecnt, status.ch0_high_level);
                    str += meta;
                    sprintf(meta, " rlen%d = %" PRIu32 "\n", probecnt, status.ch0_cyc_rlen);
                    str += meta;
                    sprintf(meta, " flen%d = %" PRIu32 "\n", probecnt, status.ch0_cyc_flen);
                    str += meta;
                    sprintf(meta, " rms%d = %" PRIu64 "\n", probecnt, status.ch0_acc_square);
                    str += meta;
                    sprintf(meta, " mean%d = %" PRIu32 "\n", probecnt, status.ch0_acc_mean);
                    str += meta;
                }
                else
                {
                    sprintf(meta, " period%d = %" PRIu32 "\n", probecnt, status.ch1_cyc_tlen);
                    str += meta;
                    sprintf(meta, " pcnt%d = %" PRIu32 "\n", probecnt, status.ch1_cyc_cnt);
                    str += meta;
                    sprintf(meta, " max%d = %d\n", probecnt, status.ch1_max);
                    str += meta;
                    sprintf(meta, " min%d = %d\n", probecnt, status.ch1_min);
                    str += meta;
                    sprintf(meta, " plen%d = %" PRIu32 "\n", probecnt, status.ch1_cyc_plen);
                    str += meta;
                    sprintf(meta, " llen%d = %" PRIu32 "\n", probecnt, status.ch1_cyc_llen);
                    str += meta;
                    sprintf(meta, " level%d = %d\n", probecnt, status.ch1_level_valid);
                    str += meta;
                    sprintf(meta, " plevel%d = %d\n", probecnt, status.ch1_plevel);
                    str += meta;
                    sprintf(meta, " low%d = %" PRIu32 "\n", probecnt, status.ch1_low_level);
                    str += meta;
                    sprintf(meta, " high%d = %" PRIu32 "\n", probecnt, status.ch1_high_level);
                    str += meta;
                    sprintf(meta, " rlen%d = %" PRIu32 "\n", probecnt, status.ch1_cyc_rlen);
                    str += meta;
                    sprintf(meta, " flen%d = %" PRIu32 "\n", probecnt, status.ch1_cyc_flen);
                    str += meta;
                    sprintf(meta, " rms%d = %" PRIu64 "\n", probecnt, status.ch1_acc_square);
                    str += meta;
                    sprintf(meta, " mean%d = %" PRIu32 "\n", probecnt, status.ch1_acc_mean);
                    str += meta;
                }
            }
        }
        else if (mode == ANALOG)
        {
            sprintf(meta, " enable%d = %d\n", probecnt, probe->enabled);
            str += meta;
            sprintf(meta, " coupling%d = %d\n", probecnt, probe->coupling);
            str += meta;
            sprintf(meta, " vDiv%d = %" PRIu64 "\n", probecnt, probe->vdiv);
            str += meta;
            sprintf(meta, " vOffset%d = %d\n", probecnt, probe->hw_offset);
            str += meta;
            sprintf(meta, " mapUnit%d = %s\n", probecnt, probe->map_unit);
            str += meta;
            sprintf(meta, " mapMax%d = %lf\n", probecnt, probe->map_max);
            str += meta;
            sprintf(meta, " mapMin%d = %lf\n", probecnt, probe->map_min);
            str += meta;
        }
        probecnt++;
    } 

    return true;
}

//export as csv file
bool StoreSession::export_start()
{
    std::set<int> type_set;
    for(auto s : _session->get_signals()) {
        int _tp = s->get_type();
        type_set.insert(_tp);
    }

    if (type_set.size() > 1) {
        _error = L_S(STR_PAGE_DLG, S_ID(IDS_MSG_STORESESS_EXPORTSTART_ERROR1), 
                "DSView does not currently support\nfile export for multiple data types.");
        return false;
    } else if (type_set.size() == 0) {
        _error = L_S(STR_PAGE_DLG, S_ID(IDS_MSG_STORESESS_EXPORTSTART_ERROR2), "No data to save.");
        return false;
    }

    const auto snapshot = _session->get_snapshot(*type_set.begin());
    assert(snapshot);
    // Check we have data
    if (snapshot->empty()) {
        _error = L_S(STR_PAGE_DLG, S_ID(IDS_MSG_STORESESS_EXPORTSTART_ERROR2), "No data to save.");
        return false;
    }

    if (_file_name == ""){
        _error = L_S(STR_PAGE_DLG, S_ID(IDS_MSG_STORESESS_EXPORTSTART_ERROR3), "No set file name.");
        return false;
    }

    const struct sr_output_module **supportedModules = sr_output_list();
    while (*supportedModules)
    {
        if (*supportedModules == NULL)
            break;
        if (!strcmp((*supportedModules)->id, _suffix.toUtf8().data()))
        {
            _outModule = *supportedModules;
            break;
        }
        supportedModules++;
    }

    if (_outModule == NULL)
    {
        _error = L_S(STR_PAGE_DLG, S_ID(IDS_MSG_STORESESS_EXPORTSTART_ERROR4), "Invalid export format.");
    }
    else
    {
        if (_thread.joinable()) _thread.join();
        _thread = std::thread(&StoreSession::export_proc, this, snapshot);
        return !_has_error;
    }

    _error.clear();
    return false;
}

void StoreSession::export_proc(data::Snapshot *snapshot)
{
    assert(snapshot);

        //set export all data flag
    AppConfig &app = AppConfig::Instance();
    int origin_flag = app.appOptions.originalData ? 1 : 0;

    data::LogicSnapshot *logic_snapshot = NULL;
    data::AnalogSnapshot *analog_snapshot = NULL;
    data::DsoSnapshot *dso_snapshot = NULL;
    int channel_type;

    if ((logic_snapshot = dynamic_cast<data::LogicSnapshot*>(snapshot))) {
        channel_type = SR_CHANNEL_LOGIC;
    } else if ((dso_snapshot = dynamic_cast<data::DsoSnapshot*>(snapshot))) {
        channel_type = SR_CHANNEL_DSO;
    } else if ((analog_snapshot = dynamic_cast<data::AnalogSnapshot*>(snapshot))) {
        channel_type = SR_CHANNEL_ANALOG;
    } else {
        _has_error = true;
        _error = L_S(STR_PAGE_DLG, S_ID(IDS_MSG_STORESESS_EXPORTPROC_ERROR1), "data type don't support.");
        return;
    }

    GHashTable *params = g_hash_table_new(g_str_hash, g_str_equal);
    GVariant* filenameGVariant = g_variant_new_bytestring(_file_name.toUtf8().data());
    g_hash_table_insert(params, (char*)"filename", filenameGVariant);
    GVariant* typeGVariant = g_variant_new_int16(channel_type);
    g_hash_table_insert(params, (char*)"type", typeGVariant);

    struct sr_output output;
    output.module = (sr_output_module*) _outModule;
    output.sdi = _session->get_device()->inst();
    output.param = NULL;

    if(_outModule->init){
       if(_outModule->init(&output, params) != SR_OK){
        dsv_err("Failed to init export module.");
        return;
       }
    }

    QFile file(_file_name);
    file.open(QIODevice::WriteOnly | QIODevice::Text);
    QTextStream out(&file); 
    encoding::set_utf8(out);
    //out.setGenerateByteOrderMark(true);  // UTF-8 without BOM

    // Meta
    GString *data_out;
    struct sr_datafeed_packet p;
    struct sr_datafeed_meta meta;
    struct sr_config *src;

    src = _session->get_device()->new_config(SR_CONF_SAMPLERATE,
                g_variant_new_uint64(_session->cur_snap_samplerate()));

    meta.config = g_slist_append(NULL, src);

    src = _session->get_device()->new_config(SR_CONF_LIMIT_SAMPLES,
                g_variant_new_uint64(snapshot->get_sample_count()));

    meta.config = g_slist_append(meta.config, src);

    GVariant *gvar;
    int bits=0;

    _session->get_device()->get_config_byte(SR_CONF_UNIT_BITS, bits);

    gvar = _session->get_device()->get_config(SR_CONF_REF_MIN);
    if (gvar != NULL) {
        src = _session->get_device()->new_config(SR_CONF_REF_MIN, gvar);
        g_variant_unref(gvar);
    } 
    else {
        src = _session->get_device()->new_config(SR_CONF_REF_MIN, g_variant_new_uint32(1));
    }

    meta.config = g_slist_append(meta.config, src);

    gvar = _session->get_device()->get_config(SR_CONF_REF_MAX);
    if (gvar != NULL) {
        src = _session->get_device()->new_config(SR_CONF_REF_MAX, gvar);
        g_variant_unref(gvar);
    }
    else {
        src = _session->get_device()->new_config(SR_CONF_REF_MAX, g_variant_new_uint32((1 << bits) - 1));
    }
    meta.config = g_slist_append(meta.config, src);

    p.type = SR_DF_META;
    p.status = SR_PKT_OK;
    p.payload = &meta;
    p.bExportOriginalData = 0;
    _outModule->receive(&output, &p, &data_out);
    if(data_out){
        out << QString::fromUtf8((char*) data_out->str);
        g_string_free(data_out,TRUE);
    }
    for (GSList *l = meta.config; l; l = l->next) {
        src = (struct sr_config *)l->data;
        _session->get_device()->free_config(src);
    }
    g_slist_free(meta.config);

    if (channel_type == SR_CHANNEL_LOGIC) {
        _unit_count = logic_snapshot->get_ring_sample_count();
        int blk_num = logic_snapshot->get_block_num();
        bool sample;
        std::vector<uint8_t *> buf_vec;
        std::vector<bool> buf_sample;

        for (int blk = 0; !_canceled  &&  blk < blk_num; blk++) {
            uint64_t buf_sample_num = logic_snapshot->get_block_size(blk) * 8;
            buf_vec.clear();
            buf_sample.clear();

            for(auto s : _session->get_signals()) {
                int ch_type = s->get_type();
                if (ch_type == SR_CHANNEL_LOGIC) {
                    int ch_index = s->get_index();
                    if (!logic_snapshot->has_data(ch_index))
                        continue;
                    uint8_t *buf = logic_snapshot->get_block_buf(blk, ch_index, sample);
                    buf_vec.push_back(buf);
                    buf_sample.push_back(sample);
                }
            }

            uint16_t unitsize = ceil(buf_vec.size() / 8.0);
            unsigned int usize = 8192;
            unsigned int size = usize;
            struct sr_datafeed_logic lp;

            for(uint64_t i = 0; !_canceled && i < buf_sample_num; i+=usize){
                if(buf_sample_num - i < usize)
                    size = buf_sample_num - i;
                uint8_t *xbuf = (uint8_t *)malloc(size * unitsize);
                if (xbuf == NULL) {
                    _has_error = true;
                    _error = L_S(STR_PAGE_DLG, S_ID(IDS_MSG_STORESESS_EXPORTPROC_ERROR2), "xbuffer malloc failed.");
                    return;
                }                
                memset(xbuf, 0, size * unitsize);

                for (uint64_t j = 0; j < size; j++) {
                    for (unsigned int k = 0; k < buf_vec.size(); k++) {
                        if (buf_vec[k] == NULL && buf_sample[k])
                            xbuf[j*unitsize+k/8] +=  1 << k%8;
                        else if (buf_vec[k] && (buf_vec[k][(i+j)/8] & (1 << j%8)))
                            xbuf[j*unitsize+k/8] +=  1 << k%8;
                    }
                }

                lp.data = xbuf;
                lp.length = size * unitsize;
                lp.unitsize = unitsize;
                p.type = SR_DF_LOGIC;
                p.status = SR_PKT_OK;
                p.payload = &lp;
                p.bExportOriginalData = origin_flag;
                _outModule->receive(&output, &p, &data_out);

                if(data_out){
                    out << QString::fromUtf8((char*) data_out->str);
                    g_string_free(data_out,TRUE);
                }

                _units_stored += size;
                if (xbuf)
                    free(xbuf);
                progress_updated();
            }
        }

    } else if (channel_type == SR_CHANNEL_DSO) {
        _unit_count = snapshot->get_sample_count(); 
        unsigned int usize = 8192;
        unsigned int size = usize;
        struct sr_datafeed_dso dp; 

        uint8_t *ch_data_buffer = (uint8_t*)malloc(usize * dso_snapshot->get_channel_num() + 1);
        if (ch_data_buffer == NULL){
            dsv_err("StoreSession::export_proc, malloc failed.");
            return;
        }

        int ch_num = dso_snapshot->get_channel_num();

        for(uint64_t i = 0; !_canceled && i < _unit_count; i+=usize){
            if(_unit_count - i < usize)
                size = _unit_count - i;

            // Make the cross data buffer.
            for (int ch=0; ch<ch_num; ch++)
            {
                uint8_t *wr = ch_data_buffer + ch;
                const uint8_t *rd = dso_snapshot->get_samples(0,0, ch) + i;
                const uint8_t *rd_end = rd + size;
                
                while (rd < rd_end)
                {
                    *wr = *rd;                     
                    wr += ch_num;
                    rd++;
                }
            }

            dp.data = ch_data_buffer;
            dp.num_samples = size;
            p.type = SR_DF_DSO;
            p.status = SR_PKT_OK;
            p.payload = &dp;
            p.bExportOriginalData = 0;
            _outModule->receive(&output, &p, &data_out);

            if(data_out){
                out << (char*) data_out->str;
                g_string_free(data_out,TRUE);
            }

            _units_stored += size;
            progress_updated();
        }

        if (ch_data_buffer){
            free(ch_data_buffer);
            ch_data_buffer = NULL;
        }

    } else if (channel_type == SR_CHANNEL_ANALOG) {
        _unit_count = snapshot->get_sample_count();
        unsigned char* datat = (unsigned char*)analog_snapshot->get_data();
        unsigned int usize = 8192;
        unsigned int size = usize;
        struct sr_datafeed_analog ap;

        for(uint64_t i = 0; !_canceled && i < _unit_count; i+=usize){
            if(_unit_count - i < usize)
                size = _unit_count - i;
            ap.data = &datat[i*snapshot->get_channel_num()];
            ap.num_samples = size;
            p.type = SR_DF_ANALOG;
            p.status = SR_PKT_OK;
            p.payload = &ap;
            p.bExportOriginalData = 0;
            _outModule->receive(&output, &p, &data_out);
            if(data_out){
                out << (char*) data_out->str;
                g_string_free(data_out,TRUE);
            }

            _units_stored += size;
            progress_updated();
        }
    }

    // optional, as QFile destructor will already do it:
    file.close();
    _outModule->cleanup(&output);
    g_hash_table_destroy(params);
    if (filenameGVariant != NULL)
        g_variant_unref(filenameGVariant);

    progress_updated();
}

 
bool StoreSession::decoders_gen(std::string &str)
{  
    QJsonArray dec_array;
    if (!gen_decoders_json(dec_array))
        return false;
    QJsonDocument sessionDoc(dec_array);
    QString data = QString::fromUtf8(sessionDoc.toJson()); 
    str = std::string(data.toLocal8Bit().data());
    return true;
}

bool StoreSession::gen_decoders_json(QJsonArray &array)
{  
    for(auto s : _session->get_decode_signals()) {
        QJsonObject dec_obj;
        QJsonArray stack_array;
        QJsonObject show_obj;
        const auto &stack = s->decoder();
        const auto &decoderList = stack->stack();

        for(auto dec : decoderList) 
        {
            QJsonArray ch_array;
            const srd_decoder *const d = dec->decoder();;
            const bool have_probes = (d->channels || d->opt_channels) != 0;

            if (have_probes) {
                for(auto it = dec->channels().begin();it != dec->channels().end(); it++) {
                    QJsonObject ch_obj;
                    ch_obj[(*it).first->id] = QJsonValue::fromVariant((*it).second);
                    ch_array.push_back(ch_obj);
                }
            }

            QJsonObject options_obj;
            auto dec_binding = new prop::binding::DecoderOptions(stack, dec);

            for (GSList *l = d->options; l; l = l->next)
            {
                const srd_decoder_option *const opt =
                    (srd_decoder_option*)l->data;

                if (g_variant_is_of_type(opt->def, G_VARIANT_TYPE("d"))) {
                    GVariant *const var = dec_binding->getter(opt->id);
                    if (var != NULL) {
                        options_obj[opt->id] = QJsonValue::fromVariant(g_variant_get_double(var));
                        g_variant_unref(var);
                    }
                } else if (g_variant_is_of_type(opt->def, G_VARIANT_TYPE("x"))) {
                    GVariant *const var = dec_binding->getter(opt->id);
                    if (var != NULL) {
                        options_obj[opt->id] = QJsonValue::fromVariant(get_integer(var));
                        g_variant_unref(var);
                    }
                } else if (g_variant_is_of_type(opt->def, G_VARIANT_TYPE("s"))) {
                    GVariant *const var = dec_binding->getter(opt->id);
                    if (var != NULL) {
                        const char *sz = g_variant_get_string(var, NULL);
                        options_obj[opt->id] = QJsonValue::fromVariant(QString(sz));
                        g_variant_unref(var);
                    }
                }else {
                    continue;
                }
            }

            if (have_probes) {
                dec_obj["id"] = QJsonValue::fromVariant(QString(d->id));
                dec_obj["channel"] = ch_array;
                dec_obj["options"] = options_obj;
            } else {
                QJsonObject stack_obj;
                stack_obj["id"] = QJsonValue::fromVariant(QString(d->id));
                stack_obj["options"] = options_obj;
                stack_array.push_back(stack_obj);
            }
            show_obj[d->id] = QJsonValue::fromVariant(dec->shown());
        }
        
        dec_obj["version"] = DEOCDER_CONFIG_VERSION;
        dec_obj["label"] = QString(s->get_name().toUtf8().data());
        dec_obj["stacked decoders"] = stack_array;
        dec_obj["view_index"] = s->get_view_index();

        auto rows = stack->get_rows_gshow();
        for (auto i = rows.begin(); i != rows.end(); i++) {
            dsv::decode::Row _row = (*i).first;
            QString kn = _row.title_id();
            show_obj[kn] = QJsonValue::fromVariant((*i).second);
        }
        dec_obj["show"] = show_obj;

        array.push_back(dec_obj);
    }

    return true;
}

bool StoreSession::load_decoders(dock::ProtocolDock *widget, QJsonArray &dec_array)
{
    if (_session->get_device()->get_work_mode() != LOGIC)
    {
        dsv_info("StoreSession::load_decoders(), is not LOGIC mode.");
        return false;
    }

    if (dec_array.isEmpty()){
        dsv_info("StoreSession::load_decoders(), json object array is empty.");
        return false;
    }

    int dec_index = -1;
    
    for (const QJsonValue &dec_value : dec_array)
    {
        QJsonObject dec_obj = dec_value.toObject(); 
        std::vector<view::DecodeTrace*> &pre_dsigs = _session->get_decode_signals();
        std::list<dsv::decode::Decoder*> sub_decoders;

        //get sub decoders
        if (dec_obj.contains("stacked decoders")) {
                for(const QJsonValue &value : dec_obj["stacked decoders"].toArray()) {
                    QJsonObject stacked_obj = value.toObject();

                    GSList *dl = g_slist_copy((GSList*)srd_decoder_list());
                    for(; dl; dl = dl->next) {
                        const srd_decoder *const d = (srd_decoder*)dl->data;
                        assert(d);

                        if (QString::fromUtf8(d->id) == stacked_obj["id"].toString()) {
                            sub_decoders.push_back(new decode::Decoder(d));
                            break;
                        }
                    }
                    g_slist_free(dl);
                }
        }

        //create protocol
        bool ret = widget->add_protocol_by_id(dec_obj["id"].toString(), true, sub_decoders);
        if (!ret)
        {
            for(auto sub : sub_decoders){
                delete sub;
            }
            sub_decoders.clear();

            continue; //protocol is not exists;
        }

        dec_index++;

        if (dec_obj.contains("label")){
            _session->set_decoder_row_label(dec_index, dec_obj["label"].toString());    
        }

        if (dec_obj.contains("view_index")){
            int chan_view_index = dec_obj["view_index"].toInt();
            _session->get_decoder_trace(dec_index)->set_view_index(chan_view_index);
        }

        std::list<int> bind_indexs;

        std::vector<view::DecodeTrace*> &aft_dsigs = _session->get_decode_signals();

        if (aft_dsigs.size() >= pre_dsigs.size()) {
            const GSList *l;
            
            auto new_dsig = aft_dsigs.back();
            auto stack = new_dsig->decoder();
 
            auto &decoder_list = stack->stack();

            for(auto dec : decoder_list) 
            {
                const srd_decoder *const d = dec->decoder();
                QJsonObject options_obj;

                if (dec == decoder_list.front()) {
                    std::map<const srd_channel*, int> probe_map;
                    // Load the mandatory channels
                    for(l = d->channels; l; l = l->next) {
                        const struct srd_channel *const pdch = (struct srd_channel *)l->data;

                        for (const QJsonValue &value : dec_obj["channel"].toArray()) {
                            QJsonObject ch_obj = value.toObject();
                            if (ch_obj.contains(pdch->id)) {
                                int bind_chan = ch_obj[pdch->id].toInt();
                                probe_map[pdch] = bind_chan;

                                auto fd_it = find(bind_indexs.begin(), bind_indexs.end(), bind_chan);
                                if (fd_it == bind_indexs.end())
                                    bind_indexs.push_back(bind_chan);
                                break;
                            }
                        }
                    }

                    // Load the optional channels
                    for(l = d->opt_channels; l; l = l->next) {
                        const struct srd_channel *const pdch = (struct srd_channel *)l->data;

                        for (const QJsonValue &value : dec_obj["channel"].toArray()) {
                            QJsonObject ch_obj = value.toObject();
                            if (ch_obj.contains(pdch->id)) {
                                int bind_chan = ch_obj[pdch->id].toInt();
                                probe_map[pdch] = bind_chan;

                                auto fd_it = find(bind_indexs.begin(), bind_indexs.end(), bind_chan);
                                if (fd_it == bind_indexs.end())
                                    bind_indexs.push_back(bind_chan);
                                break;
                            }
                        }
                    }
                    dec->set_probes(probe_map);
                    options_obj = dec_obj["options"].toObject();
                }
                else {
                    for(const QJsonValue &value : dec_obj["stacked decoders"].toArray()) {
                        QJsonObject stacked_obj = value.toObject();
                        if (QString::fromUtf8(d->id) == stacked_obj["id"].toString()) {
                            options_obj = stacked_obj["options"].toObject();
                            break;
                        }
                    }
                }

                for (l = d->options; l; l = l->next) {
                    const srd_decoder_option *const opt = (srd_decoder_option*)l->data;

                    if (options_obj.contains(opt->id)) 
                    {
                        GVariant *new_value = NULL;
                        // When the numberic value is a string, it got zero always,
                        // so must convert from string.
                        QString vs = options_obj[opt->id].toString();

                        if (g_variant_is_of_type(opt->def, G_VARIANT_TYPE("d"))) 
                        {
                            double vi = options_obj[opt->id].toDouble();
                            if (vs != "") vi = vs.toDouble();
                            new_value = g_variant_new_double(vi);
                        }
                        else if (g_variant_is_of_type(opt->def, G_VARIANT_TYPE("x"))) {
                            const GVariantType *const type = g_variant_get_type(opt->def);

                            if (g_variant_type_equal(type, G_VARIANT_TYPE_BYTE)){
                                int vi = options_obj[opt->id].toInt();                               
                                if (vs != "") vi = vs.toInt();
                                new_value = g_variant_new_byte(vi);
                            }
                            else if (g_variant_type_equal(type, G_VARIANT_TYPE_INT16)){
                                int vi = options_obj[opt->id].toInt();                               
                                if (vs != "") vi = vs.toInt();
                                new_value = g_variant_new_int16(vi);
                            }
                            else if (g_variant_type_equal(type, G_VARIANT_TYPE_UINT16)){
                                int vi = options_obj[opt->id].toInt();                               
                                if (vs != "") vi = vs.toInt();
                                new_value = g_variant_new_uint16(vi);
                            }
                            else if (g_variant_type_equal(type, G_VARIANT_TYPE_INT32)){
                                int vi = options_obj[opt->id].toInt();                               
                                if (vs != "") vi = vs.toInt();
                                new_value = g_variant_new_int32(vi);
                            }
                            else if (g_variant_type_equal(type, G_VARIANT_TYPE_UINT32)){
                                int vi = options_obj[opt->id].toInt();                               
                                if (vs != "") vi = vs.toInt();
                                new_value = g_variant_new_uint32(vi);
                            }
                            else if (g_variant_type_equal(type, G_VARIANT_TYPE_INT64)){
                                int vi = options_obj[opt->id].toInt();                               
                                if (vs != "") vi = vs.toInt();
                                new_value = g_variant_new_int64(vi);
                            }
                            else if (g_variant_type_equal(type, G_VARIANT_TYPE_UINT64)){
                                int vi = options_obj[opt->id].toInt();                               
                                if (vs != "") vi = vs.toInt();
                                new_value = g_variant_new_uint64(vi);
                            }
                        }
                        else if (g_variant_is_of_type(opt->def, G_VARIANT_TYPE("s"))) {
                            new_value = g_variant_new_string(vs.toUtf8().data());
                        }

                        if (new_value != NULL){
                            dec->set_option(opt->id, new_value);
                        }
                    }
                }
                dec->commit();

                if (dec_obj.contains("show")) {
                    QJsonObject show_obj = dec_obj["show"].toObject();
                    if (show_obj.contains(d->id)) {
                        dec->show(show_obj[d->id].toBool());
                    }
                }
            }

            // Restore the binded channel index
            if (bind_indexs.size() > 0){
                auto dec_trace = _session->get_decoder_trace(dec_index);
                if (dec_trace != NULL)
                    dec_trace->set_index_list(bind_indexs);
            }

            int decoder_cfg_version = -1;

            if (dec_obj.contains("version")){
                decoder_cfg_version = dec_obj["version"].toInt();
            }

            if (dec_obj.contains("show")) {
                QJsonObject show_obj = dec_obj["show"].toObject();
                std::map<const dsv::decode::Row, bool> rows = stack->get_rows_gshow();

                for (auto i = rows.begin();i != rows.end(); i++) {
                    QString key;

                    if (decoder_cfg_version == -1)
                        key = (*i).first.title();
                    else
                        key = (*i).first.title_id();

                    if (show_obj.contains(key)) {
                        bool bShow = show_obj[key].toBool();
                        const dsv::decode::Row r = (*i).first;
                        stack->set_rows_gshow(r, bShow);
                    }
                }
            }
        }
    }

    return true;
}
 

double StoreSession::get_integer(GVariant *var)
{
    double val = 0;
    const GVariantType *const type = g_variant_get_type(var);
    assert(type);

    if (g_variant_type_equal(type, G_VARIANT_TYPE_BYTE))
        val = g_variant_get_byte(var);
    else if (g_variant_type_equal(type, G_VARIANT_TYPE_INT16))
        val = g_variant_get_int16(var);
    else if (g_variant_type_equal(type, G_VARIANT_TYPE_UINT16))
        val = g_variant_get_uint16(var);
    else if (g_variant_type_equal(type, G_VARIANT_TYPE_INT32))
        val = g_variant_get_int32(var);
    else if (g_variant_type_equal(type, G_VARIANT_TYPE_UINT32))
        val = g_variant_get_uint32(var);
    else if (g_variant_type_equal(type, G_VARIANT_TYPE_INT64))
        val = g_variant_get_int64(var);
    else if (g_variant_type_equal(type, G_VARIANT_TYPE_UINT64))
        val = g_variant_get_uint64(var);
    else
        assert(false);

    return val;
}

QString StoreSession::MakeSaveFile(bool bDlg)
{
    QString default_name;

    AppConfig &app = AppConfig::Instance(); 
    if (app.userHistory.saveDir != "")
    {
        default_name = app.userHistory.saveDir + "/"  + _session->get_device()->name() + "-";
    } 
    else{
        QDir _dir;
        QString _root = _dir.home().path();                
        default_name =  _root + "/" + _session->get_device()->name() + "-";
    } 

    for (const GSList *l = _session->get_device()->get_device_mode_list(); l; l = l->next) 
    {
        const sr_dev_mode *mode = (const sr_dev_mode *)l->data;
        if (_session->get_device()->get_work_mode() == mode->mode) {
            default_name += mode->acronym;
            break;
        }
    }

    default_name += _session->get_session_time().toString("-yyMMdd-hhmmss");

    // Show the dialog
    if (bDlg)
    {
        default_name = QFileDialog::getSaveFileName(
            NULL,
            L_S(STR_PAGE_MSG, S_ID(IDS_MSG_SAVE_FILE),"Save File"),
            default_name,
            //tr
            "DSView Data (*.dsl)");

        if (default_name.isEmpty())
        {
            return ""; //no select file
        }

        QString _dir_path = path::GetDirectoryName(default_name);

        if (_dir_path != app.userHistory.saveDir)
        {
            app.userHistory.saveDir = _dir_path;
            app.SaveHistory();
        }
    }

    QFileInfo f(default_name);
    if (f.suffix().compare("dsl"))
    {
        //Tr
        default_name.append(".dsl");
    }
    _file_name = default_name;
    return default_name;     
}

QString StoreSession::MakeExportFile(bool bDlg)
{
    QString default_name;
    AppConfig &app = AppConfig::Instance();  
    
    if (app.userHistory.exportDir != "")
    {
        default_name = app.userHistory.exportDir  + "/"  + _session->get_device()->name() + "-";
    } 
    else{
        QDir _dir;
        QString _root = _dir.home().path();    
        default_name =  _root + "/" + _session->get_device()->name() + "-";
    }  

    for (const GSList *l = _session->get_device()->get_device_mode_list(); l; l = l->next) {
        const sr_dev_mode *mode = (const sr_dev_mode *)l->data;
        if (_session->get_device()->get_work_mode() == mode->mode) {
            default_name += mode->acronym;
            break;
        }
    }
    default_name += _session->get_session_time().toString("-yyMMdd-hhmmss");

    //ext name
    QList<QString> supportedFormats = getSuportedExportFormats();
    QString filter;
    for(int i = 0; i < supportedFormats.count();i++){
        filter.append(supportedFormats[i]);
        if(i < supportedFormats.count() - 1)
            filter.append(";;");
    }

    QString selfilter;
    if (app.userHistory.exportFormat != "" 
            && _session->get_device()->get_work_mode() == LOGIC){
        selfilter.append(app.userHistory.exportFormat);
    }
    else{
        selfilter.append(".csv");
    }

    if (bDlg)
    {
        default_name = QFileDialog::getSaveFileName(
            NULL,
            L_S(STR_PAGE_MSG, S_ID(IDS_MSG_EXPORT_DATA),"Export Data"),
            default_name,
            filter,
            &selfilter);

        if (default_name == "")
        {
            return "";
        }

        bool bChange = false;
        QString _dir_path = path::GetDirectoryName(default_name);
        if (_dir_path != app.userHistory.exportDir)
        {
            app.userHistory.exportDir = _dir_path;
            bChange = true;
        }
        
        if (selfilter != app.userHistory.exportFormat 
                && _session->get_device()->get_work_mode() == LOGIC){
            app.userHistory.exportFormat = selfilter;
             bChange = true;            
        }

        if (bChange){
            app.SaveHistory();            
        }
    }

    QString extName = selfilter;
    if (extName == ""){
        extName = filter;
    }

    QStringList list = extName.split('.').last().split(')');
    _suffix = list.first();

    QFileInfo f(default_name);
    if(f.suffix().compare(_suffix)){
        //tr
         default_name += "." + _suffix;
    }           

    _file_name = default_name;
    return default_name;    
}

bool StoreSession::IsLogicDataType()
{
    std::set<int> type_set;
    for(auto sig : _session->get_signals()) {
        type_set.insert(sig->get_type());
    }

    if (type_set.size()){
        int type = *(type_set.begin());
        return type == SR_CHANNEL_LOGIC;
    }

    return false;
}

void StoreSession::MakeChunkName(char *chunk_name, int chunk_num, int index, int type, int version)
{ 
    chunk_name[0] = 0;

    if (version >= 2)
    {
        const char *type_name = NULL;
        type_name = (type == SR_CHANNEL_LOGIC) ? "L" : (type == SR_CHANNEL_DSO)  ? "O"
                                                   : (type == SR_CHANNEL_ANALOG) ? "A"
                                                                                 : "U";
        snprintf(chunk_name, 15, "%s-%d/%d", type_name, index, chunk_num);
    }
    else
    {
        snprintf(chunk_name, 15, "data");
    }
}

} //namespace com
} //namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "dstimer.h" 
#include <assert.h>

namespace dsv {
namespace com {

DsTimer::DsTimer()
{
    _binded = false;
    _isActived = false;
}

void DsTimer::on_timeout()
{
     _call(); //call back
}

void DsTimer::TimeOut(int millsec, CALLBACL_FUNC f)
{
    _call = f;
    QTimer::singleShot(millsec, this, SLOT(on_timeout()));
}

void DsTimer::TimeOut(int millsec)
{
    if (_call == NULL){
        assert(false);
    }
    QTimer::singleShot(millsec, this, SLOT(on_timeout()));
}

void DsTimer::Start(int millsec, CALLBACL_FUNC f)
 {  
     if (_isActived)
        return;

     _call = f;

     if (!_binded){
        _binded = true;
        connect(&_timer, SIGNAL(timeout()), this, SLOT(on_timeout())); 
     }
     
     _timer.start(millsec);
     _isActived = true;
     _beginTime = high_resolution_clock::now();
}

void DsTimer::SetCallback(CALLBACL_FUNC f)
 {
    _call = f;

    if(!_binded){
        _binded = true;
        connect(&_timer, SIGNAL(timeout()), this, SLOT(on_timeout())); 
    }  
 }

 void DsTimer::Start(int millsec)
 {  
     //check if connect
     assert(_binded);

     if (_isActived)
        return;
     
    _timer.start(millsec);
    _isActived = true;
    _beginTime = high_resolution_clock::now();
 }

 void DsTimer::Stop()
 {
     if (_isActived)
        _timer.stop();
     _isActived = false;
 }

 long long DsTimer::GetActiveTimeLong()
 {
    high_resolution_clock::time_point endTime = high_resolution_clock::now();
    milliseconds timeInterval = std::chrono::duration_cast<milliseconds>(endTime - _beginTime);
    return timeInterval.count();
 }

 void DsTimer::ResetActiveTime()
 {
     _beginTime = high_resolution_clock::now();
 }

} //namespace com
} //namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

//test git 2

#pragma once 

#include <minizip/zip.h>
#include <minizip/unzip.h>
 

namespace dsv {
namespace com {

class ZipMaker
{
public:
    ZipMaker();

    ~ZipMaker();

    //create new zip archive in the memory
    bool CreateNew(const char *fileName, bool bAppend);

    //free the source
    void Release();

    //save data to file
    bool Close();

    //add a inner file from  buffer
    bool AddFromBuffer(const char *innerFile, const char *buffer, unsigned int buferSize);

    //add a inner file from local file
    bool AddFromFile(const char *localFile, const char *innerFile);

    //get the last error
    const char *GetError();

public:
    int m_opt_compress_level;

private:
    zipFile         m_zDoc; //zip file handle
    zip_fileinfo    *m_zi; //life must as m_zDoc; 
    char     m_error[500];
};


//------------------ZipReader
class ZipInnerFileData
{
public:
    ZipInnerFileData(char *data, int size);
    ~ZipInnerFileData();

    inline char *data(){
        return _data;
    }
    inline int size(){
        return _size;
    }

private:
    char *_data;
    int  _size;
};

class ZipReader{
public:
    ZipReader(const char *filePath);
    ~ZipReader();
    void Close();

    inline bool HaveArchive(){
        return m_archive != NULL;
    }

    ZipInnerFileData* GetInnterFileData(const char *innerFile);

    void ReleaseInnerFileData(ZipInnerFileData *data);


private:
    unzFile  m_archive;
};

} //namespace com
} //namespace dsv
 
/****************************************************************************
** Meta object code from reading C++ file 'dstimer.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "dstimer.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'dstimer.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEcomSCOPEDsTimerENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEcomSCOPEDsTimerENDCLASS = QtMocHelpers::stringData(
    "dsv::com::DsTimer",
    "on_timeout",
    ""
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEcomSCOPEDsTimerENDCLASS_t {
    uint offsetsAndSizes[6];
    char stringdata0[18];
    char stringdata1[11];
    char stringdata2[1];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEcomSCOPEDsTimerENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEcomSCOPEDsTimerENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEcomSCOPEDsTimerENDCLASS = {
    {
        QT_MOC_LITERAL(0, 17),  // "dsv::com::DsTimer"
        QT_MOC_LITERAL(18, 10),  // "on_timeout"
        QT_MOC_LITERAL(29, 0)   // ""
    },
    "dsv::com::DsTimer",
    "on_timeout",
    ""
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEcomSCOPEDsTimerENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   20,    2, 0x08,    1 /* Private */,

 // slots: parameters
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::com::DsTimer::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEcomSCOPEDsTimerENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEcomSCOPEDsTimerENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEcomSCOPEDsTimerENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<DsTimer, std::true_type>,
        // method 'on_timeout'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::com::DsTimer::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<DsTimer *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->on_timeout(); break;
        default: ;
        }
    }
    (void)_a;
}

const QMetaObject *dsv::com::DsTimer::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::com::DsTimer::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEcomSCOPEDsTimerENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int dsv::com::DsTimer::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 1;
    }
    return _id;
}
QT_WARNING_POP
/****************************************************************************
** Meta object code from reading C++ file 'storesession.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "storesession.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'storesession.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEcomSCOPEStoreSessionENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEcomSCOPEStoreSessionENDCLASS = QtMocHelpers::stringData(
    "dsv::com::StoreSession",
    "progress_updated",
    ""
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEcomSCOPEStoreSessionENDCLASS_t {
    uint offsetsAndSizes[6];
    char stringdata0[23];
    char stringdata1[17];
    char stringdata2[1];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEcomSCOPEStoreSessionENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEcomSCOPEStoreSessionENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEcomSCOPEStoreSessionENDCLASS = {
    {
        QT_MOC_LITERAL(0, 22),  // "dsv::com::StoreSession"
        QT_MOC_LITERAL(23, 16),  // "progress_updated"
        QT_MOC_LITERAL(40, 0)   // ""
    },
    "dsv::com::StoreSession",
    "progress_updated",
    ""
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEcomSCOPEStoreSessionENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   20,    2, 0x06,    1 /* Public */,

 // signals: parameters
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::com::StoreSession::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEcomSCOPEStoreSessionENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEcomSCOPEStoreSessionENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEcomSCOPEStoreSessionENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<StoreSession, std::true_type>,
        // method 'progress_updated'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::com::StoreSession::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<StoreSession *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->progress_updated(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (StoreSession::*)();
            if (_t _q_method = &StoreSession::progress_updated; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
    }
    (void)_a;
}

const QMetaObject *dsv::com::StoreSession::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::com::StoreSession::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEcomSCOPEStoreSessionENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int dsv::com::StoreSession::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 1;
    }
    return _id;
}

// SIGNAL 0
void dsv::com::StoreSession::progress_updated()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "zipmaker.h" 
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <time.h>

namespace dsv {
namespace com {
  
ZipMaker::ZipMaker() :
    m_zDoc(NULL)
{
    m_error[0] = 0; 
    m_opt_compress_level = Z_BEST_SPEED;
    m_zi = NULL;
}

ZipMaker::~ZipMaker()
{
    Release();
}

bool ZipMaker::CreateNew(const char *fileName, bool bAppend)
{
     assert(fileName);

     Release();
 
     m_zDoc = zipOpen64(fileName, bAppend); 
     if (m_zDoc == NULL) {
        strcpy(m_error, "zipOpen64 error");
    } 

//make zip inner file time 
    m_zi = new zip_fileinfo();

    time_t rawtime;
    time (&rawtime);
    struct tm *tinf= localtime(&rawtime);

    struct tm &ti = *tinf;
    zip_fileinfo &zi= *(zip_fileinfo*)m_zi;

    zi.tmz_date.tm_year = ti.tm_year;
    zi.tmz_date.tm_mon  = ti.tm_mon;
    zi.tmz_date.tm_mday = ti.tm_mday;
    zi.tmz_date.tm_hour = ti.tm_hour;
    zi.tmz_date.tm_min  = ti.tm_min;
    zi.tmz_date.tm_sec  = ti.tm_sec;
    zi.dosDate = 0;
      
    return m_zDoc != NULL;
}

void ZipMaker::Release()
{  
    if (m_zDoc){
       zipClose((zipFile)m_zDoc, NULL);
       m_zDoc = NULL;       
   }
   if (m_zi){
       delete ((zip_fileinfo*)m_zi);
       m_zi = NULL;
   }
}

bool ZipMaker::Close(){
    if (m_zDoc){
       zipClose((zipFile)m_zDoc, NULL);
       m_zDoc = NULL;
       return true;
   }
   return false;     
}

bool ZipMaker::AddFromBuffer(const char *innerFile, const char *buffer, unsigned int buferSize)
{
    assert(buffer);
    assert(innerFile);
    assert(m_zDoc);   
    int level = m_opt_compress_level;

    if (level < Z_DEFAULT_COMPRESSION  || level > Z_BEST_COMPRESSION){
        level = Z_DEFAULT_COMPRESSION;
    }

    zipOpenNewFileInZip((zipFile)m_zDoc,innerFile,(zip_fileinfo*)m_zi,
                                NULL,0,NULL,0,NULL ,
                                Z_DEFLATED,
                                level);

    zipWriteInFileInZip((zipFile)m_zDoc, buffer, (unsigned int)buferSize);

    zipCloseFileInZip((zipFile)m_zDoc);

    return true;
}

bool ZipMaker::AddFromFile(const char *localFile, const char *innerFile)
{
    assert(localFile);

    struct stat st;
    FILE *fp;
    char *data = NULL;
    long long size = 0;

    if ((fp = fopen(localFile, "rb")) == NULL) {
        strcpy(m_error, "fopen error");        
        return false;
    }

    if (fstat(fileno(fp), &st) < 0) {
        strcpy(m_error, "fstat error");    
        fclose(fp);
        return -1;
    } 

    if ((data = (char*)malloc((size_t)st.st_size)) == NULL) {
        strcpy(m_error, "can't malloc buffer");
        fclose(fp);
        return false;
    }

    if (fread(data, 1, (size_t)st.st_size, fp) < (size_t)st.st_size) {
        strcpy(m_error, "fread error");
        free(data);
        fclose(fp);
        return false;
    }

    fclose(fp);
    size = (size_t)st.st_size;

    bool ret = AddFromBuffer(innerFile, data, size);
    return ret;
}

const char *ZipMaker::GetError()
{
    if (m_error[0])
        return m_error;
    return NULL;
}

//-----------------ZipReader

ZipInnerFileData::ZipInnerFileData(char *data, int size)
{
    _data = data;
    _size = size;
}

ZipInnerFileData::~ZipInnerFileData()
{
    if (_data != NULL){
        free(_data);
        _data = NULL;
    }
}

ZipReader::ZipReader(const char *filePath)
{
    m_archive = NULL;
    m_archive = unzOpen64(filePath);
}

ZipReader::~ZipReader()
{
    Close();
}

void ZipReader::Close()
{
    if (m_archive != NULL){
        unzClose(m_archive);
        m_archive = NULL;
    }
}

ZipInnerFileData* ZipReader::GetInnterFileData(const char *innerFile)
{
    char *metafile = NULL;
    char szFilePath[15];
    unz_file_info64 fileInfo;
   
    if (m_archive == NULL){
        return NULL;
    }
  
    // inner file not exists
    if (unzLocateFile(m_archive, innerFile, 0) != UNZ_OK){
        return NULL;
    }

    if (unzGetCurrentFileInfo64(m_archive, &fileInfo, szFilePath,
                                sizeof(szFilePath), NULL, 0, NULL, 0) != UNZ_OK)
    {  
        return NULL;
    }

    if (unzOpenCurrentFile(m_archive) != UNZ_OK)
    { 
        return NULL;
    }

    if (fileInfo.uncompressed_size > 0 && (metafile = (char *)malloc(fileInfo.uncompressed_size)))
    {
        unzReadCurrentFile(m_archive, metafile, fileInfo.uncompressed_size);
        unzCloseCurrentFile(m_archive);

         ZipInnerFileData *data = new ZipInnerFileData(metafile, fileInfo.uncompressed_size);
         return data;
    } 
 
    return NULL;
}

void ZipReader::ReleaseInnerFileData(ZipInnerFileData *data)
{
    if (data){
        delete data;
    }
}

} //namespace com
} //namespace dsv/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */
 
#ifndef DSVIEW_PV_WIDGETS_FAKELINEEDIT_H
#define DSVIEW_PV_WIDGETS_FAKELINEEDIT_H

#include <QLineEdit>

namespace dsv {

namespace widgets {

class FakeLineEdit : public QLineEdit
{
    Q_OBJECT
public:
    explicit FakeLineEdit(QLineEdit *parent = 0);
    
private:
    void mousePressEvent(QMouseEvent * event);

signals:
    void trigger();

public slots:
    
};

} // namespace widgets
} // namespace dsv

#endif // DSVIEW_PV_WIDGETS_FAKELINEEDIT_H
/****************************************************************************
** Meta object code from reading C++ file 'decodermenu.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "decodermenu.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'decodermenu.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEDecoderMenuENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEDecoderMenuENDCLASS = QtMocHelpers::stringData(
    "dsv::widgets::DecoderMenu",
    "decoder_selected",
    "",
    "srd_decoder*",
    "decoder",
    "selected",
    "on_action",
    "action"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEDecoderMenuENDCLASS_t {
    uint offsetsAndSizes[16];
    char stringdata0[26];
    char stringdata1[17];
    char stringdata2[1];
    char stringdata3[13];
    char stringdata4[8];
    char stringdata5[9];
    char stringdata6[10];
    char stringdata7[7];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEDecoderMenuENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEDecoderMenuENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEDecoderMenuENDCLASS = {
    {
        QT_MOC_LITERAL(0, 25),  // "dsv::widgets::DecoderMenu"
        QT_MOC_LITERAL(26, 16),  // "decoder_selected"
        QT_MOC_LITERAL(43, 0),  // ""
        QT_MOC_LITERAL(44, 12),  // "srd_decoder*"
        QT_MOC_LITERAL(57, 7),  // "decoder"
        QT_MOC_LITERAL(65, 8),  // "selected"
        QT_MOC_LITERAL(74, 9),  // "on_action"
        QT_MOC_LITERAL(84, 6)   // "action"
    },
    "dsv::widgets::DecoderMenu",
    "decoder_selected",
    "",
    "srd_decoder*",
    "decoder",
    "selected",
    "on_action",
    "action"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEwidgetsSCOPEDecoderMenuENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       3,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       2,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   32,    2, 0x06,    1 /* Public */,
       5,    0,   35,    2, 0x06,    3 /* Public */,

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       6,    1,   36,    2, 0x08,    4 /* Private */,

 // signals: parameters
    QMetaType::Void, 0x80000000 | 3,    4,
    QMetaType::Void,

 // slots: parameters
    QMetaType::Void, QMetaType::QObjectStar,    7,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::widgets::DecoderMenu::staticMetaObject = { {
    QMetaObject::SuperData::link<QMenu::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEDecoderMenuENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEwidgetsSCOPEDecoderMenuENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEDecoderMenuENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<DecoderMenu, std::true_type>,
        // method 'decoder_selected'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<srd_decoder *, std::false_type>,
        // method 'selected'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_action'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QObject *, std::false_type>
    >,
    nullptr
} };

void dsv::widgets::DecoderMenu::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<DecoderMenu *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->decoder_selected((*reinterpret_cast< std::add_pointer_t<srd_decoder*>>(_a[1]))); break;
        case 1: _t->selected(); break;
        case 2: _t->on_action((*reinterpret_cast< std::add_pointer_t<QObject*>>(_a[1]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (DecoderMenu::*)(srd_decoder * );
            if (_t _q_method = &DecoderMenu::decoder_selected; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (DecoderMenu::*)();
            if (_t _q_method = &DecoderMenu::selected; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 1;
                return;
            }
        }
    }
}

const QMetaObject *dsv::widgets::DecoderMenu::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::widgets::DecoderMenu::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEDecoderMenuENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QMenu::qt_metacast(_clname);
}

int dsv::widgets::DecoderMenu::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QMenu::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 3)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 3;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 3)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 3;
    }
    return _id;
}

// SIGNAL 0
void dsv::widgets::DecoderMenu::decoder_selected(srd_decoder * _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}

// SIGNAL 1
void dsv::widgets::DecoderMenu::selected()
{
    QMetaObject::activate(this, &staticMetaObject, 1, nullptr);
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */
 
#include "fakelineedit.h"
#include <QMouseEvent>

namespace dsv {
namespace widgets {

FakeLineEdit::FakeLineEdit(QLineEdit *parent) :
    QLineEdit(parent)
{
}

void FakeLineEdit::mousePressEvent(QMouseEvent *event)
{
    if (event->button() & Qt::LeftButton) {
        trigger();
    }
}

} // namespace widgets
} // namespace dsv
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2013 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_WIDGETS_DECODERGROUPBOX_H
#define DSVIEW_PV_WIDGETS_DECODERGROUPBOX_H

 
#include <QPushButton>
#include <QGridLayout>
#include <QFont>
#include <QWidget>

namespace dsv {

namespace data{
    class DecoderStack;
}

namespace decode{
    class Decoder;
}

namespace widgets {

class DecoderGroupBox : public QWidget
{
	Q_OBJECT

public:
    DecoderGroupBox(dsv::data::DecoderStack *decoder_stack,
                    decode::Decoder *dec, QLayout *dec_layout,
                    QWidget *parent, QFont font);
    ~DecoderGroupBox();
    bool eventFilter(QObject *o, QEvent *e);

    inline int get_row_count(){
        return _row_num;
    }

signals:
	void show_hide_decoder();
    void show_hide_row();
    void del_stack(decode::Decoder *_dec);

private slots:
    void tog_icon();
    void on_del_stack();

private:
    QWidget *_widget;

    dsv::data::DecoderStack  *_decoder_stack;
    decode::Decoder   *_dec;
    int _index;

    QGridLayout *_layout;
    QPushButton *_del_button;
    QPushButton *_show_button;
    std::list <QPushButton *> _row_show_button;
    int _row_num;
    
public:
    int _content_width;
};

} // widgets
} // pv

#endif // DSVIEW_PV_WIDGETS_DECODERGROUPBOX_H
/****************************************************************************
** Meta object code from reading C++ file 'fakelineedit.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "fakelineedit.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'fakelineedit.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEFakeLineEditENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEFakeLineEditENDCLASS = QtMocHelpers::stringData(
    "dsv::widgets::FakeLineEdit",
    "trigger",
    ""
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEFakeLineEditENDCLASS_t {
    uint offsetsAndSizes[6];
    char stringdata0[27];
    char stringdata1[8];
    char stringdata2[1];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEFakeLineEditENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEFakeLineEditENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEFakeLineEditENDCLASS = {
    {
        QT_MOC_LITERAL(0, 26),  // "dsv::widgets::FakeLineEdit"
        QT_MOC_LITERAL(27, 7),  // "trigger"
        QT_MOC_LITERAL(35, 0)   // ""
    },
    "dsv::widgets::FakeLineEdit",
    "trigger",
    ""
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEwidgetsSCOPEFakeLineEditENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   20,    2, 0x06,    1 /* Public */,

 // signals: parameters
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::widgets::FakeLineEdit::staticMetaObject = { {
    QMetaObject::SuperData::link<QLineEdit::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEFakeLineEditENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEwidgetsSCOPEFakeLineEditENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEFakeLineEditENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<FakeLineEdit, std::true_type>,
        // method 'trigger'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::widgets::FakeLineEdit::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<FakeLineEdit *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->trigger(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (FakeLineEdit::*)();
            if (_t _q_method = &FakeLineEdit::trigger; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
    }
    (void)_a;
}

const QMetaObject *dsv::widgets::FakeLineEdit::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::widgets::FakeLineEdit::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEFakeLineEditENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QLineEdit::qt_metacast(_clname);
}

int dsv::widgets::FakeLineEdit::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QLineEdit::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 1;
    }
    return _id;
}

// SIGNAL 0
void dsv::widgets::FakeLineEdit::trigger()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}
QT_WARNING_POP
/****************************************************************************
** Meta object code from reading C++ file 'decodergroupbox.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "decodergroupbox.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'decodergroupbox.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEDecoderGroupBoxENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEDecoderGroupBoxENDCLASS = QtMocHelpers::stringData(
    "dsv::widgets::DecoderGroupBox",
    "show_hide_decoder",
    "",
    "show_hide_row",
    "del_stack",
    "decode::Decoder*",
    "_dec",
    "tog_icon",
    "on_del_stack"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEDecoderGroupBoxENDCLASS_t {
    uint offsetsAndSizes[18];
    char stringdata0[30];
    char stringdata1[18];
    char stringdata2[1];
    char stringdata3[14];
    char stringdata4[10];
    char stringdata5[17];
    char stringdata6[5];
    char stringdata7[9];
    char stringdata8[13];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEDecoderGroupBoxENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEDecoderGroupBoxENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEDecoderGroupBoxENDCLASS = {
    {
        QT_MOC_LITERAL(0, 29),  // "dsv::widgets::DecoderGroupBox"
        QT_MOC_LITERAL(30, 17),  // "show_hide_decoder"
        QT_MOC_LITERAL(48, 0),  // ""
        QT_MOC_LITERAL(49, 13),  // "show_hide_row"
        QT_MOC_LITERAL(63, 9),  // "del_stack"
        QT_MOC_LITERAL(73, 16),  // "decode::Decoder*"
        QT_MOC_LITERAL(90, 4),  // "_dec"
        QT_MOC_LITERAL(95, 8),  // "tog_icon"
        QT_MOC_LITERAL(104, 12)   // "on_del_stack"
    },
    "dsv::widgets::DecoderGroupBox",
    "show_hide_decoder",
    "",
    "show_hide_row",
    "del_stack",
    "decode::Decoder*",
    "_dec",
    "tog_icon",
    "on_del_stack"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEwidgetsSCOPEDecoderGroupBoxENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       5,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       3,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   44,    2, 0x06,    1 /* Public */,
       3,    0,   45,    2, 0x06,    2 /* Public */,
       4,    1,   46,    2, 0x06,    3 /* Public */,

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       7,    0,   49,    2, 0x08,    5 /* Private */,
       8,    0,   50,    2, 0x08,    6 /* Private */,

 // signals: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, 0x80000000 | 5,    6,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::widgets::DecoderGroupBox::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEDecoderGroupBoxENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEwidgetsSCOPEDecoderGroupBoxENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEDecoderGroupBoxENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<DecoderGroupBox, std::true_type>,
        // method 'show_hide_decoder'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'show_hide_row'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'del_stack'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<decode::Decoder *, std::false_type>,
        // method 'tog_icon'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_del_stack'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::widgets::DecoderGroupBox::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<DecoderGroupBox *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->show_hide_decoder(); break;
        case 1: _t->show_hide_row(); break;
        case 2: _t->del_stack((*reinterpret_cast< std::add_pointer_t<decode::Decoder*>>(_a[1]))); break;
        case 3: _t->tog_icon(); break;
        case 4: _t->on_del_stack(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (DecoderGroupBox::*)();
            if (_t _q_method = &DecoderGroupBox::show_hide_decoder; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (DecoderGroupBox::*)();
            if (_t _q_method = &DecoderGroupBox::show_hide_row; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 1;
                return;
            }
        }
        {
            using _t = void (DecoderGroupBox::*)(decode::Decoder * );
            if (_t _q_method = &DecoderGroupBox::del_stack; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 2;
                return;
            }
        }
    }
}

const QMetaObject *dsv::widgets::DecoderGroupBox::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::widgets::DecoderGroupBox::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEDecoderGroupBoxENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int dsv::widgets::DecoderGroupBox::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 5)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 5;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 5)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 5;
    }
    return _id;
}

// SIGNAL 0
void dsv::widgets::DecoderGroupBox::show_hide_decoder()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}

// SIGNAL 1
void dsv::widgets::DecoderGroupBox::show_hide_row()
{
    QMetaObject::activate(this, &staticMetaObject, 1, nullptr);
}

// SIGNAL 2
void dsv::widgets::DecoderGroupBox::del_stack(decode::Decoder * _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 2, _a);
}
QT_WARNING_POP
/*
 * This file is part of the PulseView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2013 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "decodergroupbox.h"
#include <libsigrokdecode.h>
#include <QHBoxLayout>
#include <QLabel>
#include <QPushButton>
#include <QVBoxLayout>
#include <QVariant>
#include <QApplication>
#include <assert.h>
#include "../data/decoderstack.h"
#include "../decode/decoder.h"
#include "../decode/row.h"
#include "../config/appconfig.h"

using namespace dsv::config;

namespace dsv {
namespace widgets {

DecoderGroupBox::DecoderGroupBox(data::DecoderStack *decoder_stack,
                                 decode::Decoder *dec,
                                 QLayout *dec_layout,
                                 QWidget *parent, QFont font):
    QWidget(parent)
{
    _row_num = 0;
    _content_width = 0;

    _dec = dec;
    _decoder_stack = decoder_stack;
    _widget = new QWidget(this);
    _layout = new QGridLayout(_widget);
    _layout->setContentsMargins(0, 0, 0, 0);
    _layout->setVerticalSpacing(2);

    QString iconPath = AppConfig::GetIconPath();
    _layout->addWidget(new QLabel(QString("<h3 style='font-style:italic'>%1</h3>").arg(_dec->decoder()->name), _widget),
        0, 0);
	_layout->setColumnStretch(0, 1);

    const srd_decoder *const d = _dec->decoder();
    assert(d);

    _index = 0;
    for(auto dec : _decoder_stack->stack()) {
        if (dec == _dec)
            break;
        _index++;
    }
    _show_button = new QPushButton(QIcon(_dec->shown() ?
                                             iconPath+"/shown.svg" :
                                             iconPath+"/hidden.svg"), QString(), _widget);
    _show_button->setProperty("index", -1);

    connect(_show_button, SIGNAL(clicked()), this, SLOT(tog_icon()));

    _layout->addWidget(_show_button, 0, 2);

    _row_num++;


    // add row show/hide
    int index = 0;
    auto rows = _decoder_stack->get_rows_gshow();

    for (auto i = rows.begin();
        i != rows.end(); i++) {
        if ((*i).first.decoder() == _dec->decoder()) {
            QPushButton *show_button = new QPushButton(QIcon((*i).second ?
                                                                 iconPath+"/shown.svg" :
                                                                 iconPath+"/hidden.svg"), QString(), _widget);
            show_button->setProperty("index", index);
            connect(show_button, SIGNAL(clicked()), this, SLOT(tog_icon()));

            _row_show_button.push_back(show_button);
            QLabel *lb = new QLabel((*i).first.title(), _widget);
            lb->setFont(font);
            _layout->addWidget(lb, _row_show_button.size(), 0);
            _layout->addWidget(show_button, _row_show_button.size(), 2);
        }
        index++;

        _row_num++;
    }

    _layout->addLayout(dec_layout, _row_show_button.size()+1, 0, 1, 3);
    _widget->setLayout(_layout);

    _content_width = _widget->sizeHint().width();

    parent->layout()->addWidget(_widget); 
}

DecoderGroupBox::~DecoderGroupBox()
{
}

bool DecoderGroupBox::eventFilter(QObject *o, QEvent *e)
{  
    (void)e;
    (void)o;
    return false;
}

void DecoderGroupBox::tog_icon()
{
    QString iconPath = AppConfig::GetIconPath();
    QPushButton *sc = dynamic_cast<QPushButton*>(sender());
    int index = sc->property("index").toInt();

    if (index == -1) {
        int i = _index;

       for(auto dec : _decoder_stack->stack()) {
            if (i-- == 0) {
                dec->show(!dec->shown());
                sc->setIcon(QIcon(dec->shown() ? iconPath+"/shown.svg" :
                                                 iconPath+"/hidden.svg"));
                break;
            }
        }
    } else {
        auto rows = _decoder_stack->get_rows_gshow();

        for (auto i = rows.begin(); i != rows.end(); i++) {
            if (index-- == 0) {
                _decoder_stack->set_rows_gshow((*i).first, !(*i).second);
                //rows[(*i).first] = !(*i).second;
                sc->setIcon(QIcon(rows[(*i).first] ? iconPath+"/hidden.svg" :
                                                    iconPath+"/shown.svg"));
                break;
            }
        }
    }
}

void DecoderGroupBox::on_del_stack()
{
    int i = _index;
    for(auto dec : _decoder_stack->stack()) {
        if (i-- == 0) {
            del_stack(dec);
            break;
        }
    }
}

} // widgets
} // pv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "border.h"
#include "../appcore/mainframe.h" 
#include <QPainter>
#include <QLinearGradient>
#include <QRadialGradient>
#include "../config/appconfig.h"

using namespace dsv::config;
using namespace dsv::appcore;

namespace dsv {
namespace widgets {

const QColor Border::dark_border0 = QColor(80, 80, 80, 255);
const QColor Border::dark_border1 = QColor(48, 47, 47, 200);
const QColor Border::dark_border2 = QColor(48, 47, 47, 150);
const QColor Border::dark_border3 = QColor(48, 47, 47, 100);
const QColor Border::dark_border4 = QColor(48, 47, 47, 10);

const QColor Border::light_border0 = QColor(100, 100, 100, 255);
const QColor Border::light_border1 = QColor(150, 150, 150, 150);
const QColor Border::light_border2 = QColor(150, 150, 150, 100);
const QColor Border::light_border3 = QColor(150, 150, 150, 50);
const QColor Border::light_border4 = QColor(150, 150, 150, 0);

Border::Border(int type, QWidget *parent) :
    QWidget(parent),
    _type(type)
{
    setAttribute(Qt::WA_TranslucentBackground);
    setMouseTracking(true);
}

void Border::paintEvent(QPaintEvent *)
{
    QPainter painter(this);
    painter.setPen(Qt::NoPen);
    painter.setRenderHint(QPainter::Antialiasing, true);
    QLinearGradient linearGrad(QPointF(width(), height()), QPointF(0, 0));
    AppConfig &app = AppConfig::Instance(); 
    QString style = app.frameOptions.style;

    if (style == THEME_STYLE_DARK) {
        linearGrad.setColorAt(0, dark_border0);
        linearGrad.setColorAt(0.25, dark_border1);
        linearGrad.setColorAt(0.5, dark_border2);
        linearGrad.setColorAt(0.75, dark_border3);
        linearGrad.setColorAt(1, dark_border4);
    } else {
        linearGrad.setColorAt(0, light_border0);
        linearGrad.setColorAt(0.25, light_border1);
        linearGrad.setColorAt(0.5, light_border2);
        linearGrad.setColorAt(0.75, light_border3);
        linearGrad.setColorAt(1, light_border4);
    }

    QRadialGradient radialGrad(QPointF(0, 0), width());
    if (style == THEME_STYLE_DARK) {
        radialGrad.setColorAt(0, dark_border0);
        radialGrad.setColorAt(0.25, dark_border1);
        radialGrad.setColorAt(0.5, dark_border2);
        radialGrad.setColorAt(0.75, dark_border3);
        radialGrad.setColorAt(1, dark_border4);
    } else {
        radialGrad.setColorAt(0, light_border0);
        radialGrad.setColorAt(0.25, light_border1);
        radialGrad.setColorAt(0.5, light_border2);
        radialGrad.setColorAt(0.75, light_border3);
        radialGrad.setColorAt(1, light_border4);
    }

    if (_type == MainFrame::TopLeft) {
        QRectF rectangle(0, 0, width()*2, height()*2);
        radialGrad.setCenter(QPointF(width(), height()));
        radialGrad.setFocalPoint(QPointF(width(), height()));
        painter.setBrush(QBrush(radialGrad));
        painter.drawPie(rectangle, 90 * 16, 180 * 16);
    } else if (_type == MainFrame::TopRight) {
        QRectF rectangle(-width(), 0, width()*2, height()*2);
        radialGrad.setCenter(QPointF(0, height()));
        radialGrad.setFocalPoint(QPointF(0, height()));
        painter.setBrush(QBrush(radialGrad));
        painter.drawPie(rectangle, 0 * 16, 90 * 16);
    } else if (_type == MainFrame::BottomLeft) {
        QRectF rectangle(0, -height(), width()*2, height()*2);
        radialGrad.setCenter(QPointF(width(), 0));
        radialGrad.setFocalPoint(QPointF(width(), 0));
        painter.setBrush(QBrush(radialGrad));
        painter.drawPie(rectangle, 180 * 16, 270 * 16);
    } else if (_type == MainFrame::BottomRight) {
        QRectF rectangle(-width(), -height(), width()*2, height()*2);
        radialGrad.setCenter(QPointF(0, 0));
        radialGrad.setFocalPoint(QPointF(0, 0));
        painter.setBrush(QBrush(radialGrad));
        painter.drawPie(rectangle, 270 * 16, 360 * 16);
    } else if (_type == MainFrame::Top) {
        linearGrad.setStart(QPointF(0, height()));
        linearGrad.setFinalStop(QPointF(0, 0));
        painter.setBrush(QBrush(linearGrad));
        painter.drawRect(rect());
    } else if (_type == MainFrame::Bottom) {
        linearGrad.setStart(QPointF(0, 0));
        linearGrad.setFinalStop(QPointF(0, height()));
        painter.setBrush(QBrush(linearGrad));
        painter.drawRect(rect());
    } else if (_type == MainFrame::Left) {
        linearGrad.setStart(QPointF(width(), 0));
        linearGrad.setFinalStop(QPointF(0, 0));
        painter.setBrush(QBrush(linearGrad));
        painter.drawRect(rect());
    } else if (_type == MainFrame::Right) {
        linearGrad.setStart(QPointF(0, 0));
        linearGrad.setFinalStop(QPointF(width(), 0));
        painter.setBrush(QBrush(linearGrad));
        painter.drawRect(rect());
    }
}

void Border::leaveEvent(QEvent*)
{
    //setCursor(Qt::ArrowCursor);
}

} // namespace widgets
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 Joel Holdsworth <joel@airwebreathe.org.uk>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_WIDGETS_DECODERMENU_H
#define DSVIEW_PV_WIDGETS_DECODERMENU_H

#include <QMenu>
#include <QSignalMapper>

struct srd_decoder;

namespace dsv {
namespace widgets {

class DecoderMenu : public QMenu
{
	Q_OBJECT;

public:
	DecoderMenu(QWidget *parent, bool first_level_decoder = false);

private:
	static int decoder_name_cmp(const void *a, const void *b);


private slots:
	void on_action(QObject *action);

signals:
	void decoder_selected(srd_decoder *decoder);
    void selected();

private:
	QSignalMapper _mapper;
};

} // widgets
} // pv

#endif // DSVIEW_PV_WIDGETS_DECODERMENU_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 Joel Holdsworth <joel@airwebreathe.org.uk>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "decodermenu.h"
#include <libsigrokdecode.h>
#include <assert.h>

namespace dsv {
namespace widgets {

DecoderMenu::DecoderMenu(QWidget *parent, bool first_level_decoder) :
	QMenu(parent),
	_mapper(this)
{
	GSList *l = g_slist_sort(g_slist_copy(
		(GSList*)srd_decoder_list()), decoder_name_cmp);
	for(; l; l = l->next)
	{
		const srd_decoder *const d = (srd_decoder*)l->data;
		assert(d);

		const bool have_probes = (d->channels || d->opt_channels) != 0;
		if (first_level_decoder == have_probes) {
			QAction *const action =
				addAction(QString::fromUtf8(d->name));
            action->setData(QVariant::fromValue(l->data));
			_mapper.setMapping(action, action);
			connect(action, SIGNAL(triggered()),
				&_mapper, SLOT(map()));
		}
	}
	g_slist_free(l);

#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
	connect(&_mapper, SIGNAL(mappedObject(QObject*)), this, SLOT(on_action(QObject*)));
#else
	connect(&_mapper, SIGNAL(mapped(QObject*)), this, SLOT(on_action(QObject*)));
#endif
}

int DecoderMenu::decoder_name_cmp(const void *a, const void *b)
{
	return strcmp(((const srd_decoder*)a)->name,
		((const srd_decoder*)b)->name);
}

void DecoderMenu::on_action(QObject *action)
{
	assert(action);
	srd_decoder *const dec =
		(srd_decoder*)((QAction*)action)->data().value<void*>();
	assert(dec);

    selected();
	decoder_selected(dec);	
}

} // widgets
} // pv
/****************************************************************************
** Meta object code from reading C++ file 'border.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "border.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'border.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEBorderENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEBorderENDCLASS = QtMocHelpers::stringData(
    "dsv::widgets::Border"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEBorderENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[21];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEBorderENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEBorderENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEBorderENDCLASS = {
    {
        QT_MOC_LITERAL(0, 20)   // "dsv::widgets::Border"
    },
    "dsv::widgets::Border"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEwidgetsSCOPEBorderENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::widgets::Border::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEBorderENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEwidgetsSCOPEBorderENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEBorderENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<Border, std::true_type>
    >,
    nullptr
} };

void dsv::widgets::Border::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *dsv::widgets::Border::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::widgets::Border::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEwidgetsSCOPEBorderENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int dsv::widgets::Border::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_WIDGETS_BORDER_H
#define DSVIEW_PV_WIDGETS_BORDER_H

#include <QWidget>

namespace dsv {
namespace widgets {

class Border : public QWidget
{
    Q_OBJECT
private:
    static const QColor dark_border0;
    static const QColor dark_border1;
    static const QColor dark_border2;
    static const QColor dark_border3;
    static const QColor dark_border4;

    static const QColor light_border0;
    static const QColor light_border1;
    static const QColor light_border2;
    static const QColor light_border3;
    static const QColor light_border4;

public:
    explicit Border(int type, QWidget *parent = 0);

protected:
    void paintEvent(QPaintEvent *);
    void leaveEvent(QEvent *);

private:
    int _type;
};

} // namespace widgets
} // namespace dsv

#endif // DSVIEW_PV_WIDGETS_BORDER_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2022 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "keywordlineedit.h"
#include "../config/appconfig.h"

#include "../ui/langresource.h"

KeywordLineEdit::KeywordLineEdit(QWidget *parent, IKeywordActive *active)
:QLineEdit(parent)
{ 
    _bText = false;
    _active = active;
    this->ResetText();
}

 void KeywordLineEdit::mousePressEvent(QMouseEvent *e)
 {
      if (e->button() == Qt::LeftButton && _active != NULL){          
         _active->BeginEditKeyword();
     } 
     QLineEdit::mousePressEvent(e); 
 }

 void KeywordLineEdit::ResetText()
 { 
     if (_bText){
         return;         
     }

    //tr
    this->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_KEY_DECODER_SEARCH), "Decoder search..."));
 }

 void KeywordLineEdit::SetInputText(QString text)
 {
     _bText = true;
     this->setText(text);
 }
/****************************************************************************
** Meta object code from reading C++ file 'protocolitemlayer.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "protocolitemlayer.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'protocolitemlayer.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEProtocolItemLayerENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEProtocolItemLayerENDCLASS = QtMocHelpers::stringData(
    "dsv::dock::ProtocolItemLayer",
    "on_set_protocol",
    "",
    "on_del_protocol",
    "on_format_select_changed",
    "index"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEProtocolItemLayerENDCLASS_t {
    uint offsetsAndSizes[12];
    char stringdata0[29];
    char stringdata1[16];
    char stringdata2[1];
    char stringdata3[16];
    char stringdata4[25];
    char stringdata5[6];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEProtocolItemLayerENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEProtocolItemLayerENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEProtocolItemLayerENDCLASS = {
    {
        QT_MOC_LITERAL(0, 28),  // "dsv::dock::ProtocolItemLayer"
        QT_MOC_LITERAL(29, 15),  // "on_set_protocol"
        QT_MOC_LITERAL(45, 0),  // ""
        QT_MOC_LITERAL(46, 15),  // "on_del_protocol"
        QT_MOC_LITERAL(62, 24),  // "on_format_select_changed"
        QT_MOC_LITERAL(87, 5)   // "index"
    },
    "dsv::dock::ProtocolItemLayer",
    "on_set_protocol",
    "",
    "on_del_protocol",
    "on_format_select_changed",
    "index"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdockSCOPEProtocolItemLayerENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       3,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   32,    2, 0x08,    1 /* Private */,
       3,    0,   33,    2, 0x08,    2 /* Private */,
       4,    1,   34,    2, 0x08,    3 /* Private */,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::Int,    5,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dock::ProtocolItemLayer::staticMetaObject = { {
    QMetaObject::SuperData::link<QHBoxLayout::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEProtocolItemLayerENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdockSCOPEProtocolItemLayerENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEProtocolItemLayerENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<ProtocolItemLayer, std::true_type>,
        // method 'on_set_protocol'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_del_protocol'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_format_select_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>
    >,
    nullptr
} };

void dsv::dock::ProtocolItemLayer::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<ProtocolItemLayer *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->on_set_protocol(); break;
        case 1: _t->on_del_protocol(); break;
        case 2: _t->on_format_select_changed((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        default: ;
        }
    }
}

const QMetaObject *dsv::dock::ProtocolItemLayer::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dock::ProtocolItemLayer::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEProtocolItemLayerENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QHBoxLayout::qt_metacast(_clname);
}

int dsv::dock::ProtocolItemLayer::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QHBoxLayout::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 3)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 3;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 3)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 3;
    }
    return _id;
}
QT_WARNING_POP
/****************************************************************************
** Meta object code from reading C++ file 'measuredock.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "measuredock.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'measuredock.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEMeasureDockENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEMeasureDockENDCLASS = QtMocHelpers::stringData(
    "dsv::dock::MeasureDock",
    "goto_cursor",
    "",
    "del_dist_measure",
    "add_edge_measure",
    "del_edge_measure",
    "show_all_coursor",
    "set_sel_cursor",
    "update_dist",
    "update_edge",
    "set_cursor_btn_color",
    "QPushButton*",
    "btn",
    "del_cursor",
    "add_dist_measure",
    "cursor_update",
    "cursor_moving",
    "reCalc",
    "measure_updated",
    "refresh"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEMeasureDockENDCLASS_t {
    uint offsetsAndSizes[40];
    char stringdata0[23];
    char stringdata1[12];
    char stringdata2[1];
    char stringdata3[17];
    char stringdata4[17];
    char stringdata5[17];
    char stringdata6[17];
    char stringdata7[15];
    char stringdata8[12];
    char stringdata9[12];
    char stringdata10[21];
    char stringdata11[13];
    char stringdata12[4];
    char stringdata13[11];
    char stringdata14[17];
    char stringdata15[14];
    char stringdata16[14];
    char stringdata17[7];
    char stringdata18[16];
    char stringdata19[8];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEMeasureDockENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEMeasureDockENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEMeasureDockENDCLASS = {
    {
        QT_MOC_LITERAL(0, 22),  // "dsv::dock::MeasureDock"
        QT_MOC_LITERAL(23, 11),  // "goto_cursor"
        QT_MOC_LITERAL(35, 0),  // ""
        QT_MOC_LITERAL(36, 16),  // "del_dist_measure"
        QT_MOC_LITERAL(53, 16),  // "add_edge_measure"
        QT_MOC_LITERAL(70, 16),  // "del_edge_measure"
        QT_MOC_LITERAL(87, 16),  // "show_all_coursor"
        QT_MOC_LITERAL(104, 14),  // "set_sel_cursor"
        QT_MOC_LITERAL(119, 11),  // "update_dist"
        QT_MOC_LITERAL(131, 11),  // "update_edge"
        QT_MOC_LITERAL(143, 20),  // "set_cursor_btn_color"
        QT_MOC_LITERAL(164, 12),  // "QPushButton*"
        QT_MOC_LITERAL(177, 3),  // "btn"
        QT_MOC_LITERAL(181, 10),  // "del_cursor"
        QT_MOC_LITERAL(192, 16),  // "add_dist_measure"
        QT_MOC_LITERAL(209, 13),  // "cursor_update"
        QT_MOC_LITERAL(223, 13),  // "cursor_moving"
        QT_MOC_LITERAL(237, 6),  // "reCalc"
        QT_MOC_LITERAL(244, 15),  // "measure_updated"
        QT_MOC_LITERAL(260, 7)   // "refresh"
    },
    "dsv::dock::MeasureDock",
    "goto_cursor",
    "",
    "del_dist_measure",
    "add_edge_measure",
    "del_edge_measure",
    "show_all_coursor",
    "set_sel_cursor",
    "update_dist",
    "update_edge",
    "set_cursor_btn_color",
    "QPushButton*",
    "btn",
    "del_cursor",
    "add_dist_measure",
    "cursor_update",
    "cursor_moving",
    "reCalc",
    "measure_updated",
    "refresh"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdockSCOPEMeasureDockENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
      16,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,  110,    2, 0x08,    1 /* Private */,
       3,    0,  111,    2, 0x08,    2 /* Private */,
       4,    0,  112,    2, 0x08,    3 /* Private */,
       5,    0,  113,    2, 0x08,    4 /* Private */,
       6,    0,  114,    2, 0x08,    5 /* Private */,
       7,    0,  115,    2, 0x08,    6 /* Private */,
       8,    0,  116,    2, 0x08,    7 /* Private */,
       9,    0,  117,    2, 0x08,    8 /* Private */,
      10,    1,  118,    2, 0x08,    9 /* Private */,
      13,    0,  121,    2, 0x08,   11 /* Private */,
      14,    0,  122,    2, 0x08,   12 /* Private */,
      15,    0,  123,    2, 0x0a,   13 /* Public */,
      16,    0,  124,    2, 0x0a,   14 /* Public */,
      17,    0,  125,    2, 0x0a,   15 /* Public */,
      18,    0,  126,    2, 0x0a,   16 /* Public */,
      19,    0,  127,    2, 0x0a,   17 /* Public */,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, 0x80000000 | 11,   12,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dock::MeasureDock::staticMetaObject = { {
    QMetaObject::SuperData::link<QScrollArea::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEMeasureDockENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdockSCOPEMeasureDockENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEMeasureDockENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<MeasureDock, std::true_type>,
        // method 'goto_cursor'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'del_dist_measure'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'add_edge_measure'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'del_edge_measure'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'show_all_coursor'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'set_sel_cursor'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'update_dist'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'update_edge'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'set_cursor_btn_color'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QPushButton *, std::false_type>,
        // method 'del_cursor'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'add_dist_measure'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'cursor_update'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'cursor_moving'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'reCalc'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'measure_updated'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'refresh'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::dock::MeasureDock::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<MeasureDock *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->goto_cursor(); break;
        case 1: _t->del_dist_measure(); break;
        case 2: _t->add_edge_measure(); break;
        case 3: _t->del_edge_measure(); break;
        case 4: _t->show_all_coursor(); break;
        case 5: _t->set_sel_cursor(); break;
        case 6: _t->update_dist(); break;
        case 7: _t->update_edge(); break;
        case 8: _t->set_cursor_btn_color((*reinterpret_cast< std::add_pointer_t<QPushButton*>>(_a[1]))); break;
        case 9: _t->del_cursor(); break;
        case 10: _t->add_dist_measure(); break;
        case 11: _t->cursor_update(); break;
        case 12: _t->cursor_moving(); break;
        case 13: _t->reCalc(); break;
        case 14: _t->measure_updated(); break;
        case 15: _t->refresh(); break;
        default: ;
        }
    }
}

const QMetaObject *dsv::dock::MeasureDock::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dock::MeasureDock::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEMeasureDockENDCLASS.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "IFontForm"))
        return static_cast< IFontForm*>(this);
    return QScrollArea::qt_metacast(_clname);
}

int dsv::dock::MeasureDock::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QScrollArea::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 16)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 16;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 16)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 16;
    }
    return _id;
}
QT_WARNING_POP
/****************************************************************************
** Meta object code from reading C++ file 'protocoldock.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "protocoldock.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'protocoldock.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEProtocolDockENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEProtocolDockENDCLASS = QtMocHelpers::stringData(
    "dsv::dock::ProtocolDock",
    "protocol_updated",
    "",
    "update_model",
    "on_add_protocol",
    "on_del_all_protocol",
    "decoded_progress",
    "progress",
    "set_model",
    "export_table_view",
    "nav_table_view",
    "item_clicked",
    "QModelIndex",
    "index",
    "column_resize",
    "old_size",
    "new_size",
    "search_pre",
    "search_nxt",
    "search_done",
    "search_changed",
    "search_update",
    "show_protocol_select"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEProtocolDockENDCLASS_t {
    uint offsetsAndSizes[46];
    char stringdata0[24];
    char stringdata1[17];
    char stringdata2[1];
    char stringdata3[13];
    char stringdata4[16];
    char stringdata5[20];
    char stringdata6[17];
    char stringdata7[9];
    char stringdata8[10];
    char stringdata9[18];
    char stringdata10[15];
    char stringdata11[13];
    char stringdata12[12];
    char stringdata13[6];
    char stringdata14[14];
    char stringdata15[9];
    char stringdata16[9];
    char stringdata17[11];
    char stringdata18[11];
    char stringdata19[12];
    char stringdata20[15];
    char stringdata21[14];
    char stringdata22[21];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEProtocolDockENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEProtocolDockENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEProtocolDockENDCLASS = {
    {
        QT_MOC_LITERAL(0, 23),  // "dsv::dock::ProtocolDock"
        QT_MOC_LITERAL(24, 16),  // "protocol_updated"
        QT_MOC_LITERAL(41, 0),  // ""
        QT_MOC_LITERAL(42, 12),  // "update_model"
        QT_MOC_LITERAL(55, 15),  // "on_add_protocol"
        QT_MOC_LITERAL(71, 19),  // "on_del_all_protocol"
        QT_MOC_LITERAL(91, 16),  // "decoded_progress"
        QT_MOC_LITERAL(108, 8),  // "progress"
        QT_MOC_LITERAL(117, 9),  // "set_model"
        QT_MOC_LITERAL(127, 17),  // "export_table_view"
        QT_MOC_LITERAL(145, 14),  // "nav_table_view"
        QT_MOC_LITERAL(160, 12),  // "item_clicked"
        QT_MOC_LITERAL(173, 11),  // "QModelIndex"
        QT_MOC_LITERAL(185, 5),  // "index"
        QT_MOC_LITERAL(191, 13),  // "column_resize"
        QT_MOC_LITERAL(205, 8),  // "old_size"
        QT_MOC_LITERAL(214, 8),  // "new_size"
        QT_MOC_LITERAL(223, 10),  // "search_pre"
        QT_MOC_LITERAL(234, 10),  // "search_nxt"
        QT_MOC_LITERAL(245, 11),  // "search_done"
        QT_MOC_LITERAL(257, 14),  // "search_changed"
        QT_MOC_LITERAL(272, 13),  // "search_update"
        QT_MOC_LITERAL(286, 20)   // "show_protocol_select"
    },
    "dsv::dock::ProtocolDock",
    "protocol_updated",
    "",
    "update_model",
    "on_add_protocol",
    "on_del_all_protocol",
    "decoded_progress",
    "progress",
    "set_model",
    "export_table_view",
    "nav_table_view",
    "item_clicked",
    "QModelIndex",
    "index",
    "column_resize",
    "old_size",
    "new_size",
    "search_pre",
    "search_nxt",
    "search_done",
    "search_changed",
    "search_update",
    "show_protocol_select"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdockSCOPEProtocolDockENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
      16,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,  110,    2, 0x06,    1 /* Public */,

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       3,    0,  111,    2, 0x0a,    2 /* Public */,
       4,    0,  112,    2, 0x08,    3 /* Private */,
       5,    0,  113,    2, 0x08,    4 /* Private */,
       6,    1,  114,    2, 0x08,    5 /* Private */,
       8,    0,  117,    2, 0x08,    7 /* Private */,
       9,    0,  118,    2, 0x08,    8 /* Private */,
      10,    0,  119,    2, 0x08,    9 /* Private */,
      11,    1,  120,    2, 0x08,   10 /* Private */,
      14,    3,  123,    2, 0x08,   12 /* Private */,
      17,    0,  130,    2, 0x08,   16 /* Private */,
      18,    0,  131,    2, 0x08,   17 /* Private */,
      19,    0,  132,    2, 0x08,   18 /* Private */,
      20,    0,  133,    2, 0x08,   19 /* Private */,
      21,    0,  134,    2, 0x08,   20 /* Private */,
      22,    0,  135,    2, 0x08,   21 /* Private */,

 // signals: parameters
    QMetaType::Void,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::Int,    7,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, 0x80000000 | 12,   13,
    QMetaType::Void, QMetaType::Int, QMetaType::Int, QMetaType::Int,   13,   15,   16,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dock::ProtocolDock::staticMetaObject = { {
    QMetaObject::SuperData::link<QScrollArea::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEProtocolDockENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdockSCOPEProtocolDockENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEProtocolDockENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<ProtocolDock, std::true_type>,
        // method 'protocol_updated'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'update_model'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_add_protocol'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_del_all_protocol'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'decoded_progress'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'set_model'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'export_table_view'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'nav_table_view'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'item_clicked'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<const QModelIndex &, std::false_type>,
        // method 'column_resize'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'search_pre'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'search_nxt'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'search_done'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'search_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'search_update'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'show_protocol_select'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::dock::ProtocolDock::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<ProtocolDock *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->protocol_updated(); break;
        case 1: _t->update_model(); break;
        case 2: _t->on_add_protocol(); break;
        case 3: _t->on_del_all_protocol(); break;
        case 4: _t->decoded_progress((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 5: _t->set_model(); break;
        case 6: _t->export_table_view(); break;
        case 7: _t->nav_table_view(); break;
        case 8: _t->item_clicked((*reinterpret_cast< std::add_pointer_t<QModelIndex>>(_a[1]))); break;
        case 9: _t->column_resize((*reinterpret_cast< std::add_pointer_t<int>>(_a[1])),(*reinterpret_cast< std::add_pointer_t<int>>(_a[2])),(*reinterpret_cast< std::add_pointer_t<int>>(_a[3]))); break;
        case 10: _t->search_pre(); break;
        case 11: _t->search_nxt(); break;
        case 12: _t->search_done(); break;
        case 13: _t->search_changed(); break;
        case 14: _t->search_update(); break;
        case 15: _t->show_protocol_select(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (ProtocolDock::*)();
            if (_t _q_method = &ProtocolDock::protocol_updated; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
    }
}

const QMetaObject *dsv::dock::ProtocolDock::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dock::ProtocolDock::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEProtocolDockENDCLASS.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "IProtocolItemLayerCallback"))
        return static_cast< IProtocolItemLayerCallback*>(this);
    if (!strcmp(_clname, "IKeywordActive"))
        return static_cast< IKeywordActive*>(this);
    if (!strcmp(_clname, "ISearchItemClick"))
        return static_cast< ISearchItemClick*>(this);
    if (!strcmp(_clname, "IDecoderPannel"))
        return static_cast< IDecoderPannel*>(this);
    if (!strcmp(_clname, "IFontForm"))
        return static_cast< IFontForm*>(this);
    return QScrollArea::qt_metacast(_clname);
}

int dsv::dock::ProtocolDock::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QScrollArea::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 16)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 16;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 16)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 16;
    }
    return _id;
}

// SIGNAL 0
void dsv::dock::ProtocolDock::protocol_updated()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "protocoldock.h"
#include <QObject>
#include <QHBoxLayout>
#include <QPainter>
#include <QFormLayout>
#include <QStandardItemModel>
#include <QTableView>
#include <QHeaderView>
#include <QScrollBar>
#include <QRegularExpression>
#include <QFuture>
#include <QProgressDialog>
#include <QtConcurrent/QtConcurrent>
#include <QSizePolicy>
#include <assert.h>
#include <map>
#include <string>
#include <QToolButton>
#include <algorithm>
#include <QTableWidgetItem>
#include "../appcore/sigsession.h"
#include "../view/decodetrace.h"
#include "../data/decodermodel.h"
#include "../data/decoderstack.h"
#include "../dialogs/protocollist.h"
#include "../dialogs/protocolexp.h" 
#include "../view/view.h"
#include "../ui/msgbox.h"
#include "../basedef.h"
#include "../config/appconfig.h"
#include "../decode/decoderstatus.h"
#include "../decode/decoder.h"
#include "../log.h"
#include "../ui/langresource.h"
#include "../appcore/appcontrol.h"
#include "../ui/fn.h"
#include "../decode/displaydataformat.h"

using namespace std;
using namespace dsv::config;
using namespace dsv::decode;

namespace dsv {
namespace dock {
   
ProtocolDock::ProtocolDock(QWidget *parent, view::View &view, SigSession *session) :
    QScrollArea(parent),
    _view(view)
{
    _session = session;
    _cur_search_index = -1;
    _search_edited = false; 
    _pro_add_button = NULL;

    //-----------------------------get protocol list
    GSList *l = const_cast<GSList*>(srd_decoder_list());
    std::map<std::string, int> pro_key_table;
    QString repeatNammes;

    for(; l; l = l->next)
    {
        const srd_decoder *const d = (srd_decoder*)l->data;
        assert(d);

        DecoderInfoItem *info = new DecoderInfoItem();
        srd_decoder *dec = (srd_decoder *)(l->data);
        info->_data_handle = dec;
        _decoderInfoList.push_back(info);

        std::string prokey(dec->id);
        if (pro_key_table.find(prokey) != pro_key_table.end())
        {
            if (repeatNammes != "")
                repeatNammes += ",";
            repeatNammes += QString(dec->id);
        }
        else
        {
            pro_key_table[prokey] = 1;
        }
    }
    g_slist_free(l);
  
    sort(_decoderInfoList.begin(), _decoderInfoList.end(), ProtocolDock::protocol_sort_callback);
  
    if (repeatNammes != ""){
        QString err = L_S(STR_PAGE_MSG, S_ID(IDS_MSG_DECODER_REPEAT), "Any decoder have repeated id or name:");
        err += repeatNammes;
        MsgBox::Show(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_ERROR), "error"), err.toUtf8().data());
    }

    //-----------------------------top panel
    QWidget *top_panel = new QWidget();
    top_panel->setMinimumHeight(70);
    _top_panel = top_panel;
    QWidget* bot_panel = new QWidget();

    _pro_add_button = new QPushButton(top_panel);
    _pro_add_button->setFlat(true);
    _del_all_button = new QPushButton(top_panel);
    _del_all_button->setFlat(true);
    _del_all_button->setCheckable(true);
    _pro_keyword_edit = new KeywordLineEdit(top_panel, this);
    _pro_keyword_edit->setReadOnly(true); 
 
    _pro_search_button = new QToolButton(top_panel);
    QHBoxLayout *pro_search_lay = new QHBoxLayout();
    pro_search_lay->setSpacing(2);
    pro_search_lay->addWidget(_pro_add_button);
    pro_search_lay->addWidget(_del_all_button);
    pro_search_lay->addWidget(_pro_keyword_edit, 1); 
    pro_search_lay->addWidget(_pro_search_button);
  
    _top_layout = new QVBoxLayout();
    _top_layout->addLayout(pro_search_lay);
    _top_layout->addStretch(1);
    top_panel->setLayout(_top_layout); 
 
    //-----------------------------bottom panel
    _bot_set_button = new QPushButton(bot_panel);
    _bot_set_button->setFlat(true);
    _bot_save_button = new QPushButton(bot_panel);
    _bot_save_button->setFlat(true);
    _dn_nav_button = new QPushButton(bot_panel);
    _dn_nav_button->setFlat(true);
    _bot_title_label = new QLabel(bot_panel);

    QHBoxLayout *bot_title_layout = new QHBoxLayout();
    bot_title_layout->setSpacing(2);
    bot_title_layout->addWidget(_bot_set_button);
    bot_title_layout->addWidget(_bot_save_button);
    bot_title_layout->addWidget(_bot_title_label, 1);
    bot_title_layout->addWidget(_dn_nav_button);
    
    _pre_button = new QPushButton(bot_panel);
    _ann_search_button = new QPushButton(bot_panel); //search icon
    _nxt_button = new QPushButton(bot_panel);
    _ann_search_edit = new QLineEdit(bot_panel);
    
    _ann_search_button->setFixedWidth(_ann_search_button->height());
    _ann_search_button->setDisabled(true);
    QHBoxLayout *ann_edit_layout = new QHBoxLayout();
    ann_edit_layout->addWidget(_ann_search_button);
    ann_edit_layout->addStretch(1);
    ann_edit_layout->setContentsMargins(0, 0, 0, 0);
    _ann_search_edit->setLayout(ann_edit_layout);
    _ann_search_edit->setTextMargins(_ann_search_button->width() + 1, 0, 0, 0);

    QHBoxLayout *ann_search_layout = new QHBoxLayout();
    ann_search_layout->setSpacing(2);
    ann_search_layout->addWidget(_pre_button);
    ann_search_layout->addWidget(_ann_search_edit, 1);
    ann_search_layout->addWidget(_nxt_button);

    _table_view = new QTableView(bot_panel);
    _table_view->setModel(_session->get_decoder_model());
    _table_view->setAlternatingRowColors(true);
    _table_view->setShowGrid(false);
    _table_view->horizontalHeader()->setStretchLastSection(true);
    _table_view->setHorizontalScrollMode(QAbstractItemView::ScrollPerPixel);
    _table_view->setVerticalScrollMode(QAbstractItemView::ScrollPerPixel); 

    _matchs_title_label = new QLabel();
    _matchs_label = new QLabel();  
    QHBoxLayout *match_layout = new QHBoxLayout();
    match_layout->addWidget(_matchs_title_label, 0, Qt::AlignLeft);
    match_layout->addWidget(_matchs_label, 0, Qt::AlignLeft);
    match_layout->addStretch(1);

    QVBoxLayout *bot_layout = new QVBoxLayout();
    bot_layout->addLayout(bot_title_layout);
    bot_layout->addLayout(ann_search_layout);
    bot_layout->addLayout(match_layout);
    bot_layout->addWidget(_table_view);
    bot_panel->setLayout(bot_layout); 

    QSplitter *split_widget = new QSplitter(this);
    split_widget->insertWidget(0, top_panel);
    split_widget->insertWidget(1, bot_panel);
    split_widget->setOrientation(Qt::Vertical);
    split_widget->setCollapsible(0, false);
    split_widget->setCollapsible(1, false);

    this->setWidgetResizable(true);
    this->setWidget(split_widget);
    split_widget->setObjectName("protocolWidget");

    retranslateUi();

    connect(_dn_nav_button, SIGNAL(clicked()),this, SLOT(nav_table_view()));
    connect(_bot_save_button, SIGNAL(clicked()),this, SLOT(export_table_view()));
    connect(_bot_set_button, SIGNAL(clicked()),this, SLOT(set_model()));
    connect(_pre_button, SIGNAL(clicked()),this, SLOT(search_pre()));
    connect(_nxt_button, SIGNAL(clicked()),this, SLOT(search_nxt()));
    connect(_pro_add_button, SIGNAL(clicked()),this, SLOT(on_add_protocol()));
    connect(_del_all_button, SIGNAL(clicked()),this, SLOT(on_del_all_protocol())); 

    connect(this, SIGNAL(protocol_updated()), this, SLOT(update_model()));
    connect(_table_view, SIGNAL(clicked(QModelIndex)), this, SLOT(item_clicked(QModelIndex)));

    connect(_table_view->horizontalHeader(), SIGNAL(sectionResized(int,int,int)), 
                    this, SLOT(column_resize(int, int, int)));

    connect(_ann_search_edit, SIGNAL(editingFinished()), this, SLOT(search_changed()));

    connect(_pro_search_button, SIGNAL(clicked()), this, SLOT(show_protocol_select()));

    update_font();
}

ProtocolDock::~ProtocolDock()
{
    //destroy protocol item layers
   for (auto it = _protocol_lay_items.begin(); it != _protocol_lay_items.end(); it++){
       DESTROY_QT_LATER(*it);
   }
   _protocol_lay_items.clear();

   //clear protocol infos list
   RELEASE_ARRAY(_decoderInfoList);
}

void ProtocolDock::retranslateUi()
{
    _ann_search_edit->setPlaceholderText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SEARCH), "search"));
    _matchs_title_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_MATCHING_ITEMS), "Matching Items:"));
    _bot_title_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_PROTOCOL_LIST_VIEWER), "Protocol List Viewer"));
    _pro_keyword_edit->ResetText();
}

void ProtocolDock::reStyle()
{
    QString iconPath = AppConfig::GetIconPath();

    if (_pro_add_button == NULL)
    {
        return;
    }

    _pro_add_button->setIcon(QIcon(iconPath+"/add.svg"));
    _del_all_button->setIcon(QIcon(iconPath+"/del.svg"));
    _bot_set_button->setIcon(QIcon(iconPath+"/gear.svg"));
    _bot_save_button->setIcon(QIcon(iconPath+"/save.svg"));
    _dn_nav_button->setIcon(QIcon(iconPath+"/nav.svg"));
    _pre_button->setIcon(QIcon(iconPath+"/pre.svg"));
    _nxt_button->setIcon(QIcon(iconPath+"/next.svg"));
    _ann_search_button->setIcon(QIcon(iconPath+"/search.svg"));
    _pro_search_button->setIcon(QIcon(iconPath + "/search.svg"));

    for (auto item : _protocol_lay_items){
        item->ResetStyle();
    }
}

void ProtocolDock::changeEvent(QEvent *event)
{
    if (event->type() == QEvent::LanguageChange)
        retranslateUi();
    else if (event->type() == QEvent::StyleChange)
        reStyle();
    QScrollArea::changeEvent(event);
}

int ProtocolDock::decoder_name_cmp(const void *a, const void *b)
{
    return strcmp(((const srd_decoder*)a)->name,
        ((const srd_decoder*)b)->name);
}

int ProtocolDock::get_protocol_index_by_id(QString id)
{
    int dex = 0;
    for (auto info : _decoderInfoList){
        srd_decoder *dec = (srd_decoder *)(info->_data_handle);
        QString proid(dec->id);
        if (id == proid){
            return dex;
        }
        ++dex;
    }
    return -1;
} 

void ProtocolDock::on_add_protocol()
{ 
     if (_decoderInfoList.size() == 0){
        MsgBox::Show(NULL, L_S(STR_PAGE_MSG, S_ID(IDS_MSG_DECODER_LIST_EMPTY), "Decoder list is empty!"));
        return;
    }
    if (_selected_protocol_id == ""){
        MsgBox::Show(NULL, L_S(STR_PAGE_MSG, S_ID(IDS_MSG_NO_SEL_DECODER), "Please select a decoder!"));
        return;
    }

    int dex = this->get_protocol_index_by_id(_selected_protocol_id);
    assert(dex >= 0);

    //check the base protocol
    srd_decoder *const dec = (srd_decoder *)(_decoderInfoList[dex]->_data_handle);
    QString pro_id(dec->id);
    std::list<decode::Decoder*> sub_decoders;
    
    assert(dec->inputs);

    QString input_id = parse_protocol_id((char *)dec->inputs->data);

    if (input_id != "logic")
    {
        pro_id = ""; //reset base protocol

        int base_dex = get_output_protocol_by_id(input_id);
        sub_decoders.push_front(new decode::Decoder(dec));

        while (base_dex != -1)
        {
            srd_decoder *base_dec = (srd_decoder *)(_decoderInfoList[base_dex]->_data_handle);
            pro_id = QString(base_dec->id); //change base protocol           

            assert(base_dec->inputs);

            input_id = parse_protocol_id((char *)base_dec->inputs->data);

            if (input_id == "logic")
            {
                break;
            }

            sub_decoders.push_front(new decode::Decoder(base_dec));
            pro_id = ""; //reset base protocol
            base_dex = get_output_protocol_by_id(input_id);
        }
    }

    if (pro_id == ""){
        MsgBox::Show(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_ERROR), "error"), 
                     L_S(STR_PAGE_MSG, S_ID(IDS_MSG_FIND_BASE_DECODER_ERROR), "find the base decoder error!"));

        for(auto sub: sub_decoders){
            delete sub;
        }
        sub_decoders.clear();

        return;
    }

    add_protocol_by_id(pro_id, false, sub_decoders);
}

bool ProtocolDock::add_protocol_by_id(QString id, bool silent, std::list<dsv::decode::Decoder*> &sub_decoders)
{
    if (_session->get_device()->get_work_mode() != LOGIC) {
        dsv_info("Protocol Analyzer\nProtocol Analyzer is only valid in Digital Mode!");
        return false;
    }

    int dex = this->get_protocol_index_by_id(id);
    if (dex == -1){
        dsv_err("Protocol not exists! id:%s", id.toUtf8().data());
        return false;
    }

    srd_decoder *const decoder = (srd_decoder *)(_decoderInfoList[dex]->_data_handle);
    DecoderStatus *dstatus = new DecoderStatus();
    dstatus->m_format = (int)DisplayDataFormat::hex;

    QString protocolName(decoder->name);
    QString protocolId(decoder->id);

    if (sub_decoders.size()){
        auto it = sub_decoders.end();
        it--;
        protocolName = QString((*it)->decoder()->name);
        protocolId = QString((*it)->decoder()->id); 
    }

    dsv::view::Trace *trace = NULL;

    if (_session->add_decoder(decoder, silent, dstatus, sub_decoders, trace) == false){
        return false;
    }

    // create item layer
    ProtocolItemLayer *layer = new ProtocolItemLayer(_top_panel, protocolName, this);
    _protocol_lay_items.push_back(layer);
    _top_layout->insertLayout(_protocol_lay_items.size(), layer);
    layer->m_decoderStatus = dstatus; 
    layer->m_protocolId = protocolId;
    layer->_trace = trace;

    // set current protocol format
    string fmt = AppConfig::Instance().GetProtocolFormat(protocolId.toStdString());
    if (fmt != "")
    {
        layer->SetProtocolFormat(fmt.c_str());
        dstatus->m_format = DisplayDataFormat::Parse(fmt.c_str());
    }

    // progress connection
    const auto &decode_sigs = _session->get_decode_signals();   
    protocol_updated();
    connect(decode_sigs.back(), SIGNAL(decoded_progress(int)), this, SLOT(decoded_progress(int)));

    return true;
}
 
 void ProtocolDock::on_del_all_protocol(){
     if (_protocol_lay_items.size() == 0){
        MsgBox::Show(NULL, L_S(STR_PAGE_MSG, S_ID(IDS_MSG_NO_DECODER_DEL), "Have no decoder to remove!"), this);
        return;
     }

    QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_DECODER_CONFIRM_DEL_ALL), "Are you sure to remove all decoder?"));
    if (MsgBox::Confirm(strMsg,  this)){
        del_all_protocol();
    }
 } 

void ProtocolDock::del_all_protocol()
{  
    if (_protocol_lay_items.size() > 0)
    {
        _session->clear_all_decoder();

        for (auto it = _protocol_lay_items.begin(); it != _protocol_lay_items.end(); it++)
        {
             DESTROY_QT_LATER((*it)); //destory control
        }

        _protocol_lay_items.clear();
        this->update();
        protocol_updated();
    }
}

void ProtocolDock::decoded_progress(int progress)
{
    const auto &decode_sigs = _session->get_decode_signals();
    unsigned int index = 0;

    for(auto d : decode_sigs) {
        int pg = d->get_progress();
        QString err;

        if (d->decoder()->out_of_memory())
            err = L_S(STR_PAGE_DLG, S_ID(IDS_DLG_OUT_OF_MEMORY), "Out of Memory");

        if (index < _protocol_lay_items.size())
        {
            ProtocolItemLayer &lay =  *(_protocol_lay_items.at(index));
            lay.SetProgress(pg, err);
            
            // have custom data format
            if (pg == 100 && lay.m_decoderStatus != NULL){
                lay.enable_format(lay.m_decoderStatus->m_bNumeric);
            }
        }

        index++;
    }

    if (progress == 0 || progress % 10 == 1){
        update_model();
    }  
}

void ProtocolDock::set_model()
{
    dsv::dialogs::ProtocolList *protocollist_dlg = new dsv::dialogs::ProtocolList(this, _session);
    protocollist_dlg->exec();
    resize_table_view(_session->get_decoder_model());
    _model_proxy.setSourceModel(_session->get_decoder_model());
    search_done();

    // clear mark_index of all DecoderStacks
    const auto &decode_sigs = _session->get_decode_signals();
        
    for(auto d : decode_sigs) {
        d->decoder()->set_mark_index(-1);
    }
}

void ProtocolDock::update_model()
{
    dsv::data::DecoderModel *decoder_model = _session->get_decoder_model();
    const auto &decode_sigs = _session->get_decode_signals();

    if (decode_sigs.size() == 0)
        decoder_model->setDecoderStack(NULL);
    else if (!decoder_model->getDecoderStack())
        decoder_model->setDecoderStack(decode_sigs.at(0)->decoder());
    else {
        unsigned int index = 0;
        for(auto d : decode_sigs) {
            if (d->decoder() == decoder_model->getDecoderStack()) {
                decoder_model->setDecoderStack(d->decoder());
                break;
            }
            index++;
        }
        if (index >= decode_sigs.size())
            decoder_model->setDecoderStack(decode_sigs.at(0)->decoder());
    }
    _model_proxy.setSourceModel(decoder_model);
    search_done();
    resize_table_view(decoder_model);
}

void ProtocolDock::resize_table_view(data::DecoderModel* decoder_model)
{
    if (decoder_model->getDecoderStack()) {
        for (int i = 0; i < decoder_model->columnCount(QModelIndex()) - 1; i++) {
            _table_view->resizeColumnToContents(i);
            if (_table_view->columnWidth(i) > 200)
                _table_view->setColumnWidth(i, 200);
        }
        int top_row = _table_view->rowAt(0);
        int bom_row = _table_view->rowAt(_table_view->height());
        if (bom_row >= top_row && top_row >= 0) {
            for (int i = top_row; i <= bom_row; i++)
                _table_view->resizeRowToContents(i);
        }
    }
}

void ProtocolDock::item_clicked(const QModelIndex &index)
{
    dsv::data::DecoderModel *decoder_model = _session->get_decoder_model();

    auto decoder_stack = decoder_model->getDecoderStack();
    if (decoder_stack) {
        dsv::decode::Annotation ann;
        if (decoder_stack->list_annotation(ann, index.column(), index.row())) {
            const auto &decode_sigs = _session->get_decode_signals();

            for(auto d : decode_sigs) {
                d->decoder()->set_mark_index(-1);
            }

            decoder_stack->set_mark_index((ann.start_sample()+ann.end_sample())/2);
            _session->show_region(ann.start_sample(), ann.end_sample(), false);
        }
    }
    _table_view->resizeRowToContents(index.row());
    if (index.column() != _model_proxy.filterKeyColumn()) {
        _model_proxy.setFilterKeyColumn(index.column());
        _model_proxy.setSourceModel(decoder_model);
        search_done();
    }
    QModelIndex filterIndex = _model_proxy.mapFromSource(index);
    if (filterIndex.isValid()) {
        _cur_search_index = filterIndex.row();
    } else {
        if (_model_proxy.rowCount() == 0) {
            _cur_search_index = -1;
        } else {
            uint64_t up = 0;
            uint64_t dn = _model_proxy.rowCount() - 1;
            do {
                uint64_t md = (up + dn)/2;
                QModelIndex curIndex = _model_proxy.mapToSource(_model_proxy.index(md,_model_proxy.filterKeyColumn()));
                if (index.row() == curIndex.row()) {
                    _cur_search_index = md;
                    break;
                } else if (md == up) {
                    if (curIndex.row() < index.row() && up < dn) {
                        QModelIndex nxtIndex = _model_proxy.mapToSource(_model_proxy.index(md+1,_model_proxy.filterKeyColumn()));
                        if (nxtIndex.row() < index.row())
                            md++;
                    }
                    _cur_search_index = md + ((curIndex.row() < index.row()) ? 0.5 : -0.5);
                    break;
                } else if (curIndex.row() < index.row()) {
                    up = md;
                } else if (curIndex.row() > index.row()) {
                    dn = md;
                }
            }while(1);
        }
    }
}

void ProtocolDock::column_resize(int index, int old_size, int new_size)
{
    (void)index;
    (void)old_size;
    (void)new_size;
    dsv::data::DecoderModel *decoder_model = _session->get_decoder_model();
    if (decoder_model->getDecoderStack()) {
        int top_row = _table_view->rowAt(0);
        int bom_row = _table_view->rowAt(_table_view->height());
        if (bom_row >= top_row && top_row >= 0) {
            for (int i = top_row; i <= bom_row; i++)
                _table_view->resizeRowToContents(i);
        }
    }
}

void ProtocolDock::export_table_view()
{
    dsv::dialogs::ProtocolExp *protocolexp_dlg = new dsv::dialogs::ProtocolExp(this, _session);
    protocolexp_dlg->exec();
}

void ProtocolDock::nav_table_view()
{
    uint64_t row_index = 0;
    dsv::data::DecoderModel *decoder_model = _session->get_decoder_model();

    auto decoder_stack = decoder_model->getDecoderStack();
    if (decoder_stack) {
        uint64_t offset = _view.offset() * (decoder_stack->samplerate() * _view.scale());
        std::map<const dsv::decode::Row, bool> rows = decoder_stack->get_rows_lshow();
        int column = _model_proxy.filterKeyColumn();
        for (std::map<const dsv::decode::Row, bool>::const_iterator i = rows.begin();
            i != rows.end(); i++) {
            if ((*i).second && column-- == 0) {
                row_index = decoder_stack->get_annotation_index((*i).first, offset);
                break;
            }
        }
        QModelIndex index = _model_proxy.mapToSource(_model_proxy.index(row_index, _model_proxy.filterKeyColumn()));
        if(index.isValid()){
            _table_view->scrollTo(index);
            _table_view->setCurrentIndex(index);

            dsv::decode::Annotation ann;
            decoder_stack->list_annotation(ann, index.column(), index.row());
            const auto &decode_sigs = _session->get_decode_signals();

            for(auto d : decode_sigs) {
                d->decoder()->set_mark_index(-1);
            }
            decoder_stack->set_mark_index((ann.start_sample()+ann.end_sample())/2);
            _view.set_all_update(true);
            _view.update();
        }
    }
}

void ProtocolDock::search_pre()
{
    search_update();
    // now the proxy only contains rows that match the name
    // let's take the pre one and map it to the original model
    if (_model_proxy.rowCount() == 0) {
        _table_view->scrollToTop();
        _table_view->clearSelection();
        _matchs_label->setText(QString::number(0));
        _cur_search_index = -1;
        return;
    }
    int i = 0;
    uint64_t rowCount = _model_proxy.rowCount();
    QModelIndex matchingIndex;
    dsv::data::DecoderModel *decoder_model = _session->get_decoder_model();

    auto decoder_stack = decoder_model->getDecoderStack();
    do {
        _cur_search_index--;
        if (_cur_search_index <= -1 || _cur_search_index >= _model_proxy.rowCount())
            _cur_search_index = _model_proxy.rowCount() - 1;

        matchingIndex = _model_proxy.mapToSource(_model_proxy.index(ceil(_cur_search_index),_model_proxy.filterKeyColumn()));
        if (!decoder_stack || !matchingIndex.isValid())
            break;
        i = 1;
        uint64_t row = matchingIndex.row() + 1;
        uint64_t col = matchingIndex.column();
        dsv::decode::Annotation ann;
        bool ann_valid;
        while(i < _str_list.size()) {
            QString nxt = _str_list.at(i);

            do {
                ann_valid = decoder_stack->list_annotation(ann, col, row);
                row++;
            }while(ann_valid && !ann.is_numberic());

            QString source = ann.annotations().at(0);
            if (ann_valid && source.contains(nxt))
                i++;
            else
                break;
        }
    }while(i < _str_list.size() && --rowCount);

    if(i >= _str_list.size() && matchingIndex.isValid()){
        _table_view->scrollTo(matchingIndex);
        _table_view->setCurrentIndex(matchingIndex);
        _table_view->clicked(matchingIndex);
    } else {
        _table_view->scrollToTop();
        _table_view->clearSelection();
        _matchs_label->setText(QString::number(0));
        _cur_search_index = -1;
    }
}

void ProtocolDock::search_nxt()
{
    search_update();
    // now the proxy only contains rows that match the name
    // let's take the pre one and map it to the original model
    if (_model_proxy.rowCount() == 0) {
        _table_view->scrollToTop();
        _table_view->clearSelection();
        _matchs_label->setText(QString::number(0));
        _cur_search_index = -1;
        return;
    }

    int i = 0;
    uint64_t rowCount = _model_proxy.rowCount();
    QModelIndex matchingIndex;
    dsv::data::DecoderModel *decoder_model = _session->get_decoder_model();
    auto decoder_stack = decoder_model->getDecoderStack();

    if (decoder_stack == NULL){ 
        dsv_err("decoder_stack is null");
        return;
    }  

    do {
        _cur_search_index++;
        if (_cur_search_index < 0 || _cur_search_index >= _model_proxy.rowCount())
            _cur_search_index = 0;

        matchingIndex = _model_proxy.mapToSource(_model_proxy.index(floor(_cur_search_index),_model_proxy.filterKeyColumn()));
        
        if (!matchingIndex.isValid())
            break;

        i = 1;
        uint64_t row = matchingIndex.row() + 1;
        uint64_t col = matchingIndex.column();
        dsv::decode::Annotation ann;
        bool ann_valid;

        while(i < _str_list.size()) {
            QString nxt = _str_list.at(i);

            do {
                ann_valid = decoder_stack->list_annotation(ann, col, row);
                row++;
            }while(ann_valid && !ann.is_numberic());

            auto strlist = ann.annotations();
            QString source = ann.annotations().at(0);
            if (ann_valid && source.contains(nxt))
                i++;
            else
                break;
        }
    }while(i < _str_list.size() && --rowCount);

    if(i >= _str_list.size() && matchingIndex.isValid()){
        _table_view->scrollTo(matchingIndex);
        _table_view->setCurrentIndex(matchingIndex);
        _table_view->clicked(matchingIndex);
    } else {
        _table_view->scrollToTop();
        _table_view->clearSelection();
        _matchs_label->setText(QString::number(0));
        _cur_search_index = -1;
    }
}

void ProtocolDock::search_done()
{
    QString str = _ann_search_edit->text().trimmed();
    QRegularExpression rx("(-)");
    _str_list = str.split(rx);
    _model_proxy.setFilterFixedString(_str_list.first());
    if (_str_list.size() > 1)
        _matchs_label->setText("...");
    else
        _matchs_label->setText(QString::number(_model_proxy.rowCount()));
}

void ProtocolDock::search_changed()
{
    _search_edited = true;
    _matchs_label->setText("...");
}

void ProtocolDock::search_update()
{
    if (!_search_edited)
        return;

    dsv::data::DecoderModel *decoder_model = _session->get_decoder_model();

    auto decoder_stack = decoder_model->getDecoderStack();
    if (!decoder_stack)
        return;

    if (decoder_stack->list_annotation_size(_model_proxy.filterKeyColumn()) > ProgressRows) {
        QFuture<void> future;
        future = QtConcurrent::run([&]{
            search_done();
        });
        Qt::WindowFlags flags = Qt::CustomizeWindowHint;
        QProgressDialog dlg(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SEARCHING), "Searching..."),
                            L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CANCEL), "Cancel"),0,0,this,flags);
        dlg.setWindowModality(Qt::WindowModal);
        dlg.setWindowFlags(Qt::Dialog | Qt::FramelessWindowHint | Qt::WindowSystemMenuHint |
                           Qt::WindowMinimizeButtonHint | Qt::WindowMaximizeButtonHint);
        dlg.setCancelButton(NULL);

        QFutureWatcher<void> watcher;
        connect(&watcher,SIGNAL(finished()),&dlg,SLOT(cancel()));
        watcher.setFuture(future);

        dlg.exec();
    } else {
        search_done();
    }
    _search_edited = false;
}

 //-------------------IProtocolItemLayerCallback
void ProtocolDock::OnProtocolSetting(void *handle){
  
    for (auto it = _protocol_lay_items.begin(); it != _protocol_lay_items.end(); it++){
       if ((*it) == handle){ 
             void *key_handel = (*it)->get_protocol_key_handel();
            _session->rst_decoder_by_key_handel(key_handel);
            protocol_updated();
           break;
       } 
   }
}

void ProtocolDock::OnProtocolDelete(void *handle){
    QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_DECODER_CONFIRM_DEL), "Are you sure to remove this decoder?"));

    if (!MsgBox::Confirm(strMsg, this)){
        return;
    } 

    for (auto it = _protocol_lay_items.begin(); it != _protocol_lay_items.end(); it++)
    {
        if ((*it) == handle)
        {
            auto lay = (*it); 
            void *key_handel = lay->get_protocol_key_handel();
        _protocol_lay_items.erase(it);
            DESTROY_QT_LATER(lay);
            _session->remove_decoder_by_key_handel(key_handel);     
            protocol_updated();
            break;
        } 
    }  
}

void ProtocolDock::OnProtocolFormatChanged(QString format, void *handle){
    for (auto it = _protocol_lay_items.begin(); it != _protocol_lay_items.end(); it++){
       if ((*it) == handle){
           auto lay = (*it); 
           AppConfig::Instance().SetProtocolFormat(lay->m_protocolId.toStdString(), format.toStdString());

           if (lay->m_decoderStatus != NULL)
           {
                  lay->m_decoderStatus->m_format = DisplayDataFormat::Parse(format.toStdString().c_str());
                  protocol_updated();
           }
        
           break;
       }
   }
} 
  

bool ProtocolDock::protocol_sort_callback(const DecoderInfoItem *o1, const DecoderInfoItem *o2)
{
    srd_decoder *dec1 = (srd_decoder *)(o1->_data_handle);
    srd_decoder *dec2 = (srd_decoder *)(o2->_data_handle);
    const char *s1 = dec1->name;
    const char *s2 = dec2->name;
    char c1 = 0;
    char c2 = 0;

    while (*s1 && *s2)
    {
        c1 = *s1;
        c2 = *s2;

        if (c1 >= 'a' && c1 <= 'z') c1 -= 32;
        if (c2 >= 'a' && c2 <= 'z') c2 -= 32;                               

        if (c1 > c2)
            return false;
        else if (c1 < c2)
            return true;
        
        s1++;
        s2++;
    }

    if (*s1)
        return false;
    else if (*s2)
        return true;

    return true;
}

 QString ProtocolDock::parse_protocol_id(const char *id)
 {
     if (id == NULL || *id == 0){
         assert(false);
     }
     char buf[25];
     strncpy(buf, id, sizeof(buf)-1);
     char *rd = buf;
     char *start = NULL;
     unsigned int len = 0;

     while (*rd && len - 1 < sizeof(buf))
     { 
         if (*rd == '['){
             start = rd++;
         }
         else if (*rd == ']'){
             *rd = 0;
             break;
         }
         ++rd;
         len++;
     }
     if (start == NULL){
         start = const_cast<char*>(id);
     }

     return QString(start);
 }

  int ProtocolDock::get_output_protocol_by_id(QString id)
  {
      int dex = 0;

      for (auto info : _decoderInfoList)
      {
          srd_decoder *dec = (srd_decoder *)(info->_data_handle);
          if (dec->outputs)
          {
              QString output_id = parse_protocol_id((char*)dec->outputs->data);
              if (output_id == id)
              {
                  QString proid(dec->id);
                  if (!proid.startsWith("0:") || output_id == proid){
                      return dex;
                  } 
              }
          }
         
          ++dex;
      }

      return -1;
  }

  void ProtocolDock::BeginEditKeyword()
  {
      show_protocol_select();
  }

  void ProtocolDock::show_protocol_select()
  {
      SearchComboBox *panel = new SearchComboBox(this);

      for (auto info : _decoderInfoList)
      {
          srd_decoder *dec = (srd_decoder *)(info->_data_handle);
          panel->AddDataItem(QString(dec->id), QString(dec->name), info);
      }

      QFont font = this->font();
      font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
      ui::set_form_font(panel, font);

      panel->SetItemClickHandle(this);
      panel->ShowDlg(_pro_keyword_edit);
  }

 void ProtocolDock::OnItemClick(void *sender, void *data_handle)
 {
    (void)sender;

     if (data_handle != NULL){
         DecoderInfoItem *info = (DecoderInfoItem*)data_handle;
         srd_decoder *dec = (srd_decoder *)(info->_data_handle); 
         this->_pro_keyword_edit->SetInputText(QString(dec->name)); 
         _selected_protocol_id = QString(dec->id);
         this->on_add_protocol();       
     }
 }

 void ProtocolDock::reset_view()
 {
    decoded_progress(0);
    update();
 }

 void ProtocolDock::update_view_status()
 {
    bool bEnable = _session->is_working() == false;
    _pro_keyword_edit->setEnabled(bEnable);
    _pro_add_button->setEnabled(bEnable);
    _pro_search_button->setEnabled(bEnable);
 }

 void ProtocolDock::update_deocder_item_name(void *trace_handel, const char *name)
 {
    for(auto p : _protocol_lay_items){
        if (p->_trace == trace_handel){
            p->set_label_name(QString(name));
            break;
        }
    }
 }

 void ProtocolDock::update_font()
 {
    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
    ui::set_form_font(this, font);
    _table_view->setFont(font);

    for(auto lay : _protocol_lay_items){
        lay->update_font();
    }

    font.setPointSizeF(font.pointSizeF() + 1);
    this->parentWidget()->setFont(font);
    _table_view->horizontalHeader()->setFont(font);
 }

} // namespace dock
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_MEASUREDOCK_H
#define DSVIEW_PV_MEASUREDOCK_H

#include <QDockWidget>
#include <QPushButton>
#include <QLabel>
#include <QRadioButton>
#include <QSlider>
#include <QLineEdit>
#include <QSpinBox>
#include <QGroupBox>
#include <QTableWidget>
#include <QCheckBox>
#include <QVector>
#include <QGridLayout>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QScrollArea>
#include <vector>
#include "../ui/dscombobox.h"
#include "../interface/icallbacks.h"

namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
    namespace view {
        class Cursor;
        class View;
    }
}
using namespace dsv::appcore;
using namespace dsv::view;

namespace dsv {
namespace dock {

struct cursor_row_info
{
    QToolButton     *del_bt;
    QPushButton     *start_bt;
    QPushButton     *end_bt;
    QLabel          *r_label;
    QComboBox       *box;
    int             cursor1;
    int             cursor2;
};

struct cursor_opt_info
{ 
    QToolButton     *del_bt;
    QPushButton     *goto_bt;
    QLabel          *info_label;
    view::Cursor    *cursor;
};

class MeasureDock : public QScrollArea, public IFontForm
{
    Q_OBJECT

private:
    static const int Max_Measure_Limits = 15;

public:
    MeasureDock(QWidget *parent, dsv::view::View &view, SigSession *session);
    ~MeasureDock();

    void reload();

private:
    void changeEvent(QEvent *event);
    void retranslateUi();
    void reStyle();

    //IFontForm
    void update_font() override;

    void build_dist_pannel();
    void build_edge_pannel();

private:
    QComboBox* create_probe_selector(QWidget *parent);
    void update_probe_selector(QComboBox *selector);

private slots:
    void goto_cursor();
    void del_dist_measure();
    void add_edge_measure();
    void del_edge_measure();
    void show_all_coursor();
    void set_sel_cursor();
    void update_dist();
    void update_edge();
    void set_cursor_btn_color(QPushButton *btn);
    void del_cursor();
    void add_dist_measure();

public slots:   
    void cursor_update();
    void cursor_moving();
    void reCalc();
    void measure_updated();
    void refresh();

private:
    SigSession *_session;
    view::View &_view;

    QWidget *_widget;
    QGridLayout *_mouse_layout;
    QGroupBox *_mouse_groupBox;
    QCheckBox *_fen_checkBox;
    QLabel *_width_label;
    QLabel *_period_label;
    QLabel *_freq_label;
    QLabel *_duty_label;
    QLabel *_add_dec_label;
    QGridLayout *_dist_layout;
    QGroupBox *_dist_groupBox;
    QToolButton *_dist_add_btn;
    QGridLayout *_edge_layout;
    QGroupBox *_edge_groupBox;
    QToolButton *_edge_add_btn;
    QPushButton *_sel_btn;
    QWidget     *_dist_pannel;
    QWidget     *_edge_pannel;

    QGridLayout *_cursor_layout;
    QGroupBox *_cursor_groupBox;
    std::vector<cursor_row_info>   _dist_row_list;
    std::vector<cursor_row_info>   _edge_row_list;
    std::vector<cursor_opt_info>   _opt_row_list;

    QLabel *_channel_label;
    QLabel *_edge_label;
    QLabel *_time_label;
    QLabel *_w_label;
    QLabel *_p_label;
    QLabel *_f_label;
    QLabel *_d_label;
};

} // namespace dock
} // namespace dsv

#endif // DSVIEW_PV_MEASUREDOCK_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#pragma once

#include <QHBoxLayout>
#include <QPushButton>
#include <QLabel>
#include <QString>
#include "../ui/dscombobox.h"

namespace dsv{
	namespace decode{
    	class DecoderStatus; 
	}
    namespace view{
        class Trace;
    }
}
using namespace dsv::decode;
using namespace dsv::view;

namespace dsv{
namespace dock{

class IProtocolItemLayerCallback
 {
    public:
        virtual void OnProtocolSetting(void *handle)=0;
        virtual void OnProtocolDelete(void *handle)=0;
        virtual void OnProtocolFormatChanged(QString format, void *handle)=0;
};

class ProtocolItemLayer: public QHBoxLayout
{
    Q_OBJECT

public:
    ProtocolItemLayer(QWidget *parent, QString protocolName, IProtocolItemLayerCallback *callback);
    ~ProtocolItemLayer();

    void SetProgress(int progress, QString text);
    void ResetStyle();
    void LoadFormatSelect(bool bSingle);
    inline QString &GetProtocolName(){return _protocolName;}
    void SetProtocolFormat(const char *format);

    inline void* get_protocol_key_handel(){
        return m_decoderStatus;
    }

    void enable_format(bool flag);

    void set_label_name(QString name);

    void update_font();
  
private slots: 
    void on_set_protocol(); 
    void on_del_protocol();
    void on_format_select_changed(int index);

public:
    DecoderStatus *m_decoderStatus; //DecoderStatus
    QString        m_protocolId;
    dsv::view::Trace *_trace;
  
private:
    QLabel *_protocol_label;
    QLabel *_progress_label;
    QPushButton *_set_button;
    QPushButton *_del_button;
    DsComboBox  *_format_combox;
    IProtocolItemLayerCallback *m_callback;
    QString     _protocolName; //the lable text
    bool        m_bSetting;
    bool        m_singleFlag; 
};

 } //dock
} //pv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_SEARCHDOCK_H
#define DSVIEW_PV_SEARCHDOCK_H

#include <QDockWidget>
#include <QPushButton>
#include <QLabel>
#include <QRadioButton>
#include <QSlider>
#include <QLineEdit>
#include <QSpinBox>
#include <QGroupBox>
#include <QTableWidget>
#include <QCheckBox>
#include <QVector>
#include <QGridLayout>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <vector>
#include "../widgets/fakelineedit.h"
#include "../ui/dscombobox.h"
#include "../interface/icallbacks.h"

namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
    namespace view {
        class View;
    }
    namespace widgets {
        class FakeLineEdit;
    }
}
using namespace dsv::appcore;
using namespace dsv::view;
using namespace dsv::widgets;

namespace dsv {
namespace dock {

class SearchDock : public QWidget, public IFontForm
{
    Q_OBJECT

public:
    SearchDock(QWidget *parent, dsv::view::View &view, SigSession *session);
    ~SearchDock();

    void paintEvent(QPaintEvent *);

private:
    void changeEvent(QEvent *event);
    void retranslateUi();
    void reStyle();

    //IFontForm
    void update_font() override;

public slots:
    void on_previous();
    void on_next();
    void on_set();

private:
    SigSession *_session;
    view::View &_view;
    std::map<uint16_t, QString> _pattern;

    QPushButton _pre_button;
    QPushButton _nxt_button;
    widgets::FakeLineEdit* _search_value;
    QPushButton *_search_button;
};

} // namespace dock
} // namespace dsv

#endif // DSVIEW_PV_SEARCHDOCK_H
/****************************************************************************
** Meta object code from reading C++ file 'keywordlineedit.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "keywordlineedit.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'keywordlineedit.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSKeywordLineEditENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSKeywordLineEditENDCLASS = QtMocHelpers::stringData(
    "KeywordLineEdit"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSKeywordLineEditENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[16];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSKeywordLineEditENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSKeywordLineEditENDCLASS_t qt_meta_stringdata_CLASSKeywordLineEditENDCLASS = {
    {
        QT_MOC_LITERAL(0, 15)   // "KeywordLineEdit"
    },
    "KeywordLineEdit"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSKeywordLineEditENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject KeywordLineEdit::staticMetaObject = { {
    QMetaObject::SuperData::link<QLineEdit::staticMetaObject>(),
    qt_meta_stringdata_CLASSKeywordLineEditENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSKeywordLineEditENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSKeywordLineEditENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<KeywordLineEdit, std::true_type>
    >,
    nullptr
} };

void KeywordLineEdit::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *KeywordLineEdit::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *KeywordLineEdit::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSKeywordLineEditENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QLineEdit::qt_metacast(_clname);
}

int KeywordLineEdit::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QLineEdit::qt_metacall(_c, _id, _a);
    return _id;
}
QT_WARNING_POP
/****************************************************************************
** Meta object code from reading C++ file 'triggerdock.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "triggerdock.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'triggerdock.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdockSCOPETriggerDockENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdockSCOPETriggerDockENDCLASS = QtMocHelpers::stringData(
    "dsv::dock::TriggerDock",
    "simple_trigger",
    "",
    "adv_trigger",
    "widget_enable",
    "index",
    "value_changed",
    "on_hex_checkbox_click",
    "ck",
    "on_serial_value_changed",
    "v",
    "on_serial_hex_changed"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdockSCOPETriggerDockENDCLASS_t {
    uint offsetsAndSizes[24];
    char stringdata0[23];
    char stringdata1[15];
    char stringdata2[1];
    char stringdata3[12];
    char stringdata4[14];
    char stringdata5[6];
    char stringdata6[14];
    char stringdata7[22];
    char stringdata8[3];
    char stringdata9[24];
    char stringdata10[2];
    char stringdata11[22];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdockSCOPETriggerDockENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdockSCOPETriggerDockENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdockSCOPETriggerDockENDCLASS = {
    {
        QT_MOC_LITERAL(0, 22),  // "dsv::dock::TriggerDock"
        QT_MOC_LITERAL(23, 14),  // "simple_trigger"
        QT_MOC_LITERAL(38, 0),  // ""
        QT_MOC_LITERAL(39, 11),  // "adv_trigger"
        QT_MOC_LITERAL(51, 13),  // "widget_enable"
        QT_MOC_LITERAL(65, 5),  // "index"
        QT_MOC_LITERAL(71, 13),  // "value_changed"
        QT_MOC_LITERAL(85, 21),  // "on_hex_checkbox_click"
        QT_MOC_LITERAL(107, 2),  // "ck"
        QT_MOC_LITERAL(110, 23),  // "on_serial_value_changed"
        QT_MOC_LITERAL(134, 1),  // "v"
        QT_MOC_LITERAL(136, 21)   // "on_serial_hex_changed"
    },
    "dsv::dock::TriggerDock",
    "simple_trigger",
    "",
    "adv_trigger",
    "widget_enable",
    "index",
    "value_changed",
    "on_hex_checkbox_click",
    "ck",
    "on_serial_value_changed",
    "v",
    "on_serial_hex_changed"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdockSCOPETriggerDockENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       7,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   56,    2, 0x08,    1 /* Private */,
       3,    0,   57,    2, 0x08,    2 /* Private */,
       4,    1,   58,    2, 0x08,    3 /* Private */,
       6,    0,   61,    2, 0x08,    5 /* Private */,
       7,    1,   62,    2, 0x08,    6 /* Private */,
       9,    1,   65,    2, 0x08,    8 /* Private */,
      11,    0,   68,    2, 0x08,   10 /* Private */,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::Int,    5,
    QMetaType::Void,
    QMetaType::Void, QMetaType::Bool,    8,
    QMetaType::Void, QMetaType::QString,   10,
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dock::TriggerDock::staticMetaObject = { {
    QMetaObject::SuperData::link<QScrollArea::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdockSCOPETriggerDockENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdockSCOPETriggerDockENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdockSCOPETriggerDockENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<TriggerDock, std::true_type>,
        // method 'simple_trigger'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'adv_trigger'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'widget_enable'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'value_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_hex_checkbox_click'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>,
        // method 'on_serial_value_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<const QString &, std::false_type>,
        // method 'on_serial_hex_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::dock::TriggerDock::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<TriggerDock *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->simple_trigger(); break;
        case 1: _t->adv_trigger(); break;
        case 2: _t->widget_enable((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 3: _t->value_changed(); break;
        case 4: _t->on_hex_checkbox_click((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        case 5: _t->on_serial_value_changed((*reinterpret_cast< std::add_pointer_t<QString>>(_a[1]))); break;
        case 6: _t->on_serial_hex_changed(); break;
        default: ;
        }
    }
}

const QMetaObject *dsv::dock::TriggerDock::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dock::TriggerDock::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdockSCOPETriggerDockENDCLASS.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "IFontForm"))
        return static_cast< IFontForm*>(this);
    return QScrollArea::qt_metacast(_clname);
}

int dsv::dock::TriggerDock::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QScrollArea::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 7)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 7;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 7)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 7;
    }
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2022 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef SEARCHCOMBOBOX_H
#define SEARCHCOMBOBOX_H

#include <QObject>
#include <QDialog>
#include <QWidget> 
#include <QMouseEvent>
#include <QPushButton>
#include <QString>
#include <vector>
#include <QEvent>
#include <QScrollArea>

class ISearchItemClick{
public:
    virtual void OnItemClick(void *sender, void *data_handle)=0;
};
 
//----------------------ComboButtonItem
class ComboButtonItem : public QPushButton
 {
    Q_OBJECT
public:
    ComboButtonItem(QWidget *parent, ISearchItemClick *click, void *data_handle);

protected:
    void mousePressEvent(QMouseEvent *e);

private:
    void *_data_handle;
    ISearchItemClick *_click;
 };

//----------------------SearchDataItem

class SearchDataItem{
public:
    QString     _id;
    QString     _name;
    void        *_data_handle;
    QWidget     *_control;
};

//----------------------SearchComboBox

class SearchComboBox : public QDialog, ISearchItemClick
{
    Q_OBJECT
public:
    explicit SearchComboBox(QWidget *parent = nullptr);

    ~SearchComboBox();

    void ShowDlg(QWidget *editline);

    void AddDataItem(QString id, QString name, void *data_handle);

    inline void SetItemClickHandle(ISearchItemClick *click){
        _item_click = click;        
    }

protected: 
    void changeEvent(QEvent *event);

private slots:
    void on_keyword_changed(const QString &value);
 
private:
    //ISearchItemClick
    void OnItemClick(void *sender, void *data_handle);

private: 
    bool    _bShow;
    std::vector<SearchDataItem*> _items;
    ISearchItemClick *_item_click;
    QScrollArea *_scroll;
};

#endif // SEARCHCOMBOBOX_H
/****************************************************************************
** Meta object code from reading C++ file 'searchcombobox.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "searchcombobox.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'searchcombobox.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSComboButtonItemENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSComboButtonItemENDCLASS = QtMocHelpers::stringData(
    "ComboButtonItem"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSComboButtonItemENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[16];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSComboButtonItemENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSComboButtonItemENDCLASS_t qt_meta_stringdata_CLASSComboButtonItemENDCLASS = {
    {
        QT_MOC_LITERAL(0, 15)   // "ComboButtonItem"
    },
    "ComboButtonItem"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSComboButtonItemENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject ComboButtonItem::staticMetaObject = { {
    QMetaObject::SuperData::link<QPushButton::staticMetaObject>(),
    qt_meta_stringdata_CLASSComboButtonItemENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSComboButtonItemENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSComboButtonItemENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<ComboButtonItem, std::true_type>
    >,
    nullptr
} };

void ComboButtonItem::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *ComboButtonItem::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *ComboButtonItem::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSComboButtonItemENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QPushButton::qt_metacast(_clname);
}

int ComboButtonItem::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QPushButton::qt_metacall(_c, _id, _a);
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSSearchComboBoxENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSSearchComboBoxENDCLASS = QtMocHelpers::stringData(
    "SearchComboBox",
    "on_keyword_changed",
    "",
    "value"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSSearchComboBoxENDCLASS_t {
    uint offsetsAndSizes[8];
    char stringdata0[15];
    char stringdata1[19];
    char stringdata2[1];
    char stringdata3[6];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSSearchComboBoxENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSSearchComboBoxENDCLASS_t qt_meta_stringdata_CLASSSearchComboBoxENDCLASS = {
    {
        QT_MOC_LITERAL(0, 14),  // "SearchComboBox"
        QT_MOC_LITERAL(15, 18),  // "on_keyword_changed"
        QT_MOC_LITERAL(34, 0),  // ""
        QT_MOC_LITERAL(35, 5)   // "value"
    },
    "SearchComboBox",
    "on_keyword_changed",
    "",
    "value"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSSearchComboBoxENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   20,    2, 0x08,    1 /* Private */,

 // slots: parameters
    QMetaType::Void, QMetaType::QString,    3,

       0        // eod
};

Q_CONSTINIT const QMetaObject SearchComboBox::staticMetaObject = { {
    QMetaObject::SuperData::link<QDialog::staticMetaObject>(),
    qt_meta_stringdata_CLASSSearchComboBoxENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSSearchComboBoxENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSSearchComboBoxENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<SearchComboBox, std::true_type>,
        // method 'on_keyword_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<const QString &, std::false_type>
    >,
    nullptr
} };

void SearchComboBox::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<SearchComboBox *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->on_keyword_changed((*reinterpret_cast< std::add_pointer_t<QString>>(_a[1]))); break;
        default: ;
        }
    }
}

const QMetaObject *SearchComboBox::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *SearchComboBox::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSSearchComboBoxENDCLASS.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "ISearchItemClick"))
        return static_cast< ISearchItemClick*>(this);
    return QDialog::qt_metacast(_clname);
}

int SearchComboBox::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QDialog::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 1;
    }
    return _id;
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "dsotriggerdock.h"
#include <QObject>
#include <QLabel>
#include <QRadioButton>
#include <QPainter>
#include <QStyleOption>
#include <QVector>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QEvent>
#include "../appcore/sigsession.h"
#include "../dialogs/dsmessagebox.h"
#include "../view/dsosignal.h" 
#include "../ui/langresource.h"
#include "../log.h"
#include "../ui/msgbox.h"
#include "../config/appconfig.h"
#include "../ui/fn.h"

using namespace boost;
using namespace std;
using namespace dsv::config;

namespace dsv {
namespace dock {

DsoTriggerDock::DsoTriggerDock(QWidget *parent, SigSession *session) :
    QScrollArea(parent),
    _session(session)
{
    this->setWidgetResizable(true);
    _widget = new QWidget(this);

    _position_label = new QLabel(_widget);
    _position_spinBox = new QSpinBox(_widget);
    _position_spinBox->setRange(1, 99);
    _position_spinBox->setButtonSymbols(QAbstractSpinBox::NoButtons);
    _position_slider = new QSlider(Qt::Horizontal, _widget);
    _position_slider->setRange(1, 99);
    connect(_position_slider, SIGNAL(valueChanged(int)), _position_spinBox, SLOT(setValue(int)));
    connect(_position_spinBox, SIGNAL(valueChanged(int)), _position_slider, SLOT(setValue(int)));
    connect(_position_slider, SIGNAL(valueChanged(int)), this, SLOT(pos_changed(int)));

    _holdoff_label = new QLabel(_widget);
    _holdoff_comboBox = new DsComboBox(_widget);
    //tr
    _holdoff_comboBox->addItem(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_S), "S"), QVariant::fromValue(1000000000));
    _holdoff_comboBox->addItem(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_MS), "mS"), QVariant::fromValue(1000000));
    _holdoff_comboBox->addItem(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_US), "uS"), QVariant::fromValue(1000));
   
    _holdoff_comboBox->setCurrentIndex(0);
    _holdoff_spinBox = new QSpinBox(_widget);
    _holdoff_spinBox->setRange(0, 999);
    _holdoff_spinBox->setButtonSymbols(QAbstractSpinBox::NoButtons);
    _holdoff_slider = new QSlider(Qt::Horizontal, _widget);
    _holdoff_slider->setRange(0, 999);

    connect(_holdoff_slider, SIGNAL(valueChanged(int)), _holdoff_spinBox, SLOT(setValue(int)));
    connect(_holdoff_spinBox, SIGNAL(valueChanged(int)), _holdoff_slider, SLOT(setValue(int)));
    connect(_holdoff_slider, SIGNAL(valueChanged(int)), this, SLOT(hold_changed(int)));
    connect(_holdoff_comboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(hold_changed(int)));

    _margin_label = new QLabel(_widget);
    _margin_slider = new QSlider(Qt::Horizontal, _widget);
    _margin_slider->setRange(0, 15);
    connect(_margin_slider, SIGNAL(valueChanged(int)), this, SLOT(margin_changed(int)));

    _tSource_label = new QLabel(_widget);
    _auto_radioButton = new QRadioButton(_widget);
    _auto_radioButton->setChecked(true);
    _ch0_radioButton = new QRadioButton(_widget);
    _ch1_radioButton = new QRadioButton(_widget);
    _ch0a1_radioButton = new QRadioButton(_widget);
    _ch0o1_radioButton = new QRadioButton(_widget);

    connect(_auto_radioButton, SIGNAL(clicked()), this, SLOT(source_changed()));
    connect(_ch0_radioButton, SIGNAL(clicked()), this, SLOT(source_changed()));
    connect(_ch1_radioButton, SIGNAL(clicked()), this, SLOT(source_changed()));
    connect(_ch0a1_radioButton, SIGNAL(clicked()), this, SLOT(source_changed()));
    connect(_ch0o1_radioButton, SIGNAL(clicked()), this, SLOT(source_changed()));

    _tType_label = new QLabel(_widget);
    _rising_radioButton = new QRadioButton(_widget);
    _rising_radioButton->setChecked(true);
    _falling_radioButton = new QRadioButton(_widget);

    connect(_rising_radioButton, SIGNAL(clicked()), this, SLOT(type_changed()));
    connect(_falling_radioButton, SIGNAL(clicked()), this, SLOT(type_changed()));

    _source_group=new QButtonGroup(_widget);
    _channel_comboBox = new DsComboBox(_widget);
    _type_group=new QButtonGroup(_widget);

    _source_group->addButton(_auto_radioButton);
    _source_group->addButton(_ch0_radioButton);
    _source_group->addButton(_ch1_radioButton);
    _source_group->addButton(_ch0a1_radioButton);
    _source_group->addButton(_ch0o1_radioButton);
    _source_group->setId(_auto_radioButton, DSO_TRIGGER_AUTO);
    _source_group->setId(_ch0_radioButton, DSO_TRIGGER_CH0);
    _source_group->setId(_ch1_radioButton, DSO_TRIGGER_CH1);
    _source_group->setId(_ch0a1_radioButton, DSO_TRIGGER_CH0A1);
    _source_group->setId(_ch0o1_radioButton, DSO_TRIGGER_CH0O1);

    _type_group->addButton(_rising_radioButton);
    _type_group->addButton(_falling_radioButton);
    _type_group->setId(_rising_radioButton, DSO_TRIGGER_RISING);
    _type_group->setId(_falling_radioButton, DSO_TRIGGER_FALLING);

    QVBoxLayout *layout = new QVBoxLayout(_widget);
    QGridLayout *gLayout = new QGridLayout();
    gLayout->setVerticalSpacing(5);
    gLayout->addWidget(_position_label, 0, 0);
    gLayout->addWidget(_position_spinBox, 0, 1);
    //tr
    gLayout->addWidget(new QLabel("%", _widget), 0, 2);
    gLayout->addWidget(_position_slider, 1, 0, 1, 4);

    gLayout->addWidget(new QLabel(_widget), 2, 0);
    gLayout->addWidget(_tSource_label, 3, 0);
    gLayout->addWidget(_auto_radioButton, 4, 0);
    gLayout->addWidget(_channel_comboBox, 4, 1, 1, 3);
    gLayout->addWidget(_ch0_radioButton, 5, 0);
    gLayout->addWidget(_ch1_radioButton, 5, 1, 1, 3);
    gLayout->addWidget(_ch0a1_radioButton, 6, 0);
    gLayout->addWidget(_ch0o1_radioButton, 6, 1, 1, 3);

    gLayout->addWidget(new QLabel(_widget), 7, 0);
    gLayout->addWidget(_tType_label, 8, 0);
    gLayout->addWidget(_rising_radioButton, 9, 0);
    gLayout->addWidget(_falling_radioButton, 10, 0);

    gLayout->addWidget(new QLabel(_widget), 11, 0);
    gLayout->addWidget(_holdoff_label, 12, 0);
    gLayout->addWidget(_holdoff_spinBox, 12, 1);
    gLayout->addWidget(_holdoff_comboBox, 12, 2);
    gLayout->addWidget(_holdoff_slider, 13, 0, 1, 4);

    gLayout->addWidget(new QLabel(_widget), 14, 0);
    gLayout->addWidget(_margin_label, 15, 0);
    gLayout->addWidget(_margin_slider, 16, 0, 1, 4);

    gLayout->setColumnStretch(4, 1);

    layout->addLayout(gLayout);
    layout->addStretch(1);
    _widget->setLayout(layout);

    this->setWidget(_widget);
    //_widget->setGeometry(0, 0, sizeHint().width(), sizeHint().height());
    _widget->setObjectName("dsoTriggerWidget");

    retranslateUi();

    update_font();
}

DsoTriggerDock::~DsoTriggerDock()
{
}

void DsoTriggerDock::changeEvent(QEvent *event)
{
    if (event->type() == QEvent::LanguageChange)
        retranslateUi();
    else if (event->type() == QEvent::StyleChange)
        reStyle();
    QScrollArea::changeEvent(event);
}

void DsoTriggerDock::retranslateUi()
{ 
    _position_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_TRIGGER_POSITION), "Trigger Position: "));
    _holdoff_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_HOLD_OFF_TIME), "Hold Off Time: "));
    _margin_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_NOISE_SENSITIVITY), "Noise Sensitivity: "));
    _tSource_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_TRIGGER_SOURCES), "Trigger Sources: "));
    _tType_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_TRIGGER_TYPES), "Trigger Types: "));
    _rising_radioButton->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_RISING_EDGE), "Rising Edge"));
    _falling_radioButton->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_FALLING_EDGE), "Falling Edge"));

    _auto_radioButton->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_AUTO), "Auto"));
    _ch0_radioButton->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CHANNEL_0), "Channel 0"));
    _ch1_radioButton->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CHANNEL_1), "Channel 1"));
    _ch0a1_radioButton->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CHANNEL_0_AND_1), "Channel 0 && 1"));
    _ch0o1_radioButton->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CHANNEL_0_OR_1), "Channel 0 | 1"));
}

void DsoTriggerDock::reStyle()
{
     
}

void DsoTriggerDock::paintEvent(QPaintEvent *e)
{
    (void)e;
}

void DsoTriggerDock::auto_trig(int index)
{
    _source_group->button(DSO_TRIGGER_AUTO)->setChecked(true);
    _channel_comboBox->setCurrentIndex(index);
    source_changed();
    channel_changed(index);
}

void DsoTriggerDock::pos_changed(int pos)
{
    int ret;
    ret = _session->get_device()->set_config_byte(
                                            SR_CONF_HORIZ_TRIGGERPOS,pos);
    if (!ret) {        
        if (_session->get_device()->is_hardware() || true){
            QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_CHANGE_HOR_TRI_POS_FAIL), 
                                       "Change horiz trigger position failed!"));
                                
            MsgBox::Show(strMsg);
        }
        
        return;
    }
    set_trig_pos(pos);
}

void DsoTriggerDock::hold_changed(int hold)
{ 
    (void)hold;
    int ret;
    uint64_t holdoff;

    if (_holdoff_comboBox->currentData().toDouble() == 1000000000)
        _holdoff_slider->setRange(0, 10);
    else
        _holdoff_slider->setRange(0, 999);

    holdoff = _holdoff_slider->value() * _holdoff_comboBox->currentData().toDouble() / 10;
    ret = _session->get_device()->set_config_uint64(
                                            SR_CONF_TRIGGER_HOLDOFF,holdoff);

    if (!ret) {
        QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_CHANGE_TRI_HOLDOFF_TIME_FAIL),
                                      "Change trigger hold off time failed!"));
        MsgBox::Show(strMsg);
    }
}

void DsoTriggerDock::margin_changed(int margin)
{
    int ret;
    ret = _session->get_device()->set_config_byte(SR_CONF_TRIGGER_MARGIN, margin);
    if (!ret) {
        QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_CHANGE_SENSITIVITY_FAIL), 
                                      "Change trigger value sensitivity failed!"));
        MsgBox::Show(strMsg);
    }
}

void DsoTriggerDock::source_changed()
{
    if (check_trig_channel() == false){
        _auto_radioButton->setChecked(true);
        _ch1_radioButton->setChecked(false);
        _ch0a1_radioButton->setChecked(false);
        _ch0o1_radioButton->setChecked(false); 

        QString msg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_DISABLED_CHANNEL_TRIG), "Disabled channels cannot be used for triggering!"));
        MsgBox::Show(msg);        
    }

    int id = _source_group->checkedId();
    int ret;

    dsv_info("Set DSO trig type:%d", id);

    ret = _session->get_device()->set_config_byte(SR_CONF_TRIGGER_SOURCE, id);
    if (!ret) {
        QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_CHANGE_SOURCE_FAIL), 
                                      "Change trigger source failed!"));
        MsgBox::Show(strMsg);
    }
}

void DsoTriggerDock::check_setting()
{
    if (check_trig_channel() == false){
        _auto_radioButton->setChecked(true);
        _ch1_radioButton->setChecked(false);
        _ch0a1_radioButton->setChecked(false);
        _ch0o1_radioButton->setChecked(false);

        _session->get_device()->set_config_byte(SR_CONF_TRIGGER_SOURCE, int(DSO_TRIGGER_AUTO));
    }
}

bool DsoTriggerDock::check_trig_channel()
{
    int id = _source_group->checkedId();
    bool b0 = _session->get_device()->channel_is_enable(0);
    bool b1 = _session->get_device()->channel_is_enable(1);

    if (DSO_TRIGGER_CH0 == id && !b0){
        dsv_err("ERROR: The trigger channel is disabled");
        return false;
    }
    else if (DSO_TRIGGER_CH1 == id && !b1){
        dsv_err("ERROR: The trigger channel is disabled");
        return false;
    }
    else if (DSO_TRIGGER_CH0A1 == id && (!b0 || !b1)){
        dsv_err("ERROR: The trigger channel is disabled");
        return false;
    }

    return true;
}

void DsoTriggerDock::channel_changed(int ch)
{
    (void)ch;
    int ret;

    ret = _session->get_device()->set_config_byte(
                                            SR_CONF_TRIGGER_CHANNEL,
                                            int(_channel_comboBox->currentData().toInt()));
    if (!ret) {
        QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_CHANGE_CHANNEL_FAIL), 
                                      "Change trigger channel failed!"));
        MsgBox::Show(strMsg);
    }
}

void DsoTriggerDock::type_changed()
{
    int id = _type_group->checkedId();
    int ret;

    ret = _session->get_device()->set_config_byte(
                                            SR_CONF_TRIGGER_SLOPE,
                                            id);
    if (!ret) {
        QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_CHANGE_TYPE_FAIL), 
                                      "Change trigger type failed!"));
        MsgBox::Show(strMsg);
    }
}

void DsoTriggerDock::device_change()
{
    bool bDisable = _session->get_device()->is_file();
    _position_spinBox->setDisabled(bDisable);
    _position_slider->setDisabled(bDisable);
}

void DsoTriggerDock::update_view()
{
    bool bDisable = _session->get_device()->is_file();
    bool ret;

    if (_session->get_device()->is_demo()){
        bDisable = true;
    }

    for(QAbstractButton * btn :  _source_group->buttons()){
        btn->setDisabled(bDisable);
    }

    for(QAbstractButton * btn : _type_group->buttons()){
        btn->setDisabled(bDisable);
    }

    _holdoff_slider->setDisabled(bDisable);
    _holdoff_spinBox->setDisabled(bDisable);
    _holdoff_comboBox->setDisabled(bDisable);
    _margin_slider->setDisabled(bDisable);
    _channel_comboBox->setDisabled(bDisable);

    _position_spinBox->setDisabled(bDisable);
    _position_slider->setDisabled(bDisable);

    if (_session->get_device()->is_demo()){
        _position_spinBox->setDisabled(false);
        _position_slider->setDisabled(false);
    }

    if (_session->get_device()->is_file()){
        return;
    }

    int pos;
    int src;
    int slope;

    // TRIGGERPOS 
    if (_session->get_device()->get_config_byte(
                                            SR_CONF_HORIZ_TRIGGERPOS, pos)) {
        _position_slider->setValue(pos);
    }

    if (_session->get_device()->get_config_byte(SR_CONF_TRIGGER_SOURCE, src)) {
        _source_group->button(src)->setChecked(true);
    }

    // setup _channel_comboBox
    disconnect(_channel_comboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(channel_changed(int)));
    _channel_comboBox->clear();
    
    for(auto s : _session->get_signals()) {
        if (s->signal_type() == SR_CHANNEL_DSO) {
            view::DsoSignal *dsoSig = (view::DsoSignal*)s;
            _channel_comboBox->addItem(dsoSig->get_name(), QVariant::fromValue(dsoSig->get_index()));
        }
    }
    ret = _session->get_device()->get_config_byte(
                                                SR_CONF_TRIGGER_CHANNEL, src);
    if (ret) { 
        for (int i = 0; i < _channel_comboBox->count(); i++) {
            if (src == _channel_comboBox->itemData(i).toInt()) {
                _channel_comboBox->setCurrentIndex(i);
                break;
            }
        }
    }
    connect(_channel_comboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(channel_changed(int)));

    ret = _session->get_device()->get_config_byte(
                                                SR_CONF_TRIGGER_SLOPE, slope);
    if (ret) {
        _type_group->button(slope)->setChecked(true);
    }

    disconnect(_holdoff_slider, SIGNAL(valueChanged(int)), this, SLOT(hold_changed(int)));
    disconnect(_holdoff_comboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(hold_changed(int)));

    uint64_t holdoff;
    ret = _session->get_device()->get_config_uint64(
                                                SR_CONF_TRIGGER_HOLDOFF, holdoff);
    if (ret) {        
        auto v = holdoff * 10.0;

        for (int i=0; i<_holdoff_comboBox->count(); i++)
        {
            if (v >= _holdoff_comboBox->itemData(i).toDouble()) {
                _holdoff_comboBox->setCurrentIndex(i);
                break;
            }
        }

        if (_holdoff_comboBox->currentData().toDouble() == 1000000000)
            _holdoff_slider->setRange(0, 10);
        else 
            _holdoff_slider->setRange(0, 999);
        
        auto v1 = holdoff * 10.0 / _holdoff_comboBox->currentData().toDouble();
        _holdoff_spinBox->setValue(v1);
    }

    connect(_holdoff_slider, SIGNAL(valueChanged(int)), this, SLOT(hold_changed(int)));
    connect(_holdoff_comboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(hold_changed(int)));

    disconnect(_margin_slider, SIGNAL(valueChanged(int)), this, SLOT(margin_changed(int)));
    
    int  margin;
    ret = _session->get_device()->get_config_byte(
                                                SR_CONF_TRIGGER_MARGIN, margin);
    if (ret) {
        _margin_slider->setValue(margin);
    }
    connect(_margin_slider, SIGNAL(valueChanged(int)), this, SLOT(margin_changed(int)));
}

void DsoTriggerDock::update_font()
{
    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
    ui::set_form_font(this, font);
    font.setPointSizeF(font.pointSizeF() + 1);
    this->parentWidget()->setFont(font);
}

} // namespace dock
} // namespace dsv
/****************************************************************************
** Meta object code from reading C++ file 'searchdock.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "searchdock.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'searchdock.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdockSCOPESearchDockENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdockSCOPESearchDockENDCLASS = QtMocHelpers::stringData(
    "dsv::dock::SearchDock",
    "on_previous",
    "",
    "on_next",
    "on_set"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdockSCOPESearchDockENDCLASS_t {
    uint offsetsAndSizes[10];
    char stringdata0[22];
    char stringdata1[12];
    char stringdata2[1];
    char stringdata3[8];
    char stringdata4[7];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdockSCOPESearchDockENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdockSCOPESearchDockENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdockSCOPESearchDockENDCLASS = {
    {
        QT_MOC_LITERAL(0, 21),  // "dsv::dock::SearchDock"
        QT_MOC_LITERAL(22, 11),  // "on_previous"
        QT_MOC_LITERAL(34, 0),  // ""
        QT_MOC_LITERAL(35, 7),  // "on_next"
        QT_MOC_LITERAL(43, 6)   // "on_set"
    },
    "dsv::dock::SearchDock",
    "on_previous",
    "",
    "on_next",
    "on_set"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdockSCOPESearchDockENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       3,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   32,    2, 0x0a,    1 /* Public */,
       3,    0,   33,    2, 0x0a,    2 /* Public */,
       4,    0,   34,    2, 0x0a,    3 /* Public */,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dock::SearchDock::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdockSCOPESearchDockENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdockSCOPESearchDockENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdockSCOPESearchDockENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<SearchDock, std::true_type>,
        // method 'on_previous'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_next'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'on_set'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void dsv::dock::SearchDock::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<SearchDock *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->on_previous(); break;
        case 1: _t->on_next(); break;
        case 2: _t->on_set(); break;
        default: ;
        }
    }
    (void)_a;
}

const QMetaObject *dsv::dock::SearchDock::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dock::SearchDock::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdockSCOPESearchDockENDCLASS.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "IFontForm"))
        return static_cast< IFontForm*>(this);
    return QWidget::qt_metacast(_clname);
}

int dsv::dock::SearchDock::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 3)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 3;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 3)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 3;
    }
    return _id;
}
QT_WARNING_POP
/****************************************************************************
** Meta object code from reading C++ file 'dsotriggerdock.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "dsotriggerdock.h"
#include <QtCore/qmetatype.h>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'dsotriggerdock.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEDsoTriggerDockENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEDsoTriggerDockENDCLASS = QtMocHelpers::stringData(
    "dsv::dock::DsoTriggerDock",
    "set_trig_pos",
    "",
    "percent",
    "auto_trig",
    "index",
    "pos_changed",
    "pos",
    "hold_changed",
    "hold",
    "margin_changed",
    "margin",
    "source_changed",
    "type_changed",
    "channel_changed",
    "ch"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEDsoTriggerDockENDCLASS_t {
    uint offsetsAndSizes[32];
    char stringdata0[26];
    char stringdata1[13];
    char stringdata2[1];
    char stringdata3[8];
    char stringdata4[10];
    char stringdata5[6];
    char stringdata6[12];
    char stringdata7[4];
    char stringdata8[13];
    char stringdata9[5];
    char stringdata10[15];
    char stringdata11[7];
    char stringdata12[15];
    char stringdata13[13];
    char stringdata14[16];
    char stringdata15[3];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEDsoTriggerDockENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEDsoTriggerDockENDCLASS_t qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEDsoTriggerDockENDCLASS = {
    {
        QT_MOC_LITERAL(0, 25),  // "dsv::dock::DsoTriggerDock"
        QT_MOC_LITERAL(26, 12),  // "set_trig_pos"
        QT_MOC_LITERAL(39, 0),  // ""
        QT_MOC_LITERAL(40, 7),  // "percent"
        QT_MOC_LITERAL(48, 9),  // "auto_trig"
        QT_MOC_LITERAL(58, 5),  // "index"
        QT_MOC_LITERAL(64, 11),  // "pos_changed"
        QT_MOC_LITERAL(76, 3),  // "pos"
        QT_MOC_LITERAL(80, 12),  // "hold_changed"
        QT_MOC_LITERAL(93, 4),  // "hold"
        QT_MOC_LITERAL(98, 14),  // "margin_changed"
        QT_MOC_LITERAL(113, 6),  // "margin"
        QT_MOC_LITERAL(120, 14),  // "source_changed"
        QT_MOC_LITERAL(135, 12),  // "type_changed"
        QT_MOC_LITERAL(148, 15),  // "channel_changed"
        QT_MOC_LITERAL(164, 2)   // "ch"
    },
    "dsv::dock::DsoTriggerDock",
    "set_trig_pos",
    "",
    "percent",
    "auto_trig",
    "index",
    "pos_changed",
    "pos",
    "hold_changed",
    "hold",
    "margin_changed",
    "margin",
    "source_changed",
    "type_changed",
    "channel_changed",
    "ch"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSdsvSCOPEdockSCOPEDsoTriggerDockENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       8,   14, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   62,    2, 0x06,    1 /* Public */,

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       4,    1,   65,    2, 0x0a,    3 /* Public */,
       6,    1,   68,    2, 0x08,    5 /* Private */,
       8,    1,   71,    2, 0x08,    7 /* Private */,
      10,    1,   74,    2, 0x08,    9 /* Private */,
      12,    0,   77,    2, 0x08,   11 /* Private */,
      13,    0,   78,    2, 0x08,   12 /* Private */,
      14,    1,   79,    2, 0x08,   13 /* Private */,

 // signals: parameters
    QMetaType::Void, QMetaType::Int,    3,

 // slots: parameters
    QMetaType::Void, QMetaType::Int,    5,
    QMetaType::Void, QMetaType::Int,    7,
    QMetaType::Void, QMetaType::Int,    9,
    QMetaType::Void, QMetaType::Int,   11,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void, QMetaType::Int,   15,

       0        // eod
};

Q_CONSTINIT const QMetaObject dsv::dock::DsoTriggerDock::staticMetaObject = { {
    QMetaObject::SuperData::link<QScrollArea::staticMetaObject>(),
    qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEDsoTriggerDockENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSdsvSCOPEdockSCOPEDsoTriggerDockENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEDsoTriggerDockENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<DsoTriggerDock, std::true_type>,
        // method 'set_trig_pos'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'auto_trig'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'pos_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'hold_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'margin_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>,
        // method 'source_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'type_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'channel_changed'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<int, std::false_type>
    >,
    nullptr
} };

void dsv::dock::DsoTriggerDock::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<DsoTriggerDock *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->set_trig_pos((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 1: _t->auto_trig((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 2: _t->pos_changed((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 3: _t->hold_changed((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 4: _t->margin_changed((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        case 5: _t->source_changed(); break;
        case 6: _t->type_changed(); break;
        case 7: _t->channel_changed((*reinterpret_cast< std::add_pointer_t<int>>(_a[1]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (DsoTriggerDock::*)(int );
            if (_t _q_method = &DsoTriggerDock::set_trig_pos; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
    }
}

const QMetaObject *dsv::dock::DsoTriggerDock::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *dsv::dock::DsoTriggerDock::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSdsvSCOPEdockSCOPEDsoTriggerDockENDCLASS.stringdata0))
        return static_cast<void*>(this);
    if (!strcmp(_clname, "IFontForm"))
        return static_cast< IFontForm*>(this);
    return QScrollArea::qt_metacast(_clname);
}

int dsv::dock::DsoTriggerDock::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QScrollArea::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 8)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 8;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 8)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 8;
    }
    return _id;
}

// SIGNAL 0
void dsv::dock::DsoTriggerDock::set_trig_pos(int _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}
QT_WARNING_POP
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2022 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "searchcombobox.h"
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QPoint>
#include <QLineEdit>
#include <QScrollBar>
#include "../config/appconfig.h"
#include "../appcore/appcontrol.h"
#include "../ui/fn.h"

using namespace dsv::appcore;
using namespace dsv::config;

//----------------------ComboButtonItem

ComboButtonItem::ComboButtonItem(QWidget *parent, ISearchItemClick *click, void *data_handle)
:QPushButton(parent)
{
    _click = click;
    _data_handle = data_handle;
}

void ComboButtonItem::mousePressEvent(QMouseEvent *e)
{
    (void)e;
    
    if (_click != NULL){
        _click->OnItemClick(this, _data_handle);
    }
}

//----------------------SearchComboBox

SearchComboBox::SearchComboBox(QWidget *parent)
    : QDialog(parent)
{ 
    _bShow = false;
    _item_click = NULL;
    setWindowFlags(Qt::Dialog | Qt::FramelessWindowHint | Qt::WindowSystemMenuHint);
}

SearchComboBox::~SearchComboBox(){
    //release resource
    for (auto o : _items){
        delete o;
    }
    _items.clear();  
}

void SearchComboBox::ShowDlg(QWidget *editline)
{
    if (_bShow)
        return;   

    _bShow = true;
    
    int w = 350; 
    int h = 550;
    int eh = 20;

    if (editline != NULL){
       w = editline->width();
    } 

    this->setFixedSize(w, h);

    QVBoxLayout *grid = new QVBoxLayout(this);
    this->setLayout(grid);
    grid->setContentsMargins(0,0,0,0);
    grid->setAlignment(Qt::AlignTop);
    grid->setSpacing(2);

    QLineEdit *edit = new QLineEdit(this);
    edit->setMaximumWidth(this->width()); 
    grid->addWidget(edit);    
    eh = edit->height();

    QWidget *panel= new QWidget(this);
    panel->setContentsMargins(0,0,0,0);
    panel->setFixedSize(w, h - eh);
    grid->addWidget(panel);   

    QWidget *listPanel =  new QWidget(panel);
    QVBoxLayout *listLay = new QVBoxLayout(listPanel);
    listLay->setContentsMargins(2, 2, 20, 2);
    listLay->setSpacing(0);
    listLay->setAlignment(Qt::AlignTop);

    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);

    for(auto o : _items)
    { 
        ComboButtonItem *bt = new ComboButtonItem(panel, this, o);
        bt->setText(o->_name);
        bt->setObjectName("flat");
        bt->setMaximumWidth(w - 20);
        bt->setMinimumWidth(w - 20);
        o->_control = bt;
        bt->setFont(font);

        listLay->addWidget(bt);        
    } 
 
    _scroll = new QScrollArea(panel);
    _scroll->setWidget(listPanel);
    _scroll->setStyleSheet("QScrollArea{border:none;}");
    _scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    _scroll->setFixedSize(w, h - eh);

    if (editline != NULL)
    {
        QPoint p1 = editline->pos();
        QPoint p2 = editline->mapToGlobal(p1);
        int x = p2.x() - p1.x();
        int y = p2.y() - p1.y();
        this->move(x, y);       
    } 

    edit->setFocus();

    connect(edit, SIGNAL(textEdited(const QString &)), 
                    this, SLOT(on_keyword_changed(const QString &)));

    this->show();
}

void SearchComboBox::AddDataItem(QString id, QString name, void *data_handle)
{
    SearchDataItem *item = new SearchDataItem();
    item->_id = id;
    item->_name = name;
    item->_data_handle = data_handle;
    this->_items.push_back(item);
}

 void SearchComboBox::changeEvent(QEvent *event)
 {
    if (event->type() == QEvent::ActivationChange){
        if (this->isActiveWindow() == false){
            this->close();
            this->deleteLater();
            return;
        }
    }
    
    QWidget::changeEvent(event);
 }

 void SearchComboBox::OnItemClick(void *sender, void *data_handle)
 {
    (void)sender;

     if (data_handle != NULL && _item_click){
         SearchDataItem *item = (SearchDataItem*)data_handle;        
          this->close();
          ISearchItemClick *click = _item_click;
          this->deleteLater();
         click->OnItemClick(this, item->_data_handle);
     }
 }

 void SearchComboBox::on_keyword_changed(const QString &value)
 {
     if (_items.size() == 0)
        return;

     for(auto o : _items)
     {
         if (value == "" 
            || o->_name.indexOf(value, 0, Qt::CaseInsensitive) >= 0
            || o->_id.indexOf(value, 0, Qt::CaseInsensitive) >= 0){
                if (o->_control->isHidden()){
                    o->_control->show();
                }
         }
         else if (o->_control->isHidden() == false){
             o->_control->hide();
         }
     }
     
    _scroll->verticalScrollBar()->setValue(0);
 }
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "searchdock.h"
#include <QObject>
#include <QPainter> 
#include <QRect>
#include <QMouseEvent>
#include <QFuture>
#include <QProgressDialog>
#include <QtConcurrent/QtConcurrent>
#include <stdint.h> 
#include "../appcore/sigsession.h"
#include "../view/cursor.h"
#include "../view/view.h"
#include "../view/timemarker.h"
#include "../view/ruler.h"
#include "../dialogs/search.h"
#include "../data/snapshot.h"
#include "../data/logicsnapshot.h"
#include "../dialogs/dsmessagebox.h"
#include "../config/appconfig.h"
#include "../ui/langresource.h"
#include "../ui/msgbox.h"
#include "../appcore/appcontrol.h"
#include "../ui/fn.h"

using namespace dsv::config;

namespace dsv {
namespace dock {

using namespace dsv::view;
using namespace dsv::widgets;

SearchDock::SearchDock(QWidget *parent, View &view, SigSession *session) :
    QWidget(parent),
    _session(session),
    _view(view)
{ 
    _search_button = new QPushButton(this);
    _search_button->setFixedWidth(_search_button->height());
    _search_button->setDisabled(true);

    QLineEdit *_search_parent = new QLineEdit(this);
    _search_parent->setVisible(false);
    _search_value = new FakeLineEdit(_search_parent);

    QHBoxLayout *search_layout = new QHBoxLayout();
    search_layout->addWidget(_search_button);
    search_layout->addStretch();
    search_layout->setContentsMargins(0, 0, 0, 0);
    _search_value->setLayout(search_layout);
    _search_value->setTextMargins(_search_button->width(), 0, 0, 0);
    _search_value->setReadOnly(true);

    connect(_search_value, SIGNAL(trigger()), this, SLOT(on_set()));

    QHBoxLayout *layout = new QHBoxLayout();
    layout->addStretch(1);
    layout->addWidget(&_pre_button);
    layout->addWidget(_search_value);
    layout->addWidget(&_nxt_button);
    layout->addStretch(1);

    setLayout(layout);

    retranslateUi();

    update_font();

    connect(&_pre_button, SIGNAL(clicked()), this, SLOT(on_previous()));
    connect(&_nxt_button, SIGNAL(clicked()),this, SLOT(on_next()));
}

SearchDock::~SearchDock()
{
}

void SearchDock::changeEvent(QEvent *event)
{
    if (event->type() == QEvent::LanguageChange)
        retranslateUi();
    else if (event->type() == QEvent::StyleChange)
        reStyle();
    QWidget::changeEvent(event);
}

void SearchDock::retranslateUi()
{
    _search_value->setPlaceholderText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SEARCH), "search"));
}

void SearchDock::reStyle()
{
    QString iconPath = AppConfig::GetIconPath();

    _pre_button.setIcon(QIcon(iconPath+"/pre.svg"));
    _nxt_button.setIcon(QIcon(iconPath+"/next.svg"));
    _search_button->setIcon(QIcon(iconPath+"/search.svg"));
}

void SearchDock::paintEvent(QPaintEvent *)
{
//    QStyleOption opt;
//    opt.init(this);
//    QPainter p(this);
//    style()->drawPrimitive(QStyle::PE_Widget, &opt, &p, this);
}

void SearchDock::on_previous()
{
    bool ret;
    int64_t last_pos;
    bool last_hit;
    const auto snapshot = _session->get_snapshot(SR_CHANNEL_LOGIC);
    assert(snapshot);
    const auto logic_snapshot = dynamic_cast<data::LogicSnapshot*>(snapshot);

    if (logic_snapshot == NULL || logic_snapshot->empty()) {
        QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_NO_SAMPLE_DATA), "No Sample data!"));
        MsgBox::Show(strMsg);        
        return;
    }

    const int64_t end = logic_snapshot->get_sample_count() - 1;
    last_pos = _view.get_search_pos();
    last_hit = _view.get_search_hit();
    if (last_pos == 0) {
        QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_SEARCH_AT_START), "Search cursor at the start position!"));
        MsgBox::Show(strMsg);
        return;
    }
    else {
        QFuture<void> future;
        future = QtConcurrent::run([&]{
            last_pos -= last_hit;
            ret = logic_snapshot->pattern_search(0, end, last_pos, _pattern, false);
        });
        Qt::WindowFlags flags = Qt::CustomizeWindowHint;
        QProgressDialog dlg(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SEARCH_PREVIOUS), "Search Previous..."),
                            L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CANCEL), "Cancel"),0,0,this,flags);
        dlg.setWindowModality(Qt::WindowModal);
        dlg.setWindowFlags(Qt::Dialog | Qt::FramelessWindowHint | Qt::WindowSystemMenuHint |
                           Qt::WindowMinimizeButtonHint | Qt::WindowMaximizeButtonHint);
        dlg.setCancelButton(NULL);

        QFutureWatcher<void> watcher;
        connect(&watcher,SIGNAL(finished()),&dlg,SLOT(cancel()));
        watcher.setFuture(future);
        dlg.exec();

        if (!ret) {
            QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_PATTERN_NOT_FOUND), "Pattern not found!"));
            MsgBox::Show(strMsg);
            return;
        } else {
            _view.set_search_pos(last_pos, true);
        }
    }
}

void SearchDock::on_next()
{
    bool ret;
    int64_t last_pos;
    const auto snapshot = _session->get_snapshot(SR_CHANNEL_LOGIC);
    assert(snapshot);
    const auto logic_snapshot = dynamic_cast<data::LogicSnapshot*>(snapshot);

    if (logic_snapshot == NULL || logic_snapshot->empty()) {
        QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_NO_SAMPLE_DATA), "No Sample data!"));
        MsgBox::Show(strMsg);
        return;
    }

    const int64_t end = logic_snapshot->get_sample_count() - 1;
    last_pos = _view.get_search_pos() + _view.get_search_hit();
    if (last_pos >= end) {
        QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_SEARCH_AT_END), "Search cursor at the end position!"));
        MsgBox::Show(strMsg);
        return;
    } else {
        QFuture<void> future;
        future = QtConcurrent::run([&]{
            ret = logic_snapshot->pattern_search(0, end, last_pos, _pattern, true);
        });
        Qt::WindowFlags flags = Qt::CustomizeWindowHint;
        QProgressDialog dlg(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SEARCH_NEXT), "Search Next..."),
                            L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CANCEL), "Cancel"),0,0,this,flags);
        dlg.setWindowModality(Qt::WindowModal);
        dlg.setWindowFlags(Qt::Dialog | Qt::FramelessWindowHint | Qt::WindowSystemMenuHint |
                           Qt::WindowMinimizeButtonHint | Qt::WindowMaximizeButtonHint);
        dlg.setCancelButton(NULL);

        QFutureWatcher<void> watcher;
        connect(&watcher,SIGNAL(finished()),&dlg,SLOT(cancel()));
        watcher.setFuture(future);
        dlg.exec();

        if (!ret) {
            QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_PATTERN_NOT_FOUND), "Pattern not found!"));
            MsgBox::Show(strMsg);
            return;
        } else {
            _view.set_search_pos(last_pos, true);
        }
    }
}

void SearchDock::on_set()
{
    dialogs::Search dlg(this, _session, _pattern);
    connect(_session->device_event_object(), SIGNAL(device_updated()), &dlg, SLOT(reject()));

    if (dlg.exec()) {
        std::map<uint16_t, QString> new_pattern = dlg.get_pattern();

        QString search_label;
        for (auto& iter:new_pattern) {
            iter.second.remove(QChar(' '), Qt::CaseInsensitive);
            iter.second = iter.second.toUpper();
            search_label.push_back(iter.second);
        }

        _search_value->setText(search_label);
        QFontMetrics fm = this->fontMetrics();
        //fm.width(search_label)
        int tw = fm.boundingRect(search_label).width();
        _search_value->setFixedWidth(tw + _search_button->width()+20);

        if (new_pattern != _pattern) {
            _view.set_search_pos(_view.get_search_pos(), false);
            _pattern = new_pattern;
        }
    }
}

void SearchDock::update_font()
{
    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
    _search_value->setFont(font);
}

} // namespace dock
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_PROTOCOLDOCK_H
#define DSVIEW_PV_PROTOCOLDOCK_H

#include <libsigrokdecode.h>

#include <QDockWidget>
#include <QPushButton>
#include <QLabel> 
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QScrollArea>
#include <QSplitter>
#include <QTableView>
#include <QSortFilterProxyModel>
#include <QLineEdit>
#include <QToolButton>
#include <vector>
#include <mutex>
#include <list>
#include "../data/decodermodel.h"
#include "protocolitemlayer.h"
#include "keywordlineedit.h"
#include "searchcombobox.h"
#include "../interface/icallbacks.h"

namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
    namespace decode{
        class Decoder;
    }
    namespace data {
        class DecoderModel;
    }
    namespace view {
        class View;
    }
}
using namespace dsv::appcore;
using namespace dsv::decode;
using namespace dsv::data;
using namespace dsv::view;

namespace dsv {
namespace dock {

struct DecoderInfoItem{
    void  *_data_handle; //srd_decoder* type
};

class ProtocolDock : public QScrollArea, 
public IProtocolItemLayerCallback, 
public IKeywordActive,
public ISearchItemClick,
public IDecoderPannel,
public IFontForm
{
    Q_OBJECT

public:
    static const uint64_t ProgressRows = 100000;

public:
    ProtocolDock(QWidget *parent, view::View &view, SigSession *session);
    ~ProtocolDock();

    void del_all_protocol(); 
    bool add_protocol_by_id(QString id, bool silent, std::list<dsv::decode::Decoder*> &sub_decoders);

    void reset_view();
    void update_view_status();

private:
    void changeEvent(QEvent *event);
    void retranslateUi();
    void reStyle();
    int get_protocol_index_by_id(QString id);
    static QString parse_protocol_id(const char *id);
    int get_output_protocol_by_id(QString id);

    static int decoder_name_cmp(const void *a, const void *b);
    void resize_table_view(data::DecoderModel *decoder_model);
    static bool protocol_sort_callback(const DecoderInfoItem *o1, const DecoderInfoItem *o2);

    //IProtocolItemLayerCallback
    void OnProtocolSetting(void *handle) override;
    void OnProtocolDelete(void *handle) override;
    void OnProtocolFormatChanged(QString format, void *handle) override;

    //IKeywordActive
    void BeginEditKeyword() override; 

    //ISearchItemClick
    void OnItemClick(void *sender, void *data_handle) override;

    //IDecoderPannel
    void update_deocder_item_name(void *trace_handel, const char *name) override;

    //IFontForm
    void update_font() override;

signals:
    void protocol_updated();

public slots:
    void update_model();

private slots:
    void on_add_protocol(); 
    void on_del_all_protocol();
    void decoded_progress(int progress);
    void set_model();   
    void export_table_view();
    void nav_table_view();
    void item_clicked(const QModelIndex &index);
    void column_resize(int index, int old_size, int new_size);
    void search_pre();
    void search_nxt();
    void search_done();
    void search_changed();
    void search_update();
    void show_protocol_select();

private:
    SigSession *_session;
    view::View &_view;
    QSortFilterProxyModel _model_proxy;
    int _cur_search_index;
    QStringList _str_list;

    QWidget     *_top_panel; 
    QTableView  *_table_view;
    QPushButton *_pre_button;
    QPushButton *_nxt_button;
    QLineEdit *_ann_search_edit; 
    QLabel *_matchs_label;
    QLabel *_matchs_title_label;
    QLabel *_bot_title_label;

    QPushButton *_pro_add_button;
    QPushButton *_del_all_button; 
    QVBoxLayout *_top_layout;
    std::vector <ProtocolItemLayer*> _protocol_lay_items; //protocol item layers

    QPushButton *_bot_set_button;
    QPushButton *_bot_save_button;
    QPushButton *_dn_nav_button;
    QPushButton *_ann_search_button;
    std::vector<DecoderInfoItem*> _decoderInfoList;
    KeywordLineEdit *_pro_keyword_edit;
    QString     _selected_protocol_id;
    QToolButton *_pro_search_button; 

    mutable std::mutex _search_mutex;
    bool _search_edited; 
};

} // namespace dock
} // namespace dsv

#endif // DSVIEW_PV_PROTOCOLDOCK_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2022 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef KEY_WORD_LINE_EDIT_H
#define KEY_WORD_LINE_EDIT_H

#include <QObject>
#include <QLineEdit> 
#include <QMouseEvent>
#include <QWidget>

class IKeywordActive{
public:
    virtual void BeginEditKeyword()=0;
};

class KeywordLineEdit : public QLineEdit
 {
    Q_OBJECT

public:
    KeywordLineEdit(QWidget *parent, IKeywordActive *active);

    void ResetText();

    void SetInputText(QString text);

protected:
    void mousePressEvent(QMouseEvent *e); 

private:
    IKeywordActive  *_active;
    bool            _bText;
};


#endif
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "measuredock.h"
#include <math.h>
#include <QObject>
#include <QPainter>
#include "../view/cursor.h"
#include "../view/view.h"
#include "../view/viewport.h"
#include "../view/timemarker.h"
#include "../view/ruler.h"
#include "../view/logicsignal.h"
#include "../data/signaldata.h"
#include "../data/snapshot.h" 
#include "../dialogs/dsdialog.h"
#include "../dialogs/dsmessagebox.h"
#include "../config/appconfig.h"
#include "../ui/langresource.h"
#include "../ui/msgbox.h"
#include "../appcore/appcontrol.h"
#include "../appcore/sigsession.h"
#include "../ui/fn.h"
#include "../log.h"

using namespace boost;
using namespace dsv::config;
using namespace dsv::view;

namespace dsv {
namespace dock {
    
MeasureDock::MeasureDock(QWidget *parent, View &view, SigSession *session) :
    QScrollArea(parent),
    _session(session),
    _view(view)
{     
    _widget = new QWidget(this);  

    _dist_pannel = NULL;
    _edge_pannel = NULL;

    _mouse_groupBox = new QGroupBox(_widget);
    _fen_checkBox = new QCheckBox(_widget);
    _fen_checkBox->setChecked(true);
    _width_label = new QLabel(_widget);
    _period_label = new QLabel(_widget);
    _freq_label = new QLabel(_widget);
    _duty_label = new QLabel(_widget);

    _w_label = new QLabel(_widget);
    _p_label = new QLabel(_widget);
    _f_label = new QLabel(_widget);
    _d_label = new QLabel(_widget);
    _mouse_layout = new QGridLayout();
    _mouse_layout->setVerticalSpacing(5);
    _mouse_layout->addWidget(_fen_checkBox, 0, 0, 1, 6);
    _mouse_layout->addWidget(_w_label, 1, 0);
    _mouse_layout->addWidget(_width_label, 1, 1);
    _mouse_layout->addWidget(_p_label, 1, 4);
    _mouse_layout->addWidget(_period_label, 1, 5);
    _mouse_layout->addWidget(_f_label, 2, 4);
    _mouse_layout->addWidget(_freq_label, 2, 5);
    _mouse_layout->addWidget(_d_label, 2, 0);
    _mouse_layout->addWidget(_duty_label, 2, 1);
    _mouse_layout->addWidget(new QLabel(_widget), 0, 6);
    _mouse_layout->addWidget(new QLabel(_widget), 1, 6);
    _mouse_layout->addWidget(new QLabel(_widget), 2, 6);
    _mouse_layout->setColumnStretch(5, 1);
    _mouse_groupBox->setLayout(_mouse_layout);

    /* cursor distance group */
    _dist_groupBox = new QGroupBox(_widget);
    _dist_groupBox->setMinimumWidth(300);
    _dist_add_btn = new QToolButton(_widget);   

    _dist_layout = new QGridLayout(_widget);
    _dist_layout->setVerticalSpacing(5);
    _dist_layout->addWidget(_dist_add_btn, 0, 0);
    _dist_layout->addWidget(new QLabel(_widget), 0, 1, 1, 3);
    _add_dec_label = new QLabel(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_TIME_SAMPLES), "Time/Samples"), _widget);
    _dist_layout->addWidget(_add_dec_label, 0, 4);
    _dist_layout->addWidget(new QLabel(_widget), 0, 5, 1, 2);
    _dist_layout->setColumnStretch(1, 50);
    _dist_layout->setColumnStretch(6, 100);
    _dist_groupBox->setLayout(_dist_layout);

    /* cursor edges group */
    _edge_groupBox = new QGroupBox(_widget);
    _edge_groupBox->setMinimumWidth(300);
    _edge_add_btn = new QToolButton(_widget);

    _channel_label = new QLabel(_widget);
    _edge_label = new QLabel(_widget);
    _edge_layout = new QGridLayout(_widget);
    _edge_layout->setVerticalSpacing(5);
    _edge_layout->addWidget(_edge_add_btn, 0, 0);
    _edge_layout->addWidget(new QLabel(_widget), 0, 1, 1, 4);
    _edge_layout->addWidget(_channel_label, 0, 5);
    _edge_layout->addWidget(_edge_label, 0, 6);
    _edge_layout->setColumnStretch(1, 50);
    _edge_groupBox->setLayout(_edge_layout);

    /* cursors group */
    _time_label = new QLabel(_widget);
    _cursor_groupBox = new QGroupBox(_widget);
    _cursor_layout = new QGridLayout(_widget);
    _cursor_layout->addWidget(_time_label, 0, 2);
    _cursor_layout->addWidget(new QLabel(_widget), 0, 3);
    _cursor_layout->setColumnStretch(3, 1);

    _cursor_groupBox->setLayout(_cursor_layout);

    QVBoxLayout *layout = new QVBoxLayout(_widget);
    layout->addWidget(_mouse_groupBox);
    layout->addWidget(_dist_groupBox);
    layout->addWidget(_edge_groupBox);
    layout->addWidget(_cursor_groupBox);
    layout->addStretch(1);
    _widget->setLayout(layout);

    this->setWidget(_widget);
    _widget->setGeometry(0, 0, sizeHint().width(), 2000);
    _widget->setObjectName("measureWidget");

    retranslateUi();

    add_dist_measure();

    connect(_dist_add_btn, SIGNAL(clicked()), this, SLOT(add_dist_measure()));
    connect(_edge_add_btn, SIGNAL(clicked()), this, SLOT(add_edge_measure()));
    connect(_fen_checkBox, SIGNAL(stateChanged(int)), &_view, SLOT(set_measure_en(int)));
    connect(&_view, SIGNAL(measure_updated()), this, SLOT(measure_updated()));

    update_font();
}

MeasureDock::~MeasureDock()
{
}

void MeasureDock::changeEvent(QEvent *event)
{
    if (event->type() == QEvent::LanguageChange)
        retranslateUi();
    else if (event->type() == QEvent::StyleChange)
        reStyle();
    QScrollArea::changeEvent(event);
}

void MeasureDock::retranslateUi()
{
    _mouse_groupBox->setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_MOUSE_MEASUREMENT), "Mouse measurement"));
    _fen_checkBox->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_ENABLE_FLOATING_MEASUREMENT), "Enable floating measurement"));
    _dist_groupBox->setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CURSOR_DISTANCE), "Cursor Distance"));
    _edge_groupBox->setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_EDGES), "Edges"));
    _cursor_groupBox->setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CURSORS), "Cursors"));

    _channel_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CHANNEL), "Channel"));
    _edge_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_RIS_OR_FAL_EDGE), "Rising/Falling/Edges"));
    _time_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_TIME_SAMPLES), "Time/Samples"));
    _add_dec_label->setText(_time_label->text());

    _w_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_W), "W: "));
    _p_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_P), "P: "));
    _f_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_F), "F: "));
    _d_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_D), "D: "));
}

void MeasureDock::reStyle()
{
    QString iconPath = AppConfig::GetIconPath();

    _dist_add_btn->setIcon(QIcon(iconPath+"/add.svg"));
    _edge_add_btn->setIcon(QIcon(iconPath+"/add.svg"));

    for (auto it = _dist_row_list.begin(); it != _dist_row_list.end(); it++)
    {
        (*it).del_bt->setIcon(QIcon(iconPath+"/del.svg"));
    }

    for (auto it = _edge_row_list.begin(); it != _edge_row_list.end(); it++)
    {
        (*it).del_bt->setIcon(QIcon(iconPath+"/del.svg"));
    }

    for (auto it = _opt_row_list.begin(); it != _opt_row_list.end(); it++)
    {
        (*it).del_bt->setIcon(QIcon(iconPath+"/del.svg"));
    }
}

void MeasureDock::refresh()
{

}

void MeasureDock::reload()
{
    if (_session->get_device()->get_work_mode() == LOGIC)
        _edge_groupBox->setVisible(true);
    else
        _edge_groupBox->setVisible(false);

    for (auto &o : _edge_row_list){
        update_probe_selector(o.box);
    }

    reCalc();
}

void MeasureDock::measure_updated()
{
    _width_label->setText(_view.get_measure("width"));
    _period_label->setText(_view.get_measure("period"));
    _freq_label->setText(_view.get_measure("frequency"));
    _duty_label->setText(_view.get_measure("duty"));
}

void MeasureDock::build_dist_pannel()
{
    if (_dist_pannel != NULL){
        _dist_pannel->deleteLater();
        _dist_pannel = NULL;
    }

    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);

    QGridLayout  *lay = new QGridLayout();
    _dist_pannel = new QWidget();    
    _dist_pannel->setLayout(lay);
    lay->setColumnStretch(1, 50);
    lay->setColumnStretch(6, 100);
    lay->setVerticalSpacing(5);
    lay->setContentsMargins(0,0,0,0);
    
    int dex = 0;
    QLabel cal_lb;
    cal_lb.setFont(font);
    int bt_w = cal_lb.fontMetrics().horizontalAdvance("22") + 8;

    for (auto &o : _dist_row_list)
    {
        QWidget *row_widget = new QWidget(_widget);
        row_widget->setContentsMargins(0,0,0,0);
        QHBoxLayout *row_layout = new QHBoxLayout(row_widget);
        row_layout->setContentsMargins(0,0,0,0);
        row_layout->setSpacing(0);
        row_widget->setLayout(row_layout);

        QString iconPath = AppConfig::GetIconPath();
        QToolButton *del_btn = new QToolButton(row_widget);
        del_btn->setIcon(QIcon(iconPath+"/del.svg"));
        del_btn->setCheckable(true);
        //tr
        QPushButton *s_btn = new QPushButton("", row_widget);
        //tr
        QPushButton *e_btn = new QPushButton("", row_widget);
        QLabel *r_label = new QLabel(row_widget);
        //tr
        QLabel *g_label = new QLabel("-", row_widget);
        g_label->setContentsMargins(0,0,0,0);

        row_layout->addWidget(del_btn);
        row_layout->addSpacing(5);
        row_layout->addWidget(s_btn);
        row_layout->addWidget(g_label);
        row_layout->addWidget(e_btn);
        row_layout->addSpacing(5);
        row_layout->addWidget(r_label, 100);

        r_label->setFont(font);
        s_btn->setFont(font);
        e_btn->setFont(font);
        g_label->setFont(font);

        s_btn->setFixedWidth(bt_w);
        e_btn->setFixedWidth(bt_w);

        lay->addWidget(row_widget, dex++, 0, 1, 7);

        if (o.r_label != NULL){
            r_label->setText(o.r_label->text());
        }

        o.del_bt = del_btn;
        o.start_bt = s_btn;
        o.end_bt = e_btn;
        o.r_label = r_label;

        if (o.cursor1 != -1){
            o.start_bt->setText(QString::number(o.cursor1));
            set_cursor_btn_color(o.start_bt);
        }
        if (o.cursor2 != -1){
            o.end_bt->setText(QString::number(o.cursor2));
            set_cursor_btn_color(o.end_bt);
        }

        connect(del_btn, SIGNAL(clicked()), this, SLOT(del_dist_measure()));
        connect(s_btn, SIGNAL(clicked()), this, SLOT(show_all_coursor()));
        connect(e_btn, SIGNAL(clicked()), this, SLOT(show_all_coursor()));
    }

    _dist_layout->addWidget(_dist_pannel, 1, 0, 1, 7);
}

void MeasureDock::add_dist_measure()
{
    if (_dist_row_list.size() < Max_Measure_Limits)
    {
        cursor_row_info inf;
        inf.cursor1 = -1;
        inf.cursor2 = -1;
        inf.box = NULL;
        inf.del_bt = NULL;
        inf.start_bt = NULL;
        inf.end_bt = NULL;
        inf.r_label = NULL;

        _dist_row_list.push_back(inf);

        build_dist_pannel();
    }  
}

void MeasureDock::del_dist_measure()
{
    QToolButton* src = dynamic_cast<QToolButton *>(sender());
    assert(src); 

    for (auto it =_dist_row_list.begin(); it != _dist_row_list.end(); it++)
    {
        if ((*it).del_bt == src){
            _dist_row_list.erase(it);
            build_dist_pannel();
            break;
        }
    }
}

void MeasureDock::build_edge_pannel()
{
    if (_edge_pannel != NULL)
    {
        _edge_pannel->deleteLater();
        _edge_pannel = NULL;
    }

    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
    QGridLayout  *lay = new QGridLayout();
    _edge_pannel = new QWidget();   
    _edge_pannel->setLayout(lay);
    lay->setColumnStretch(1, 50);
    lay->setColumnStretch(6, 100);
    lay->setVerticalSpacing(5);
    lay->setContentsMargins(0,0,0,0);
  
    int dex = 0;
    QLabel cal_lb;
    cal_lb.setFont(font);
    int bt_w = cal_lb.fontMetrics().horizontalAdvance("22") + 8;

    for (auto &o : _edge_row_list)
    {
        QWidget *row_widget = new QWidget(_widget);
        row_widget->setContentsMargins(0,0,0,0);
        QHBoxLayout *row_layout = new QHBoxLayout(row_widget);
        row_layout->setContentsMargins(0,0,0,0);
        row_layout->setSpacing(0);
        row_widget->setLayout(row_layout);

        QString iconPath = AppConfig::GetIconPath();
        QToolButton *del_btn = new QToolButton(row_widget);
        del_btn->setIcon(QIcon(iconPath+"/del.svg"));
        del_btn->setCheckable(true);
        //tr
        QPushButton *s_btn = new QPushButton(" ", row_widget);
        //tr
        QPushButton *e_btn = new QPushButton(" ", row_widget);
        QLabel *r_label = new QLabel(row_widget);
        //tr
        QLabel *g_label = new QLabel("-", row_widget);
        g_label->setContentsMargins(0,0,0,0);
        //tr
        QLabel *a_label = new QLabel("@", row_widget);
        a_label->setContentsMargins(0,0,0,0);
        QComboBox *ch_cmb = create_probe_selector(row_widget);

        row_layout->addWidget(del_btn);
        row_layout->addSpacing(5);
        row_layout->addWidget(s_btn);
        row_layout->addWidget(g_label);
        row_layout->addWidget(e_btn);
        row_layout->addWidget(a_label);
        row_layout->addWidget(ch_cmb);
        row_layout->addSpacing(5);
        row_layout->addWidget(r_label, 100);

        g_label->setFont(font);
        a_label->setFont(font);
        s_btn->setFont(font);
        e_btn->setFont(font);
        a_label->setFont(font);

        s_btn->setFixedWidth(bt_w);
        e_btn->setFixedWidth(bt_w);

        lay->addWidget(row_widget, dex++, 0, 1, 7);

        if (o.r_label != NULL){
            r_label->setText(o.r_label->text());
        }

        o.del_bt = del_btn;
        o.start_bt = s_btn;
        o.end_bt = e_btn;
        o.r_label = r_label;
        o.box = ch_cmb;

        if (o.cursor1 != -1){
            o.start_bt->setText(QString::number(o.cursor1));
            set_cursor_btn_color(o.start_bt);
        }
        if (o.cursor2 != -1){
            o.end_bt->setText(QString::number(o.cursor2));
            set_cursor_btn_color(o.end_bt);
        }

        connect(del_btn, SIGNAL(clicked()), this, SLOT(del_edge_measure()));
        connect(s_btn, SIGNAL(clicked()), this, SLOT(show_all_coursor()));
        connect(e_btn, SIGNAL(clicked()), this, SLOT(show_all_coursor()));
        connect(ch_cmb, SIGNAL(currentIndexChanged(int)), this, SLOT(update_edge()));
    }

    _edge_layout->addWidget(_edge_pannel, 1, 0, 1, 7);
}

void MeasureDock::add_edge_measure()
{
    if (_edge_row_list.size() < Max_Measure_Limits)
    {
        cursor_row_info inf;
        inf.cursor1 = -1;
        inf.cursor2 = -1;
        inf.box = NULL;
        inf.del_bt = NULL;
        inf.start_bt = NULL;
        inf.end_bt = NULL;
        inf.r_label = NULL;

        _edge_row_list.push_back(inf);
        build_edge_pannel();
    } 
}

void MeasureDock::del_edge_measure()
{
    QToolButton* src = dynamic_cast<QToolButton *>(sender());
    assert(src); 

    for (auto it =_edge_row_list.begin(); it != _edge_row_list.end(); it++)
    {
        if ((*it).del_bt == src){
            _edge_row_list.erase(it);
            build_edge_pannel();
            break;
        }
    }
}

void MeasureDock::show_all_coursor()
{
    auto &cursor_list = _view.get_cursorList();

    if (cursor_list.empty()) {
        QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_PLEASE_INSERT_CURSOR), 
                                       "Please insert cursor before using cursor measure."));
        MsgBox::Show(strMsg);
        return;
    }

    _sel_btn = qobject_cast<QPushButton *>(sender());

    QDialog cursor_dlg(_widget);
    cursor_dlg.setWindowFlags(Qt::FramelessWindowHint | Qt::Popup | Qt::WindowSystemMenuHint |
                              Qt::WindowMinimizeButtonHint | Qt::WindowMaximizeButtonHint);

    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);

    int index = 0;
    QGridLayout *glayout = new QGridLayout(&cursor_dlg);

    for(auto i = cursor_list.begin(); i != cursor_list.end(); i++) {
        QPushButton *cursor_btn = new QPushButton(&cursor_dlg);
        cursor_btn->setText(QString::number(index+1));
        set_cursor_btn_color(cursor_btn);
        cursor_btn->setFont(font);
        glayout->addWidget(cursor_btn, index/4, index%4, 1, 1);

        connect(cursor_btn, SIGNAL(clicked()), &cursor_dlg, SLOT(accept()));
        connect(cursor_btn, SIGNAL(clicked()), this, SLOT(set_sel_cursor()));
        index++;
    }

    QRect sel_btn_rect = _sel_btn->geometry();
    sel_btn_rect.moveTopLeft(_sel_btn->parentWidget()->mapToGlobal(sel_btn_rect.topLeft()));
    cursor_dlg.setGeometry(sel_btn_rect.left(), sel_btn_rect.bottom()+10,
                           cursor_dlg.width(), cursor_dlg.height());
    cursor_dlg.exec();
}

void MeasureDock::set_sel_cursor()
{
    assert(_sel_btn);
    QPushButton *sel_cursor_bt = qobject_cast<QPushButton *>(sender());
    int type = 0;
    cursor_row_info *inf = NULL;

    if (type == 0)
    {
        for (auto &o : _dist_row_list){
            if (o.start_bt == _sel_btn || o.end_bt == _sel_btn){
                inf = &o;
                type = 1;
                break;
            }
        }
    }

    if (type == 0)
    {
        for (auto &o : _edge_row_list){
            if (o.start_bt == _sel_btn || o.end_bt == _sel_btn){
                inf = &o;
                type = 2;
                break;
            }
        }
    } 

    assert(inf);

    _sel_btn->setText(sel_cursor_bt->text());
    set_cursor_btn_color(_sel_btn);

    if (inf->start_bt == _sel_btn){
        inf->cursor1 = sel_cursor_bt->text().toInt();
    }
    else if (inf->end_bt == _sel_btn){
        inf->cursor2 = sel_cursor_bt->text().toInt();
    }

    if (type == 1)
        update_dist();
    else
        update_edge();
}

void MeasureDock::update_dist()
{
    auto &cursor_list = _view.get_cursorList();

    for (auto &inf : _dist_row_list) 
    {  
        if (inf.cursor1 != -1) {
            if (inf.cursor1 > (int)cursor_list.size()) {
                inf.start_bt->setText("");
                set_cursor_btn_color(inf.start_bt);
                inf.cursor1 = -1;
            }
        }

        if (inf.cursor2 != -1) {
            if (inf.cursor2 > (int)cursor_list.size()) {
                inf.end_bt->setText("");
                set_cursor_btn_color(inf.end_bt);
                inf.cursor2 = -1;
            }
        }

        if (inf.cursor1 != -1 && inf.cursor2 != -1) {
            int64_t delta = _view.get_cursor_samples(inf.cursor1-1) -
                            _view.get_cursor_samples(inf.cursor2-1);
            QString delta_text = _view.get_cm_delta(inf.cursor1-1, inf.cursor2-1) +
                                 "/" + QString::number(delta);
            if (delta < 0)
                delta_text.replace('+', '-');
            inf.r_label->setText(delta_text);
        }
        else {
            inf.r_label->setText(" ");
        }
    }
}

void MeasureDock::update_edge()
{ 
    auto &cursor_list = _view.get_cursorList();

    for (auto &inf : _edge_row_list)
    {
        if (inf.cursor1 != -1) {
            if (inf.cursor1 > (int)cursor_list.size()) {
                inf.start_bt->setText("");
                set_cursor_btn_color(inf.start_bt);
                inf.cursor1 = -1;
            }
        }
        if (inf.cursor2 != -1) {
            if (inf.cursor2 > (int)cursor_list.size()) {
                inf.end_bt->setText("");
                set_cursor_btn_color(inf.end_bt);
                inf.cursor2 = -1;
            }
        }

        bool mValid = false;
        if (inf.cursor1 != -1 && inf.cursor2 != -1) {
            uint64_t rising_edges;
            uint64_t falling_edges;

            for(auto s : _session->get_signals()) {
                if (s->signal_type() == SR_CHANNEL_LOGIC
                        && s->enabled()
                        && s->get_index() == inf.box->currentText().toInt())
                  {
                    view::LogicSignal *logicSig = (view::LogicSignal*)s;

                    if (logicSig->edges(_view.get_cursor_samples(inf.cursor2-1),
                            _view.get_cursor_samples(inf.cursor1-1), rising_edges, falling_edges)) 
                    {
                        QString delta_text = QString::number(rising_edges) + "/" +
                                             QString::number(falling_edges) + "/" +
                                             QString::number(rising_edges + falling_edges);
                        inf.r_label->setText(delta_text);
                        mValid = true;
                        break;
                    }
                }
            }
        }

        if (!mValid)
            inf.r_label->setText("-/-/-");
    }
}

void MeasureDock::set_cursor_btn_color(QPushButton *btn)
{
    bool ret;
    const unsigned int start = btn->text().toInt(&ret) - 1;
    QColor cursor_color = ret ? view::Ruler::CursorColor[start%8] : QColor("#302F2F");
    QString border_width = ret ? "0px" : "1px";
    QString normal = "{background-color:" + cursor_color.name() +
            "; color:black" + "; border-width:" + border_width + ";}";
    QString hover = "{background-color:" + cursor_color.darker().name() +
            "; color:black" + "; border-width:" + border_width + ";}";
    QString style = "QPushButton:hover" + hover +
                    "QPushButton" + normal;
    btn->setStyleSheet(style);
}

QComboBox* MeasureDock::create_probe_selector(QWidget *parent)
{
    DsComboBox *selector = new DsComboBox(parent);
    update_probe_selector(selector);
    return selector;
}

void MeasureDock::update_probe_selector(QComboBox *selector)
{
    selector->clear(); 

    for(auto s : _session->get_signals()) {
        if (s->signal_type() == SR_CHANNEL_LOGIC && s->enabled()){
            selector->addItem(QString::number(s->get_index()));
        }
    }
}

void MeasureDock::cursor_moving()
{
    if (_view.cursors_shown()) {      
        auto &cursor_list = _view.get_cursorList();

        if (cursor_list.size() != _opt_row_list.size()){
            assert(false);
        }

        int index = 0;

        for(auto i = cursor_list.begin(); i != cursor_list.end(); i++) {
            QString _cur_text = _view.get_cm_time(index) + "/" 
                    + QString::number(_view.get_cursor_samples(index));
            _opt_row_list[index].info_label->setText(_cur_text);
            index++;
        }
    }

    update_dist();
}

void MeasureDock::reCalc()
{
    cursor_update();
    update_dist();
    update_edge();
}

void MeasureDock::goto_cursor()
{
    QPushButton *src = qobject_cast<QPushButton *>(sender());
    assert(src);

    int index = 0;

    for (auto it = _opt_row_list.begin(); it != _opt_row_list.end(); it++)
    {
        if ( (*it).goto_bt == src){
            _view.set_cursor_middle(index);
            break;
        }
        index++;
    }
}

void MeasureDock::cursor_update()
{
    using namespace dsv::data;

   for(auto it = _opt_row_list.begin(); it != _opt_row_list.end(); it++)
   {
        (*it).del_bt->deleteLater();
        (*it).goto_bt->deleteLater();
        (*it).info_label->deleteLater();
   }
   _opt_row_list.clear();

    update_dist();
    update_edge();

    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);

    QLabel cal_lb;
    cal_lb.setFont(font);
    int bt_w = cal_lb.fontMetrics().horizontalAdvance("22") + 8;

    int index = 1;
    int cursor_dex = 0;
    QString iconPath = AppConfig::GetIconPath();
    auto &cursor_list = _view.get_cursorList();

    for(auto it = cursor_list.begin(); it != cursor_list.end(); it++) {
        QToolButton *del_btn = new QToolButton(_widget);
        del_btn->setIcon(QIcon(iconPath+"/del.svg"));
        del_btn->setCheckable(true);
        QPushButton *cursor_pushButton = new QPushButton(QString::number(index), _widget);
        set_cursor_btn_color(cursor_pushButton);

        QString cur_pos = _view.get_cm_time(cursor_dex) + "/" 
                    + QString::number(_view.get_cursor_samples(cursor_dex));
        QLabel *curpos_label = new QLabel(cur_pos, _widget); 

        _cursor_layout->addWidget(del_btn, 1+index, 0);
        _cursor_layout->addWidget(cursor_pushButton, 1 + index, 1);
        _cursor_layout->addWidget(curpos_label, 1 + index, 2);
        curpos_label->setFont(font);
        cursor_pushButton->setFont(font);
        cursor_pushButton->setFixedWidth(bt_w);

        connect(del_btn, SIGNAL(clicked()), this, SLOT(del_cursor()));
        connect(cursor_pushButton, SIGNAL(clicked()), this, SLOT(goto_cursor()));

        cursor_opt_info inf = {del_btn, cursor_pushButton, curpos_label, (*it)};
        _opt_row_list.push_back(inf);

        index++;
        cursor_dex++;
    }
}

void MeasureDock::del_cursor()
{
    QToolButton *src = qobject_cast<QToolButton *>(sender());
    assert(src);
    
    Cursor* cursor = NULL;
    auto &cursor_list = _view.get_cursorList();
    
    for (auto it = _opt_row_list.begin(); it != _opt_row_list.end(); it++)
    {
        if ((*it).del_bt == src){   
            cursor = (*it).cursor;
            break;
        }
    }

    if (cursor)
        _view.del_cursor(cursor);
    if (cursor_list.empty())
        _view.show_cursors(false);

    cursor_update();
    _view.update();
}

void MeasureDock::update_font()
{
    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
    ui::set_form_font(this, font);
    font.setPointSizeF(font.pointSizeF() + 1);
    this->parentWidget()->setFont(font);
}

} // namespace dock
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "triggerdock.h"
#include <QObject>
#include <QGridLayout>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QPainter>
#include <QRegularExpressionValidator>
#include <QSplitter>
#include <QInputMethodEvent>
#include <QApplication>
#include <math.h>
#include <libsigrok.h>

#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
    #include <QRegularExpression>
    #include <QRegularExpressionValidator>
#else
    #include <QRegExp>
    #include <QRegExpValidator>
#endif

#include "../appcore/sigsession.h"
#include "../dialogs/dsmessagebox.h"
#include "../view/view.h"
#include "../config/appconfig.h"
#include "../appcore/deviceagent.h"
#include "../view/logicsignal.h"
#include "../ui/langresource.h"
#include "../ui/msgbox.h"
#include "../log.h"
#include "../decode/annotationrestable.h"
#include "../appcore/appcontrol.h"
#include "../ui/fn.h"

using namespace dsv::config;

namespace dsv {
namespace dock {

const int TriggerDock::MinTrigPosition = 1;

TriggerDock::TriggerDock(QWidget *parent, SigSession *session) :
    QScrollArea(parent),
    _session(session)
{
    
    _cur_ch_num = 16;
    if (_session->get_device()->have_instance()) {
        _session->get_device()->get_config_int16(SR_CONF_TOTAL_CH_NUM, _cur_ch_num);
    }

    _serial_hex_label = NULL;
    _serial_hex_lineEdit = NULL;
    _serial_hex_ck_label = NULL;
    _is_serial_val_setting = false;

    _widget = new QWidget(this);
    _simple_radioButton = new QRadioButton(_widget);
    _simple_radioButton->setChecked(true);
    _adv_radioButton = new QRadioButton(_widget);

    _position_label = new QLabel(_widget);
    _position_spinBox = new QSpinBox(_widget);
    _position_spinBox->setRange(MinTrigPosition, DS_MAX_TRIG_PERCENT);
    _position_spinBox->setButtonSymbols(QAbstractSpinBox::NoButtons);
    _position_slider = new QSlider(Qt::Horizontal, _widget);
    _position_slider->setRange(MinTrigPosition, DS_MAX_TRIG_PERCENT);
    connect(_position_slider, SIGNAL(valueChanged(int)), _position_spinBox, SLOT(setValue(int)));
    connect(_position_spinBox, SIGNAL(valueChanged(int)), _position_slider, SLOT(setValue(int)));

    _stages_label = new QLabel(_widget);
    _stages_label->setDisabled(true);
    stages_comboBox = new DsComboBox(_widget);

    for (int i = 1; i <= TriggerStages; i++){
        stages_comboBox->addItem(QString::number(i));
    }

    stages_comboBox->setDisabled(true);

    _adv_tabWidget = new QTabWidget(_widget);
    _adv_tabWidget->setTabPosition(QTabWidget::North);
    _adv_tabWidget->setDisabled(true);
    setup_adv_tab();

    connect(_simple_radioButton, SIGNAL(clicked()), this, SLOT(simple_trigger()));
    connect(_adv_radioButton, SIGNAL(clicked()), this, SLOT(adv_trigger()));
    connect(stages_comboBox, SIGNAL(currentIndexChanged(int)), this, SLOT(widget_enable(int)));


    QVBoxLayout *layout = new QVBoxLayout(_widget);
    QGridLayout *gLayout = new QGridLayout();
    gLayout->setVerticalSpacing(5);
    gLayout->addWidget(_simple_radioButton, 0, 0);
    gLayout->addWidget(_adv_radioButton, 1, 0);
    gLayout->addWidget(_position_label, 2, 0);
    gLayout->addWidget(_position_spinBox, 2, 1);
    //tr
    gLayout->addWidget(new QLabel("%", _widget), 2, 2);
    gLayout->addWidget(_position_slider, 3, 0, 1, 3);
    gLayout->addWidget(_stages_label, 4, 0);
    gLayout->addWidget(stages_comboBox, 4, 1);
    gLayout->addWidget(new QLabel(_widget), 4, 2);
    gLayout->setColumnStretch(2, 1);

    layout->addLayout(gLayout);
    layout->addWidget(_adv_tabWidget);
    layout->addStretch(1);
    _widget->setLayout(layout);

    this->setWidget(_widget);
    _widget->setObjectName("triggerWidget");

    retranslateUi();

    update_font();
}

TriggerDock::~TriggerDock()
{
}

void TriggerDock::changeEvent(QEvent *event)
{
    if (event->type() == QEvent::LanguageChange)
        retranslateUi();
    else if (event->type() == QEvent::StyleChange)
        reStyle();
    QScrollArea::changeEvent(event);
}

void TriggerDock::retranslateUi()
{
    _simple_radioButton->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SIMPLE_TRIGGER), "Simple Trigger"));
    _adv_radioButton->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_ADVANCED_TRIGGER), "Advanced Trigger"));
    _position_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_TRIGGER_POSITION), "Trigger Position: "));
    _stages_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_TOTAL_TRIGGER_STAGES), "Total Trigger Stages: "));
    _serial_start_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_START_FLAG), "Start Flag: "));
    _serial_stop_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_STOP_FLAG), "Stop Flag: "));
    _serial_edge_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CLOCK_FLAG), "Clock Flag: "));
    _serial_data_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_DATA_CHANNEL), "Data Channel: "));
    _serial_value_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_DATA_VALUE), "Data Value: "));
    _serial_groupBox->setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SERIAL_TRIGGER), "Serial Trigger"));
    _serial_hex_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SERIAL_HEX), "Hex: "));
    _serial_hex_ck_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SERIAL_INPUT_AS_HEX), "Input hex"));

    _adv_tabWidget->setTabText(0, L_S(STR_PAGE_DLG, S_ID(IDS_DLG_STAGE_TRIGGER), "Stage Trigger"));
    _adv_tabWidget->setTabText(1, L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SERIAL_TRIGGER), "Serial Trigger"));
    _serial_note_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SERIAL_NOTE_LABEL), 
                                "X: Don't care\n0: Low level\n1: High level\nR: Rising edge\nF: Falling edge\nC: Rising/Falling edge"));
    _data_bits_label->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_DATA_BITS), "Data Bits"));

    for (int i = 0; i < _inv_exp_label_list.length(); i++){
        _inv_exp_label_list.at(i)->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_INV), "Inv"));
    }

    for (int i = 0; i < _count_exp_label_list.length(); i++){
        _count_exp_label_list.at(i)->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_COUNTER), "Counter"));
    }

    for (int i = 0; i < _contiguous_label_list.length(); i++){
        _contiguous_label_list.at(i)->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_CONTIGUOUS), "Contiguous"));
    }

    for (int i = 0; i < _stage_groupBox_list.length(); i++){
        _stage_groupBox_list.at(i)->setTitle(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_STAGE), "Stage")+QString::number(i));
    }

    for (int i = 0; i < _stage_note_label_list.length(); i++){
        _stage_note_label_list.at(i)->setText(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SERIAL_NOTE_LABEL), 
                                             "X: Don't care\n0: Low level\n1: High level\nR: Rising edge\nF: Falling edge\nC: Rising/Falling edge"));
    }
}

void TriggerDock::reStyle()
{     
}

void TriggerDock::paintEvent(QPaintEvent *)
{
}

void TriggerDock::simple_trigger()
{
    _stages_label->setDisabled(true);
    stages_comboBox->setDisabled(true);
    _adv_tabWidget->setDisabled(true);
}

void TriggerDock::adv_trigger()
{
    if (_session->get_device()->is_hardware_logic()) {
        bool stream = false;
        _session->get_device()->get_config_bool(SR_CONF_STREAM, stream);   
        
        if (stream) {
            QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_STREAM_NO_AD_TRIGGER),
                                          "Stream Mode Don't Support Advanced Trigger!"));
            MsgBox::Show(strMsg);
            _simple_radioButton->setChecked(true);
        }
        else {
            widget_enable(0);
        }
    }
    else if (_session->get_device()->is_file() == false){
        QString strMsg(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_AD_TRIGGER_NEED_HARDWARE),
                                      "Advanced Trigger need DSLogic Hardware Support!"));
        MsgBox::Show(strMsg);
        _simple_radioButton->setChecked(true);
    }
}

void TriggerDock::widget_enable(int index)
{
    (void) index;

    int enable_stages;
    _stages_label->setDisabled(false);
    stages_comboBox->setVisible(true);
    stages_comboBox->setDisabled(false);
    _adv_tabWidget->setDisabled(false);
    enable_stages = stages_comboBox->currentText().toInt();

    for (int i = 0; i < enable_stages; i++) {
        _stage_tabWidget->setTabEnabled(i, true);
    }

    for (int i = enable_stages; i < TriggerStages; i++) {
          _stage_tabWidget->setTabEnabled(i, false);
    }
}

void TriggerDock::value_changed()
{
    QLineEdit* sc=dynamic_cast<QLineEdit*>(sender());
    if(sc != NULL) {
        for (int i = 0; i < TriggerProbes*2-1; i++) {
            if ((i >= sc->text().size()) || (i % 2 == 0 && sc->text().at(i) == ' ')) {
                sc->setText(sc->text().insert(i, 'X'));
                i++;
            }
        }
        sc->setText(sc->text().toUpper());
        lineEdit_highlight(sc);
    }
}

void TriggerDock::device_updated()
{
    uint64_t hw_depth;
    bool stream = false;
    uint8_t maxRange;
    uint64_t sample_limits; 
    int mode = _session->get_device()->get_work_mode();
    bool ret;
    int ch_num;

    ret = _session->get_device()->get_config_uint64(SR_CONF_HW_DEPTH, hw_depth);

    if (ret) {
        if (mode == LOGIC) {
            _session->get_device()->get_config_bool(SR_CONF_STREAM, stream);
            sample_limits = _session->get_device()->get_sample_limit();

            _adv_radioButton->setEnabled(!stream);
            _position_spinBox->setEnabled(!stream);
            _position_slider->setEnabled(!stream);

            if (stream)
                maxRange = 1;
            else if (hw_depth >= sample_limits)
                maxRange = DS_MAX_TRIG_PERCENT;
            else
                maxRange = ceil(hw_depth * DS_MAX_TRIG_PERCENT / sample_limits);
            
            _position_spinBox->setRange(MinTrigPosition, maxRange);
            _position_slider->setRange(MinTrigPosition, maxRange);

            if (_session->get_device()->is_virtual() || stream) {
                _simple_radioButton->setChecked(true);
                simple_trigger();
            }
        }
    }

    ret = _session->get_device()->get_config_int16(SR_CONF_TOTAL_CH_NUM, ch_num);
    if (ret) { 
        if (ch_num != _cur_ch_num) {
            _cur_ch_num = ch_num;
            setup_adv_tab();
            retranslateUi();
        }
    }

    this->setEnabled(_session->is_loop_mode() == false);
}

bool TriggerDock::commit_trigger()
{
    // trigger position update
    ds_trigger_set_pos(_position_slider->value());

    // trigger mode update
    if (_simple_radioButton->isChecked()) {
        ds_trigger_set_mode(SIMPLE_TRIGGER);
        return false;
    }
    else {
        ds_trigger_set_en(true);
        if (_adv_tabWidget->currentIndex() == 0)
            ds_trigger_set_mode(ADV_TRIGGER);
        else if (_adv_tabWidget->currentIndex() == 1)
            ds_trigger_set_mode(SERIAL_TRIGGER);

        // trigger stage update
        ds_trigger_set_stage(stages_comboBox->currentText().toInt() - 1);

        // trigger value update
        if (_adv_tabWidget->currentIndex() == 0) {
            for (int i = 0; i < stages_comboBox->currentText().toInt(); i++) {
                QString value0_str, value1_str;
                if (_cur_ch_num == 32) {
                    value0_str = _value0_ext32_lineEdit_list.at(i)->text() + " " + _value0_lineEdit_list.at(i)->text();
                    value1_str = _value1_ext32_lineEdit_list.at(i)->text() + " " + _value1_lineEdit_list.at(i)->text();
                } else {
                    value0_str = _value0_lineEdit_list.at(i)->text();
                    value1_str = _value1_lineEdit_list.at(i)->text();
                }
                ds_trigger_stage_set_value(i, _cur_ch_num, value0_str.toLocal8Bit().data(),
                                                           value1_str.toLocal8Bit().data());
            }
        } else if(_adv_tabWidget->currentIndex() == 1){
            QString start_str, stop_str, edge_str, comp_str;
            if (_cur_ch_num == 32) {
                start_str = _serial_start_ext32_lineEdit->text() + " " + _serial_start_lineEdit->text();
                stop_str = _serial_stop_ext32_lineEdit->text() + " " + _serial_stop_lineEdit->text();
                edge_str = _serial_edge_ext32_lineEdit->text() + " " + _serial_edge_lineEdit->text();
                comp_str = _value1_ext32_lineEdit_list.at(1)->text() + " " + _value1_lineEdit_list.at(1)->text();
            } else {
                start_str = _serial_start_lineEdit->text();
                stop_str = _serial_stop_lineEdit->text();
                edge_str = _serial_edge_lineEdit->text();
                comp_str = _value1_lineEdit_list.at(1)->text();
            }
            ds_trigger_stage_set_value(0, _cur_ch_num, start_str.toLocal8Bit().data(),
                                                       stop_str.toLocal8Bit().data());
            ds_trigger_stage_set_value(1, _cur_ch_num, edge_str.toLocal8Bit().data(),
                                                       comp_str.toLocal8Bit().data());

            //_serial_data_comboBox
            const int data_channel = _serial_data_comboBox->currentText().toInt();
            QString channel = "X X X X X X X X X X X X X X X X";
            QString channel_ext32 = "X X X X X X X X X X X X X X X X";
            if (_cur_ch_num == 32) {
                if (data_channel < 16)
                    channel.replace(30 - 2*data_channel, 1, '0');
                else
                    channel_ext32.replace(30 - 2*(data_channel - 16), 1, '0');
            } else {
                channel.replace(30 - 2*data_channel, 1, '0');
            }
            ds_trigger_stage_set_value(2, TriggerProbes,
                                 channel.toLocal8Bit().data(),
                                 channel_ext32.toLocal8Bit().data());
            ds_trigger_stage_set_value(STriggerDataStage, TriggerProbes,
                                 _serial_value_lineEdit->text().toLocal8Bit().data(),
                                 _value1_lineEdit_list.at(3)->text().toLocal8Bit().data());
        }

        // trigger logic update
        for (int i = 0; i < stages_comboBox->currentText().toInt(); i++) {
            const char logic = (_contiguous_checkbox_list.at(i)->isChecked() << 1) +
                               _logic_comboBox_list.at(i)->currentIndex();
            ds_trigger_stage_set_logic(i, TriggerProbes,
                                 logic);
        }

        // trigger inv update
        for (int i = 0; i < stages_comboBox->currentText().toInt(); i++) {
            ds_trigger_stage_set_inv(i, TriggerProbes,
                                 _inv0_comboBox_list.at(i)->currentIndex(),
                                 _inv1_comboBox_list.at(i)->currentIndex());
        }

        // trigger count update
        if (_adv_tabWidget->currentIndex() == 0) {
            for (int i = 0; i < stages_comboBox->currentText().toInt(); i++) {
                ds_trigger_stage_set_count(i, TriggerProbes,
                                           _count_spinBox_list.at(i)->value(),
                                           0);
            }
        } else if(_adv_tabWidget->currentIndex() == 1){
            ds_trigger_stage_set_count(1, TriggerProbes,
                                       1,
                                       0);
            ds_trigger_stage_set_count(3, TriggerProbes,
                                       _serial_bits_comboBox->currentText().toInt() - 1,
                                       0);
        }
        return true;
    }
}

void TriggerDock::update_view()
{
    // TRIGGERPOS
    //uint16_t pos = ds_trigger_get_pos();
    //_position_slider->setValue(pos);
}

QJsonObject TriggerDock::get_session()
{
    QJsonObject trigSes;
    trigSes["advTriggerMode"] = _adv_radioButton->isChecked();
    trigSes["triggerPos"] = _position_slider->value();
    trigSes["triggerStages"] = stages_comboBox->currentIndex();
    trigSes["triggerTab"] = _adv_tabWidget->currentIndex();

    for (int i = 0; i < stages_comboBox->count(); i++) {
        QString value0_str = "stageTriggerValue0" + QString::number(i);
        QString inv0_str = "stageTriggerInv0" + QString::number(i);
        QString value1_str = "stageTriggerValue1" + QString::number(i);
        QString inv1_str = "stageTriggerInv1" + QString::number(i);

        QString logic_str = "stageTriggerLogic" + QString::number(i);
        QString count_str = "stageTriggerCount" + QString::number(i);
        QString conti_str = "stageTriggerContiguous" + QString::number(i);

        trigSes[value0_str] = _value0_lineEdit_list.at(i)->text();
        trigSes[value1_str] = _value1_lineEdit_list.at(i)->text();
        trigSes[inv0_str] = _inv0_comboBox_list.at(i)->currentIndex();
        trigSes[inv1_str] = _inv1_comboBox_list.at(i)->currentIndex();

        trigSes[logic_str] = _logic_comboBox_list.at(i)->currentIndex();
        trigSes[count_str] = _count_spinBox_list.at(i)->value();
        trigSes[conti_str] = _contiguous_checkbox_list.at(i)->isChecked();

        if (_cur_ch_num == 32) {
            QString value0_ext32_str = "stageTriggerExt32Value0" + QString::number(i);
            QString value1_ext32_str = "stageTriggerExt32Value1" + QString::number(i);

            trigSes[value0_ext32_str] = _value0_ext32_lineEdit_list.at(i)->text();
            trigSes[value1_ext32_str] = _value1_ext32_lineEdit_list.at(i)->text();
        }
    }

    trigSes["serialTriggerStart"] = _serial_start_lineEdit->text();
    trigSes["serialTriggerStop"] = _serial_stop_lineEdit->text();
    trigSes["serialTriggerClock"] = _serial_edge_lineEdit->text();
    trigSes["serialTriggerChannel"] = _serial_data_comboBox->currentIndex();
    trigSes["serialTriggerData"] = _serial_value_lineEdit->text();
    trigSes["serialTriggerBits"] = _serial_bits_comboBox->currentIndex();

    if (_cur_ch_num == 32) {
        trigSes["serialTriggerExt32Start"] = _serial_start_ext32_lineEdit->text();
        trigSes["serialTriggerExt32Stop"] = _serial_stop_ext32_lineEdit->text();
        trigSes["serialTriggerExt32Clock"] = _serial_edge_ext32_lineEdit->text();
    }

    return trigSes;
}

void TriggerDock::set_session(QJsonObject ses)
{
    _position_slider->setValue(ses["triggerPos"].toDouble());
    stages_comboBox->setCurrentIndex(ses["triggerStages"].toDouble());
    _adv_tabWidget->setCurrentIndex(ses["triggerTab"].toDouble());
    if (ses["advTriggerMode"].toBool())
        _adv_radioButton->click();
    else
        _simple_radioButton->click();

    for (int i = 0; i < stages_comboBox->count(); i++) {
        QString value0_str = "stageTriggerValue0" + QString::number(i);
        QString inv0_str = "stageTriggerInv0" + QString::number(i);
        QString value1_str = "stageTriggerValue1" + QString::number(i);
        QString inv1_str = "stageTriggerInv1" + QString::number(i);

        QString logic_str = "stageTriggerLogic" + QString::number(i);
        QString count_str = "stageTriggerCount" + QString::number(i);
        QString conti_str = "stageTriggerContiguous" + QString::number(i);

        _value0_lineEdit_list.at(i)->setText(ses[value0_str].toString());
        lineEdit_highlight(_value0_lineEdit_list.at(i));
        _value1_lineEdit_list.at(i)->setText(ses[value1_str].toString());
        lineEdit_highlight(_value1_lineEdit_list.at(i));
        _inv0_comboBox_list.at(i)->setCurrentIndex(ses[inv0_str].toDouble());
        _inv1_comboBox_list.at(i)->setCurrentIndex(ses[inv1_str].toDouble());

        _logic_comboBox_list.at(i)->setCurrentIndex(ses[logic_str].toDouble());
        _count_spinBox_list.at(i)->setValue(ses[count_str].toDouble());
        _contiguous_checkbox_list.at(i)->setChecked(ses[conti_str].toBool());

        if (_cur_ch_num == 32) {
            QString value0_ext32_str = "stageTriggerExt32Value0" + QString::number(i);
            QString value1_ext32_str = "stageTriggerExt32Value1" + QString::number(i);

            if (ses.contains(value0_ext32_str)) {
                _value0_ext32_lineEdit_list.at(i)->setText(ses[value0_ext32_str].toString());
                lineEdit_highlight(_value0_ext32_lineEdit_list.at(i));
            }
            if (ses.contains(value1_ext32_str)) {
                _value1_ext32_lineEdit_list.at(i)->setText(ses[value1_ext32_str].toString());
                lineEdit_highlight(_value1_ext32_lineEdit_list.at(i));
            }
        }
    }

    _serial_start_lineEdit->setText(ses["serialTriggerStart"].toString());
    lineEdit_highlight(_serial_start_lineEdit);
    _serial_stop_lineEdit->setText(ses["serialTriggerStop"].toString());
    lineEdit_highlight(_serial_stop_lineEdit);
    _serial_edge_lineEdit->setText(ses["serialTriggerClock"].toString());
    lineEdit_highlight(_serial_edge_lineEdit);
    _serial_data_comboBox->setCurrentIndex(ses["serialTriggerChannel"].toDouble());
    _serial_value_lineEdit->setText(ses["serialTriggerData"].toString());
    lineEdit_highlight(_serial_value_lineEdit);
    _serial_bits_comboBox->setCurrentIndex(ses["serialTriggerBits"].toDouble());

    if (_cur_ch_num == 32) {
        if (ses.contains("serialTriggerExt32Start")) {
            _serial_start_ext32_lineEdit->setText(ses["serialTriggerExt32Start"].toString());
            lineEdit_highlight(_serial_start_ext32_lineEdit);
        }
        if (ses.contains("serialTriggerExt32Stop")) {
            _serial_stop_ext32_lineEdit->setText(ses["serialTriggerExt32Stop"].toString());
            lineEdit_highlight(_serial_stop_ext32_lineEdit);
        }
        if (ses.contains("serialTriggerExt32Clock")) {
            _serial_edge_ext32_lineEdit->setText(ses["serialTriggerExt32Clock"].toString());
            lineEdit_highlight(_serial_edge_ext32_lineEdit);
        }
    }
}

void TriggerDock::setup_adv_tab()
{
    int row;

    for (int i = _adv_tabWidget->count(); i > 0; i--)
    {
        _adv_tabWidget->widget(i-1)->deleteLater();
        _adv_tabWidget->removeTab(i-1);
    }
    _logic_comboBox_list.clear();
    _value0_lineEdit_list.clear();
    _count_spinBox_list.clear();
    _inv0_comboBox_list.clear();
    _value1_lineEdit_list.clear();
    _inv1_comboBox_list.clear();
    _contiguous_checkbox_list.clear();
    _inv_exp_label_list.clear();
    _count_exp_label_list.clear();
    _contiguous_label_list.clear();
    _stage_note_label_list.clear();
    _stage_groupBox_list.clear();

    _value0_ext32_lineEdit_list.clear();
    _value1_ext32_lineEdit_list.clear();

    QFont font("Monaco");
    font.setStyleHint(QFont::Monospace);
    font.setFixedPitch(true);

    _stage_tabWidget = new QTabWidget(_widget);
    _stage_tabWidget->setTabPosition(QTabWidget::East);
    _stage_tabWidget->setUsesScrollButtons(false);

    const QString mask = "N N N N N N N N N N N N N N N N";
    QRegularExpression value_rx("[10XRFCxrfc ]+");
    QValidator *value_validator = new QRegularExpressionValidator(value_rx, _stage_tabWidget);

    for (int i = 0; i < TriggerStages; i++) {
        DsComboBox *_logic_comboBox = new DsComboBox(_stage_tabWidget);
        _logic_comboBox->addItem(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_OR), "Or"));
        _logic_comboBox->addItem(L_S(STR_PAGE_DLG, S_ID(IDS_DLG_AND), "And"));
        _logic_comboBox->setCurrentIndex(1);
        _logic_comboBox_list.push_back(_logic_comboBox);

        QLineEdit *_value0_lineEdit = new QLineEdit("X X X X X X X X X X X X X X X X", _stage_tabWidget);
        _value0_lineEdit->setFont(font);
        _value0_lineEdit->setValidator(value_validator);
        _value0_lineEdit->setMaxLength(TriggerProbes * 2 - 1);
        _value0_lineEdit->setInputMask(mask);
        _value0_lineEdit->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);
        _value0_lineEdit_list.push_back(_value0_lineEdit);
        QSpinBox *_count_spinBox = new QSpinBox(_stage_tabWidget);
        _count_spinBox->setRange(1, INT32_MAX);
        _count_spinBox->setButtonSymbols(QAbstractSpinBox::NoButtons);
        _count_spinBox_list.push_back(_count_spinBox);
        DsComboBox *_inv0_comboBox = new DsComboBox(_stage_tabWidget);
        //tr
        _inv0_comboBox->addItem("==");
        _inv0_comboBox->addItem("!=");
        _inv0_comboBox_list.push_back(_inv0_comboBox);

        QLineEdit *_value1_lineEdit = new QLineEdit("X X X X X X X X X X X X X X X X", _stage_tabWidget);
        _value1_lineEdit->setFont(font);
        _value1_lineEdit->setValidator(value_validator);
        _value1_lineEdit->setMaxLength(TriggerProbes * 2 - 1);
        _value1_lineEdit->setInputMask(mask);
        _value1_lineEdit->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);
        _value1_lineEdit_list.push_back(_value1_lineEdit);
        DsComboBox *_inv1_comboBox = new DsComboBox(_stage_tabWidget);
        //tr
        _inv1_comboBox->addItem("==");
        _inv1_comboBox->addItem("!=");
        _inv1_comboBox_list.push_back(_inv1_comboBox);

        connect(_value0_lineEdit, SIGNAL(editingFinished()), this, SLOT(value_changed()));
        connect(_value1_lineEdit, SIGNAL(editingFinished()), this, SLOT(value_changed()));

        QCheckBox *_contiguous_checkbox = new QCheckBox(_stage_tabWidget);
        _contiguous_checkbox_list.push_back(_contiguous_checkbox);

        QLabel *value0_exp_label = new QLabel("15 ---------- 8 7 ----------- 0 ", _stage_tabWidget);
        value0_exp_label->setFont(font);
        QLabel *inv0_exp_label = new QLabel(_stage_tabWidget);
        _inv_exp_label_list.push_back(inv0_exp_label);
        QLabel *value1_exp_label = new QLabel("15 ---------- 8 7 ----------- 0 ", _stage_tabWidget);
        value1_exp_label->setFont(font);
        QLabel *inv1_exp_label = new QLabel(_stage_tabWidget);
        _inv_exp_label_list.push_back(inv1_exp_label);

        QLabel *count_exp_label = new QLabel(_stage_tabWidget);
        _count_exp_label_list.push_back(count_exp_label);

        QVBoxLayout *stage_layout = new QVBoxLayout();
        QGridLayout *stage_glayout = new QGridLayout();
        stage_glayout->setVerticalSpacing(5);

        row = 1;
        if (_cur_ch_num == 32) {
            QLineEdit *_value0_ext32_lineEdit = new QLineEdit("X X X X X X X X X X X X X X X X", _stage_tabWidget);
            _value0_ext32_lineEdit->setFont(font);
            _value0_ext32_lineEdit->setValidator(value_validator);
            _value0_ext32_lineEdit->setMaxLength(TriggerProbes * 2 - 1);
            _value0_ext32_lineEdit->setInputMask(mask);
            _value0_ext32_lineEdit->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);
            _value0_ext32_lineEdit_list.push_back(_value0_ext32_lineEdit);

            QLineEdit *_value1_ext32_lineEdit = new QLineEdit("X X X X X X X X X X X X X X X X", _stage_tabWidget);
            _value1_ext32_lineEdit->setFont(font);
            _value1_ext32_lineEdit->setValidator(value_validator);
            _value1_ext32_lineEdit->setMaxLength(TriggerProbes * 2 - 1);
            _value1_ext32_lineEdit->setInputMask(mask);
            _value1_ext32_lineEdit->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);
            _value1_ext32_lineEdit_list.push_back(_value1_ext32_lineEdit);

            QLabel *value0_ext32_exp_label = new QLabel("31 --------- 24 23 ---------- 16", _stage_tabWidget);
            value0_ext32_exp_label->setFont(font);
            QLabel *value1_ext32_exp_label = new QLabel("31 --------- 24 23 ---------- 16", _stage_tabWidget);
            value1_ext32_exp_label->setFont(font);

            stage_glayout->addWidget(value0_ext32_exp_label, row++, 0);
            stage_glayout->addWidget(_value0_ext32_lineEdit, row++, 0);
            stage_glayout->addWidget(value0_exp_label, row, 0);
            stage_glayout->addWidget(inv0_exp_label, row++, 1);
            stage_glayout->addWidget(_value0_lineEdit, row, 0);
            stage_glayout->addWidget(_inv0_comboBox, row, 1);
            stage_glayout->addWidget(_logic_comboBox, row++, 2);

            stage_glayout->addWidget(new QLabel(_stage_tabWidget), row++, 0);

            stage_glayout->addWidget(value1_ext32_exp_label, row++, 0);
            stage_glayout->addWidget(_value1_ext32_lineEdit, row++, 0);
            stage_glayout->addWidget(value1_exp_label, row, 0);
            stage_glayout->addWidget(inv1_exp_label, row++, 1);
            stage_glayout->addWidget(_value1_lineEdit, row, 0);
            stage_glayout->addWidget(_inv1_comboBox, row++, 1);

            connect(_value0_ext32_lineEdit, SIGNAL(editingFinished()), this, SLOT(value_changed()));
            connect(_value1_ext32_lineEdit, SIGNAL(editingFinished()), this, SLOT(value_changed()));
        } else {
            stage_glayout->addWidget(value0_exp_label, row, 0);
            stage_glayout->addWidget(inv0_exp_label, row++, 1);
            stage_glayout->addWidget(_value0_lineEdit, row, 0);
            stage_glayout->addWidget(_inv0_comboBox, row, 1);
            stage_glayout->addWidget(_logic_comboBox, row++, 2);

            stage_glayout->addWidget(new QLabel(_stage_tabWidget), row++, 0);

            stage_glayout->addWidget(value1_exp_label, row, 0);
            stage_glayout->addWidget(inv1_exp_label, row++, 1);
            stage_glayout->addWidget(_value1_lineEdit, row, 0);
            stage_glayout->addWidget(_inv1_comboBox, row++, 1);
        }

        stage_glayout->addWidget(new QLabel(_stage_tabWidget), row++, 0);

        QLabel *contiguous_label = new QLabel(_stage_tabWidget);
        _contiguous_label_list.push_back(contiguous_label);
        stage_glayout->addWidget(contiguous_label, row, 1, 1, 2);
        stage_glayout->addWidget(_contiguous_checkbox, row++, 0, 1, 1, Qt::AlignRight);
        stage_glayout->addWidget(count_exp_label, row, 1, 1, 2);
        stage_glayout->addWidget(_count_spinBox, row++, 0);

        stage_layout->addLayout(stage_glayout);
        stage_layout->addSpacing(20);
        QLabel *stage_note_label = new QLabel(_stage_tabWidget);
        _stage_note_label_list.push_back(stage_note_label);
        stage_layout->addWidget(stage_note_label);
        stage_layout->addStretch(1);

        QGroupBox *stage_groupBox = new QGroupBox(_stage_tabWidget);
        stage_groupBox->setFlat(true);
        stage_groupBox->setLayout(stage_layout);
        _stage_groupBox_list.push_back(stage_groupBox);

        _stage_tabWidget->addTab((QWidget *)stage_groupBox, QString::number(i));
    }

    _serial_groupBox = new QGroupBox(_widget);
    _serial_groupBox->setFlat(true);

    _serial_start_label = new QLabel(_serial_groupBox);
    _serial_start_lineEdit = new QLineEdit("X X X X X X X X X X X X X X X X", _serial_groupBox);
    _serial_start_lineEdit->setFont(font);
    _serial_start_lineEdit->setValidator(value_validator);
    _serial_start_lineEdit->setMaxLength(TriggerProbes * 2 - 1);
    _serial_start_lineEdit->setInputMask(mask);
    _serial_start_lineEdit->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);

    _serial_stop_label = new QLabel(_serial_groupBox);
    _serial_stop_lineEdit = new QLineEdit("X X X X X X X X X X X X X X X X", _serial_groupBox);
    _serial_stop_lineEdit->setFont(font);
    _serial_stop_lineEdit->setValidator(value_validator);
    _serial_stop_lineEdit->setMaxLength(TriggerProbes * 2 - 1);
    _serial_stop_lineEdit->setInputMask(mask);
    _serial_stop_lineEdit->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);

    _serial_edge_label = new QLabel(_serial_groupBox);
    _serial_edge_lineEdit = new QLineEdit("X X X X X X X X X X X X X X X X", _serial_groupBox);
    _serial_edge_lineEdit->setFont(font);
    _serial_edge_lineEdit->setValidator(value_validator);
    _serial_edge_lineEdit->setMaxLength(TriggerProbes * 2 - 1);
    _serial_edge_lineEdit->setInputMask(mask);
    _serial_edge_lineEdit->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);

    _serial_data_label = new QLabel(_serial_groupBox);
    _serial_data_comboBox = new DsComboBox(_serial_groupBox);

    for(int i = 0; i < _cur_ch_num; i++){
        _serial_data_comboBox->addItem(QString::number(i));
    }

    _serial_value_label = new QLabel(_serial_groupBox);
    _serial_value_lineEdit = new QLineEdit("X X X X X X X X X X X X X X X X", _serial_groupBox);
    _serial_value_lineEdit->setFont(font);
    _serial_value_lineEdit->setMaxLength(TriggerProbes * 2 - 1);
    _serial_value_lineEdit->setInputMask(mask);
    _serial_value_lineEdit->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);

    QRegularExpression value_rx2("[10Xx ]+");
    QValidator *value_validator2 = new QRegularExpressionValidator(value_rx2, _stage_tabWidget);
    _serial_value_lineEdit->setValidator(value_validator2);

    _serial_hex_label = new QLabel(_serial_groupBox);
    _serial_hex_lineEdit = new QLineEdit("", _serial_groupBox);
    _serial_hex_lineEdit->setMaxLength(4);
    QRegularExpression value_rx_hex("[0-9a-fA-F]+");
    QValidator *value_validator_hex = new QRegularExpressionValidator(value_rx_hex, _stage_tabWidget);
    _serial_hex_lineEdit->setValidator(value_validator_hex);
    _serial_hex_lineEdit->setMaximumWidth(70);
    _serial_hex_lineEdit->setReadOnly(true);

    QCheckBox *hex_ckbox = new QCheckBox();
    _serial_hex_ck_label = new QLabel();
    hex_ckbox->setMaximumWidth(18);

    QHBoxLayout *hex_lay = new QHBoxLayout();
    hex_lay->setSpacing(5);
    hex_lay->setContentsMargins(0,0,0,0);
    QWidget *hex_wid = new QWidget();
    hex_wid->setLayout(hex_lay);
    hex_lay->setAlignment(Qt::AlignLeft);
    hex_lay->addWidget(_serial_hex_lineEdit);
    hex_lay->addWidget(hex_ckbox);
    hex_lay->addWidget(_serial_hex_ck_label);

    connect(hex_ckbox, SIGNAL(clicked(bool)), this, SLOT(on_hex_checkbox_click(bool))); 
  
    _serial_bits_comboBox = new DsComboBox(_serial_groupBox);

    for(int i = 1; i <= 16; i++){
        _serial_bits_comboBox->addItem(QString::number(i));
    }

    QVBoxLayout *serial_layout = new QVBoxLayout();
    QGridLayout *serial_glayout = new QGridLayout();
    serial_glayout->setVerticalSpacing(5);

    row = 1;
    if (_cur_ch_num == 32) {
        _serial_start_ext32_lineEdit = new QLineEdit("X X X X X X X X X X X X X X X X", _serial_groupBox);
        _serial_start_ext32_lineEdit->setFont(font);
        _serial_start_ext32_lineEdit->setValidator(value_validator);
        _serial_start_ext32_lineEdit->setMaxLength(TriggerProbes * 2 - 1);
        _serial_start_ext32_lineEdit->setInputMask(mask);
        _serial_start_ext32_lineEdit->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);

        _serial_stop_ext32_lineEdit = new QLineEdit("X X X X X X X X X X X X X X X X", _serial_groupBox);
        _serial_stop_ext32_lineEdit->setFont(font);
        _serial_stop_ext32_lineEdit->setValidator(value_validator);
        _serial_stop_ext32_lineEdit->setMaxLength(TriggerProbes * 2 - 1);
        _serial_stop_ext32_lineEdit->setInputMask(mask);
        _serial_stop_ext32_lineEdit->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);

        _serial_edge_ext32_lineEdit = new QLineEdit("X X X X X X X X X X X X X X X X", _serial_groupBox);
        _serial_edge_ext32_lineEdit->setFont(font);
        _serial_edge_ext32_lineEdit->setValidator(value_validator);
        _serial_edge_ext32_lineEdit->setMaxLength(TriggerProbes * 2 - 1);
        _serial_edge_ext32_lineEdit->setInputMask(mask);
        _serial_edge_ext32_lineEdit->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Preferred);

        connect(_serial_start_ext32_lineEdit, SIGNAL(editingFinished()), this, SLOT(value_changed()));
        connect(_serial_stop_ext32_lineEdit, SIGNAL(editingFinished()), this, SLOT(value_changed()));
        connect(_serial_edge_ext32_lineEdit, SIGNAL(editingFinished()), this, SLOT(value_changed()));

        QLabel *serial0_value_exp_label = new QLabel("31 --------- 24 23 ---------- 16", _serial_groupBox);
        serial0_value_exp_label->setFont(font);
        serial_glayout->addWidget(serial0_value_exp_label, row++, 1, 1, 3);
        serial_glayout->addWidget(_serial_start_ext32_lineEdit, row, 1, 1, 3);
        serial_glayout->addWidget(new QLabel(_serial_groupBox), row++, 4);
        QLabel *serial1_value_exp_label = new QLabel("15 ---------- 8 7 ----------- 0 ", _serial_groupBox);
        serial1_value_exp_label->setFont(font);
        serial_glayout->addWidget(serial1_value_exp_label, row++, 1, 1, 3);
        serial_glayout->addWidget(_serial_start_label, row, 0);
        serial_glayout->addWidget(_serial_start_lineEdit, row, 1, 1, 3);
        serial_glayout->addWidget(new QLabel(_serial_groupBox), row++, 4);

        serial_glayout->addWidget(new QLabel(_stage_tabWidget), row++, 0);

        QLabel *serial2_value_exp_label = new QLabel("31 --------- 24 23 ---------- 16", _serial_groupBox);
        serial2_value_exp_label->setFont(font);
        serial_glayout->addWidget(serial2_value_exp_label, row++, 1, 1, 3);
        serial_glayout->addWidget(_serial_stop_ext32_lineEdit, row++, 1, 1, 3);
        QLabel *serial3_value_exp_label = new QLabel("15 ---------- 8 7 ----------- 0 ", _serial_groupBox);
        serial3_value_exp_label->setFont(font);
        serial_glayout->addWidget(serial3_value_exp_label, row++, 1, 1, 3);
        serial_glayout->addWidget(_serial_stop_label, row, 0);
        serial_glayout->addWidget(_serial_stop_lineEdit, row++, 1, 1, 3);

        serial_glayout->addWidget(new QLabel(_stage_tabWidget), row++, 0);

        QLabel *serial4_value_exp_label = new QLabel("31 --------- 24 23 ---------- 16", _serial_groupBox);
        serial4_value_exp_label->setFont(font);
        serial_glayout->addWidget(serial4_value_exp_label, row++, 1, 1, 3);
        serial_glayout->addWidget(_serial_edge_ext32_lineEdit, row++, 1, 1, 3);
        QLabel *serial5_value_exp_label = new QLabel("15 ---------- 8 7 ----------- 0 ", _serial_groupBox);
        serial5_value_exp_label->setFont(font);
        serial_glayout->addWidget(serial5_value_exp_label, row++, 1, 1, 3);
        serial_glayout->addWidget(_serial_edge_label, row, 0);
        serial_glayout->addWidget(_serial_edge_lineEdit, row++, 1, 1, 3);
    }
    else {
        QLabel *serial0_value_exp_label = new QLabel("15 ---------- 8 7 ----------- 0 ", _serial_groupBox);
        serial0_value_exp_label->setFont(font);
        serial_glayout->addWidget(serial0_value_exp_label, row++, 1, 1, 3);
        serial_glayout->addWidget(_serial_start_label, row, 0);
        serial_glayout->addWidget(_serial_start_lineEdit, row, 1, 1, 3);
        serial_glayout->addWidget(new QLabel(_serial_groupBox), row++, 4);

        serial_glayout->addWidget(new QLabel(_stage_tabWidget), row++, 0);

        QLabel *serial1_value_exp_label = new QLabel("15 ---------- 8 7 ----------- 0 ", _serial_groupBox);
        serial1_value_exp_label->setFont(font);
        serial_glayout->addWidget(serial1_value_exp_label, row++, 1, 1, 3);
        serial_glayout->addWidget(_serial_stop_label, row, 0);
        serial_glayout->addWidget(_serial_stop_lineEdit, row++, 1, 1, 3);

        serial_glayout->addWidget(new QLabel(_stage_tabWidget), row++, 0);

        QLabel *serial2_value_exp_label = new QLabel("15 ---------- 8 7 ----------- 0 ", _serial_groupBox);
        serial2_value_exp_label->setFont(font);
        serial_glayout->addWidget(serial2_value_exp_label, row++, 1, 1, 3);
        serial_glayout->addWidget(_serial_edge_label, row, 0);
        serial_glayout->addWidget(_serial_edge_lineEdit, row++, 1, 1, 3);
    }

    serial_glayout->addWidget(new QLabel(_serial_groupBox), row++, 0, 1, 5);
    serial_glayout->addWidget(_serial_data_label, row, 0);
    serial_glayout->addWidget(_serial_data_comboBox, row++, 1);
    _data_bits_label = new QLabel(_serial_groupBox);
    serial_glayout->addWidget(_data_bits_label, row, 0);
    serial_glayout->addWidget(_serial_bits_comboBox, row++, 1);
    serial_glayout->addWidget(_serial_value_label, row, 0);
    serial_glayout->addWidget(_serial_value_lineEdit, row++, 1, 1, 3);
    serial_glayout->addWidget(_serial_hex_label, row, 0);
    serial_glayout->addWidget(hex_wid, row++, 1, 1, 3);

    _serial_note_label = new QLabel(_serial_groupBox);
    serial_layout->addLayout(serial_glayout);
    serial_layout->addSpacing(20);
    serial_layout->addWidget(_serial_note_label);
    serial_layout->addStretch(1);

    _serial_groupBox->setLayout(serial_layout);

    connect(_serial_start_lineEdit, SIGNAL(editingFinished()), this, SLOT(value_changed()));
    connect(_serial_stop_lineEdit, SIGNAL(editingFinished()), this, SLOT(value_changed()));
    connect(_serial_edge_lineEdit, SIGNAL(editingFinished()), this, SLOT(value_changed()));
    connect(_serial_value_lineEdit, SIGNAL(editingFinished()), this, SLOT(value_changed()));

    connect(_serial_value_lineEdit, SIGNAL(textChanged(const QString&)), 
                this, SLOT(on_serial_value_changed(const QString&)));

    connect(_serial_hex_lineEdit, SIGNAL(editingFinished()), 
                this, SLOT(on_serial_hex_changed()));

    _adv_tabWidget->addTab((QWidget *)_stage_tabWidget, L_S(STR_PAGE_DLG, S_ID(IDS_DLG_STAGE_TRIGGER), "Stage Trigger"));
    _adv_tabWidget->addTab((QWidget *)_serial_groupBox, L_S(STR_PAGE_DLG, S_ID(IDS_DLG_SERIAL_TRIGGER), "Serial Trigger"));
}

void TriggerDock::lineEdit_highlight(QLineEdit *dst) {
    if (dst == NULL)
        return;

    QTextCharFormat fmt;
    fmt.setForeground(view::View::Red);
    QList<QInputMethodEvent::Attribute> attributes;
    for (int i = 0; i < dst->text().size(); i++) {
        if (dst->text().at(i) != 'X' && dst->text().at(i) != ' ')
            attributes.append(QInputMethodEvent::Attribute(QInputMethodEvent::TextFormat, i-dst->cursorPosition(), 1, fmt));
    }
    QInputMethodEvent event(QString(), attributes);
    QCoreApplication::sendEvent(dst, &event);
}

void TriggerDock::try_commit_trigger()
{   
    AppConfig &app = AppConfig::Instance(); 
    int num = 0;

    int mode = _session->get_device()->get_work_mode();
    bool bInstant = _session->is_instant();

    ds_trigger_reset();

    if (mode != LOGIC || bInstant){
        return;
    }

    if (commit_trigger() == false) 
    {
        /* simple trigger check trigger_enable */
        for(auto s : _session->get_signals()){ 
            if (s->signal_type() == SR_CHANNEL_LOGIC) {
                view::LogicSignal *logicSig = (view::LogicSignal*)s;
                if (logicSig->commit_trig())
                    num++;
            }
        }

        if (app.appOptions.warnofMultiTrig && num > 1)
        {
            dialogs::DSMessageBox msg(this);
            msg.mBox()->setText(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_TRIGGER), "Trigger"));
            msg.mBox()->setInformativeText(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_SET_TRI_MULTI_CHANNEL), 
                                          "Trigger setted on multiple channels!\nCapture will Only triggered when all setted channels fullfill at one sample"));
            msg.mBox()->setIcon(QMessageBox::Information);

            QPushButton *noMoreButton = msg.mBox()->addButton(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_NOT_SHOW_AGAIN), "Not Show Again"), QMessageBox::ActionRole);
            QPushButton *cancelButton = msg.mBox()->addButton(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_CLEAR_TRIG), "Clear Trig"), QMessageBox::ActionRole);
            msg.mBox()->addButton(L_S(STR_PAGE_MSG, S_ID(IDS_MSG_CONTINUE), "Continue"), QMessageBox::ActionRole);

            msg.exec();

            if (msg.mBox()->clickedButton() == cancelButton) {
                for(auto s : _session->get_signals()){
                    if (s->signal_type() == SR_CHANNEL_LOGIC) {
                        view::LogicSignal *logicSig = (view::LogicSignal*)s;
                        logicSig->set_trig(view::LogicSignal::NONTRIG);
                        logicSig->commit_trig();
                    }
                }
            }

            if (msg.mBox()->clickedButton() == noMoreButton)
            {
                app.appOptions.warnofMultiTrig  = false;              
            }
        }
    }
}

void TriggerDock::on_hex_checkbox_click(bool ck)
{
   _serial_hex_lineEdit->setReadOnly(!ck);
   if (ck){
       _serial_hex_lineEdit->setFocus();
   }
}

void TriggerDock::on_serial_value_changed(const QString &v)
{
    if (_is_serial_val_setting)
        return;

    QString s(v);
    s = s.replace(" ", "").toLower();
    _serial_hex_lineEdit->setText("");

    if (s != "" && s.indexOf("x") == -1)
    { 
        char *buf = s.toLocal8Bit().data();
        int len = s.length();
        unsigned long val = 0;

        if (len == 16)
        {
            for (int i=0; i<len; i++)
            { 
                if (*(buf+i) == '1'){
                    val += 1 << (len - i - 1);
                }
            }

            char tmp[10];
            sprintf(tmp, "%02lX", val);
            _serial_hex_lineEdit->setText(QString(tmp));
        }       
    }
}

void TriggerDock::on_serial_hex_changed()
{
    if (_is_serial_val_setting)
        return;
    
    _is_serial_val_setting = true;

    QString s = _serial_hex_lineEdit->text();
    _serial_hex_lineEdit->setText(s.toUpper());

    if (s.length() <= 4)
    {
        while (s.length() < 4){
            s = "0" + s;
        }
        
        const char *str = s.toLocal8Bit().data();
        char *endptr = NULL;
        unsigned long val = strtoul(str, &endptr, 16);
        char buffer[18];
        AnnotationResTable::decimalToBinString(val, 16, buffer, sizeof(buffer));
        _serial_value_lineEdit->setText(QString(buffer));
    }

    _is_serial_val_setting = false;
}

void TriggerDock::update_font()
{
    QFont font = this->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
    ui::set_form_font(this, font);
    font.setPointSizeF(font.pointSizeF() + 1);
    this->parentWidget()->setFont(font);
}

} // namespace dock
} // namespace dsv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2021 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "protocolitemlayer.h"
#include "../basedef.h"
#include <assert.h> 
#include "../config/appconfig.h"
#include "../decode/displaydataformat.h"

using namespace dsv::config;
 
namespace dsv {
namespace dock {
  
ProtocolItemLayer::ProtocolItemLayer(QWidget *parent, QString protocolName, IProtocolItemLayerCallback *callback)
{
        assert(parent);
        assert(callback);

        m_callback = callback;
        _protocolName = protocolName;
        m_bSetting = false;
        m_decoderStatus = NULL;
        _trace = NULL;

        _protocol_label = new QLabel(parent);
        _progress_label = new QLabel(parent);
        _set_button = new QPushButton(parent);
        _del_button = new QPushButton(parent);
        _format_combox = new DsComboBox(parent);

        QString iconPath = AppConfig::GetIconPath();
        _del_button->setFlat(true);
        _del_button->setIcon(QIcon(iconPath + "/del.svg"));
        _set_button->setFlat(true);
        _set_button->setIcon(QIcon(iconPath + "/gear.svg"));
        _protocol_label->setText(protocolName);

        m_singleFlag = true;     

        LoadFormatSelect(false);
 
        QHBoxLayout *hori_layout = this;
        hori_layout->addWidget(_set_button);
        hori_layout->addWidget(_del_button);
        hori_layout->addWidget(_format_combox);
        hori_layout->addWidget(_protocol_label);
        hori_layout->addWidget(_progress_label);   

        hori_layout->addStretch(1);

        enable_format(false);

        connect(_del_button, SIGNAL(clicked()),this, SLOT(on_del_protocol()));        
        connect(_set_button, SIGNAL(clicked()),this, SLOT(on_set_protocol()));
        connect(_format_combox, SIGNAL(currentIndexChanged(int)),this, SLOT(on_format_select_changed(int)));

        update_font();
}

ProtocolItemLayer::~ProtocolItemLayer(){ 
     DESTROY_QT_OBJECT(_progress_label);
     DESTROY_QT_OBJECT(_protocol_label);
     DESTROY_QT_OBJECT(_set_button);
     DESTROY_QT_OBJECT(_del_button);
     DESTROY_QT_OBJECT(_format_combox);
}
 

//-------------control event
void ProtocolItemLayer::on_set_protocol()
{
    m_callback->OnProtocolSetting(this);
}

void ProtocolItemLayer::on_del_protocol(){
    m_callback->OnProtocolDelete(this);
}

void ProtocolItemLayer::on_format_select_changed(int index){
    if (index >= 0 && !m_bSetting){
        QString text = _format_combox->currentText();
        m_callback->OnProtocolFormatChanged(text, this);
    } 
}
//-----------------

 void ProtocolItemLayer::SetProgress(int progress, QString text){
      QString str = QString::number(progress) + "%" + text;

       if (progress == 100)
            _progress_label->setStyleSheet("color:green;");
        else
            _progress_label->setStyleSheet("color:red;");

        if (progress >= 0)
            _progress_label->setText(str);
        else
            _progress_label->setText("");
 }

void ProtocolItemLayer::ResetStyle(){
    QString iconPath = AppConfig::GetIconPath();
     _del_button->setIcon(QIcon(iconPath + "/del.svg"));
    _set_button->setIcon(QIcon(iconPath + "/gear.svg"));
}

void ProtocolItemLayer::LoadFormatSelect(bool bSingle)
{
    if (bSingle == m_singleFlag){
        return;
    }
    m_singleFlag = bSingle;

    m_bSetting = true;
    _format_combox->clear(); 

    if (!bSingle){
        _format_combox->addItem("hex");
        _format_combox->addItem("dec");       
        _format_combox->addItem("oct");
        _format_combox->addItem("bin");
    }
    _format_combox->addItem("ascii");
    
    _format_combox->setCurrentIndex(0);
    m_bSetting = false;
}

 void ProtocolItemLayer::SetProtocolFormat(const char *format)
 {
     assert(format);

     m_bSetting = true;
     int dex = DisplayDataFormat::Parse(format);
     if (dex < (int)_format_combox->count()){
        _format_combox->setCurrentIndex(dex);
     }
     m_bSetting = false;
 }

 void ProtocolItemLayer::enable_format(bool flag)
 {  
    _format_combox->setDisabled(!flag);
 }

 void ProtocolItemLayer::set_label_name(QString name)
 {
    _protocol_label->setText(name);
 }

 void ProtocolItemLayer::update_font()
 {
    QFont font = _protocol_label->font();
    font.setPointSizeF(AppConfig::Instance().appOptions.fontSize);
    _protocol_label->setFont(font);
    _format_combox->setFont(font);
 }

} //dock
} //pv
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */


#ifndef DSVIEW_PV_TRIGGERDOCK_H
#define DSVIEW_PV_TRIGGERDOCK_H

#include <QDockWidget>
#include <QPushButton>
#include <QLabel>
#include <QRadioButton>
#include <QSlider>
#include <QLineEdit>
#include <QSpinBox>
#include <QGroupBox>
#include <QCheckBox>
#include <QTableWidget>
#include <QJsonObject>
#include <QVector>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QScrollArea>
#include <vector>
#include "../ui/dscombobox.h"
#include "../interface/icallbacks.h"

namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
}
using namespace dsv::appcore;

namespace dsv {
namespace dock {

class TriggerDock : public QScrollArea, public IFontForm
{
    Q_OBJECT

private:
    static const int MinTrigPosition;

public:
    TriggerDock(QWidget *parent, SigSession *session);
    ~TriggerDock();

    void paintEvent(QPaintEvent *);

    void update_view();

    QJsonObject get_session();
    void set_session(QJsonObject ses);

    void device_updated();

    void try_commit_trigger();

private:
    void changeEvent(QEvent *event);
    void retranslateUi();
    void reStyle();

    void setup_adv_tab();
    void lineEdit_highlight(QLineEdit *dst);

      /*
     * commit trigger setting
     * return 0: simple trigger
     *        1: advanced trigger
     */
    bool commit_trigger();

    //IFontForm
    void update_font() override;

private slots:
    void simple_trigger();
    void adv_trigger();
    void widget_enable(int index);
    void value_changed();
    void on_hex_checkbox_click(bool ck);
    void on_serial_value_changed(const QString &v);
    void on_serial_hex_changed();

private:
    SigSession *_session;

    int _cur_ch_num;
    QWidget *_widget;

    QRadioButton *_simple_radioButton;
    QRadioButton *_adv_radioButton;

    QLabel *_position_label;
    QSpinBox *_position_spinBox;
    QSlider *_position_slider;

    QLabel *_stages_label;
    DsComboBox *stages_comboBox;

    QTabWidget *_stage_tabWidget;

    QVector <QGroupBox *> _stage_groupBox_list;
    QVector <QLabel *>    _mu_label_list;
    QVector <DsComboBox *> _logic_comboBox_list;
    QVector <QLineEdit *> _value0_lineEdit_list;
    QVector <QLineEdit *> _value0_ext32_lineEdit_list;
    QVector <QSpinBox *> _count_spinBox_list;
    QVector <DsComboBox *> _inv0_comboBox_list;
    QVector <QLineEdit *> _value1_lineEdit_list;
    QVector <QLineEdit *> _value1_ext32_lineEdit_list;
    QVector <DsComboBox *> _inv1_comboBox_list;
    QVector <QCheckBox *> _contiguous_checkbox_list;

    QTabWidget *_adv_tabWidget;
    QGroupBox *_serial_groupBox;
    QLabel *_serial_start_label;
    QLineEdit *_serial_start_lineEdit;
    QLineEdit *_serial_start_ext32_lineEdit;
    QLabel *_serial_stop_label;
    QLineEdit *_serial_stop_lineEdit;
    QLineEdit *_serial_stop_ext32_lineEdit;
    QLabel *_serial_edge_label;
    QLineEdit *_serial_edge_lineEdit;
    QLineEdit *_serial_edge_ext32_lineEdit;
    QLabel *_serial_data_label;
    DsComboBox *_serial_data_comboBox;
    QLabel *_serial_value_label;
    QLineEdit *_serial_value_lineEdit;
    DsComboBox *_serial_bits_comboBox;
    QLabel *_serial_hex_label;
    QLineEdit *_serial_hex_lineEdit;
    QLabel *_serial_hex_ck_label;

    QLabel *_serial_note_label;
    QLabel *_data_bits_label;
    bool    _is_serial_val_setting;

    QVector <QLabel *>  _inv_exp_label_list;
    QVector <QLabel *>  _count_exp_label_list;
    QVector <QLabel *>  _contiguous_label_list;
    QVector <QLabel *>  _stage_note_label_list;

};

} // namespace dock
} // namespace dsv

#endif // DSVIEW_PV_TRIGGERDOCK_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2013 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef DSVIEW_PV_DSOTRIGGERDOCK_H
#define DSVIEW_PV_DSOTRIGGERDOCK_H

#include <QDockWidget>
#include <QSlider>
#include <QSpinBox>
#include <QButtonGroup>
#include <QScrollArea>
#include <QLabel>
#include <QRadioButton>
#include <vector>
#include "../ui/dscombobox.h"
#include "../interface/icallbacks.h"

namespace dsv{
	namespace appcore{
    	class SigSession; 
	}
}
using namespace dsv::appcore;

namespace dsv {
namespace dock {

class DsoTriggerDock : public QScrollArea, public IFontForm
{
    Q_OBJECT

public:
    DsoTriggerDock(QWidget *parent, SigSession *session);
    ~DsoTriggerDock();
 
    void device_change();
    void update_view();
    void check_setting();

private:
    void paintEvent(QPaintEvent *e);
    void changeEvent(QEvent *event);
    void retranslateUi();
    void reStyle();
    bool check_trig_channel();

    //IFontForm
    void update_font() override;

signals:
    void set_trig_pos(int percent);

public slots:
    void auto_trig(int index);

private slots:
    void pos_changed(int pos);
    void hold_changed(int hold);
    void margin_changed(int margin);
    void source_changed();
    void type_changed();
    void channel_changed(int ch);

private:
    SigSession *_session;

    QWidget *_widget;

    DsComboBox *_holdoff_comboBox;
    QSpinBox *_holdoff_spinBox;
    QSlider *_holdoff_slider;

    QSlider *_margin_slider;

    QSpinBox *_position_spinBox;
    QSlider *_position_slider;

    QButtonGroup *_source_group;
    DsComboBox *_channel_comboBox;
    QButtonGroup *_type_group;

    QLabel *_position_label;
    QLabel *_holdoff_label;
    QLabel *_margin_label;
    QLabel *_tSource_label;
    QLabel *_tType_label;
    QRadioButton *_rising_radioButton;
    QRadioButton *_falling_radioButton;

    QRadioButton *_auto_radioButton;
    QRadioButton *_ch0_radioButton;
    QRadioButton *_ch1_radioButton;
    QRadioButton *_ch0a1_radioButton;
    QRadioButton *_ch0o1_radioButton;
};

} // namespace dock
} // namespace dsv

#endif // DSVIEW_PV_DSOTRIGGERDOCK_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 * 
 * Copyright (C) 2016 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef MYSTYLE_H
#define MYSTYLE_H

#include <QProxyStyle>

class MyStyle : public QProxyStyle
{
    Q_OBJECT
    public:
    int pixelMetric(PixelMetric metric, const QStyleOption * option = 0, const QWidget * widget = 0 ) {
        int s = QProxyStyle::pixelMetric(metric, option, widget);
        if (metric == QStyle::PM_SmallIconSize) {
            s = 24;
        }
        return s;
    }
};

#endif // MYSTYLE_H
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2022 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef UTILITY_PATH_H
#define UTILITY_PATH_H

#include <string>
#include <QString>

namespace dsv{
namespace path{
    std::string ConvertPath(QString fileName);

    QString GetDirectoryName(QString path);

    std::string ToUnicodePath(QString path);
}
}
 
#endif/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2022 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef UTILITY_ENCODING_H
#define UTILITY_ENCODING_H

class QTextStream;

namespace dsv{
namespace encoding{

    void init();
    
    void set_utf8(QTextStream &stream);
}
}

#endif/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2022 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */
#include "array.h"
#include <assert.h>

namespace dsv
{
    namespace array
    {
        uint64_t find_min_uint64(uint64_t *arr, int size)
        { 
            assert(arr);
            assert(size);

            uint64_t *p = arr;            
            uint64_t v = *p;            

            for (int i=1; i<size; i++){
                p++;
                if (*p < v)
                    v = *p;
            }
            return v;
        }

        uint64_t find_max_uint64(uint64_t *arr, int size)
        { 
            assert(arr);
            assert(size);

            uint64_t *p = arr;            
            uint64_t v = *p;            

            for (int i=1; i<size; i++){
                p++;
                if (*p > v)
                    v = *p;
            }
            return v;
        }
    }    
}/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2022 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#ifndef UTILITY_ARRAY_H
#define UTILITY_ARRAY_H

#include <stdint.h>

namespace dsv
{
    namespace array
    {
        uint64_t find_min_uint64(uint64_t *arr, int size);

        uint64_t find_max_uint64(uint64_t *arr, int size);
    }    
}

#endif/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2022 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */

#include "path.h"
#ifdef _WIN32
#include <QTextCodec>
#include "../log.h"
#include <string.h>
#endif

namespace dsv{
namespace path{

    std::string ConvertPath(QString fileName)
    {
        return fileName.toUtf8().toStdString();
    }

    QString GetDirectoryName(QString path)
    {
        int lstdex = path.lastIndexOf('/');
        if (lstdex != -1)
        {
            return path.left(lstdex);
        }
        return path;
    }

    std::string ToUnicodePath(QString path)
    {
        std::string str;
         
#ifdef _WIN32
        QTextCodec *codec = QTextCodec::codecForName("System");
        if (codec != NULL){
            QByteArray str_tmp = codec->fromUnicode(path);
            str = str_tmp.data();
        } 
        else{
            dsv_err("Error: can't get \"System\" page code");
            str = path.toUtf8().data();
        }       
#else
        str = path.toUtf8().data();        
#endif

        return str;
    }
}
}
/*
 * This file is part of the DSView project.
 * DSView is based on PulseView.
 *
 * Copyright (C) 2022 DreamSourceLab <support@dreamsourcelab.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */
#include "encoding.h"

#include <QTextStream>

#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
#include <QStringConverter>
#else
#include <QTextCodec>
#endif 

#ifdef _WIN32
#include <QTextCodec>
#endif

namespace dsv{
namespace encoding{

    void init()
    {
#ifdef _WIN32
     QTextCodec::setCodecForLocale(QTextCodec::codecForName("UTF-8"));
#endif
    }

    void set_utf8(QTextStream &stream)
    {
#if QT_VERSION >= QT_VERSION_CHECK(6, 0, 0)
        stream.setEncoding(QStringConverter::Utf8);
#else
        QTextCodec *code = QTextCodec::codecForName("UTF-8");
        stream.setCodec(code);
#endif
    }
}
}